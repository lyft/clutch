syntax = "proto3";

package clutch.bot.slackbot.v1;

option go_package = "github.com/lyft/clutch/backend/api/bot/slackbot/v1;slackbotv1";

import "api/v1/annotations.proto";
import "google/api/annotations.proto";
import "google/protobuf/struct.proto";

service SlackBotAPI {
  rpc Event(EventRequest) returns (EventResponse) {
    option (google.api.http) = {
      post : "/v1/bot/slackbot/event"
      body : "*"
    };
    option (clutch.api.v1.action).type = CREATE;
  }
}

// The structure of events vary from type to type. The full list of event types can be found here
// https://api.slack.com/events. For the bot feature, we will be receiving app_mention events (events that mention the
// bot) or message.im events (a message posted in a DM with the bot).
message Event {
  // the type of event
  string type = 1;
  // the user who messaged the bot
  string user = 2;
  // the message text
  string text = 3;
  // timestamp
  string ts = 4;
  // the channel where the event happened
  string channel = 5;
  // for DM messages, this will be "im"
  string channel_type = 6;
  // when the event was dispatched
  string event_ts = 7;
  string client_msg_id = 8;
  // Unique identifier of the workspace where the event occurred
  string team = 9;
  // blocks is a list with a schema that can vary. it's received when a user interacts with a Block Kit component
  // https://api.slack.com/reference/block-kit/interactive-components
  google.protobuf.Value blocks = 10;
}

// For more details, see:
// https://api.slack.com/apis/connections/events-api#the-events-api__receiving-events
// https://api.slack.com/enterprise/apps/reference#event
message EventRequest {
  option (clutch.api.v1.redacted) = true;
  // Verification token to validate the event originated from Slack
  string token = 1;
  // if where the event occured is an external shared channel
  bool is_ext_shared_channel = 2;
  // Unique identifier of the workspace where the event occurred
  string team_id = 3;
  // Unique identifier of the installed Slack application
  string api_app_id = 4;
  // The event, an object, that happened
  // TODO: (sperry) if we expand the types of events we suscribe to and their fields vary alot, maybe we should use
  // google.protobuf.Value.
  Event event = 5;
  // Indicates which kind of event this is
  string type = 6;
  // Identifier for this specific event, globally unique across all workspaces
  string event_id = 7;
  // Epoch timestamp in seconds indicating when this event was dispatched
  int64 event_time = 9;
  // An identifier for this specific event, can be used with list of authorizations to obtain a
  // full list of installations of your app that this event is visible to
  string event_context = 8;
  // An installation of the app, object type
  google.protobuf.Value authorizations = 10;
  // Randomly generated string used as part of the URL verification handshake,
  // https://api.slack.com/apis/connections/events-api#the-events-api__subscribing-to-event-types__events-api-request-urls__request-url-configuration--verification__url-verification-handshake
  string challenge = 11;
}

// Respond back to the Slack Events API with the challenge or a 2xx,
// https://api.slack.com/apis/connections/events-api#the-events-api__responding-to-events
message EventResponse {
  option (clutch.api.v1.redacted) = true;
  // The request will include the challenge and we respond back with the same challenge to complete the URL verification
  // handshake
  string challenge = 1;
}
