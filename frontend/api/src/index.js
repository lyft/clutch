// Code generated by protobuf.js in compile-protos.sh. DO NOT EDIT.

/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const clutch = $root.clutch = (() => {

    /**
     * Namespace clutch.
     * @exports clutch
     * @namespace
     */
    const clutch = {};

    clutch.api = (function() {

        /**
         * Namespace api.
         * @memberof clutch
         * @namespace
         */
        const api = {};

        api.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.api
             * @namespace
             */
            const v1 = {};

            /**
             * ActionType enum.
             * @name clutch.api.v1.ActionType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} CREATE=1 CREATE value
             * @property {number} READ=2 READ value
             * @property {number} UPDATE=3 UPDATE value
             * @property {number} DELETE=4 DELETE value
             */
            v1.ActionType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "CREATE"] = 1;
                values[valuesById[2] = "READ"] = 2;
                values[valuesById[3] = "UPDATE"] = 3;
                values[valuesById[4] = "DELETE"] = 4;
                return values;
            })();

            v1.Action = (function() {

                /**
                 * Properties of an Action.
                 * @memberof clutch.api.v1
                 * @interface IAction
                 * @property {clutch.api.v1.ActionType|null} [type] Action type
                 */

                /**
                 * Constructs a new Action.
                 * @memberof clutch.api.v1
                 * @classdesc Represents an Action.
                 * @implements IAction
                 * @constructor
                 * @param {clutch.api.v1.IAction=} [properties] Properties to set
                 */
                function Action(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Action type.
                 * @member {clutch.api.v1.ActionType} type
                 * @memberof clutch.api.v1.Action
                 * @instance
                 */
                Action.prototype.type = 0;

                /**
                 * Verifies an Action message.
                 * @function verify
                 * @memberof clutch.api.v1.Action
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Action.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates an Action message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.api.v1.Action
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.api.v1.Action} Action
                 */
                Action.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.api.v1.Action)
                        return object;
                    let message = new $root.clutch.api.v1.Action();
                    switch (object.type) {
                    case "UNSPECIFIED":
                    case 0:
                        message.type = 0;
                        break;
                    case "CREATE":
                    case 1:
                        message.type = 1;
                        break;
                    case "READ":
                    case 2:
                        message.type = 2;
                        break;
                    case "UPDATE":
                    case 3:
                        message.type = 3;
                        break;
                    case "DELETE":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Action message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.api.v1.Action
                 * @static
                 * @param {clutch.api.v1.Action} message Action
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Action.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.clutch.api.v1.ActionType[message.type] : message.type;
                    return object;
                };

                /**
                 * Converts this Action to JSON.
                 * @function toJSON
                 * @memberof clutch.api.v1.Action
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Action.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Action;
            })();

            v1.Pattern = (function() {

                /**
                 * Properties of a Pattern.
                 * @memberof clutch.api.v1
                 * @interface IPattern
                 * @property {string|null} [typeUrl] Pattern typeUrl
                 * @property {string|null} [pattern] Pattern pattern
                 */

                /**
                 * Constructs a new Pattern.
                 * @memberof clutch.api.v1
                 * @classdesc Represents a Pattern.
                 * @implements IPattern
                 * @constructor
                 * @param {clutch.api.v1.IPattern=} [properties] Properties to set
                 */
                function Pattern(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Pattern typeUrl.
                 * @member {string} typeUrl
                 * @memberof clutch.api.v1.Pattern
                 * @instance
                 */
                Pattern.prototype.typeUrl = "";

                /**
                 * Pattern pattern.
                 * @member {string} pattern
                 * @memberof clutch.api.v1.Pattern
                 * @instance
                 */
                Pattern.prototype.pattern = "";

                /**
                 * Verifies a Pattern message.
                 * @function verify
                 * @memberof clutch.api.v1.Pattern
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Pattern.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        if (!$util.isString(message.typeUrl))
                            return "typeUrl: string expected";
                    if (message.pattern != null && message.hasOwnProperty("pattern"))
                        if (!$util.isString(message.pattern))
                            return "pattern: string expected";
                    return null;
                };

                /**
                 * Creates a Pattern message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.api.v1.Pattern
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.api.v1.Pattern} Pattern
                 */
                Pattern.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.api.v1.Pattern)
                        return object;
                    let message = new $root.clutch.api.v1.Pattern();
                    if (object.typeUrl != null)
                        message.typeUrl = String(object.typeUrl);
                    if (object.pattern != null)
                        message.pattern = String(object.pattern);
                    return message;
                };

                /**
                 * Creates a plain object from a Pattern message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.api.v1.Pattern
                 * @static
                 * @param {clutch.api.v1.Pattern} message Pattern
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Pattern.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.typeUrl = "";
                        object.pattern = "";
                    }
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        object.typeUrl = message.typeUrl;
                    if (message.pattern != null && message.hasOwnProperty("pattern"))
                        object.pattern = message.pattern;
                    return object;
                };

                /**
                 * Converts this Pattern to JSON.
                 * @function toJSON
                 * @memberof clutch.api.v1.Pattern
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Pattern.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Pattern;
            })();

            v1.Identifier = (function() {

                /**
                 * Properties of an Identifier.
                 * @memberof clutch.api.v1
                 * @interface IIdentifier
                 * @property {Array.<clutch.api.v1.IPattern>|null} [patterns] Identifier patterns
                 */

                /**
                 * Constructs a new Identifier.
                 * @memberof clutch.api.v1
                 * @classdesc Represents an Identifier.
                 * @implements IIdentifier
                 * @constructor
                 * @param {clutch.api.v1.IIdentifier=} [properties] Properties to set
                 */
                function Identifier(properties) {
                    this.patterns = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Identifier patterns.
                 * @member {Array.<clutch.api.v1.IPattern>} patterns
                 * @memberof clutch.api.v1.Identifier
                 * @instance
                 */
                Identifier.prototype.patterns = $util.emptyArray;

                /**
                 * Verifies an Identifier message.
                 * @function verify
                 * @memberof clutch.api.v1.Identifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Identifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.patterns != null && message.hasOwnProperty("patterns")) {
                        if (!Array.isArray(message.patterns))
                            return "patterns: array expected";
                        for (let i = 0; i < message.patterns.length; ++i) {
                            let error = $root.clutch.api.v1.Pattern.verify(message.patterns[i]);
                            if (error)
                                return "patterns." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Identifier message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.api.v1.Identifier
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.api.v1.Identifier} Identifier
                 */
                Identifier.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.api.v1.Identifier)
                        return object;
                    let message = new $root.clutch.api.v1.Identifier();
                    if (object.patterns) {
                        if (!Array.isArray(object.patterns))
                            throw TypeError(".clutch.api.v1.Identifier.patterns: array expected");
                        message.patterns = [];
                        for (let i = 0; i < object.patterns.length; ++i) {
                            if (typeof object.patterns[i] !== "object")
                                throw TypeError(".clutch.api.v1.Identifier.patterns: object expected");
                            message.patterns[i] = $root.clutch.api.v1.Pattern.fromObject(object.patterns[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Identifier message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.api.v1.Identifier
                 * @static
                 * @param {clutch.api.v1.Identifier} message Identifier
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Identifier.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.patterns = [];
                    if (message.patterns && message.patterns.length) {
                        object.patterns = [];
                        for (let j = 0; j < message.patterns.length; ++j)
                            object.patterns[j] = $root.clutch.api.v1.Pattern.toObject(message.patterns[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Identifier to JSON.
                 * @function toJSON
                 * @memberof clutch.api.v1.Identifier
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Identifier.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Identifier;
            })();

            v1.Reference = (function() {

                /**
                 * Properties of a Reference.
                 * @memberof clutch.api.v1
                 * @interface IReference
                 * @property {Array.<string>|null} [fields] Reference fields
                 */

                /**
                 * Constructs a new Reference.
                 * @memberof clutch.api.v1
                 * @classdesc Represents a Reference.
                 * @implements IReference
                 * @constructor
                 * @param {clutch.api.v1.IReference=} [properties] Properties to set
                 */
                function Reference(properties) {
                    this.fields = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Reference fields.
                 * @member {Array.<string>} fields
                 * @memberof clutch.api.v1.Reference
                 * @instance
                 */
                Reference.prototype.fields = $util.emptyArray;

                /**
                 * Verifies a Reference message.
                 * @function verify
                 * @memberof clutch.api.v1.Reference
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Reference.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.fields != null && message.hasOwnProperty("fields")) {
                        if (!Array.isArray(message.fields))
                            return "fields: array expected";
                        for (let i = 0; i < message.fields.length; ++i)
                            if (!$util.isString(message.fields[i]))
                                return "fields: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Reference message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.api.v1.Reference
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.api.v1.Reference} Reference
                 */
                Reference.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.api.v1.Reference)
                        return object;
                    let message = new $root.clutch.api.v1.Reference();
                    if (object.fields) {
                        if (!Array.isArray(object.fields))
                            throw TypeError(".clutch.api.v1.Reference.fields: array expected");
                        message.fields = [];
                        for (let i = 0; i < object.fields.length; ++i)
                            message.fields[i] = String(object.fields[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Reference message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.api.v1.Reference
                 * @static
                 * @param {clutch.api.v1.Reference} message Reference
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Reference.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.fields = [];
                    if (message.fields && message.fields.length) {
                        object.fields = [];
                        for (let j = 0; j < message.fields.length; ++j)
                            object.fields[j] = message.fields[j];
                    }
                    return object;
                };

                /**
                 * Converts this Reference to JSON.
                 * @function toJSON
                 * @memberof clutch.api.v1.Reference
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Reference.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Reference;
            })();

            v1.Redacted = (function() {

                /**
                 * Properties of a Redacted.
                 * @memberof clutch.api.v1
                 * @interface IRedacted
                 * @property {string|null} [redactedTypeUrl] Redacted redactedTypeUrl
                 */

                /**
                 * Constructs a new Redacted.
                 * @memberof clutch.api.v1
                 * @classdesc Represents a Redacted.
                 * @implements IRedacted
                 * @constructor
                 * @param {clutch.api.v1.IRedacted=} [properties] Properties to set
                 */
                function Redacted(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Redacted redactedTypeUrl.
                 * @member {string} redactedTypeUrl
                 * @memberof clutch.api.v1.Redacted
                 * @instance
                 */
                Redacted.prototype.redactedTypeUrl = "";

                /**
                 * Verifies a Redacted message.
                 * @function verify
                 * @memberof clutch.api.v1.Redacted
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Redacted.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.redactedTypeUrl != null && message.hasOwnProperty("redactedTypeUrl"))
                        if (!$util.isString(message.redactedTypeUrl))
                            return "redactedTypeUrl: string expected";
                    return null;
                };

                /**
                 * Creates a Redacted message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.api.v1.Redacted
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.api.v1.Redacted} Redacted
                 */
                Redacted.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.api.v1.Redacted)
                        return object;
                    let message = new $root.clutch.api.v1.Redacted();
                    if (object.redactedTypeUrl != null)
                        message.redactedTypeUrl = String(object.redactedTypeUrl);
                    return message;
                };

                /**
                 * Creates a plain object from a Redacted message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.api.v1.Redacted
                 * @static
                 * @param {clutch.api.v1.Redacted} message Redacted
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Redacted.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.redactedTypeUrl = "";
                    if (message.redactedTypeUrl != null && message.hasOwnProperty("redactedTypeUrl"))
                        object.redactedTypeUrl = message.redactedTypeUrl;
                    return object;
                };

                /**
                 * Converts this Redacted to JSON.
                 * @function toJSON
                 * @memberof clutch.api.v1.Redacted
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Redacted.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Redacted;
            })();

            v1.ErrorDetails = (function() {

                /**
                 * Properties of an ErrorDetails.
                 * @memberof clutch.api.v1
                 * @interface IErrorDetails
                 * @property {Array.<google.rpc.IStatus>|null} [wrapped] ErrorDetails wrapped
                 */

                /**
                 * Constructs a new ErrorDetails.
                 * @memberof clutch.api.v1
                 * @classdesc Represents an ErrorDetails.
                 * @implements IErrorDetails
                 * @constructor
                 * @param {clutch.api.v1.IErrorDetails=} [properties] Properties to set
                 */
                function ErrorDetails(properties) {
                    this.wrapped = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ErrorDetails wrapped.
                 * @member {Array.<google.rpc.IStatus>} wrapped
                 * @memberof clutch.api.v1.ErrorDetails
                 * @instance
                 */
                ErrorDetails.prototype.wrapped = $util.emptyArray;

                /**
                 * Verifies an ErrorDetails message.
                 * @function verify
                 * @memberof clutch.api.v1.ErrorDetails
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ErrorDetails.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.wrapped != null && message.hasOwnProperty("wrapped")) {
                        if (!Array.isArray(message.wrapped))
                            return "wrapped: array expected";
                        for (let i = 0; i < message.wrapped.length; ++i) {
                            let error = $root.google.rpc.Status.verify(message.wrapped[i]);
                            if (error)
                                return "wrapped." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an ErrorDetails message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.api.v1.ErrorDetails
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.api.v1.ErrorDetails} ErrorDetails
                 */
                ErrorDetails.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.api.v1.ErrorDetails)
                        return object;
                    let message = new $root.clutch.api.v1.ErrorDetails();
                    if (object.wrapped) {
                        if (!Array.isArray(object.wrapped))
                            throw TypeError(".clutch.api.v1.ErrorDetails.wrapped: array expected");
                        message.wrapped = [];
                        for (let i = 0; i < object.wrapped.length; ++i) {
                            if (typeof object.wrapped[i] !== "object")
                                throw TypeError(".clutch.api.v1.ErrorDetails.wrapped: object expected");
                            message.wrapped[i] = $root.google.rpc.Status.fromObject(object.wrapped[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ErrorDetails message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.api.v1.ErrorDetails
                 * @static
                 * @param {clutch.api.v1.ErrorDetails} message ErrorDetails
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ErrorDetails.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.wrapped = [];
                    if (message.wrapped && message.wrapped.length) {
                        object.wrapped = [];
                        for (let j = 0; j < message.wrapped.length; ++j)
                            object.wrapped[j] = $root.google.rpc.Status.toObject(message.wrapped[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ErrorDetails to JSON.
                 * @function toJSON
                 * @memberof clutch.api.v1.ErrorDetails
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ErrorDetails.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ErrorDetails;
            })();

            return v1;
        })();

        return api;
    })();

    clutch.assets = (function() {

        /**
         * Namespace assets.
         * @memberof clutch
         * @namespace
         */
        const assets = {};

        assets.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.assets
             * @namespace
             */
            const v1 = {};

            v1.AssetsAPI = (function() {

                /**
                 * Constructs a new AssetsAPI service.
                 * @memberof clutch.assets.v1
                 * @classdesc Represents an AssetsAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function AssetsAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (AssetsAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AssetsAPI;

                /**
                 * Callback as used by {@link clutch.assets.v1.AssetsAPI#fetch}.
                 * @memberof clutch.assets.v1.AssetsAPI
                 * @typedef FetchCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.assets.v1.FetchResponse} [response] FetchResponse
                 */

                /**
                 * Calls Fetch.
                 * @function fetch
                 * @memberof clutch.assets.v1.AssetsAPI
                 * @instance
                 * @param {clutch.assets.v1.IFetchRequest} request FetchRequest message or plain object
                 * @param {clutch.assets.v1.AssetsAPI.FetchCallback} callback Node-style callback called with the error, if any, and FetchResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AssetsAPI.prototype.fetch = function fetch(request, callback) {
                    return this.rpcCall(fetch, $root.clutch.assets.v1.FetchRequest, $root.clutch.assets.v1.FetchResponse, request, callback);
                }, "name", { value: "Fetch" });

                /**
                 * Calls Fetch.
                 * @function fetch
                 * @memberof clutch.assets.v1.AssetsAPI
                 * @instance
                 * @param {clutch.assets.v1.IFetchRequest} request FetchRequest message or plain object
                 * @returns {Promise<clutch.assets.v1.FetchResponse>} Promise
                 * @variation 2
                 */

                return AssetsAPI;
            })();

            v1.FetchRequest = (function() {

                /**
                 * Properties of a FetchRequest.
                 * @memberof clutch.assets.v1
                 * @interface IFetchRequest
                 */

                /**
                 * Constructs a new FetchRequest.
                 * @memberof clutch.assets.v1
                 * @classdesc Represents a FetchRequest.
                 * @implements IFetchRequest
                 * @constructor
                 * @param {clutch.assets.v1.IFetchRequest=} [properties] Properties to set
                 */
                function FetchRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a FetchRequest message.
                 * @function verify
                 * @memberof clutch.assets.v1.FetchRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FetchRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a FetchRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.assets.v1.FetchRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.assets.v1.FetchRequest} FetchRequest
                 */
                FetchRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.assets.v1.FetchRequest)
                        return object;
                    return new $root.clutch.assets.v1.FetchRequest();
                };

                /**
                 * Creates a plain object from a FetchRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.assets.v1.FetchRequest
                 * @static
                 * @param {clutch.assets.v1.FetchRequest} message FetchRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FetchRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this FetchRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.assets.v1.FetchRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FetchRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FetchRequest;
            })();

            v1.FetchResponse = (function() {

                /**
                 * Properties of a FetchResponse.
                 * @memberof clutch.assets.v1
                 * @interface IFetchResponse
                 */

                /**
                 * Constructs a new FetchResponse.
                 * @memberof clutch.assets.v1
                 * @classdesc Represents a FetchResponse.
                 * @implements IFetchResponse
                 * @constructor
                 * @param {clutch.assets.v1.IFetchResponse=} [properties] Properties to set
                 */
                function FetchResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a FetchResponse message.
                 * @function verify
                 * @memberof clutch.assets.v1.FetchResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FetchResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a FetchResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.assets.v1.FetchResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.assets.v1.FetchResponse} FetchResponse
                 */
                FetchResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.assets.v1.FetchResponse)
                        return object;
                    return new $root.clutch.assets.v1.FetchResponse();
                };

                /**
                 * Creates a plain object from a FetchResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.assets.v1.FetchResponse
                 * @static
                 * @param {clutch.assets.v1.FetchResponse} message FetchResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FetchResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this FetchResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.assets.v1.FetchResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FetchResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FetchResponse;
            })();

            return v1;
        })();

        return assets;
    })();

    clutch.audit = (function() {

        /**
         * Namespace audit.
         * @memberof clutch
         * @namespace
         */
        const audit = {};

        audit.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.audit
             * @namespace
             */
            const v1 = {};

            v1.AuditAPI = (function() {

                /**
                 * Constructs a new AuditAPI service.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents an AuditAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function AuditAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (AuditAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AuditAPI;

                /**
                 * Callback as used by {@link clutch.audit.v1.AuditAPI#getEvents}.
                 * @memberof clutch.audit.v1.AuditAPI
                 * @typedef GetEventsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.audit.v1.GetEventsResponse} [response] GetEventsResponse
                 */

                /**
                 * Calls GetEvents.
                 * @function getEvents
                 * @memberof clutch.audit.v1.AuditAPI
                 * @instance
                 * @param {clutch.audit.v1.IGetEventsRequest} request GetEventsRequest message or plain object
                 * @param {clutch.audit.v1.AuditAPI.GetEventsCallback} callback Node-style callback called with the error, if any, and GetEventsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AuditAPI.prototype.getEvents = function getEvents(request, callback) {
                    return this.rpcCall(getEvents, $root.clutch.audit.v1.GetEventsRequest, $root.clutch.audit.v1.GetEventsResponse, request, callback);
                }, "name", { value: "GetEvents" });

                /**
                 * Calls GetEvents.
                 * @function getEvents
                 * @memberof clutch.audit.v1.AuditAPI
                 * @instance
                 * @param {clutch.audit.v1.IGetEventsRequest} request GetEventsRequest message or plain object
                 * @returns {Promise<clutch.audit.v1.GetEventsResponse>} Promise
                 * @variation 2
                 */

                return AuditAPI;
            })();

            v1.TimeRange = (function() {

                /**
                 * Properties of a TimeRange.
                 * @memberof clutch.audit.v1
                 * @interface ITimeRange
                 * @property {google.protobuf.ITimestamp|null} [startTime] TimeRange startTime
                 * @property {google.protobuf.ITimestamp|null} [endTime] TimeRange endTime
                 */

                /**
                 * Constructs a new TimeRange.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents a TimeRange.
                 * @implements ITimeRange
                 * @constructor
                 * @param {clutch.audit.v1.ITimeRange=} [properties] Properties to set
                 */
                function TimeRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TimeRange startTime.
                 * @member {google.protobuf.ITimestamp|null|undefined} startTime
                 * @memberof clutch.audit.v1.TimeRange
                 * @instance
                 */
                TimeRange.prototype.startTime = null;

                /**
                 * TimeRange endTime.
                 * @member {google.protobuf.ITimestamp|null|undefined} endTime
                 * @memberof clutch.audit.v1.TimeRange
                 * @instance
                 */
                TimeRange.prototype.endTime = null;

                /**
                 * Verifies a TimeRange message.
                 * @function verify
                 * @memberof clutch.audit.v1.TimeRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TimeRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.startTime != null && message.hasOwnProperty("startTime")) {
                        let error = $root.google.protobuf.Timestamp.verify(message.startTime);
                        if (error)
                            return "startTime." + error;
                    }
                    if (message.endTime != null && message.hasOwnProperty("endTime")) {
                        let error = $root.google.protobuf.Timestamp.verify(message.endTime);
                        if (error)
                            return "endTime." + error;
                    }
                    return null;
                };

                /**
                 * Creates a TimeRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.audit.v1.TimeRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.audit.v1.TimeRange} TimeRange
                 */
                TimeRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.audit.v1.TimeRange)
                        return object;
                    let message = new $root.clutch.audit.v1.TimeRange();
                    if (object.startTime != null) {
                        if (typeof object.startTime !== "object")
                            throw TypeError(".clutch.audit.v1.TimeRange.startTime: object expected");
                        message.startTime = $root.google.protobuf.Timestamp.fromObject(object.startTime);
                    }
                    if (object.endTime != null) {
                        if (typeof object.endTime !== "object")
                            throw TypeError(".clutch.audit.v1.TimeRange.endTime: object expected");
                        message.endTime = $root.google.protobuf.Timestamp.fromObject(object.endTime);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TimeRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.audit.v1.TimeRange
                 * @static
                 * @param {clutch.audit.v1.TimeRange} message TimeRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TimeRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.startTime = null;
                        object.endTime = null;
                    }
                    if (message.startTime != null && message.hasOwnProperty("startTime"))
                        object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
                    if (message.endTime != null && message.hasOwnProperty("endTime"))
                        object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
                    return object;
                };

                /**
                 * Converts this TimeRange to JSON.
                 * @function toJSON
                 * @memberof clutch.audit.v1.TimeRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TimeRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TimeRange;
            })();

            v1.GetEventsRequest = (function() {

                /**
                 * Properties of a GetEventsRequest.
                 * @memberof clutch.audit.v1
                 * @interface IGetEventsRequest
                 * @property {clutch.audit.v1.ITimeRange|null} [range] GetEventsRequest range
                 * @property {google.protobuf.IDuration|null} [since] GetEventsRequest since
                 */

                /**
                 * Constructs a new GetEventsRequest.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents a GetEventsRequest.
                 * @implements IGetEventsRequest
                 * @constructor
                 * @param {clutch.audit.v1.IGetEventsRequest=} [properties] Properties to set
                 */
                function GetEventsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetEventsRequest range.
                 * @member {clutch.audit.v1.ITimeRange|null|undefined} range
                 * @memberof clutch.audit.v1.GetEventsRequest
                 * @instance
                 */
                GetEventsRequest.prototype.range = null;

                /**
                 * GetEventsRequest since.
                 * @member {google.protobuf.IDuration|null|undefined} since
                 * @memberof clutch.audit.v1.GetEventsRequest
                 * @instance
                 */
                GetEventsRequest.prototype.since = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * GetEventsRequest window.
                 * @member {"range"|"since"|undefined} window
                 * @memberof clutch.audit.v1.GetEventsRequest
                 * @instance
                 */
                Object.defineProperty(GetEventsRequest.prototype, "window", {
                    get: $util.oneOfGetter($oneOfFields = ["range", "since"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies a GetEventsRequest message.
                 * @function verify
                 * @memberof clutch.audit.v1.GetEventsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetEventsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.range != null && message.hasOwnProperty("range")) {
                        properties.window = 1;
                        {
                            let error = $root.clutch.audit.v1.TimeRange.verify(message.range);
                            if (error)
                                return "range." + error;
                        }
                    }
                    if (message.since != null && message.hasOwnProperty("since")) {
                        if (properties.window === 1)
                            return "window: multiple values";
                        properties.window = 1;
                        {
                            let error = $root.google.protobuf.Duration.verify(message.since);
                            if (error)
                                return "since." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetEventsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.audit.v1.GetEventsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.audit.v1.GetEventsRequest} GetEventsRequest
                 */
                GetEventsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.audit.v1.GetEventsRequest)
                        return object;
                    let message = new $root.clutch.audit.v1.GetEventsRequest();
                    if (object.range != null) {
                        if (typeof object.range !== "object")
                            throw TypeError(".clutch.audit.v1.GetEventsRequest.range: object expected");
                        message.range = $root.clutch.audit.v1.TimeRange.fromObject(object.range);
                    }
                    if (object.since != null) {
                        if (typeof object.since !== "object")
                            throw TypeError(".clutch.audit.v1.GetEventsRequest.since: object expected");
                        message.since = $root.google.protobuf.Duration.fromObject(object.since);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetEventsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.audit.v1.GetEventsRequest
                 * @static
                 * @param {clutch.audit.v1.GetEventsRequest} message GetEventsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetEventsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.range != null && message.hasOwnProperty("range")) {
                        object.range = $root.clutch.audit.v1.TimeRange.toObject(message.range, options);
                        if (options.oneofs)
                            object.window = "range";
                    }
                    if (message.since != null && message.hasOwnProperty("since")) {
                        object.since = $root.google.protobuf.Duration.toObject(message.since, options);
                        if (options.oneofs)
                            object.window = "since";
                    }
                    return object;
                };

                /**
                 * Converts this GetEventsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.audit.v1.GetEventsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetEventsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetEventsRequest;
            })();

            v1.Resource = (function() {

                /**
                 * Properties of a Resource.
                 * @memberof clutch.audit.v1
                 * @interface IResource
                 * @property {string|null} [typeUrl] Resource typeUrl
                 * @property {string|null} [id] Resource id
                 */

                /**
                 * Constructs a new Resource.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents a Resource.
                 * @implements IResource
                 * @constructor
                 * @param {clutch.audit.v1.IResource=} [properties] Properties to set
                 */
                function Resource(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Resource typeUrl.
                 * @member {string} typeUrl
                 * @memberof clutch.audit.v1.Resource
                 * @instance
                 */
                Resource.prototype.typeUrl = "";

                /**
                 * Resource id.
                 * @member {string} id
                 * @memberof clutch.audit.v1.Resource
                 * @instance
                 */
                Resource.prototype.id = "";

                /**
                 * Verifies a Resource message.
                 * @function verify
                 * @memberof clutch.audit.v1.Resource
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Resource.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        if (!$util.isString(message.typeUrl))
                            return "typeUrl: string expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    return null;
                };

                /**
                 * Creates a Resource message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.audit.v1.Resource
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.audit.v1.Resource} Resource
                 */
                Resource.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.audit.v1.Resource)
                        return object;
                    let message = new $root.clutch.audit.v1.Resource();
                    if (object.typeUrl != null)
                        message.typeUrl = String(object.typeUrl);
                    if (object.id != null)
                        message.id = String(object.id);
                    return message;
                };

                /**
                 * Creates a plain object from a Resource message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.audit.v1.Resource
                 * @static
                 * @param {clutch.audit.v1.Resource} message Resource
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Resource.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.typeUrl = "";
                        object.id = "";
                    }
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        object.typeUrl = message.typeUrl;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    return object;
                };

                /**
                 * Converts this Resource to JSON.
                 * @function toJSON
                 * @memberof clutch.audit.v1.Resource
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Resource.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Resource;
            })();

            v1.RequestMetadata = (function() {

                /**
                 * Properties of a RequestMetadata.
                 * @memberof clutch.audit.v1
                 * @interface IRequestMetadata
                 * @property {google.protobuf.IAny|null} [body] RequestMetadata body
                 */

                /**
                 * Constructs a new RequestMetadata.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents a RequestMetadata.
                 * @implements IRequestMetadata
                 * @constructor
                 * @param {clutch.audit.v1.IRequestMetadata=} [properties] Properties to set
                 */
                function RequestMetadata(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RequestMetadata body.
                 * @member {google.protobuf.IAny|null|undefined} body
                 * @memberof clutch.audit.v1.RequestMetadata
                 * @instance
                 */
                RequestMetadata.prototype.body = null;

                /**
                 * Verifies a RequestMetadata message.
                 * @function verify
                 * @memberof clutch.audit.v1.RequestMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RequestMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.body != null && message.hasOwnProperty("body")) {
                        let error = $root.google.protobuf.Any.verify(message.body);
                        if (error)
                            return "body." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RequestMetadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.audit.v1.RequestMetadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.audit.v1.RequestMetadata} RequestMetadata
                 */
                RequestMetadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.audit.v1.RequestMetadata)
                        return object;
                    let message = new $root.clutch.audit.v1.RequestMetadata();
                    if (object.body != null) {
                        if (typeof object.body !== "object")
                            throw TypeError(".clutch.audit.v1.RequestMetadata.body: object expected");
                        message.body = $root.google.protobuf.Any.fromObject(object.body);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RequestMetadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.audit.v1.RequestMetadata
                 * @static
                 * @param {clutch.audit.v1.RequestMetadata} message RequestMetadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RequestMetadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.body = null;
                    if (message.body != null && message.hasOwnProperty("body"))
                        object.body = $root.google.protobuf.Any.toObject(message.body, options);
                    return object;
                };

                /**
                 * Converts this RequestMetadata to JSON.
                 * @function toJSON
                 * @memberof clutch.audit.v1.RequestMetadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RequestMetadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RequestMetadata;
            })();

            v1.ResponseMetadata = (function() {

                /**
                 * Properties of a ResponseMetadata.
                 * @memberof clutch.audit.v1
                 * @interface IResponseMetadata
                 * @property {google.protobuf.IAny|null} [body] ResponseMetadata body
                 */

                /**
                 * Constructs a new ResponseMetadata.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents a ResponseMetadata.
                 * @implements IResponseMetadata
                 * @constructor
                 * @param {clutch.audit.v1.IResponseMetadata=} [properties] Properties to set
                 */
                function ResponseMetadata(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ResponseMetadata body.
                 * @member {google.protobuf.IAny|null|undefined} body
                 * @memberof clutch.audit.v1.ResponseMetadata
                 * @instance
                 */
                ResponseMetadata.prototype.body = null;

                /**
                 * Verifies a ResponseMetadata message.
                 * @function verify
                 * @memberof clutch.audit.v1.ResponseMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ResponseMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.body != null && message.hasOwnProperty("body")) {
                        let error = $root.google.protobuf.Any.verify(message.body);
                        if (error)
                            return "body." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ResponseMetadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.audit.v1.ResponseMetadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.audit.v1.ResponseMetadata} ResponseMetadata
                 */
                ResponseMetadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.audit.v1.ResponseMetadata)
                        return object;
                    let message = new $root.clutch.audit.v1.ResponseMetadata();
                    if (object.body != null) {
                        if (typeof object.body !== "object")
                            throw TypeError(".clutch.audit.v1.ResponseMetadata.body: object expected");
                        message.body = $root.google.protobuf.Any.fromObject(object.body);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ResponseMetadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.audit.v1.ResponseMetadata
                 * @static
                 * @param {clutch.audit.v1.ResponseMetadata} message ResponseMetadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ResponseMetadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.body = null;
                    if (message.body != null && message.hasOwnProperty("body"))
                        object.body = $root.google.protobuf.Any.toObject(message.body, options);
                    return object;
                };

                /**
                 * Converts this ResponseMetadata to JSON.
                 * @function toJSON
                 * @memberof clutch.audit.v1.ResponseMetadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ResponseMetadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ResponseMetadata;
            })();

            v1.RequestEvent = (function() {

                /**
                 * Properties of a RequestEvent.
                 * @memberof clutch.audit.v1
                 * @interface IRequestEvent
                 * @property {string|null} [username] RequestEvent username
                 * @property {string|null} [serviceName] RequestEvent serviceName
                 * @property {string|null} [methodName] RequestEvent methodName
                 * @property {clutch.api.v1.ActionType|null} [type] RequestEvent type
                 * @property {google.rpc.IStatus|null} [status] RequestEvent status
                 * @property {Array.<clutch.audit.v1.IResource>|null} [resources] RequestEvent resources
                 * @property {clutch.audit.v1.IRequestMetadata|null} [requestMetadata] RequestEvent requestMetadata
                 * @property {clutch.audit.v1.IResponseMetadata|null} [responseMetadata] RequestEvent responseMetadata
                 */

                /**
                 * Constructs a new RequestEvent.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents a RequestEvent.
                 * @implements IRequestEvent
                 * @constructor
                 * @param {clutch.audit.v1.IRequestEvent=} [properties] Properties to set
                 */
                function RequestEvent(properties) {
                    this.resources = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RequestEvent username.
                 * @member {string} username
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 */
                RequestEvent.prototype.username = "";

                /**
                 * RequestEvent serviceName.
                 * @member {string} serviceName
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 */
                RequestEvent.prototype.serviceName = "";

                /**
                 * RequestEvent methodName.
                 * @member {string} methodName
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 */
                RequestEvent.prototype.methodName = "";

                /**
                 * RequestEvent type.
                 * @member {clutch.api.v1.ActionType} type
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 */
                RequestEvent.prototype.type = 0;

                /**
                 * RequestEvent status.
                 * @member {google.rpc.IStatus|null|undefined} status
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 */
                RequestEvent.prototype.status = null;

                /**
                 * RequestEvent resources.
                 * @member {Array.<clutch.audit.v1.IResource>} resources
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 */
                RequestEvent.prototype.resources = $util.emptyArray;

                /**
                 * RequestEvent requestMetadata.
                 * @member {clutch.audit.v1.IRequestMetadata|null|undefined} requestMetadata
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 */
                RequestEvent.prototype.requestMetadata = null;

                /**
                 * RequestEvent responseMetadata.
                 * @member {clutch.audit.v1.IResponseMetadata|null|undefined} responseMetadata
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 */
                RequestEvent.prototype.responseMetadata = null;

                /**
                 * Verifies a RequestEvent message.
                 * @function verify
                 * @memberof clutch.audit.v1.RequestEvent
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RequestEvent.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.username != null && message.hasOwnProperty("username"))
                        if (!$util.isString(message.username))
                            return "username: string expected";
                    if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                        if (!$util.isString(message.serviceName))
                            return "serviceName: string expected";
                    if (message.methodName != null && message.hasOwnProperty("methodName"))
                        if (!$util.isString(message.methodName))
                            return "methodName: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.status != null && message.hasOwnProperty("status")) {
                        let error = $root.google.rpc.Status.verify(message.status);
                        if (error)
                            return "status." + error;
                    }
                    if (message.resources != null && message.hasOwnProperty("resources")) {
                        if (!Array.isArray(message.resources))
                            return "resources: array expected";
                        for (let i = 0; i < message.resources.length; ++i) {
                            let error = $root.clutch.audit.v1.Resource.verify(message.resources[i]);
                            if (error)
                                return "resources." + error;
                        }
                    }
                    if (message.requestMetadata != null && message.hasOwnProperty("requestMetadata")) {
                        let error = $root.clutch.audit.v1.RequestMetadata.verify(message.requestMetadata);
                        if (error)
                            return "requestMetadata." + error;
                    }
                    if (message.responseMetadata != null && message.hasOwnProperty("responseMetadata")) {
                        let error = $root.clutch.audit.v1.ResponseMetadata.verify(message.responseMetadata);
                        if (error)
                            return "responseMetadata." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RequestEvent message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.audit.v1.RequestEvent
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.audit.v1.RequestEvent} RequestEvent
                 */
                RequestEvent.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.audit.v1.RequestEvent)
                        return object;
                    let message = new $root.clutch.audit.v1.RequestEvent();
                    if (object.username != null)
                        message.username = String(object.username);
                    if (object.serviceName != null)
                        message.serviceName = String(object.serviceName);
                    if (object.methodName != null)
                        message.methodName = String(object.methodName);
                    switch (object.type) {
                    case "UNSPECIFIED":
                    case 0:
                        message.type = 0;
                        break;
                    case "CREATE":
                    case 1:
                        message.type = 1;
                        break;
                    case "READ":
                    case 2:
                        message.type = 2;
                        break;
                    case "UPDATE":
                    case 3:
                        message.type = 3;
                        break;
                    case "DELETE":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    if (object.status != null) {
                        if (typeof object.status !== "object")
                            throw TypeError(".clutch.audit.v1.RequestEvent.status: object expected");
                        message.status = $root.google.rpc.Status.fromObject(object.status);
                    }
                    if (object.resources) {
                        if (!Array.isArray(object.resources))
                            throw TypeError(".clutch.audit.v1.RequestEvent.resources: array expected");
                        message.resources = [];
                        for (let i = 0; i < object.resources.length; ++i) {
                            if (typeof object.resources[i] !== "object")
                                throw TypeError(".clutch.audit.v1.RequestEvent.resources: object expected");
                            message.resources[i] = $root.clutch.audit.v1.Resource.fromObject(object.resources[i]);
                        }
                    }
                    if (object.requestMetadata != null) {
                        if (typeof object.requestMetadata !== "object")
                            throw TypeError(".clutch.audit.v1.RequestEvent.requestMetadata: object expected");
                        message.requestMetadata = $root.clutch.audit.v1.RequestMetadata.fromObject(object.requestMetadata);
                    }
                    if (object.responseMetadata != null) {
                        if (typeof object.responseMetadata !== "object")
                            throw TypeError(".clutch.audit.v1.RequestEvent.responseMetadata: object expected");
                        message.responseMetadata = $root.clutch.audit.v1.ResponseMetadata.fromObject(object.responseMetadata);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RequestEvent message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.audit.v1.RequestEvent
                 * @static
                 * @param {clutch.audit.v1.RequestEvent} message RequestEvent
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RequestEvent.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.resources = [];
                    if (options.defaults) {
                        object.username = "";
                        object.serviceName = "";
                        object.methodName = "";
                        object.type = options.enums === String ? "UNSPECIFIED" : 0;
                        object.status = null;
                        object.requestMetadata = null;
                        object.responseMetadata = null;
                    }
                    if (message.username != null && message.hasOwnProperty("username"))
                        object.username = message.username;
                    if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                        object.serviceName = message.serviceName;
                    if (message.methodName != null && message.hasOwnProperty("methodName"))
                        object.methodName = message.methodName;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.clutch.api.v1.ActionType[message.type] : message.type;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = $root.google.rpc.Status.toObject(message.status, options);
                    if (message.resources && message.resources.length) {
                        object.resources = [];
                        for (let j = 0; j < message.resources.length; ++j)
                            object.resources[j] = $root.clutch.audit.v1.Resource.toObject(message.resources[j], options);
                    }
                    if (message.requestMetadata != null && message.hasOwnProperty("requestMetadata"))
                        object.requestMetadata = $root.clutch.audit.v1.RequestMetadata.toObject(message.requestMetadata, options);
                    if (message.responseMetadata != null && message.hasOwnProperty("responseMetadata"))
                        object.responseMetadata = $root.clutch.audit.v1.ResponseMetadata.toObject(message.responseMetadata, options);
                    return object;
                };

                /**
                 * Converts this RequestEvent to JSON.
                 * @function toJSON
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RequestEvent.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RequestEvent;
            })();

            v1.Event = (function() {

                /**
                 * Properties of an Event.
                 * @memberof clutch.audit.v1
                 * @interface IEvent
                 * @property {google.protobuf.ITimestamp|null} [occurredAt] Event occurredAt
                 * @property {clutch.audit.v1.IRequestEvent|null} [event] Event event
                 */

                /**
                 * Constructs a new Event.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents an Event.
                 * @implements IEvent
                 * @constructor
                 * @param {clutch.audit.v1.IEvent=} [properties] Properties to set
                 */
                function Event(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Event occurredAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} occurredAt
                 * @memberof clutch.audit.v1.Event
                 * @instance
                 */
                Event.prototype.occurredAt = null;

                /**
                 * Event event.
                 * @member {clutch.audit.v1.IRequestEvent|null|undefined} event
                 * @memberof clutch.audit.v1.Event
                 * @instance
                 */
                Event.prototype.event = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Event eventType.
                 * @member {"event"|undefined} eventType
                 * @memberof clutch.audit.v1.Event
                 * @instance
                 */
                Object.defineProperty(Event.prototype, "eventType", {
                    get: $util.oneOfGetter($oneOfFields = ["event"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies an Event message.
                 * @function verify
                 * @memberof clutch.audit.v1.Event
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Event.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt")) {
                        let error = $root.google.protobuf.Timestamp.verify(message.occurredAt);
                        if (error)
                            return "occurredAt." + error;
                    }
                    if (message.event != null && message.hasOwnProperty("event")) {
                        properties.eventType = 1;
                        {
                            let error = $root.clutch.audit.v1.RequestEvent.verify(message.event);
                            if (error)
                                return "event." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Event message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.audit.v1.Event
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.audit.v1.Event} Event
                 */
                Event.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.audit.v1.Event)
                        return object;
                    let message = new $root.clutch.audit.v1.Event();
                    if (object.occurredAt != null) {
                        if (typeof object.occurredAt !== "object")
                            throw TypeError(".clutch.audit.v1.Event.occurredAt: object expected");
                        message.occurredAt = $root.google.protobuf.Timestamp.fromObject(object.occurredAt);
                    }
                    if (object.event != null) {
                        if (typeof object.event !== "object")
                            throw TypeError(".clutch.audit.v1.Event.event: object expected");
                        message.event = $root.clutch.audit.v1.RequestEvent.fromObject(object.event);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Event message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.audit.v1.Event
                 * @static
                 * @param {clutch.audit.v1.Event} message Event
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Event.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.occurredAt = null;
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt"))
                        object.occurredAt = $root.google.protobuf.Timestamp.toObject(message.occurredAt, options);
                    if (message.event != null && message.hasOwnProperty("event")) {
                        object.event = $root.clutch.audit.v1.RequestEvent.toObject(message.event, options);
                        if (options.oneofs)
                            object.eventType = "event";
                    }
                    return object;
                };

                /**
                 * Converts this Event to JSON.
                 * @function toJSON
                 * @memberof clutch.audit.v1.Event
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Event.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Event;
            })();

            v1.GetEventsResponse = (function() {

                /**
                 * Properties of a GetEventsResponse.
                 * @memberof clutch.audit.v1
                 * @interface IGetEventsResponse
                 * @property {Array.<clutch.audit.v1.IEvent>|null} [events] GetEventsResponse events
                 */

                /**
                 * Constructs a new GetEventsResponse.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents a GetEventsResponse.
                 * @implements IGetEventsResponse
                 * @constructor
                 * @param {clutch.audit.v1.IGetEventsResponse=} [properties] Properties to set
                 */
                function GetEventsResponse(properties) {
                    this.events = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetEventsResponse events.
                 * @member {Array.<clutch.audit.v1.IEvent>} events
                 * @memberof clutch.audit.v1.GetEventsResponse
                 * @instance
                 */
                GetEventsResponse.prototype.events = $util.emptyArray;

                /**
                 * Verifies a GetEventsResponse message.
                 * @function verify
                 * @memberof clutch.audit.v1.GetEventsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetEventsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.events != null && message.hasOwnProperty("events")) {
                        if (!Array.isArray(message.events))
                            return "events: array expected";
                        for (let i = 0; i < message.events.length; ++i) {
                            let error = $root.clutch.audit.v1.Event.verify(message.events[i]);
                            if (error)
                                return "events." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetEventsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.audit.v1.GetEventsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.audit.v1.GetEventsResponse} GetEventsResponse
                 */
                GetEventsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.audit.v1.GetEventsResponse)
                        return object;
                    let message = new $root.clutch.audit.v1.GetEventsResponse();
                    if (object.events) {
                        if (!Array.isArray(object.events))
                            throw TypeError(".clutch.audit.v1.GetEventsResponse.events: array expected");
                        message.events = [];
                        for (let i = 0; i < object.events.length; ++i) {
                            if (typeof object.events[i] !== "object")
                                throw TypeError(".clutch.audit.v1.GetEventsResponse.events: object expected");
                            message.events[i] = $root.clutch.audit.v1.Event.fromObject(object.events[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetEventsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.audit.v1.GetEventsResponse
                 * @static
                 * @param {clutch.audit.v1.GetEventsResponse} message GetEventsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetEventsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.events = [];
                    if (message.events && message.events.length) {
                        object.events = [];
                        for (let j = 0; j < message.events.length; ++j)
                            object.events[j] = $root.clutch.audit.v1.Event.toObject(message.events[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetEventsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.audit.v1.GetEventsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetEventsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetEventsResponse;
            })();

            return v1;
        })();

        return audit;
    })();

    clutch.authn = (function() {

        /**
         * Namespace authn.
         * @memberof clutch
         * @namespace
         */
        const authn = {};

        authn.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.authn
             * @namespace
             */
            const v1 = {};

            v1.AuthnAPI = (function() {

                /**
                 * Constructs a new AuthnAPI service.
                 * @memberof clutch.authn.v1
                 * @classdesc Represents an AuthnAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function AuthnAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (AuthnAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AuthnAPI;

                /**
                 * Callback as used by {@link clutch.authn.v1.AuthnAPI#login}.
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @typedef LoginCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.authn.v1.LoginResponse} [response] LoginResponse
                 */

                /**
                 * Calls Login.
                 * @function login
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @instance
                 * @param {clutch.authn.v1.ILoginRequest} request LoginRequest message or plain object
                 * @param {clutch.authn.v1.AuthnAPI.LoginCallback} callback Node-style callback called with the error, if any, and LoginResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AuthnAPI.prototype.login = function login(request, callback) {
                    return this.rpcCall(login, $root.clutch.authn.v1.LoginRequest, $root.clutch.authn.v1.LoginResponse, request, callback);
                }, "name", { value: "Login" });

                /**
                 * Calls Login.
                 * @function login
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @instance
                 * @param {clutch.authn.v1.ILoginRequest} request LoginRequest message or plain object
                 * @returns {Promise<clutch.authn.v1.LoginResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.authn.v1.AuthnAPI#callback}.
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @typedef CallbackCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.authn.v1.CallbackResponse} [response] CallbackResponse
                 */

                /**
                 * Calls Callback.
                 * @function callback
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @instance
                 * @param {clutch.authn.v1.ICallbackRequest} request CallbackRequest message or plain object
                 * @param {clutch.authn.v1.AuthnAPI.CallbackCallback} callback Node-style callback called with the error, if any, and CallbackResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AuthnAPI.prototype.callback = function callback(request, callback) {
                    return this.rpcCall(callback, $root.clutch.authn.v1.CallbackRequest, $root.clutch.authn.v1.CallbackResponse, request, callback);
                }, "name", { value: "Callback" });

                /**
                 * Calls Callback.
                 * @function callback
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @instance
                 * @param {clutch.authn.v1.ICallbackRequest} request CallbackRequest message or plain object
                 * @returns {Promise<clutch.authn.v1.CallbackResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.authn.v1.AuthnAPI#createToken}.
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @typedef CreateTokenCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.authn.v1.CreateTokenResponse} [response] CreateTokenResponse
                 */

                /**
                 * Calls CreateToken.
                 * @function createToken
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @instance
                 * @param {clutch.authn.v1.ICreateTokenRequest} request CreateTokenRequest message or plain object
                 * @param {clutch.authn.v1.AuthnAPI.CreateTokenCallback} callback Node-style callback called with the error, if any, and CreateTokenResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AuthnAPI.prototype.createToken = function createToken(request, callback) {
                    return this.rpcCall(createToken, $root.clutch.authn.v1.CreateTokenRequest, $root.clutch.authn.v1.CreateTokenResponse, request, callback);
                }, "name", { value: "CreateToken" });

                /**
                 * Calls CreateToken.
                 * @function createToken
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @instance
                 * @param {clutch.authn.v1.ICreateTokenRequest} request CreateTokenRequest message or plain object
                 * @returns {Promise<clutch.authn.v1.CreateTokenResponse>} Promise
                 * @variation 2
                 */

                return AuthnAPI;
            })();

            v1.LoginRequest = (function() {

                /**
                 * Properties of a LoginRequest.
                 * @memberof clutch.authn.v1
                 * @interface ILoginRequest
                 * @property {string|null} [redirectUrl] LoginRequest redirectUrl
                 */

                /**
                 * Constructs a new LoginRequest.
                 * @memberof clutch.authn.v1
                 * @classdesc Represents a LoginRequest.
                 * @implements ILoginRequest
                 * @constructor
                 * @param {clutch.authn.v1.ILoginRequest=} [properties] Properties to set
                 */
                function LoginRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LoginRequest redirectUrl.
                 * @member {string} redirectUrl
                 * @memberof clutch.authn.v1.LoginRequest
                 * @instance
                 */
                LoginRequest.prototype.redirectUrl = "";

                /**
                 * Verifies a LoginRequest message.
                 * @function verify
                 * @memberof clutch.authn.v1.LoginRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LoginRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.redirectUrl != null && message.hasOwnProperty("redirectUrl"))
                        if (!$util.isString(message.redirectUrl))
                            return "redirectUrl: string expected";
                    return null;
                };

                /**
                 * Creates a LoginRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authn.v1.LoginRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authn.v1.LoginRequest} LoginRequest
                 */
                LoginRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authn.v1.LoginRequest)
                        return object;
                    let message = new $root.clutch.authn.v1.LoginRequest();
                    if (object.redirectUrl != null)
                        message.redirectUrl = String(object.redirectUrl);
                    return message;
                };

                /**
                 * Creates a plain object from a LoginRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authn.v1.LoginRequest
                 * @static
                 * @param {clutch.authn.v1.LoginRequest} message LoginRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LoginRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.redirectUrl = "";
                    if (message.redirectUrl != null && message.hasOwnProperty("redirectUrl"))
                        object.redirectUrl = message.redirectUrl;
                    return object;
                };

                /**
                 * Converts this LoginRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.authn.v1.LoginRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LoginRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LoginRequest;
            })();

            v1.LoginResponse = (function() {

                /**
                 * Properties of a LoginResponse.
                 * @memberof clutch.authn.v1
                 * @interface ILoginResponse
                 * @property {string|null} [authUrl] LoginResponse authUrl
                 * @property {clutch.authn.v1.LoginResponse.IToken|null} [token] LoginResponse token
                 */

                /**
                 * Constructs a new LoginResponse.
                 * @memberof clutch.authn.v1
                 * @classdesc Represents a LoginResponse.
                 * @implements ILoginResponse
                 * @constructor
                 * @param {clutch.authn.v1.ILoginResponse=} [properties] Properties to set
                 */
                function LoginResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LoginResponse authUrl.
                 * @member {string|null|undefined} authUrl
                 * @memberof clutch.authn.v1.LoginResponse
                 * @instance
                 */
                LoginResponse.prototype.authUrl = null;

                /**
                 * LoginResponse token.
                 * @member {clutch.authn.v1.LoginResponse.IToken|null|undefined} token
                 * @memberof clutch.authn.v1.LoginResponse
                 * @instance
                 */
                LoginResponse.prototype.token = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * LoginResponse return.
                 * @member {"authUrl"|"token"|undefined} return_
                 * @memberof clutch.authn.v1.LoginResponse
                 * @instance
                 */
                Object.defineProperty(LoginResponse.prototype, "return", {
                    get: $util.oneOfGetter($oneOfFields = ["authUrl", "token"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies a LoginResponse message.
                 * @function verify
                 * @memberof clutch.authn.v1.LoginResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LoginResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.authUrl != null && message.hasOwnProperty("authUrl")) {
                        properties["return"] = 1;
                        if (!$util.isString(message.authUrl))
                            return "authUrl: string expected";
                    }
                    if (message.token != null && message.hasOwnProperty("token")) {
                        if (properties["return"] === 1)
                            return "return: multiple values";
                        properties["return"] = 1;
                        {
                            let error = $root.clutch.authn.v1.LoginResponse.Token.verify(message.token);
                            if (error)
                                return "token." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a LoginResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authn.v1.LoginResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authn.v1.LoginResponse} LoginResponse
                 */
                LoginResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authn.v1.LoginResponse)
                        return object;
                    let message = new $root.clutch.authn.v1.LoginResponse();
                    if (object.authUrl != null)
                        message.authUrl = String(object.authUrl);
                    if (object.token != null) {
                        if (typeof object.token !== "object")
                            throw TypeError(".clutch.authn.v1.LoginResponse.token: object expected");
                        message.token = $root.clutch.authn.v1.LoginResponse.Token.fromObject(object.token);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a LoginResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authn.v1.LoginResponse
                 * @static
                 * @param {clutch.authn.v1.LoginResponse} message LoginResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LoginResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.authUrl != null && message.hasOwnProperty("authUrl")) {
                        object.authUrl = message.authUrl;
                        if (options.oneofs)
                            object["return"] = "authUrl";
                    }
                    if (message.token != null && message.hasOwnProperty("token")) {
                        object.token = $root.clutch.authn.v1.LoginResponse.Token.toObject(message.token, options);
                        if (options.oneofs)
                            object["return"] = "token";
                    }
                    return object;
                };

                /**
                 * Converts this LoginResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.authn.v1.LoginResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LoginResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                LoginResponse.Token = (function() {

                    /**
                     * Properties of a Token.
                     * @memberof clutch.authn.v1.LoginResponse
                     * @interface IToken
                     * @property {string|null} [accessToken] Token accessToken
                     * @property {string|null} [refreshToken] Token refreshToken
                     */

                    /**
                     * Constructs a new Token.
                     * @memberof clutch.authn.v1.LoginResponse
                     * @classdesc Represents a Token.
                     * @implements IToken
                     * @constructor
                     * @param {clutch.authn.v1.LoginResponse.IToken=} [properties] Properties to set
                     */
                    function Token(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Token accessToken.
                     * @member {string} accessToken
                     * @memberof clutch.authn.v1.LoginResponse.Token
                     * @instance
                     */
                    Token.prototype.accessToken = "";

                    /**
                     * Token refreshToken.
                     * @member {string} refreshToken
                     * @memberof clutch.authn.v1.LoginResponse.Token
                     * @instance
                     */
                    Token.prototype.refreshToken = "";

                    /**
                     * Verifies a Token message.
                     * @function verify
                     * @memberof clutch.authn.v1.LoginResponse.Token
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Token.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.accessToken != null && message.hasOwnProperty("accessToken"))
                            if (!$util.isString(message.accessToken))
                                return "accessToken: string expected";
                        if (message.refreshToken != null && message.hasOwnProperty("refreshToken"))
                            if (!$util.isString(message.refreshToken))
                                return "refreshToken: string expected";
                        return null;
                    };

                    /**
                     * Creates a Token message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.authn.v1.LoginResponse.Token
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.authn.v1.LoginResponse.Token} Token
                     */
                    Token.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.authn.v1.LoginResponse.Token)
                            return object;
                        let message = new $root.clutch.authn.v1.LoginResponse.Token();
                        if (object.accessToken != null)
                            message.accessToken = String(object.accessToken);
                        if (object.refreshToken != null)
                            message.refreshToken = String(object.refreshToken);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Token message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.authn.v1.LoginResponse.Token
                     * @static
                     * @param {clutch.authn.v1.LoginResponse.Token} message Token
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Token.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.accessToken = "";
                            object.refreshToken = "";
                        }
                        if (message.accessToken != null && message.hasOwnProperty("accessToken"))
                            object.accessToken = message.accessToken;
                        if (message.refreshToken != null && message.hasOwnProperty("refreshToken"))
                            object.refreshToken = message.refreshToken;
                        return object;
                    };

                    /**
                     * Converts this Token to JSON.
                     * @function toJSON
                     * @memberof clutch.authn.v1.LoginResponse.Token
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Token.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Token;
                })();

                return LoginResponse;
            })();

            v1.CallbackRequest = (function() {

                /**
                 * Properties of a CallbackRequest.
                 * @memberof clutch.authn.v1
                 * @interface ICallbackRequest
                 * @property {string|null} [code] CallbackRequest code
                 * @property {string|null} [state] CallbackRequest state
                 * @property {string|null} [error] CallbackRequest error
                 * @property {string|null} [errorDescription] CallbackRequest errorDescription
                 */

                /**
                 * Constructs a new CallbackRequest.
                 * @memberof clutch.authn.v1
                 * @classdesc Represents a CallbackRequest.
                 * @implements ICallbackRequest
                 * @constructor
                 * @param {clutch.authn.v1.ICallbackRequest=} [properties] Properties to set
                 */
                function CallbackRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CallbackRequest code.
                 * @member {string} code
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @instance
                 */
                CallbackRequest.prototype.code = "";

                /**
                 * CallbackRequest state.
                 * @member {string} state
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @instance
                 */
                CallbackRequest.prototype.state = "";

                /**
                 * CallbackRequest error.
                 * @member {string} error
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @instance
                 */
                CallbackRequest.prototype.error = "";

                /**
                 * CallbackRequest errorDescription.
                 * @member {string} errorDescription
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @instance
                 */
                CallbackRequest.prototype.errorDescription = "";

                /**
                 * Verifies a CallbackRequest message.
                 * @function verify
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CallbackRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (!$util.isString(message.code))
                            return "code: string expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        if (!$util.isString(message.state))
                            return "state: string expected";
                    if (message.error != null && message.hasOwnProperty("error"))
                        if (!$util.isString(message.error))
                            return "error: string expected";
                    if (message.errorDescription != null && message.hasOwnProperty("errorDescription"))
                        if (!$util.isString(message.errorDescription))
                            return "errorDescription: string expected";
                    return null;
                };

                /**
                 * Creates a CallbackRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authn.v1.CallbackRequest} CallbackRequest
                 */
                CallbackRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authn.v1.CallbackRequest)
                        return object;
                    let message = new $root.clutch.authn.v1.CallbackRequest();
                    if (object.code != null)
                        message.code = String(object.code);
                    if (object.state != null)
                        message.state = String(object.state);
                    if (object.error != null)
                        message.error = String(object.error);
                    if (object.errorDescription != null)
                        message.errorDescription = String(object.errorDescription);
                    return message;
                };

                /**
                 * Creates a plain object from a CallbackRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @static
                 * @param {clutch.authn.v1.CallbackRequest} message CallbackRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CallbackRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.code = "";
                        object.state = "";
                        object.error = "";
                        object.errorDescription = "";
                    }
                    if (message.code != null && message.hasOwnProperty("code"))
                        object.code = message.code;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = message.state;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = message.error;
                    if (message.errorDescription != null && message.hasOwnProperty("errorDescription"))
                        object.errorDescription = message.errorDescription;
                    return object;
                };

                /**
                 * Converts this CallbackRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CallbackRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CallbackRequest;
            })();

            v1.CallbackResponse = (function() {

                /**
                 * Properties of a CallbackResponse.
                 * @memberof clutch.authn.v1
                 * @interface ICallbackResponse
                 * @property {string|null} [accessToken] CallbackResponse accessToken
                 * @property {string|null} [refreshToken] CallbackResponse refreshToken
                 */

                /**
                 * Constructs a new CallbackResponse.
                 * @memberof clutch.authn.v1
                 * @classdesc Represents a CallbackResponse.
                 * @implements ICallbackResponse
                 * @constructor
                 * @param {clutch.authn.v1.ICallbackResponse=} [properties] Properties to set
                 */
                function CallbackResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CallbackResponse accessToken.
                 * @member {string} accessToken
                 * @memberof clutch.authn.v1.CallbackResponse
                 * @instance
                 */
                CallbackResponse.prototype.accessToken = "";

                /**
                 * CallbackResponse refreshToken.
                 * @member {string} refreshToken
                 * @memberof clutch.authn.v1.CallbackResponse
                 * @instance
                 */
                CallbackResponse.prototype.refreshToken = "";

                /**
                 * Verifies a CallbackResponse message.
                 * @function verify
                 * @memberof clutch.authn.v1.CallbackResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CallbackResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.accessToken != null && message.hasOwnProperty("accessToken"))
                        if (!$util.isString(message.accessToken))
                            return "accessToken: string expected";
                    if (message.refreshToken != null && message.hasOwnProperty("refreshToken"))
                        if (!$util.isString(message.refreshToken))
                            return "refreshToken: string expected";
                    return null;
                };

                /**
                 * Creates a CallbackResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authn.v1.CallbackResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authn.v1.CallbackResponse} CallbackResponse
                 */
                CallbackResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authn.v1.CallbackResponse)
                        return object;
                    let message = new $root.clutch.authn.v1.CallbackResponse();
                    if (object.accessToken != null)
                        message.accessToken = String(object.accessToken);
                    if (object.refreshToken != null)
                        message.refreshToken = String(object.refreshToken);
                    return message;
                };

                /**
                 * Creates a plain object from a CallbackResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authn.v1.CallbackResponse
                 * @static
                 * @param {clutch.authn.v1.CallbackResponse} message CallbackResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CallbackResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.accessToken = "";
                        object.refreshToken = "";
                    }
                    if (message.accessToken != null && message.hasOwnProperty("accessToken"))
                        object.accessToken = message.accessToken;
                    if (message.refreshToken != null && message.hasOwnProperty("refreshToken"))
                        object.refreshToken = message.refreshToken;
                    return object;
                };

                /**
                 * Converts this CallbackResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.authn.v1.CallbackResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CallbackResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CallbackResponse;
            })();

            v1.CreateTokenRequest = (function() {

                /**
                 * Properties of a CreateTokenRequest.
                 * @memberof clutch.authn.v1
                 * @interface ICreateTokenRequest
                 * @property {string|null} [subject] CreateTokenRequest subject
                 * @property {google.protobuf.IDuration|null} [expiry] CreateTokenRequest expiry
                 * @property {clutch.authn.v1.CreateTokenRequest.TokenType|null} [tokenType] CreateTokenRequest tokenType
                 */

                /**
                 * Constructs a new CreateTokenRequest.
                 * @memberof clutch.authn.v1
                 * @classdesc Represents a CreateTokenRequest.
                 * @implements ICreateTokenRequest
                 * @constructor
                 * @param {clutch.authn.v1.ICreateTokenRequest=} [properties] Properties to set
                 */
                function CreateTokenRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateTokenRequest subject.
                 * @member {string} subject
                 * @memberof clutch.authn.v1.CreateTokenRequest
                 * @instance
                 */
                CreateTokenRequest.prototype.subject = "";

                /**
                 * CreateTokenRequest expiry.
                 * @member {google.protobuf.IDuration|null|undefined} expiry
                 * @memberof clutch.authn.v1.CreateTokenRequest
                 * @instance
                 */
                CreateTokenRequest.prototype.expiry = null;

                /**
                 * CreateTokenRequest tokenType.
                 * @member {clutch.authn.v1.CreateTokenRequest.TokenType} tokenType
                 * @memberof clutch.authn.v1.CreateTokenRequest
                 * @instance
                 */
                CreateTokenRequest.prototype.tokenType = 0;

                /**
                 * Verifies a CreateTokenRequest message.
                 * @function verify
                 * @memberof clutch.authn.v1.CreateTokenRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateTokenRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.subject != null && message.hasOwnProperty("subject"))
                        if (!$util.isString(message.subject))
                            return "subject: string expected";
                    if (message.expiry != null && message.hasOwnProperty("expiry")) {
                        let error = $root.google.protobuf.Duration.verify(message.expiry);
                        if (error)
                            return "expiry." + error;
                    }
                    if (message.tokenType != null && message.hasOwnProperty("tokenType"))
                        switch (message.tokenType) {
                        default:
                            return "tokenType: enum value expected";
                        case 0:
                        case 1:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a CreateTokenRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authn.v1.CreateTokenRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authn.v1.CreateTokenRequest} CreateTokenRequest
                 */
                CreateTokenRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authn.v1.CreateTokenRequest)
                        return object;
                    let message = new $root.clutch.authn.v1.CreateTokenRequest();
                    if (object.subject != null)
                        message.subject = String(object.subject);
                    if (object.expiry != null) {
                        if (typeof object.expiry !== "object")
                            throw TypeError(".clutch.authn.v1.CreateTokenRequest.expiry: object expected");
                        message.expiry = $root.google.protobuf.Duration.fromObject(object.expiry);
                    }
                    switch (object.tokenType) {
                    case "UNSPECIFIED":
                    case 0:
                        message.tokenType = 0;
                        break;
                    case "SERVICE":
                    case 1:
                        message.tokenType = 1;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateTokenRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authn.v1.CreateTokenRequest
                 * @static
                 * @param {clutch.authn.v1.CreateTokenRequest} message CreateTokenRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateTokenRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.subject = "";
                        object.expiry = null;
                        object.tokenType = options.enums === String ? "UNSPECIFIED" : 0;
                    }
                    if (message.subject != null && message.hasOwnProperty("subject"))
                        object.subject = message.subject;
                    if (message.expiry != null && message.hasOwnProperty("expiry"))
                        object.expiry = $root.google.protobuf.Duration.toObject(message.expiry, options);
                    if (message.tokenType != null && message.hasOwnProperty("tokenType"))
                        object.tokenType = options.enums === String ? $root.clutch.authn.v1.CreateTokenRequest.TokenType[message.tokenType] : message.tokenType;
                    return object;
                };

                /**
                 * Converts this CreateTokenRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.authn.v1.CreateTokenRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateTokenRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * TokenType enum.
                 * @name clutch.authn.v1.CreateTokenRequest.TokenType
                 * @enum {number}
                 * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                 * @property {number} SERVICE=1 SERVICE value
                 */
                CreateTokenRequest.TokenType = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNSPECIFIED"] = 0;
                    values[valuesById[1] = "SERVICE"] = 1;
                    return values;
                })();

                return CreateTokenRequest;
            })();

            v1.CreateTokenResponse = (function() {

                /**
                 * Properties of a CreateTokenResponse.
                 * @memberof clutch.authn.v1
                 * @interface ICreateTokenResponse
                 * @property {string|null} [accessToken] CreateTokenResponse accessToken
                 */

                /**
                 * Constructs a new CreateTokenResponse.
                 * @memberof clutch.authn.v1
                 * @classdesc Represents a CreateTokenResponse.
                 * @implements ICreateTokenResponse
                 * @constructor
                 * @param {clutch.authn.v1.ICreateTokenResponse=} [properties] Properties to set
                 */
                function CreateTokenResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateTokenResponse accessToken.
                 * @member {string} accessToken
                 * @memberof clutch.authn.v1.CreateTokenResponse
                 * @instance
                 */
                CreateTokenResponse.prototype.accessToken = "";

                /**
                 * Verifies a CreateTokenResponse message.
                 * @function verify
                 * @memberof clutch.authn.v1.CreateTokenResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateTokenResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.accessToken != null && message.hasOwnProperty("accessToken"))
                        if (!$util.isString(message.accessToken))
                            return "accessToken: string expected";
                    return null;
                };

                /**
                 * Creates a CreateTokenResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authn.v1.CreateTokenResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authn.v1.CreateTokenResponse} CreateTokenResponse
                 */
                CreateTokenResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authn.v1.CreateTokenResponse)
                        return object;
                    let message = new $root.clutch.authn.v1.CreateTokenResponse();
                    if (object.accessToken != null)
                        message.accessToken = String(object.accessToken);
                    return message;
                };

                /**
                 * Creates a plain object from a CreateTokenResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authn.v1.CreateTokenResponse
                 * @static
                 * @param {clutch.authn.v1.CreateTokenResponse} message CreateTokenResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateTokenResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.accessToken = "";
                    if (message.accessToken != null && message.hasOwnProperty("accessToken"))
                        object.accessToken = message.accessToken;
                    return object;
                };

                /**
                 * Converts this CreateTokenResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.authn.v1.CreateTokenResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateTokenResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateTokenResponse;
            })();

            return v1;
        })();

        return authn;
    })();

    clutch.authz = (function() {

        /**
         * Namespace authz.
         * @memberof clutch
         * @namespace
         */
        const authz = {};

        authz.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.authz
             * @namespace
             */
            const v1 = {};

            v1.AuthzAPI = (function() {

                /**
                 * Constructs a new AuthzAPI service.
                 * @memberof clutch.authz.v1
                 * @classdesc Represents an AuthzAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function AuthzAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (AuthzAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AuthzAPI;

                /**
                 * Callback as used by {@link clutch.authz.v1.AuthzAPI#check}.
                 * @memberof clutch.authz.v1.AuthzAPI
                 * @typedef CheckCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.authz.v1.CheckResponse} [response] CheckResponse
                 */

                /**
                 * Calls Check.
                 * @function check
                 * @memberof clutch.authz.v1.AuthzAPI
                 * @instance
                 * @param {clutch.authz.v1.ICheckRequest} request CheckRequest message or plain object
                 * @param {clutch.authz.v1.AuthzAPI.CheckCallback} callback Node-style callback called with the error, if any, and CheckResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AuthzAPI.prototype.check = function check(request, callback) {
                    return this.rpcCall(check, $root.clutch.authz.v1.CheckRequest, $root.clutch.authz.v1.CheckResponse, request, callback);
                }, "name", { value: "Check" });

                /**
                 * Calls Check.
                 * @function check
                 * @memberof clutch.authz.v1.AuthzAPI
                 * @instance
                 * @param {clutch.authz.v1.ICheckRequest} request CheckRequest message or plain object
                 * @returns {Promise<clutch.authz.v1.CheckResponse>} Promise
                 * @variation 2
                 */

                return AuthzAPI;
            })();

            v1.Subject = (function() {

                /**
                 * Properties of a Subject.
                 * @memberof clutch.authz.v1
                 * @interface ISubject
                 * @property {string|null} [user] Subject user
                 * @property {Array.<string>|null} [groups] Subject groups
                 */

                /**
                 * Constructs a new Subject.
                 * @memberof clutch.authz.v1
                 * @classdesc Represents a Subject.
                 * @implements ISubject
                 * @constructor
                 * @param {clutch.authz.v1.ISubject=} [properties] Properties to set
                 */
                function Subject(properties) {
                    this.groups = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Subject user.
                 * @member {string} user
                 * @memberof clutch.authz.v1.Subject
                 * @instance
                 */
                Subject.prototype.user = "";

                /**
                 * Subject groups.
                 * @member {Array.<string>} groups
                 * @memberof clutch.authz.v1.Subject
                 * @instance
                 */
                Subject.prototype.groups = $util.emptyArray;

                /**
                 * Verifies a Subject message.
                 * @function verify
                 * @memberof clutch.authz.v1.Subject
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Subject.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.user != null && message.hasOwnProperty("user"))
                        if (!$util.isString(message.user))
                            return "user: string expected";
                    if (message.groups != null && message.hasOwnProperty("groups")) {
                        if (!Array.isArray(message.groups))
                            return "groups: array expected";
                        for (let i = 0; i < message.groups.length; ++i)
                            if (!$util.isString(message.groups[i]))
                                return "groups: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Subject message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authz.v1.Subject
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authz.v1.Subject} Subject
                 */
                Subject.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authz.v1.Subject)
                        return object;
                    let message = new $root.clutch.authz.v1.Subject();
                    if (object.user != null)
                        message.user = String(object.user);
                    if (object.groups) {
                        if (!Array.isArray(object.groups))
                            throw TypeError(".clutch.authz.v1.Subject.groups: array expected");
                        message.groups = [];
                        for (let i = 0; i < object.groups.length; ++i)
                            message.groups[i] = String(object.groups[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Subject message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authz.v1.Subject
                 * @static
                 * @param {clutch.authz.v1.Subject} message Subject
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Subject.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.groups = [];
                    if (options.defaults)
                        object.user = "";
                    if (message.user != null && message.hasOwnProperty("user"))
                        object.user = message.user;
                    if (message.groups && message.groups.length) {
                        object.groups = [];
                        for (let j = 0; j < message.groups.length; ++j)
                            object.groups[j] = message.groups[j];
                    }
                    return object;
                };

                /**
                 * Converts this Subject to JSON.
                 * @function toJSON
                 * @memberof clutch.authz.v1.Subject
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Subject.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Subject;
            })();

            v1.CheckRequest = (function() {

                /**
                 * Properties of a CheckRequest.
                 * @memberof clutch.authz.v1
                 * @interface ICheckRequest
                 * @property {clutch.authz.v1.ISubject|null} [subject] CheckRequest subject
                 * @property {string|null} [method] CheckRequest method
                 * @property {clutch.api.v1.ActionType|null} [actionType] CheckRequest actionType
                 * @property {string|null} [resource] CheckRequest resource
                 */

                /**
                 * Constructs a new CheckRequest.
                 * @memberof clutch.authz.v1
                 * @classdesc Represents a CheckRequest.
                 * @implements ICheckRequest
                 * @constructor
                 * @param {clutch.authz.v1.ICheckRequest=} [properties] Properties to set
                 */
                function CheckRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CheckRequest subject.
                 * @member {clutch.authz.v1.ISubject|null|undefined} subject
                 * @memberof clutch.authz.v1.CheckRequest
                 * @instance
                 */
                CheckRequest.prototype.subject = null;

                /**
                 * CheckRequest method.
                 * @member {string} method
                 * @memberof clutch.authz.v1.CheckRequest
                 * @instance
                 */
                CheckRequest.prototype.method = "";

                /**
                 * CheckRequest actionType.
                 * @member {clutch.api.v1.ActionType} actionType
                 * @memberof clutch.authz.v1.CheckRequest
                 * @instance
                 */
                CheckRequest.prototype.actionType = 0;

                /**
                 * CheckRequest resource.
                 * @member {string} resource
                 * @memberof clutch.authz.v1.CheckRequest
                 * @instance
                 */
                CheckRequest.prototype.resource = "";

                /**
                 * Verifies a CheckRequest message.
                 * @function verify
                 * @memberof clutch.authz.v1.CheckRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CheckRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.subject != null && message.hasOwnProperty("subject")) {
                        let error = $root.clutch.authz.v1.Subject.verify(message.subject);
                        if (error)
                            return "subject." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        if (!$util.isString(message.method))
                            return "method: string expected";
                    if (message.actionType != null && message.hasOwnProperty("actionType"))
                        switch (message.actionType) {
                        default:
                            return "actionType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.resource != null && message.hasOwnProperty("resource"))
                        if (!$util.isString(message.resource))
                            return "resource: string expected";
                    return null;
                };

                /**
                 * Creates a CheckRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authz.v1.CheckRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authz.v1.CheckRequest} CheckRequest
                 */
                CheckRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authz.v1.CheckRequest)
                        return object;
                    let message = new $root.clutch.authz.v1.CheckRequest();
                    if (object.subject != null) {
                        if (typeof object.subject !== "object")
                            throw TypeError(".clutch.authz.v1.CheckRequest.subject: object expected");
                        message.subject = $root.clutch.authz.v1.Subject.fromObject(object.subject);
                    }
                    if (object.method != null)
                        message.method = String(object.method);
                    switch (object.actionType) {
                    case "UNSPECIFIED":
                    case 0:
                        message.actionType = 0;
                        break;
                    case "CREATE":
                    case 1:
                        message.actionType = 1;
                        break;
                    case "READ":
                    case 2:
                        message.actionType = 2;
                        break;
                    case "UPDATE":
                    case 3:
                        message.actionType = 3;
                        break;
                    case "DELETE":
                    case 4:
                        message.actionType = 4;
                        break;
                    }
                    if (object.resource != null)
                        message.resource = String(object.resource);
                    return message;
                };

                /**
                 * Creates a plain object from a CheckRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authz.v1.CheckRequest
                 * @static
                 * @param {clutch.authz.v1.CheckRequest} message CheckRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CheckRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.subject = null;
                        object.method = "";
                        object.actionType = options.enums === String ? "UNSPECIFIED" : 0;
                        object.resource = "";
                    }
                    if (message.subject != null && message.hasOwnProperty("subject"))
                        object.subject = $root.clutch.authz.v1.Subject.toObject(message.subject, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = message.method;
                    if (message.actionType != null && message.hasOwnProperty("actionType"))
                        object.actionType = options.enums === String ? $root.clutch.api.v1.ActionType[message.actionType] : message.actionType;
                    if (message.resource != null && message.hasOwnProperty("resource"))
                        object.resource = message.resource;
                    return object;
                };

                /**
                 * Converts this CheckRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.authz.v1.CheckRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CheckRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CheckRequest;
            })();

            /**
             * Decision enum.
             * @name clutch.authz.v1.Decision
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} DENY=1 DENY value
             * @property {number} ALLOW=2 ALLOW value
             */
            v1.Decision = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "DENY"] = 1;
                values[valuesById[2] = "ALLOW"] = 2;
                return values;
            })();

            v1.CheckResponse = (function() {

                /**
                 * Properties of a CheckResponse.
                 * @memberof clutch.authz.v1
                 * @interface ICheckResponse
                 * @property {clutch.authz.v1.Decision|null} [decision] CheckResponse decision
                 */

                /**
                 * Constructs a new CheckResponse.
                 * @memberof clutch.authz.v1
                 * @classdesc Represents a CheckResponse.
                 * @implements ICheckResponse
                 * @constructor
                 * @param {clutch.authz.v1.ICheckResponse=} [properties] Properties to set
                 */
                function CheckResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CheckResponse decision.
                 * @member {clutch.authz.v1.Decision} decision
                 * @memberof clutch.authz.v1.CheckResponse
                 * @instance
                 */
                CheckResponse.prototype.decision = 0;

                /**
                 * Verifies a CheckResponse message.
                 * @function verify
                 * @memberof clutch.authz.v1.CheckResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CheckResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.decision != null && message.hasOwnProperty("decision"))
                        switch (message.decision) {
                        default:
                            return "decision: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a CheckResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authz.v1.CheckResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authz.v1.CheckResponse} CheckResponse
                 */
                CheckResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authz.v1.CheckResponse)
                        return object;
                    let message = new $root.clutch.authz.v1.CheckResponse();
                    switch (object.decision) {
                    case "UNSPECIFIED":
                    case 0:
                        message.decision = 0;
                        break;
                    case "DENY":
                    case 1:
                        message.decision = 1;
                        break;
                    case "ALLOW":
                    case 2:
                        message.decision = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CheckResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authz.v1.CheckResponse
                 * @static
                 * @param {clutch.authz.v1.CheckResponse} message CheckResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CheckResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.decision = options.enums === String ? "UNSPECIFIED" : 0;
                    if (message.decision != null && message.hasOwnProperty("decision"))
                        object.decision = options.enums === String ? $root.clutch.authz.v1.Decision[message.decision] : message.decision;
                    return object;
                };

                /**
                 * Converts this CheckResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.authz.v1.CheckResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CheckResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CheckResponse;
            })();

            return v1;
        })();

        return authz;
    })();

    clutch.aws = (function() {

        /**
         * Namespace aws.
         * @memberof clutch
         * @namespace
         */
        const aws = {};

        aws.dynamodb = (function() {

            /**
             * Namespace dynamodb.
             * @memberof clutch.aws
             * @namespace
             */
            const dynamodb = {};

            dynamodb.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.aws.dynamodb
                 * @namespace
                 */
                const v1 = {};

                v1.DDBAPI = (function() {

                    /**
                     * Constructs a new DDBAPI service.
                     * @memberof clutch.aws.dynamodb.v1
                     * @classdesc Represents a DDBAPI
                     * @extends $protobuf.rpc.Service
                     * @constructor
                     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                     */
                    function DDBAPI(rpcImpl, requestDelimited, responseDelimited) {
                        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                    }

                    (DDBAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = DDBAPI;

                    /**
                     * Callback as used by {@link clutch.aws.dynamodb.v1.DDBAPI#describeTable}.
                     * @memberof clutch.aws.dynamodb.v1.DDBAPI
                     * @typedef DescribeTableCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.aws.dynamodb.v1.DescribeTableResponse} [response] DescribeTableResponse
                     */

                    /**
                     * Calls DescribeTable.
                     * @function describeTable
                     * @memberof clutch.aws.dynamodb.v1.DDBAPI
                     * @instance
                     * @param {clutch.aws.dynamodb.v1.IDescribeTableRequest} request DescribeTableRequest message or plain object
                     * @param {clutch.aws.dynamodb.v1.DDBAPI.DescribeTableCallback} callback Node-style callback called with the error, if any, and DescribeTableResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(DDBAPI.prototype.describeTable = function describeTable(request, callback) {
                        return this.rpcCall(describeTable, $root.clutch.aws.dynamodb.v1.DescribeTableRequest, $root.clutch.aws.dynamodb.v1.DescribeTableResponse, request, callback);
                    }, "name", { value: "DescribeTable" });

                    /**
                     * Calls DescribeTable.
                     * @function describeTable
                     * @memberof clutch.aws.dynamodb.v1.DDBAPI
                     * @instance
                     * @param {clutch.aws.dynamodb.v1.IDescribeTableRequest} request DescribeTableRequest message or plain object
                     * @returns {Promise<clutch.aws.dynamodb.v1.DescribeTableResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.aws.dynamodb.v1.DDBAPI#updateCapacity}.
                     * @memberof clutch.aws.dynamodb.v1.DDBAPI
                     * @typedef UpdateCapacityCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.aws.dynamodb.v1.UpdateCapacityResponse} [response] UpdateCapacityResponse
                     */

                    /**
                     * Calls UpdateCapacity.
                     * @function updateCapacity
                     * @memberof clutch.aws.dynamodb.v1.DDBAPI
                     * @instance
                     * @param {clutch.aws.dynamodb.v1.IUpdateCapacityRequest} request UpdateCapacityRequest message or plain object
                     * @param {clutch.aws.dynamodb.v1.DDBAPI.UpdateCapacityCallback} callback Node-style callback called with the error, if any, and UpdateCapacityResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(DDBAPI.prototype.updateCapacity = function updateCapacity(request, callback) {
                        return this.rpcCall(updateCapacity, $root.clutch.aws.dynamodb.v1.UpdateCapacityRequest, $root.clutch.aws.dynamodb.v1.UpdateCapacityResponse, request, callback);
                    }, "name", { value: "UpdateCapacity" });

                    /**
                     * Calls UpdateCapacity.
                     * @function updateCapacity
                     * @memberof clutch.aws.dynamodb.v1.DDBAPI
                     * @instance
                     * @param {clutch.aws.dynamodb.v1.IUpdateCapacityRequest} request UpdateCapacityRequest message or plain object
                     * @returns {Promise<clutch.aws.dynamodb.v1.UpdateCapacityResponse>} Promise
                     * @variation 2
                     */

                    return DDBAPI;
                })();

                v1.Table = (function() {

                    /**
                     * Properties of a Table.
                     * @memberof clutch.aws.dynamodb.v1
                     * @interface ITable
                     * @property {string|null} [name] Table name
                     * @property {string|null} [region] Table region
                     * @property {Array.<clutch.aws.dynamodb.v1.IGlobalSecondaryIndex>|null} [globalSecondaryIndexes] Table globalSecondaryIndexes
                     * @property {clutch.aws.dynamodb.v1.IThroughput|null} [provisionedThroughput] Table provisionedThroughput
                     * @property {clutch.aws.dynamodb.v1.Table.Status|null} [status] Table status
                     * @property {clutch.aws.dynamodb.v1.Table.BillingMode|null} [billingMode] Table billingMode
                     * @property {string|null} [account] Table account
                     */

                    /**
                     * Constructs a new Table.
                     * @memberof clutch.aws.dynamodb.v1
                     * @classdesc Represents a Table.
                     * @implements ITable
                     * @constructor
                     * @param {clutch.aws.dynamodb.v1.ITable=} [properties] Properties to set
                     */
                    function Table(properties) {
                        this.globalSecondaryIndexes = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Table name.
                     * @member {string} name
                     * @memberof clutch.aws.dynamodb.v1.Table
                     * @instance
                     */
                    Table.prototype.name = "";

                    /**
                     * Table region.
                     * @member {string} region
                     * @memberof clutch.aws.dynamodb.v1.Table
                     * @instance
                     */
                    Table.prototype.region = "";

                    /**
                     * Table globalSecondaryIndexes.
                     * @member {Array.<clutch.aws.dynamodb.v1.IGlobalSecondaryIndex>} globalSecondaryIndexes
                     * @memberof clutch.aws.dynamodb.v1.Table
                     * @instance
                     */
                    Table.prototype.globalSecondaryIndexes = $util.emptyArray;

                    /**
                     * Table provisionedThroughput.
                     * @member {clutch.aws.dynamodb.v1.IThroughput|null|undefined} provisionedThroughput
                     * @memberof clutch.aws.dynamodb.v1.Table
                     * @instance
                     */
                    Table.prototype.provisionedThroughput = null;

                    /**
                     * Table status.
                     * @member {clutch.aws.dynamodb.v1.Table.Status} status
                     * @memberof clutch.aws.dynamodb.v1.Table
                     * @instance
                     */
                    Table.prototype.status = 0;

                    /**
                     * Table billingMode.
                     * @member {clutch.aws.dynamodb.v1.Table.BillingMode} billingMode
                     * @memberof clutch.aws.dynamodb.v1.Table
                     * @instance
                     */
                    Table.prototype.billingMode = 0;

                    /**
                     * Table account.
                     * @member {string} account
                     * @memberof clutch.aws.dynamodb.v1.Table
                     * @instance
                     */
                    Table.prototype.account = "";

                    /**
                     * Verifies a Table message.
                     * @function verify
                     * @memberof clutch.aws.dynamodb.v1.Table
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Table.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.globalSecondaryIndexes != null && message.hasOwnProperty("globalSecondaryIndexes")) {
                            if (!Array.isArray(message.globalSecondaryIndexes))
                                return "globalSecondaryIndexes: array expected";
                            for (let i = 0; i < message.globalSecondaryIndexes.length; ++i) {
                                let error = $root.clutch.aws.dynamodb.v1.GlobalSecondaryIndex.verify(message.globalSecondaryIndexes[i]);
                                if (error)
                                    return "globalSecondaryIndexes." + error;
                            }
                        }
                        if (message.provisionedThroughput != null && message.hasOwnProperty("provisionedThroughput")) {
                            let error = $root.clutch.aws.dynamodb.v1.Throughput.verify(message.provisionedThroughput);
                            if (error)
                                return "provisionedThroughput." + error;
                        }
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                            case 8:
                                break;
                            }
                        if (message.billingMode != null && message.hasOwnProperty("billingMode"))
                            switch (message.billingMode) {
                            default:
                                return "billingMode: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates a Table message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.dynamodb.v1.Table
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.dynamodb.v1.Table} Table
                     */
                    Table.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.dynamodb.v1.Table)
                            return object;
                        let message = new $root.clutch.aws.dynamodb.v1.Table();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.globalSecondaryIndexes) {
                            if (!Array.isArray(object.globalSecondaryIndexes))
                                throw TypeError(".clutch.aws.dynamodb.v1.Table.globalSecondaryIndexes: array expected");
                            message.globalSecondaryIndexes = [];
                            for (let i = 0; i < object.globalSecondaryIndexes.length; ++i) {
                                if (typeof object.globalSecondaryIndexes[i] !== "object")
                                    throw TypeError(".clutch.aws.dynamodb.v1.Table.globalSecondaryIndexes: object expected");
                                message.globalSecondaryIndexes[i] = $root.clutch.aws.dynamodb.v1.GlobalSecondaryIndex.fromObject(object.globalSecondaryIndexes[i]);
                            }
                        }
                        if (object.provisionedThroughput != null) {
                            if (typeof object.provisionedThroughput !== "object")
                                throw TypeError(".clutch.aws.dynamodb.v1.Table.provisionedThroughput: object expected");
                            message.provisionedThroughput = $root.clutch.aws.dynamodb.v1.Throughput.fromObject(object.provisionedThroughput);
                        }
                        switch (object.status) {
                        case "UNSPECIFIED":
                        case 0:
                            message.status = 0;
                            break;
                        case "UNKNOWN":
                        case 1:
                            message.status = 1;
                            break;
                        case "CREATING":
                        case 2:
                            message.status = 2;
                            break;
                        case "UPDATING":
                        case 3:
                            message.status = 3;
                            break;
                        case "DELETING":
                        case 4:
                            message.status = 4;
                            break;
                        case "ACTIVE":
                        case 5:
                            message.status = 5;
                            break;
                        case "INACCESSIBLE_ENCRYPTION_CREDENTIALS":
                        case 6:
                            message.status = 6;
                            break;
                        case "ARCHIVING":
                        case 7:
                            message.status = 7;
                            break;
                        case "ARCHIVED":
                        case 8:
                            message.status = 8;
                            break;
                        }
                        switch (object.billingMode) {
                        case "BILLING_UNSPECIFIED":
                        case 0:
                            message.billingMode = 0;
                            break;
                        case "BILLING_UNKNOWN":
                        case 1:
                            message.billingMode = 1;
                            break;
                        case "PROVISIONED":
                        case 2:
                            message.billingMode = 2;
                            break;
                        case "PAY_PER_REQUEST":
                        case 3:
                            message.billingMode = 3;
                            break;
                        }
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Table message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.dynamodb.v1.Table
                     * @static
                     * @param {clutch.aws.dynamodb.v1.Table} message Table
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Table.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.globalSecondaryIndexes = [];
                        if (options.defaults) {
                            object.name = "";
                            object.region = "";
                            object.provisionedThroughput = null;
                            object.status = options.enums === String ? "UNSPECIFIED" : 0;
                            object.billingMode = options.enums === String ? "BILLING_UNSPECIFIED" : 0;
                            object.account = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.globalSecondaryIndexes && message.globalSecondaryIndexes.length) {
                            object.globalSecondaryIndexes = [];
                            for (let j = 0; j < message.globalSecondaryIndexes.length; ++j)
                                object.globalSecondaryIndexes[j] = $root.clutch.aws.dynamodb.v1.GlobalSecondaryIndex.toObject(message.globalSecondaryIndexes[j], options);
                        }
                        if (message.provisionedThroughput != null && message.hasOwnProperty("provisionedThroughput"))
                            object.provisionedThroughput = $root.clutch.aws.dynamodb.v1.Throughput.toObject(message.provisionedThroughput, options);
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.clutch.aws.dynamodb.v1.Table.Status[message.status] : message.status;
                        if (message.billingMode != null && message.hasOwnProperty("billingMode"))
                            object.billingMode = options.enums === String ? $root.clutch.aws.dynamodb.v1.Table.BillingMode[message.billingMode] : message.billingMode;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this Table to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.dynamodb.v1.Table
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Table.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Status enum.
                     * @name clutch.aws.dynamodb.v1.Table.Status
                     * @enum {number}
                     * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                     * @property {number} UNKNOWN=1 UNKNOWN value
                     * @property {number} CREATING=2 CREATING value
                     * @property {number} UPDATING=3 UPDATING value
                     * @property {number} DELETING=4 DELETING value
                     * @property {number} ACTIVE=5 ACTIVE value
                     * @property {number} INACCESSIBLE_ENCRYPTION_CREDENTIALS=6 INACCESSIBLE_ENCRYPTION_CREDENTIALS value
                     * @property {number} ARCHIVING=7 ARCHIVING value
                     * @property {number} ARCHIVED=8 ARCHIVED value
                     */
                    Table.Status = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNSPECIFIED"] = 0;
                        values[valuesById[1] = "UNKNOWN"] = 1;
                        values[valuesById[2] = "CREATING"] = 2;
                        values[valuesById[3] = "UPDATING"] = 3;
                        values[valuesById[4] = "DELETING"] = 4;
                        values[valuesById[5] = "ACTIVE"] = 5;
                        values[valuesById[6] = "INACCESSIBLE_ENCRYPTION_CREDENTIALS"] = 6;
                        values[valuesById[7] = "ARCHIVING"] = 7;
                        values[valuesById[8] = "ARCHIVED"] = 8;
                        return values;
                    })();

                    /**
                     * BillingMode enum.
                     * @name clutch.aws.dynamodb.v1.Table.BillingMode
                     * @enum {number}
                     * @property {number} BILLING_UNSPECIFIED=0 BILLING_UNSPECIFIED value
                     * @property {number} BILLING_UNKNOWN=1 BILLING_UNKNOWN value
                     * @property {number} PROVISIONED=2 PROVISIONED value
                     * @property {number} PAY_PER_REQUEST=3 PAY_PER_REQUEST value
                     */
                    Table.BillingMode = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "BILLING_UNSPECIFIED"] = 0;
                        values[valuesById[1] = "BILLING_UNKNOWN"] = 1;
                        values[valuesById[2] = "PROVISIONED"] = 2;
                        values[valuesById[3] = "PAY_PER_REQUEST"] = 3;
                        return values;
                    })();

                    return Table;
                })();

                v1.GlobalSecondaryIndex = (function() {

                    /**
                     * Properties of a GlobalSecondaryIndex.
                     * @memberof clutch.aws.dynamodb.v1
                     * @interface IGlobalSecondaryIndex
                     * @property {string|null} [name] GlobalSecondaryIndex name
                     * @property {clutch.aws.dynamodb.v1.IThroughput|null} [provisionedThroughput] GlobalSecondaryIndex provisionedThroughput
                     * @property {clutch.aws.dynamodb.v1.GlobalSecondaryIndex.Status|null} [status] GlobalSecondaryIndex status
                     */

                    /**
                     * Constructs a new GlobalSecondaryIndex.
                     * @memberof clutch.aws.dynamodb.v1
                     * @classdesc Represents a GlobalSecondaryIndex.
                     * @implements IGlobalSecondaryIndex
                     * @constructor
                     * @param {clutch.aws.dynamodb.v1.IGlobalSecondaryIndex=} [properties] Properties to set
                     */
                    function GlobalSecondaryIndex(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GlobalSecondaryIndex name.
                     * @member {string} name
                     * @memberof clutch.aws.dynamodb.v1.GlobalSecondaryIndex
                     * @instance
                     */
                    GlobalSecondaryIndex.prototype.name = "";

                    /**
                     * GlobalSecondaryIndex provisionedThroughput.
                     * @member {clutch.aws.dynamodb.v1.IThroughput|null|undefined} provisionedThroughput
                     * @memberof clutch.aws.dynamodb.v1.GlobalSecondaryIndex
                     * @instance
                     */
                    GlobalSecondaryIndex.prototype.provisionedThroughput = null;

                    /**
                     * GlobalSecondaryIndex status.
                     * @member {clutch.aws.dynamodb.v1.GlobalSecondaryIndex.Status} status
                     * @memberof clutch.aws.dynamodb.v1.GlobalSecondaryIndex
                     * @instance
                     */
                    GlobalSecondaryIndex.prototype.status = 0;

                    /**
                     * Verifies a GlobalSecondaryIndex message.
                     * @function verify
                     * @memberof clutch.aws.dynamodb.v1.GlobalSecondaryIndex
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GlobalSecondaryIndex.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.provisionedThroughput != null && message.hasOwnProperty("provisionedThroughput")) {
                            let error = $root.clutch.aws.dynamodb.v1.Throughput.verify(message.provisionedThroughput);
                            if (error)
                                return "provisionedThroughput." + error;
                        }
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a GlobalSecondaryIndex message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.dynamodb.v1.GlobalSecondaryIndex
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.dynamodb.v1.GlobalSecondaryIndex} GlobalSecondaryIndex
                     */
                    GlobalSecondaryIndex.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.dynamodb.v1.GlobalSecondaryIndex)
                            return object;
                        let message = new $root.clutch.aws.dynamodb.v1.GlobalSecondaryIndex();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.provisionedThroughput != null) {
                            if (typeof object.provisionedThroughput !== "object")
                                throw TypeError(".clutch.aws.dynamodb.v1.GlobalSecondaryIndex.provisionedThroughput: object expected");
                            message.provisionedThroughput = $root.clutch.aws.dynamodb.v1.Throughput.fromObject(object.provisionedThroughput);
                        }
                        switch (object.status) {
                        case "UNSPECIFIED":
                        case 0:
                            message.status = 0;
                            break;
                        case "UNKNOWN":
                        case 1:
                            message.status = 1;
                            break;
                        case "CREATING":
                        case 2:
                            message.status = 2;
                            break;
                        case "UPDATING":
                        case 3:
                            message.status = 3;
                            break;
                        case "DELETING":
                        case 4:
                            message.status = 4;
                            break;
                        case "ACTIVE":
                        case 5:
                            message.status = 5;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GlobalSecondaryIndex message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.dynamodb.v1.GlobalSecondaryIndex
                     * @static
                     * @param {clutch.aws.dynamodb.v1.GlobalSecondaryIndex} message GlobalSecondaryIndex
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GlobalSecondaryIndex.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.provisionedThroughput = null;
                            object.status = options.enums === String ? "UNSPECIFIED" : 0;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.provisionedThroughput != null && message.hasOwnProperty("provisionedThroughput"))
                            object.provisionedThroughput = $root.clutch.aws.dynamodb.v1.Throughput.toObject(message.provisionedThroughput, options);
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.clutch.aws.dynamodb.v1.GlobalSecondaryIndex.Status[message.status] : message.status;
                        return object;
                    };

                    /**
                     * Converts this GlobalSecondaryIndex to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.dynamodb.v1.GlobalSecondaryIndex
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GlobalSecondaryIndex.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Status enum.
                     * @name clutch.aws.dynamodb.v1.GlobalSecondaryIndex.Status
                     * @enum {number}
                     * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                     * @property {number} UNKNOWN=1 UNKNOWN value
                     * @property {number} CREATING=2 CREATING value
                     * @property {number} UPDATING=3 UPDATING value
                     * @property {number} DELETING=4 DELETING value
                     * @property {number} ACTIVE=5 ACTIVE value
                     */
                    GlobalSecondaryIndex.Status = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNSPECIFIED"] = 0;
                        values[valuesById[1] = "UNKNOWN"] = 1;
                        values[valuesById[2] = "CREATING"] = 2;
                        values[valuesById[3] = "UPDATING"] = 3;
                        values[valuesById[4] = "DELETING"] = 4;
                        values[valuesById[5] = "ACTIVE"] = 5;
                        return values;
                    })();

                    return GlobalSecondaryIndex;
                })();

                v1.IndexUpdateAction = (function() {

                    /**
                     * Properties of an IndexUpdateAction.
                     * @memberof clutch.aws.dynamodb.v1
                     * @interface IIndexUpdateAction
                     * @property {string|null} [name] IndexUpdateAction name
                     * @property {clutch.aws.dynamodb.v1.IThroughput|null} [indexThroughput] IndexUpdateAction indexThroughput
                     */

                    /**
                     * Constructs a new IndexUpdateAction.
                     * @memberof clutch.aws.dynamodb.v1
                     * @classdesc Represents an IndexUpdateAction.
                     * @implements IIndexUpdateAction
                     * @constructor
                     * @param {clutch.aws.dynamodb.v1.IIndexUpdateAction=} [properties] Properties to set
                     */
                    function IndexUpdateAction(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * IndexUpdateAction name.
                     * @member {string} name
                     * @memberof clutch.aws.dynamodb.v1.IndexUpdateAction
                     * @instance
                     */
                    IndexUpdateAction.prototype.name = "";

                    /**
                     * IndexUpdateAction indexThroughput.
                     * @member {clutch.aws.dynamodb.v1.IThroughput|null|undefined} indexThroughput
                     * @memberof clutch.aws.dynamodb.v1.IndexUpdateAction
                     * @instance
                     */
                    IndexUpdateAction.prototype.indexThroughput = null;

                    /**
                     * Verifies an IndexUpdateAction message.
                     * @function verify
                     * @memberof clutch.aws.dynamodb.v1.IndexUpdateAction
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    IndexUpdateAction.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.indexThroughput != null && message.hasOwnProperty("indexThroughput")) {
                            let error = $root.clutch.aws.dynamodb.v1.Throughput.verify(message.indexThroughput);
                            if (error)
                                return "indexThroughput." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an IndexUpdateAction message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.dynamodb.v1.IndexUpdateAction
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.dynamodb.v1.IndexUpdateAction} IndexUpdateAction
                     */
                    IndexUpdateAction.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.dynamodb.v1.IndexUpdateAction)
                            return object;
                        let message = new $root.clutch.aws.dynamodb.v1.IndexUpdateAction();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.indexThroughput != null) {
                            if (typeof object.indexThroughput !== "object")
                                throw TypeError(".clutch.aws.dynamodb.v1.IndexUpdateAction.indexThroughput: object expected");
                            message.indexThroughput = $root.clutch.aws.dynamodb.v1.Throughput.fromObject(object.indexThroughput);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an IndexUpdateAction message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.dynamodb.v1.IndexUpdateAction
                     * @static
                     * @param {clutch.aws.dynamodb.v1.IndexUpdateAction} message IndexUpdateAction
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    IndexUpdateAction.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.indexThroughput = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.indexThroughput != null && message.hasOwnProperty("indexThroughput"))
                            object.indexThroughput = $root.clutch.aws.dynamodb.v1.Throughput.toObject(message.indexThroughput, options);
                        return object;
                    };

                    /**
                     * Converts this IndexUpdateAction to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.dynamodb.v1.IndexUpdateAction
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    IndexUpdateAction.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return IndexUpdateAction;
                })();

                v1.Throughput = (function() {

                    /**
                     * Properties of a Throughput.
                     * @memberof clutch.aws.dynamodb.v1
                     * @interface IThroughput
                     * @property {number|Long|null} [writeCapacityUnits] Throughput writeCapacityUnits
                     * @property {number|Long|null} [readCapacityUnits] Throughput readCapacityUnits
                     */

                    /**
                     * Constructs a new Throughput.
                     * @memberof clutch.aws.dynamodb.v1
                     * @classdesc Represents a Throughput.
                     * @implements IThroughput
                     * @constructor
                     * @param {clutch.aws.dynamodb.v1.IThroughput=} [properties] Properties to set
                     */
                    function Throughput(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Throughput writeCapacityUnits.
                     * @member {number|Long} writeCapacityUnits
                     * @memberof clutch.aws.dynamodb.v1.Throughput
                     * @instance
                     */
                    Throughput.prototype.writeCapacityUnits = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Throughput readCapacityUnits.
                     * @member {number|Long} readCapacityUnits
                     * @memberof clutch.aws.dynamodb.v1.Throughput
                     * @instance
                     */
                    Throughput.prototype.readCapacityUnits = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Verifies a Throughput message.
                     * @function verify
                     * @memberof clutch.aws.dynamodb.v1.Throughput
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Throughput.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.writeCapacityUnits != null && message.hasOwnProperty("writeCapacityUnits"))
                            if (!$util.isInteger(message.writeCapacityUnits) && !(message.writeCapacityUnits && $util.isInteger(message.writeCapacityUnits.low) && $util.isInteger(message.writeCapacityUnits.high)))
                                return "writeCapacityUnits: integer|Long expected";
                        if (message.readCapacityUnits != null && message.hasOwnProperty("readCapacityUnits"))
                            if (!$util.isInteger(message.readCapacityUnits) && !(message.readCapacityUnits && $util.isInteger(message.readCapacityUnits.low) && $util.isInteger(message.readCapacityUnits.high)))
                                return "readCapacityUnits: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a Throughput message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.dynamodb.v1.Throughput
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.dynamodb.v1.Throughput} Throughput
                     */
                    Throughput.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.dynamodb.v1.Throughput)
                            return object;
                        let message = new $root.clutch.aws.dynamodb.v1.Throughput();
                        if (object.writeCapacityUnits != null)
                            if ($util.Long)
                                (message.writeCapacityUnits = $util.Long.fromValue(object.writeCapacityUnits)).unsigned = false;
                            else if (typeof object.writeCapacityUnits === "string")
                                message.writeCapacityUnits = parseInt(object.writeCapacityUnits, 10);
                            else if (typeof object.writeCapacityUnits === "number")
                                message.writeCapacityUnits = object.writeCapacityUnits;
                            else if (typeof object.writeCapacityUnits === "object")
                                message.writeCapacityUnits = new $util.LongBits(object.writeCapacityUnits.low >>> 0, object.writeCapacityUnits.high >>> 0).toNumber();
                        if (object.readCapacityUnits != null)
                            if ($util.Long)
                                (message.readCapacityUnits = $util.Long.fromValue(object.readCapacityUnits)).unsigned = false;
                            else if (typeof object.readCapacityUnits === "string")
                                message.readCapacityUnits = parseInt(object.readCapacityUnits, 10);
                            else if (typeof object.readCapacityUnits === "number")
                                message.readCapacityUnits = object.readCapacityUnits;
                            else if (typeof object.readCapacityUnits === "object")
                                message.readCapacityUnits = new $util.LongBits(object.readCapacityUnits.low >>> 0, object.readCapacityUnits.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from a Throughput message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.dynamodb.v1.Throughput
                     * @static
                     * @param {clutch.aws.dynamodb.v1.Throughput} message Throughput
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Throughput.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.writeCapacityUnits = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.writeCapacityUnits = options.longs === String ? "0" : 0;
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.readCapacityUnits = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.readCapacityUnits = options.longs === String ? "0" : 0;
                        }
                        if (message.writeCapacityUnits != null && message.hasOwnProperty("writeCapacityUnits"))
                            if (typeof message.writeCapacityUnits === "number")
                                object.writeCapacityUnits = options.longs === String ? String(message.writeCapacityUnits) : message.writeCapacityUnits;
                            else
                                object.writeCapacityUnits = options.longs === String ? $util.Long.prototype.toString.call(message.writeCapacityUnits) : options.longs === Number ? new $util.LongBits(message.writeCapacityUnits.low >>> 0, message.writeCapacityUnits.high >>> 0).toNumber() : message.writeCapacityUnits;
                        if (message.readCapacityUnits != null && message.hasOwnProperty("readCapacityUnits"))
                            if (typeof message.readCapacityUnits === "number")
                                object.readCapacityUnits = options.longs === String ? String(message.readCapacityUnits) : message.readCapacityUnits;
                            else
                                object.readCapacityUnits = options.longs === String ? $util.Long.prototype.toString.call(message.readCapacityUnits) : options.longs === Number ? new $util.LongBits(message.readCapacityUnits.low >>> 0, message.readCapacityUnits.high >>> 0).toNumber() : message.readCapacityUnits;
                        return object;
                    };

                    /**
                     * Converts this Throughput to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.dynamodb.v1.Throughput
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Throughput.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Throughput;
                })();

                v1.DescribeTableRequest = (function() {

                    /**
                     * Properties of a DescribeTableRequest.
                     * @memberof clutch.aws.dynamodb.v1
                     * @interface IDescribeTableRequest
                     * @property {string|null} [tableName] DescribeTableRequest tableName
                     * @property {string|null} [region] DescribeTableRequest region
                     * @property {string|null} [account] DescribeTableRequest account
                     */

                    /**
                     * Constructs a new DescribeTableRequest.
                     * @memberof clutch.aws.dynamodb.v1
                     * @classdesc Represents a DescribeTableRequest.
                     * @implements IDescribeTableRequest
                     * @constructor
                     * @param {clutch.aws.dynamodb.v1.IDescribeTableRequest=} [properties] Properties to set
                     */
                    function DescribeTableRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * DescribeTableRequest tableName.
                     * @member {string} tableName
                     * @memberof clutch.aws.dynamodb.v1.DescribeTableRequest
                     * @instance
                     */
                    DescribeTableRequest.prototype.tableName = "";

                    /**
                     * DescribeTableRequest region.
                     * @member {string} region
                     * @memberof clutch.aws.dynamodb.v1.DescribeTableRequest
                     * @instance
                     */
                    DescribeTableRequest.prototype.region = "";

                    /**
                     * DescribeTableRequest account.
                     * @member {string} account
                     * @memberof clutch.aws.dynamodb.v1.DescribeTableRequest
                     * @instance
                     */
                    DescribeTableRequest.prototype.account = "";

                    /**
                     * Verifies a DescribeTableRequest message.
                     * @function verify
                     * @memberof clutch.aws.dynamodb.v1.DescribeTableRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DescribeTableRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.tableName != null && message.hasOwnProperty("tableName"))
                            if (!$util.isString(message.tableName))
                                return "tableName: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates a DescribeTableRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.dynamodb.v1.DescribeTableRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.dynamodb.v1.DescribeTableRequest} DescribeTableRequest
                     */
                    DescribeTableRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.dynamodb.v1.DescribeTableRequest)
                            return object;
                        let message = new $root.clutch.aws.dynamodb.v1.DescribeTableRequest();
                        if (object.tableName != null)
                            message.tableName = String(object.tableName);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from a DescribeTableRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.dynamodb.v1.DescribeTableRequest
                     * @static
                     * @param {clutch.aws.dynamodb.v1.DescribeTableRequest} message DescribeTableRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DescribeTableRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.tableName = "";
                            object.region = "";
                            object.account = "";
                        }
                        if (message.tableName != null && message.hasOwnProperty("tableName"))
                            object.tableName = message.tableName;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this DescribeTableRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.dynamodb.v1.DescribeTableRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DescribeTableRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return DescribeTableRequest;
                })();

                v1.DescribeTableResponse = (function() {

                    /**
                     * Properties of a DescribeTableResponse.
                     * @memberof clutch.aws.dynamodb.v1
                     * @interface IDescribeTableResponse
                     * @property {clutch.aws.dynamodb.v1.ITable|null} [table] DescribeTableResponse table
                     */

                    /**
                     * Constructs a new DescribeTableResponse.
                     * @memberof clutch.aws.dynamodb.v1
                     * @classdesc Represents a DescribeTableResponse.
                     * @implements IDescribeTableResponse
                     * @constructor
                     * @param {clutch.aws.dynamodb.v1.IDescribeTableResponse=} [properties] Properties to set
                     */
                    function DescribeTableResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * DescribeTableResponse table.
                     * @member {clutch.aws.dynamodb.v1.ITable|null|undefined} table
                     * @memberof clutch.aws.dynamodb.v1.DescribeTableResponse
                     * @instance
                     */
                    DescribeTableResponse.prototype.table = null;

                    /**
                     * Verifies a DescribeTableResponse message.
                     * @function verify
                     * @memberof clutch.aws.dynamodb.v1.DescribeTableResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DescribeTableResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.table != null && message.hasOwnProperty("table")) {
                            let error = $root.clutch.aws.dynamodb.v1.Table.verify(message.table);
                            if (error)
                                return "table." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a DescribeTableResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.dynamodb.v1.DescribeTableResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.dynamodb.v1.DescribeTableResponse} DescribeTableResponse
                     */
                    DescribeTableResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.dynamodb.v1.DescribeTableResponse)
                            return object;
                        let message = new $root.clutch.aws.dynamodb.v1.DescribeTableResponse();
                        if (object.table != null) {
                            if (typeof object.table !== "object")
                                throw TypeError(".clutch.aws.dynamodb.v1.DescribeTableResponse.table: object expected");
                            message.table = $root.clutch.aws.dynamodb.v1.Table.fromObject(object.table);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a DescribeTableResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.dynamodb.v1.DescribeTableResponse
                     * @static
                     * @param {clutch.aws.dynamodb.v1.DescribeTableResponse} message DescribeTableResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DescribeTableResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.table = null;
                        if (message.table != null && message.hasOwnProperty("table"))
                            object.table = $root.clutch.aws.dynamodb.v1.Table.toObject(message.table, options);
                        return object;
                    };

                    /**
                     * Converts this DescribeTableResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.dynamodb.v1.DescribeTableResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DescribeTableResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return DescribeTableResponse;
                })();

                v1.UpdateCapacityRequest = (function() {

                    /**
                     * Properties of an UpdateCapacityRequest.
                     * @memberof clutch.aws.dynamodb.v1
                     * @interface IUpdateCapacityRequest
                     * @property {string|null} [tableName] UpdateCapacityRequest tableName
                     * @property {string|null} [region] UpdateCapacityRequest region
                     * @property {clutch.aws.dynamodb.v1.IThroughput|null} [tableThroughput] UpdateCapacityRequest tableThroughput
                     * @property {Array.<clutch.aws.dynamodb.v1.IIndexUpdateAction>|null} [gsiUpdates] UpdateCapacityRequest gsiUpdates
                     * @property {boolean|null} [ignoreMaximums] UpdateCapacityRequest ignoreMaximums
                     * @property {string|null} [account] UpdateCapacityRequest account
                     */

                    /**
                     * Constructs a new UpdateCapacityRequest.
                     * @memberof clutch.aws.dynamodb.v1
                     * @classdesc Represents an UpdateCapacityRequest.
                     * @implements IUpdateCapacityRequest
                     * @constructor
                     * @param {clutch.aws.dynamodb.v1.IUpdateCapacityRequest=} [properties] Properties to set
                     */
                    function UpdateCapacityRequest(properties) {
                        this.gsiUpdates = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UpdateCapacityRequest tableName.
                     * @member {string} tableName
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityRequest
                     * @instance
                     */
                    UpdateCapacityRequest.prototype.tableName = "";

                    /**
                     * UpdateCapacityRequest region.
                     * @member {string} region
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityRequest
                     * @instance
                     */
                    UpdateCapacityRequest.prototype.region = "";

                    /**
                     * UpdateCapacityRequest tableThroughput.
                     * @member {clutch.aws.dynamodb.v1.IThroughput|null|undefined} tableThroughput
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityRequest
                     * @instance
                     */
                    UpdateCapacityRequest.prototype.tableThroughput = null;

                    /**
                     * UpdateCapacityRequest gsiUpdates.
                     * @member {Array.<clutch.aws.dynamodb.v1.IIndexUpdateAction>} gsiUpdates
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityRequest
                     * @instance
                     */
                    UpdateCapacityRequest.prototype.gsiUpdates = $util.emptyArray;

                    /**
                     * UpdateCapacityRequest ignoreMaximums.
                     * @member {boolean} ignoreMaximums
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityRequest
                     * @instance
                     */
                    UpdateCapacityRequest.prototype.ignoreMaximums = false;

                    /**
                     * UpdateCapacityRequest account.
                     * @member {string} account
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityRequest
                     * @instance
                     */
                    UpdateCapacityRequest.prototype.account = "";

                    /**
                     * Verifies an UpdateCapacityRequest message.
                     * @function verify
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UpdateCapacityRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.tableName != null && message.hasOwnProperty("tableName"))
                            if (!$util.isString(message.tableName))
                                return "tableName: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.tableThroughput != null && message.hasOwnProperty("tableThroughput")) {
                            let error = $root.clutch.aws.dynamodb.v1.Throughput.verify(message.tableThroughput);
                            if (error)
                                return "tableThroughput." + error;
                        }
                        if (message.gsiUpdates != null && message.hasOwnProperty("gsiUpdates")) {
                            if (!Array.isArray(message.gsiUpdates))
                                return "gsiUpdates: array expected";
                            for (let i = 0; i < message.gsiUpdates.length; ++i) {
                                let error = $root.clutch.aws.dynamodb.v1.IndexUpdateAction.verify(message.gsiUpdates[i]);
                                if (error)
                                    return "gsiUpdates." + error;
                            }
                        }
                        if (message.ignoreMaximums != null && message.hasOwnProperty("ignoreMaximums"))
                            if (typeof message.ignoreMaximums !== "boolean")
                                return "ignoreMaximums: boolean expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates an UpdateCapacityRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.dynamodb.v1.UpdateCapacityRequest} UpdateCapacityRequest
                     */
                    UpdateCapacityRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.dynamodb.v1.UpdateCapacityRequest)
                            return object;
                        let message = new $root.clutch.aws.dynamodb.v1.UpdateCapacityRequest();
                        if (object.tableName != null)
                            message.tableName = String(object.tableName);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.tableThroughput != null) {
                            if (typeof object.tableThroughput !== "object")
                                throw TypeError(".clutch.aws.dynamodb.v1.UpdateCapacityRequest.tableThroughput: object expected");
                            message.tableThroughput = $root.clutch.aws.dynamodb.v1.Throughput.fromObject(object.tableThroughput);
                        }
                        if (object.gsiUpdates) {
                            if (!Array.isArray(object.gsiUpdates))
                                throw TypeError(".clutch.aws.dynamodb.v1.UpdateCapacityRequest.gsiUpdates: array expected");
                            message.gsiUpdates = [];
                            for (let i = 0; i < object.gsiUpdates.length; ++i) {
                                if (typeof object.gsiUpdates[i] !== "object")
                                    throw TypeError(".clutch.aws.dynamodb.v1.UpdateCapacityRequest.gsiUpdates: object expected");
                                message.gsiUpdates[i] = $root.clutch.aws.dynamodb.v1.IndexUpdateAction.fromObject(object.gsiUpdates[i]);
                            }
                        }
                        if (object.ignoreMaximums != null)
                            message.ignoreMaximums = Boolean(object.ignoreMaximums);
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from an UpdateCapacityRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityRequest
                     * @static
                     * @param {clutch.aws.dynamodb.v1.UpdateCapacityRequest} message UpdateCapacityRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UpdateCapacityRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.gsiUpdates = [];
                        if (options.defaults) {
                            object.tableName = "";
                            object.region = "";
                            object.tableThroughput = null;
                            object.ignoreMaximums = false;
                            object.account = "";
                        }
                        if (message.tableName != null && message.hasOwnProperty("tableName"))
                            object.tableName = message.tableName;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.tableThroughput != null && message.hasOwnProperty("tableThroughput"))
                            object.tableThroughput = $root.clutch.aws.dynamodb.v1.Throughput.toObject(message.tableThroughput, options);
                        if (message.gsiUpdates && message.gsiUpdates.length) {
                            object.gsiUpdates = [];
                            for (let j = 0; j < message.gsiUpdates.length; ++j)
                                object.gsiUpdates[j] = $root.clutch.aws.dynamodb.v1.IndexUpdateAction.toObject(message.gsiUpdates[j], options);
                        }
                        if (message.ignoreMaximums != null && message.hasOwnProperty("ignoreMaximums"))
                            object.ignoreMaximums = message.ignoreMaximums;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this UpdateCapacityRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UpdateCapacityRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UpdateCapacityRequest;
                })();

                v1.UpdateCapacityResponse = (function() {

                    /**
                     * Properties of an UpdateCapacityResponse.
                     * @memberof clutch.aws.dynamodb.v1
                     * @interface IUpdateCapacityResponse
                     * @property {clutch.aws.dynamodb.v1.ITable|null} [table] UpdateCapacityResponse table
                     */

                    /**
                     * Constructs a new UpdateCapacityResponse.
                     * @memberof clutch.aws.dynamodb.v1
                     * @classdesc Represents an UpdateCapacityResponse.
                     * @implements IUpdateCapacityResponse
                     * @constructor
                     * @param {clutch.aws.dynamodb.v1.IUpdateCapacityResponse=} [properties] Properties to set
                     */
                    function UpdateCapacityResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UpdateCapacityResponse table.
                     * @member {clutch.aws.dynamodb.v1.ITable|null|undefined} table
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityResponse
                     * @instance
                     */
                    UpdateCapacityResponse.prototype.table = null;

                    /**
                     * Verifies an UpdateCapacityResponse message.
                     * @function verify
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UpdateCapacityResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.table != null && message.hasOwnProperty("table")) {
                            let error = $root.clutch.aws.dynamodb.v1.Table.verify(message.table);
                            if (error)
                                return "table." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an UpdateCapacityResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.dynamodb.v1.UpdateCapacityResponse} UpdateCapacityResponse
                     */
                    UpdateCapacityResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.dynamodb.v1.UpdateCapacityResponse)
                            return object;
                        let message = new $root.clutch.aws.dynamodb.v1.UpdateCapacityResponse();
                        if (object.table != null) {
                            if (typeof object.table !== "object")
                                throw TypeError(".clutch.aws.dynamodb.v1.UpdateCapacityResponse.table: object expected");
                            message.table = $root.clutch.aws.dynamodb.v1.Table.fromObject(object.table);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an UpdateCapacityResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityResponse
                     * @static
                     * @param {clutch.aws.dynamodb.v1.UpdateCapacityResponse} message UpdateCapacityResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UpdateCapacityResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.table = null;
                        if (message.table != null && message.hasOwnProperty("table"))
                            object.table = $root.clutch.aws.dynamodb.v1.Table.toObject(message.table, options);
                        return object;
                    };

                    /**
                     * Converts this UpdateCapacityResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.dynamodb.v1.UpdateCapacityResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UpdateCapacityResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UpdateCapacityResponse;
                })();

                return v1;
            })();

            return dynamodb;
        })();

        aws.ec2 = (function() {

            /**
             * Namespace ec2.
             * @memberof clutch.aws
             * @namespace
             */
            const ec2 = {};

            ec2.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.aws.ec2
                 * @namespace
                 */
                const v1 = {};

                v1.EC2API = (function() {

                    /**
                     * Constructs a new EC2API service.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a EC2API
                     * @extends $protobuf.rpc.Service
                     * @constructor
                     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                     */
                    function EC2API(rpcImpl, requestDelimited, responseDelimited) {
                        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                    }

                    (EC2API.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = EC2API;

                    /**
                     * Callback as used by {@link clutch.aws.ec2.v1.EC2API#getInstance}.
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @typedef GetInstanceCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.aws.ec2.v1.GetInstanceResponse} [response] GetInstanceResponse
                     */

                    /**
                     * Calls GetInstance.
                     * @function getInstance
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @instance
                     * @param {clutch.aws.ec2.v1.IGetInstanceRequest} request GetInstanceRequest message or plain object
                     * @param {clutch.aws.ec2.v1.EC2API.GetInstanceCallback} callback Node-style callback called with the error, if any, and GetInstanceResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(EC2API.prototype.getInstance = function getInstance(request, callback) {
                        return this.rpcCall(getInstance, $root.clutch.aws.ec2.v1.GetInstanceRequest, $root.clutch.aws.ec2.v1.GetInstanceResponse, request, callback);
                    }, "name", { value: "GetInstance" });

                    /**
                     * Calls GetInstance.
                     * @function getInstance
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @instance
                     * @param {clutch.aws.ec2.v1.IGetInstanceRequest} request GetInstanceRequest message or plain object
                     * @returns {Promise<clutch.aws.ec2.v1.GetInstanceResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.aws.ec2.v1.EC2API#terminateInstance}.
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @typedef TerminateInstanceCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.aws.ec2.v1.TerminateInstanceResponse} [response] TerminateInstanceResponse
                     */

                    /**
                     * Calls TerminateInstance.
                     * @function terminateInstance
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @instance
                     * @param {clutch.aws.ec2.v1.ITerminateInstanceRequest} request TerminateInstanceRequest message or plain object
                     * @param {clutch.aws.ec2.v1.EC2API.TerminateInstanceCallback} callback Node-style callback called with the error, if any, and TerminateInstanceResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(EC2API.prototype.terminateInstance = function terminateInstance(request, callback) {
                        return this.rpcCall(terminateInstance, $root.clutch.aws.ec2.v1.TerminateInstanceRequest, $root.clutch.aws.ec2.v1.TerminateInstanceResponse, request, callback);
                    }, "name", { value: "TerminateInstance" });

                    /**
                     * Calls TerminateInstance.
                     * @function terminateInstance
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @instance
                     * @param {clutch.aws.ec2.v1.ITerminateInstanceRequest} request TerminateInstanceRequest message or plain object
                     * @returns {Promise<clutch.aws.ec2.v1.TerminateInstanceResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.aws.ec2.v1.EC2API#resizeAutoscalingGroup}.
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @typedef ResizeAutoscalingGroupCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse} [response] ResizeAutoscalingGroupResponse
                     */

                    /**
                     * Calls ResizeAutoscalingGroup.
                     * @function resizeAutoscalingGroup
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @instance
                     * @param {clutch.aws.ec2.v1.IResizeAutoscalingGroupRequest} request ResizeAutoscalingGroupRequest message or plain object
                     * @param {clutch.aws.ec2.v1.EC2API.ResizeAutoscalingGroupCallback} callback Node-style callback called with the error, if any, and ResizeAutoscalingGroupResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(EC2API.prototype.resizeAutoscalingGroup = function resizeAutoscalingGroup(request, callback) {
                        return this.rpcCall(resizeAutoscalingGroup, $root.clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest, $root.clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse, request, callback);
                    }, "name", { value: "ResizeAutoscalingGroup" });

                    /**
                     * Calls ResizeAutoscalingGroup.
                     * @function resizeAutoscalingGroup
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @instance
                     * @param {clutch.aws.ec2.v1.IResizeAutoscalingGroupRequest} request ResizeAutoscalingGroupRequest message or plain object
                     * @returns {Promise<clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.aws.ec2.v1.EC2API#rebootInstance}.
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @typedef RebootInstanceCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.aws.ec2.v1.RebootInstanceResponse} [response] RebootInstanceResponse
                     */

                    /**
                     * Calls RebootInstance.
                     * @function rebootInstance
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @instance
                     * @param {clutch.aws.ec2.v1.IRebootInstanceRequest} request RebootInstanceRequest message or plain object
                     * @param {clutch.aws.ec2.v1.EC2API.RebootInstanceCallback} callback Node-style callback called with the error, if any, and RebootInstanceResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(EC2API.prototype.rebootInstance = function rebootInstance(request, callback) {
                        return this.rpcCall(rebootInstance, $root.clutch.aws.ec2.v1.RebootInstanceRequest, $root.clutch.aws.ec2.v1.RebootInstanceResponse, request, callback);
                    }, "name", { value: "RebootInstance" });

                    /**
                     * Calls RebootInstance.
                     * @function rebootInstance
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @instance
                     * @param {clutch.aws.ec2.v1.IRebootInstanceRequest} request RebootInstanceRequest message or plain object
                     * @returns {Promise<clutch.aws.ec2.v1.RebootInstanceResponse>} Promise
                     * @variation 2
                     */

                    return EC2API;
                })();

                v1.AutoscalingGroupSize = (function() {

                    /**
                     * Properties of an AutoscalingGroupSize.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IAutoscalingGroupSize
                     * @property {number|null} [min] AutoscalingGroupSize min
                     * @property {number|null} [max] AutoscalingGroupSize max
                     * @property {number|null} [desired] AutoscalingGroupSize desired
                     */

                    /**
                     * Constructs a new AutoscalingGroupSize.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents an AutoscalingGroupSize.
                     * @implements IAutoscalingGroupSize
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IAutoscalingGroupSize=} [properties] Properties to set
                     */
                    function AutoscalingGroupSize(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * AutoscalingGroupSize min.
                     * @member {number} min
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroupSize
                     * @instance
                     */
                    AutoscalingGroupSize.prototype.min = 0;

                    /**
                     * AutoscalingGroupSize max.
                     * @member {number} max
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroupSize
                     * @instance
                     */
                    AutoscalingGroupSize.prototype.max = 0;

                    /**
                     * AutoscalingGroupSize desired.
                     * @member {number} desired
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroupSize
                     * @instance
                     */
                    AutoscalingGroupSize.prototype.desired = 0;

                    /**
                     * Verifies an AutoscalingGroupSize message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroupSize
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AutoscalingGroupSize.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.min != null && message.hasOwnProperty("min"))
                            if (!$util.isInteger(message.min))
                                return "min: integer expected";
                        if (message.max != null && message.hasOwnProperty("max"))
                            if (!$util.isInteger(message.max))
                                return "max: integer expected";
                        if (message.desired != null && message.hasOwnProperty("desired"))
                            if (!$util.isInteger(message.desired))
                                return "desired: integer expected";
                        return null;
                    };

                    /**
                     * Creates an AutoscalingGroupSize message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroupSize
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.AutoscalingGroupSize} AutoscalingGroupSize
                     */
                    AutoscalingGroupSize.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.AutoscalingGroupSize)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.AutoscalingGroupSize();
                        if (object.min != null)
                            message.min = object.min >>> 0;
                        if (object.max != null)
                            message.max = object.max >>> 0;
                        if (object.desired != null)
                            message.desired = object.desired >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from an AutoscalingGroupSize message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroupSize
                     * @static
                     * @param {clutch.aws.ec2.v1.AutoscalingGroupSize} message AutoscalingGroupSize
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AutoscalingGroupSize.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.min = 0;
                            object.max = 0;
                            object.desired = 0;
                        }
                        if (message.min != null && message.hasOwnProperty("min"))
                            object.min = message.min;
                        if (message.max != null && message.hasOwnProperty("max"))
                            object.max = message.max;
                        if (message.desired != null && message.hasOwnProperty("desired"))
                            object.desired = message.desired;
                        return object;
                    };

                    /**
                     * Converts this AutoscalingGroupSize to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroupSize
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AutoscalingGroupSize.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return AutoscalingGroupSize;
                })();

                v1.ResizeAutoscalingGroupRequest = (function() {

                    /**
                     * Properties of a ResizeAutoscalingGroupRequest.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IResizeAutoscalingGroupRequest
                     * @property {string|null} [name] ResizeAutoscalingGroupRequest name
                     * @property {string|null} [region] ResizeAutoscalingGroupRequest region
                     * @property {clutch.aws.ec2.v1.IAutoscalingGroupSize|null} [size] ResizeAutoscalingGroupRequest size
                     * @property {string|null} [account] ResizeAutoscalingGroupRequest account
                     */

                    /**
                     * Constructs a new ResizeAutoscalingGroupRequest.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a ResizeAutoscalingGroupRequest.
                     * @implements IResizeAutoscalingGroupRequest
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IResizeAutoscalingGroupRequest=} [properties] Properties to set
                     */
                    function ResizeAutoscalingGroupRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ResizeAutoscalingGroupRequest name.
                     * @member {string} name
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @instance
                     */
                    ResizeAutoscalingGroupRequest.prototype.name = "";

                    /**
                     * ResizeAutoscalingGroupRequest region.
                     * @member {string} region
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @instance
                     */
                    ResizeAutoscalingGroupRequest.prototype.region = "";

                    /**
                     * ResizeAutoscalingGroupRequest size.
                     * @member {clutch.aws.ec2.v1.IAutoscalingGroupSize|null|undefined} size
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @instance
                     */
                    ResizeAutoscalingGroupRequest.prototype.size = null;

                    /**
                     * ResizeAutoscalingGroupRequest account.
                     * @member {string} account
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @instance
                     */
                    ResizeAutoscalingGroupRequest.prototype.account = "";

                    /**
                     * Verifies a ResizeAutoscalingGroupRequest message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ResizeAutoscalingGroupRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.size != null && message.hasOwnProperty("size")) {
                            let error = $root.clutch.aws.ec2.v1.AutoscalingGroupSize.verify(message.size);
                            if (error)
                                return "size." + error;
                        }
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates a ResizeAutoscalingGroupRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest} ResizeAutoscalingGroupRequest
                     */
                    ResizeAutoscalingGroupRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.size != null) {
                            if (typeof object.size !== "object")
                                throw TypeError(".clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest.size: object expected");
                            message.size = $root.clutch.aws.ec2.v1.AutoscalingGroupSize.fromObject(object.size);
                        }
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from a ResizeAutoscalingGroupRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @static
                     * @param {clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest} message ResizeAutoscalingGroupRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ResizeAutoscalingGroupRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.region = "";
                            object.size = null;
                            object.account = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.size != null && message.hasOwnProperty("size"))
                            object.size = $root.clutch.aws.ec2.v1.AutoscalingGroupSize.toObject(message.size, options);
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this ResizeAutoscalingGroupRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ResizeAutoscalingGroupRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ResizeAutoscalingGroupRequest;
                })();

                v1.ResizeAutoscalingGroupResponse = (function() {

                    /**
                     * Properties of a ResizeAutoscalingGroupResponse.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IResizeAutoscalingGroupResponse
                     */

                    /**
                     * Constructs a new ResizeAutoscalingGroupResponse.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a ResizeAutoscalingGroupResponse.
                     * @implements IResizeAutoscalingGroupResponse
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IResizeAutoscalingGroupResponse=} [properties] Properties to set
                     */
                    function ResizeAutoscalingGroupResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Verifies a ResizeAutoscalingGroupResponse message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ResizeAutoscalingGroupResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a ResizeAutoscalingGroupResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse} ResizeAutoscalingGroupResponse
                     */
                    ResizeAutoscalingGroupResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse)
                            return object;
                        return new $root.clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse();
                    };

                    /**
                     * Creates a plain object from a ResizeAutoscalingGroupResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse
                     * @static
                     * @param {clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse} message ResizeAutoscalingGroupResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ResizeAutoscalingGroupResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this ResizeAutoscalingGroupResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ResizeAutoscalingGroupResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ResizeAutoscalingGroupResponse;
                })();

                v1.AutoscalingGroup = (function() {

                    /**
                     * Properties of an AutoscalingGroup.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IAutoscalingGroup
                     * @property {string|null} [name] AutoscalingGroup name
                     * @property {string|null} [region] AutoscalingGroup region
                     * @property {Array.<string>|null} [zones] AutoscalingGroup zones
                     * @property {clutch.aws.ec2.v1.IAutoscalingGroupSize|null} [size] AutoscalingGroup size
                     * @property {Array.<clutch.aws.ec2.v1.AutoscalingGroup.TerminationPolicy>|null} [terminationPolicies] AutoscalingGroup terminationPolicies
                     * @property {Array.<clutch.aws.ec2.v1.AutoscalingGroup.IInstance>|null} [instances] AutoscalingGroup instances
                     * @property {string|null} [account] AutoscalingGroup account
                     */

                    /**
                     * Constructs a new AutoscalingGroup.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents an AutoscalingGroup.
                     * @implements IAutoscalingGroup
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IAutoscalingGroup=} [properties] Properties to set
                     */
                    function AutoscalingGroup(properties) {
                        this.zones = [];
                        this.terminationPolicies = [];
                        this.instances = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * AutoscalingGroup name.
                     * @member {string} name
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     */
                    AutoscalingGroup.prototype.name = "";

                    /**
                     * AutoscalingGroup region.
                     * @member {string} region
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     */
                    AutoscalingGroup.prototype.region = "";

                    /**
                     * AutoscalingGroup zones.
                     * @member {Array.<string>} zones
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     */
                    AutoscalingGroup.prototype.zones = $util.emptyArray;

                    /**
                     * AutoscalingGroup size.
                     * @member {clutch.aws.ec2.v1.IAutoscalingGroupSize|null|undefined} size
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     */
                    AutoscalingGroup.prototype.size = null;

                    /**
                     * AutoscalingGroup terminationPolicies.
                     * @member {Array.<clutch.aws.ec2.v1.AutoscalingGroup.TerminationPolicy>} terminationPolicies
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     */
                    AutoscalingGroup.prototype.terminationPolicies = $util.emptyArray;

                    /**
                     * AutoscalingGroup instances.
                     * @member {Array.<clutch.aws.ec2.v1.AutoscalingGroup.IInstance>} instances
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     */
                    AutoscalingGroup.prototype.instances = $util.emptyArray;

                    /**
                     * AutoscalingGroup account.
                     * @member {string} account
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     */
                    AutoscalingGroup.prototype.account = "";

                    /**
                     * Verifies an AutoscalingGroup message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AutoscalingGroup.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.zones != null && message.hasOwnProperty("zones")) {
                            if (!Array.isArray(message.zones))
                                return "zones: array expected";
                            for (let i = 0; i < message.zones.length; ++i)
                                if (!$util.isString(message.zones[i]))
                                    return "zones: string[] expected";
                        }
                        if (message.size != null && message.hasOwnProperty("size")) {
                            let error = $root.clutch.aws.ec2.v1.AutoscalingGroupSize.verify(message.size);
                            if (error)
                                return "size." + error;
                        }
                        if (message.terminationPolicies != null && message.hasOwnProperty("terminationPolicies")) {
                            if (!Array.isArray(message.terminationPolicies))
                                return "terminationPolicies: array expected";
                            for (let i = 0; i < message.terminationPolicies.length; ++i)
                                switch (message.terminationPolicies[i]) {
                                default:
                                    return "terminationPolicies: enum value[] expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                    break;
                                }
                        }
                        if (message.instances != null && message.hasOwnProperty("instances")) {
                            if (!Array.isArray(message.instances))
                                return "instances: array expected";
                            for (let i = 0; i < message.instances.length; ++i) {
                                let error = $root.clutch.aws.ec2.v1.AutoscalingGroup.Instance.verify(message.instances[i]);
                                if (error)
                                    return "instances." + error;
                            }
                        }
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates an AutoscalingGroup message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.AutoscalingGroup} AutoscalingGroup
                     */
                    AutoscalingGroup.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.AutoscalingGroup)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.AutoscalingGroup();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.zones) {
                            if (!Array.isArray(object.zones))
                                throw TypeError(".clutch.aws.ec2.v1.AutoscalingGroup.zones: array expected");
                            message.zones = [];
                            for (let i = 0; i < object.zones.length; ++i)
                                message.zones[i] = String(object.zones[i]);
                        }
                        if (object.size != null) {
                            if (typeof object.size !== "object")
                                throw TypeError(".clutch.aws.ec2.v1.AutoscalingGroup.size: object expected");
                            message.size = $root.clutch.aws.ec2.v1.AutoscalingGroupSize.fromObject(object.size);
                        }
                        if (object.terminationPolicies) {
                            if (!Array.isArray(object.terminationPolicies))
                                throw TypeError(".clutch.aws.ec2.v1.AutoscalingGroup.terminationPolicies: array expected");
                            message.terminationPolicies = [];
                            for (let i = 0; i < object.terminationPolicies.length; ++i)
                                switch (object.terminationPolicies[i]) {
                                default:
                                case "UNSPECIFIED":
                                case 0:
                                    message.terminationPolicies[i] = 0;
                                    break;
                                case "UNKNOWN":
                                case 1:
                                    message.terminationPolicies[i] = 1;
                                    break;
                                case "OLDEST_INSTANCE":
                                case 2:
                                    message.terminationPolicies[i] = 2;
                                    break;
                                case "NEWEST_INSTANCE":
                                case 3:
                                    message.terminationPolicies[i] = 3;
                                    break;
                                case "OLDEST_LAUNCH_CONFIGURATION":
                                case 4:
                                    message.terminationPolicies[i] = 4;
                                    break;
                                case "CLOSEST_TO_NEXT_HOUR":
                                case 5:
                                    message.terminationPolicies[i] = 5;
                                    break;
                                case "DEFAULT":
                                case 6:
                                    message.terminationPolicies[i] = 6;
                                    break;
                                case "OLDEST_LAUNCH_TEMPLATE":
                                case 7:
                                    message.terminationPolicies[i] = 7;
                                    break;
                                case "ALLOCATION_STRATEGY":
                                case 8:
                                    message.terminationPolicies[i] = 8;
                                    break;
                                }
                        }
                        if (object.instances) {
                            if (!Array.isArray(object.instances))
                                throw TypeError(".clutch.aws.ec2.v1.AutoscalingGroup.instances: array expected");
                            message.instances = [];
                            for (let i = 0; i < object.instances.length; ++i) {
                                if (typeof object.instances[i] !== "object")
                                    throw TypeError(".clutch.aws.ec2.v1.AutoscalingGroup.instances: object expected");
                                message.instances[i] = $root.clutch.aws.ec2.v1.AutoscalingGroup.Instance.fromObject(object.instances[i]);
                            }
                        }
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from an AutoscalingGroup message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @static
                     * @param {clutch.aws.ec2.v1.AutoscalingGroup} message AutoscalingGroup
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AutoscalingGroup.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults) {
                            object.zones = [];
                            object.terminationPolicies = [];
                            object.instances = [];
                        }
                        if (options.defaults) {
                            object.name = "";
                            object.region = "";
                            object.size = null;
                            object.account = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.zones && message.zones.length) {
                            object.zones = [];
                            for (let j = 0; j < message.zones.length; ++j)
                                object.zones[j] = message.zones[j];
                        }
                        if (message.size != null && message.hasOwnProperty("size"))
                            object.size = $root.clutch.aws.ec2.v1.AutoscalingGroupSize.toObject(message.size, options);
                        if (message.terminationPolicies && message.terminationPolicies.length) {
                            object.terminationPolicies = [];
                            for (let j = 0; j < message.terminationPolicies.length; ++j)
                                object.terminationPolicies[j] = options.enums === String ? $root.clutch.aws.ec2.v1.AutoscalingGroup.TerminationPolicy[message.terminationPolicies[j]] : message.terminationPolicies[j];
                        }
                        if (message.instances && message.instances.length) {
                            object.instances = [];
                            for (let j = 0; j < message.instances.length; ++j)
                                object.instances[j] = $root.clutch.aws.ec2.v1.AutoscalingGroup.Instance.toObject(message.instances[j], options);
                        }
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this AutoscalingGroup to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AutoscalingGroup.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * TerminationPolicy enum.
                     * @name clutch.aws.ec2.v1.AutoscalingGroup.TerminationPolicy
                     * @enum {number}
                     * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                     * @property {number} UNKNOWN=1 UNKNOWN value
                     * @property {number} OLDEST_INSTANCE=2 OLDEST_INSTANCE value
                     * @property {number} NEWEST_INSTANCE=3 NEWEST_INSTANCE value
                     * @property {number} OLDEST_LAUNCH_CONFIGURATION=4 OLDEST_LAUNCH_CONFIGURATION value
                     * @property {number} CLOSEST_TO_NEXT_HOUR=5 CLOSEST_TO_NEXT_HOUR value
                     * @property {number} DEFAULT=6 DEFAULT value
                     * @property {number} OLDEST_LAUNCH_TEMPLATE=7 OLDEST_LAUNCH_TEMPLATE value
                     * @property {number} ALLOCATION_STRATEGY=8 ALLOCATION_STRATEGY value
                     */
                    AutoscalingGroup.TerminationPolicy = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNSPECIFIED"] = 0;
                        values[valuesById[1] = "UNKNOWN"] = 1;
                        values[valuesById[2] = "OLDEST_INSTANCE"] = 2;
                        values[valuesById[3] = "NEWEST_INSTANCE"] = 3;
                        values[valuesById[4] = "OLDEST_LAUNCH_CONFIGURATION"] = 4;
                        values[valuesById[5] = "CLOSEST_TO_NEXT_HOUR"] = 5;
                        values[valuesById[6] = "DEFAULT"] = 6;
                        values[valuesById[7] = "OLDEST_LAUNCH_TEMPLATE"] = 7;
                        values[valuesById[8] = "ALLOCATION_STRATEGY"] = 8;
                        return values;
                    })();

                    AutoscalingGroup.Instance = (function() {

                        /**
                         * Properties of an Instance.
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                         * @interface IInstance
                         * @property {string|null} [id] Instance id
                         * @property {string|null} [zone] Instance zone
                         * @property {string|null} [launchConfigurationName] Instance launchConfigurationName
                         * @property {boolean|null} [healthy] Instance healthy
                         * @property {clutch.aws.ec2.v1.AutoscalingGroup.Instance.LifecycleState|null} [lifecycleState] Instance lifecycleState
                         */

                        /**
                         * Constructs a new Instance.
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                         * @classdesc Represents an Instance.
                         * @implements IInstance
                         * @constructor
                         * @param {clutch.aws.ec2.v1.AutoscalingGroup.IInstance=} [properties] Properties to set
                         */
                        function Instance(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Instance id.
                         * @member {string} id
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @instance
                         */
                        Instance.prototype.id = "";

                        /**
                         * Instance zone.
                         * @member {string} zone
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @instance
                         */
                        Instance.prototype.zone = "";

                        /**
                         * Instance launchConfigurationName.
                         * @member {string} launchConfigurationName
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @instance
                         */
                        Instance.prototype.launchConfigurationName = "";

                        /**
                         * Instance healthy.
                         * @member {boolean} healthy
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @instance
                         */
                        Instance.prototype.healthy = false;

                        /**
                         * Instance lifecycleState.
                         * @member {clutch.aws.ec2.v1.AutoscalingGroup.Instance.LifecycleState} lifecycleState
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @instance
                         */
                        Instance.prototype.lifecycleState = 0;

                        /**
                         * Verifies an Instance message.
                         * @function verify
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Instance.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.id != null && message.hasOwnProperty("id"))
                                if (!$util.isString(message.id))
                                    return "id: string expected";
                            if (message.zone != null && message.hasOwnProperty("zone"))
                                if (!$util.isString(message.zone))
                                    return "zone: string expected";
                            if (message.launchConfigurationName != null && message.hasOwnProperty("launchConfigurationName"))
                                if (!$util.isString(message.launchConfigurationName))
                                    return "launchConfigurationName: string expected";
                            if (message.healthy != null && message.hasOwnProperty("healthy"))
                                if (typeof message.healthy !== "boolean")
                                    return "healthy: boolean expected";
                            if (message.lifecycleState != null && message.hasOwnProperty("lifecycleState"))
                                switch (message.lifecycleState) {
                                default:
                                    return "lifecycleState: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                case 10:
                                case 11:
                                case 12:
                                case 13:
                                case 14:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates an Instance message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.aws.ec2.v1.AutoscalingGroup.Instance} Instance
                         */
                        Instance.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.aws.ec2.v1.AutoscalingGroup.Instance)
                                return object;
                            let message = new $root.clutch.aws.ec2.v1.AutoscalingGroup.Instance();
                            if (object.id != null)
                                message.id = String(object.id);
                            if (object.zone != null)
                                message.zone = String(object.zone);
                            if (object.launchConfigurationName != null)
                                message.launchConfigurationName = String(object.launchConfigurationName);
                            if (object.healthy != null)
                                message.healthy = Boolean(object.healthy);
                            switch (object.lifecycleState) {
                            case "UNSPECIFIED":
                            case 0:
                                message.lifecycleState = 0;
                                break;
                            case "UNKNOWN":
                            case 1:
                                message.lifecycleState = 1;
                                break;
                            case "PENDING":
                            case 2:
                                message.lifecycleState = 2;
                                break;
                            case "PENDING_WAIT":
                            case 3:
                                message.lifecycleState = 3;
                                break;
                            case "PENDING_PROCEED":
                            case 4:
                                message.lifecycleState = 4;
                                break;
                            case "QUARANTINED":
                            case 5:
                                message.lifecycleState = 5;
                                break;
                            case "IN_SERVICE":
                            case 6:
                                message.lifecycleState = 6;
                                break;
                            case "TERMINATING":
                            case 7:
                                message.lifecycleState = 7;
                                break;
                            case "TERMINATING_WAIT":
                            case 8:
                                message.lifecycleState = 8;
                                break;
                            case "TERMINATING_PROCEED":
                            case 9:
                                message.lifecycleState = 9;
                                break;
                            case "TERMINATED":
                            case 10:
                                message.lifecycleState = 10;
                                break;
                            case "DETACHING":
                            case 11:
                                message.lifecycleState = 11;
                                break;
                            case "DETACHED":
                            case 12:
                                message.lifecycleState = 12;
                                break;
                            case "ENTERING_STANDBY":
                            case 13:
                                message.lifecycleState = 13;
                                break;
                            case "STANDBY":
                            case 14:
                                message.lifecycleState = 14;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an Instance message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @static
                         * @param {clutch.aws.ec2.v1.AutoscalingGroup.Instance} message Instance
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Instance.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.id = "";
                                object.zone = "";
                                object.launchConfigurationName = "";
                                object.healthy = false;
                                object.lifecycleState = options.enums === String ? "UNSPECIFIED" : 0;
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                object.id = message.id;
                            if (message.zone != null && message.hasOwnProperty("zone"))
                                object.zone = message.zone;
                            if (message.launchConfigurationName != null && message.hasOwnProperty("launchConfigurationName"))
                                object.launchConfigurationName = message.launchConfigurationName;
                            if (message.healthy != null && message.hasOwnProperty("healthy"))
                                object.healthy = message.healthy;
                            if (message.lifecycleState != null && message.hasOwnProperty("lifecycleState"))
                                object.lifecycleState = options.enums === String ? $root.clutch.aws.ec2.v1.AutoscalingGroup.Instance.LifecycleState[message.lifecycleState] : message.lifecycleState;
                            return object;
                        };

                        /**
                         * Converts this Instance to JSON.
                         * @function toJSON
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Instance.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * LifecycleState enum.
                         * @name clutch.aws.ec2.v1.AutoscalingGroup.Instance.LifecycleState
                         * @enum {number}
                         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                         * @property {number} UNKNOWN=1 UNKNOWN value
                         * @property {number} PENDING=2 PENDING value
                         * @property {number} PENDING_WAIT=3 PENDING_WAIT value
                         * @property {number} PENDING_PROCEED=4 PENDING_PROCEED value
                         * @property {number} QUARANTINED=5 QUARANTINED value
                         * @property {number} IN_SERVICE=6 IN_SERVICE value
                         * @property {number} TERMINATING=7 TERMINATING value
                         * @property {number} TERMINATING_WAIT=8 TERMINATING_WAIT value
                         * @property {number} TERMINATING_PROCEED=9 TERMINATING_PROCEED value
                         * @property {number} TERMINATED=10 TERMINATED value
                         * @property {number} DETACHING=11 DETACHING value
                         * @property {number} DETACHED=12 DETACHED value
                         * @property {number} ENTERING_STANDBY=13 ENTERING_STANDBY value
                         * @property {number} STANDBY=14 STANDBY value
                         */
                        Instance.LifecycleState = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "UNSPECIFIED"] = 0;
                            values[valuesById[1] = "UNKNOWN"] = 1;
                            values[valuesById[2] = "PENDING"] = 2;
                            values[valuesById[3] = "PENDING_WAIT"] = 3;
                            values[valuesById[4] = "PENDING_PROCEED"] = 4;
                            values[valuesById[5] = "QUARANTINED"] = 5;
                            values[valuesById[6] = "IN_SERVICE"] = 6;
                            values[valuesById[7] = "TERMINATING"] = 7;
                            values[valuesById[8] = "TERMINATING_WAIT"] = 8;
                            values[valuesById[9] = "TERMINATING_PROCEED"] = 9;
                            values[valuesById[10] = "TERMINATED"] = 10;
                            values[valuesById[11] = "DETACHING"] = 11;
                            values[valuesById[12] = "DETACHED"] = 12;
                            values[valuesById[13] = "ENTERING_STANDBY"] = 13;
                            values[valuesById[14] = "STANDBY"] = 14;
                            return values;
                        })();

                        return Instance;
                    })();

                    return AutoscalingGroup;
                })();

                v1.GetInstanceRequest = (function() {

                    /**
                     * Properties of a GetInstanceRequest.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IGetInstanceRequest
                     * @property {string|null} [instanceId] GetInstanceRequest instanceId
                     * @property {string|null} [region] GetInstanceRequest region
                     * @property {string|null} [account] GetInstanceRequest account
                     */

                    /**
                     * Constructs a new GetInstanceRequest.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a GetInstanceRequest.
                     * @implements IGetInstanceRequest
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IGetInstanceRequest=} [properties] Properties to set
                     */
                    function GetInstanceRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetInstanceRequest instanceId.
                     * @member {string} instanceId
                     * @memberof clutch.aws.ec2.v1.GetInstanceRequest
                     * @instance
                     */
                    GetInstanceRequest.prototype.instanceId = "";

                    /**
                     * GetInstanceRequest region.
                     * @member {string} region
                     * @memberof clutch.aws.ec2.v1.GetInstanceRequest
                     * @instance
                     */
                    GetInstanceRequest.prototype.region = "";

                    /**
                     * GetInstanceRequest account.
                     * @member {string} account
                     * @memberof clutch.aws.ec2.v1.GetInstanceRequest
                     * @instance
                     */
                    GetInstanceRequest.prototype.account = "";

                    /**
                     * Verifies a GetInstanceRequest message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.GetInstanceRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetInstanceRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                            if (!$util.isString(message.instanceId))
                                return "instanceId: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates a GetInstanceRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.GetInstanceRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.GetInstanceRequest} GetInstanceRequest
                     */
                    GetInstanceRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.GetInstanceRequest)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.GetInstanceRequest();
                        if (object.instanceId != null)
                            message.instanceId = String(object.instanceId);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetInstanceRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.GetInstanceRequest
                     * @static
                     * @param {clutch.aws.ec2.v1.GetInstanceRequest} message GetInstanceRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetInstanceRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.instanceId = "";
                            object.region = "";
                            object.account = "";
                        }
                        if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                            object.instanceId = message.instanceId;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this GetInstanceRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.GetInstanceRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetInstanceRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetInstanceRequest;
                })();

                v1.GetInstanceResponse = (function() {

                    /**
                     * Properties of a GetInstanceResponse.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IGetInstanceResponse
                     * @property {clutch.aws.ec2.v1.IInstance|null} [instance] GetInstanceResponse instance
                     */

                    /**
                     * Constructs a new GetInstanceResponse.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a GetInstanceResponse.
                     * @implements IGetInstanceResponse
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IGetInstanceResponse=} [properties] Properties to set
                     */
                    function GetInstanceResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetInstanceResponse instance.
                     * @member {clutch.aws.ec2.v1.IInstance|null|undefined} instance
                     * @memberof clutch.aws.ec2.v1.GetInstanceResponse
                     * @instance
                     */
                    GetInstanceResponse.prototype.instance = null;

                    /**
                     * Verifies a GetInstanceResponse message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.GetInstanceResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetInstanceResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.instance != null && message.hasOwnProperty("instance")) {
                            let error = $root.clutch.aws.ec2.v1.Instance.verify(message.instance);
                            if (error)
                                return "instance." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a GetInstanceResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.GetInstanceResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.GetInstanceResponse} GetInstanceResponse
                     */
                    GetInstanceResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.GetInstanceResponse)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.GetInstanceResponse();
                        if (object.instance != null) {
                            if (typeof object.instance !== "object")
                                throw TypeError(".clutch.aws.ec2.v1.GetInstanceResponse.instance: object expected");
                            message.instance = $root.clutch.aws.ec2.v1.Instance.fromObject(object.instance);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetInstanceResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.GetInstanceResponse
                     * @static
                     * @param {clutch.aws.ec2.v1.GetInstanceResponse} message GetInstanceResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetInstanceResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.instance = null;
                        if (message.instance != null && message.hasOwnProperty("instance"))
                            object.instance = $root.clutch.aws.ec2.v1.Instance.toObject(message.instance, options);
                        return object;
                    };

                    /**
                     * Converts this GetInstanceResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.GetInstanceResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetInstanceResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetInstanceResponse;
                })();

                v1.TerminateInstanceRequest = (function() {

                    /**
                     * Properties of a TerminateInstanceRequest.
                     * @memberof clutch.aws.ec2.v1
                     * @interface ITerminateInstanceRequest
                     * @property {string|null} [instanceId] TerminateInstanceRequest instanceId
                     * @property {string|null} [region] TerminateInstanceRequest region
                     * @property {string|null} [account] TerminateInstanceRequest account
                     */

                    /**
                     * Constructs a new TerminateInstanceRequest.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a TerminateInstanceRequest.
                     * @implements ITerminateInstanceRequest
                     * @constructor
                     * @param {clutch.aws.ec2.v1.ITerminateInstanceRequest=} [properties] Properties to set
                     */
                    function TerminateInstanceRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TerminateInstanceRequest instanceId.
                     * @member {string} instanceId
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceRequest
                     * @instance
                     */
                    TerminateInstanceRequest.prototype.instanceId = "";

                    /**
                     * TerminateInstanceRequest region.
                     * @member {string} region
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceRequest
                     * @instance
                     */
                    TerminateInstanceRequest.prototype.region = "";

                    /**
                     * TerminateInstanceRequest account.
                     * @member {string} account
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceRequest
                     * @instance
                     */
                    TerminateInstanceRequest.prototype.account = "";

                    /**
                     * Verifies a TerminateInstanceRequest message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TerminateInstanceRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                            if (!$util.isString(message.instanceId))
                                return "instanceId: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates a TerminateInstanceRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.TerminateInstanceRequest} TerminateInstanceRequest
                     */
                    TerminateInstanceRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.TerminateInstanceRequest)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.TerminateInstanceRequest();
                        if (object.instanceId != null)
                            message.instanceId = String(object.instanceId);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from a TerminateInstanceRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceRequest
                     * @static
                     * @param {clutch.aws.ec2.v1.TerminateInstanceRequest} message TerminateInstanceRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TerminateInstanceRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.instanceId = "";
                            object.region = "";
                            object.account = "";
                        }
                        if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                            object.instanceId = message.instanceId;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this TerminateInstanceRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TerminateInstanceRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return TerminateInstanceRequest;
                })();

                v1.TerminateInstanceResponse = (function() {

                    /**
                     * Properties of a TerminateInstanceResponse.
                     * @memberof clutch.aws.ec2.v1
                     * @interface ITerminateInstanceResponse
                     */

                    /**
                     * Constructs a new TerminateInstanceResponse.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a TerminateInstanceResponse.
                     * @implements ITerminateInstanceResponse
                     * @constructor
                     * @param {clutch.aws.ec2.v1.ITerminateInstanceResponse=} [properties] Properties to set
                     */
                    function TerminateInstanceResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Verifies a TerminateInstanceResponse message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TerminateInstanceResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a TerminateInstanceResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.TerminateInstanceResponse} TerminateInstanceResponse
                     */
                    TerminateInstanceResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.TerminateInstanceResponse)
                            return object;
                        return new $root.clutch.aws.ec2.v1.TerminateInstanceResponse();
                    };

                    /**
                     * Creates a plain object from a TerminateInstanceResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceResponse
                     * @static
                     * @param {clutch.aws.ec2.v1.TerminateInstanceResponse} message TerminateInstanceResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TerminateInstanceResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this TerminateInstanceResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TerminateInstanceResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return TerminateInstanceResponse;
                })();

                v1.RebootInstanceRequest = (function() {

                    /**
                     * Properties of a RebootInstanceRequest.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IRebootInstanceRequest
                     * @property {string|null} [instanceId] RebootInstanceRequest instanceId
                     * @property {string|null} [region] RebootInstanceRequest region
                     * @property {string|null} [account] RebootInstanceRequest account
                     */

                    /**
                     * Constructs a new RebootInstanceRequest.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a RebootInstanceRequest.
                     * @implements IRebootInstanceRequest
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IRebootInstanceRequest=} [properties] Properties to set
                     */
                    function RebootInstanceRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * RebootInstanceRequest instanceId.
                     * @member {string} instanceId
                     * @memberof clutch.aws.ec2.v1.RebootInstanceRequest
                     * @instance
                     */
                    RebootInstanceRequest.prototype.instanceId = "";

                    /**
                     * RebootInstanceRequest region.
                     * @member {string} region
                     * @memberof clutch.aws.ec2.v1.RebootInstanceRequest
                     * @instance
                     */
                    RebootInstanceRequest.prototype.region = "";

                    /**
                     * RebootInstanceRequest account.
                     * @member {string} account
                     * @memberof clutch.aws.ec2.v1.RebootInstanceRequest
                     * @instance
                     */
                    RebootInstanceRequest.prototype.account = "";

                    /**
                     * Verifies a RebootInstanceRequest message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.RebootInstanceRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RebootInstanceRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                            if (!$util.isString(message.instanceId))
                                return "instanceId: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates a RebootInstanceRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.RebootInstanceRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.RebootInstanceRequest} RebootInstanceRequest
                     */
                    RebootInstanceRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.RebootInstanceRequest)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.RebootInstanceRequest();
                        if (object.instanceId != null)
                            message.instanceId = String(object.instanceId);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from a RebootInstanceRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.RebootInstanceRequest
                     * @static
                     * @param {clutch.aws.ec2.v1.RebootInstanceRequest} message RebootInstanceRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RebootInstanceRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.instanceId = "";
                            object.region = "";
                            object.account = "";
                        }
                        if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                            object.instanceId = message.instanceId;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this RebootInstanceRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.RebootInstanceRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RebootInstanceRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return RebootInstanceRequest;
                })();

                v1.RebootInstanceResponse = (function() {

                    /**
                     * Properties of a RebootInstanceResponse.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IRebootInstanceResponse
                     */

                    /**
                     * Constructs a new RebootInstanceResponse.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a RebootInstanceResponse.
                     * @implements IRebootInstanceResponse
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IRebootInstanceResponse=} [properties] Properties to set
                     */
                    function RebootInstanceResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Verifies a RebootInstanceResponse message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.RebootInstanceResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RebootInstanceResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a RebootInstanceResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.RebootInstanceResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.RebootInstanceResponse} RebootInstanceResponse
                     */
                    RebootInstanceResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.RebootInstanceResponse)
                            return object;
                        return new $root.clutch.aws.ec2.v1.RebootInstanceResponse();
                    };

                    /**
                     * Creates a plain object from a RebootInstanceResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.RebootInstanceResponse
                     * @static
                     * @param {clutch.aws.ec2.v1.RebootInstanceResponse} message RebootInstanceResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RebootInstanceResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this RebootInstanceResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.RebootInstanceResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RebootInstanceResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return RebootInstanceResponse;
                })();

                v1.Instance = (function() {

                    /**
                     * Properties of an Instance.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IInstance
                     * @property {string|null} [instanceId] Instance instanceId
                     * @property {string|null} [region] Instance region
                     * @property {clutch.aws.ec2.v1.Instance.State|null} [state] Instance state
                     * @property {string|null} [instanceType] Instance instanceType
                     * @property {string|null} [publicIpAddress] Instance publicIpAddress
                     * @property {string|null} [privateIpAddress] Instance privateIpAddress
                     * @property {string|null} [availabilityZone] Instance availabilityZone
                     * @property {Object.<string,string>|null} [tags] Instance tags
                     * @property {string|null} [account] Instance account
                     */

                    /**
                     * Constructs a new Instance.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents an Instance.
                     * @implements IInstance
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IInstance=} [properties] Properties to set
                     */
                    function Instance(properties) {
                        this.tags = {};
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Instance instanceId.
                     * @member {string} instanceId
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.instanceId = "";

                    /**
                     * Instance region.
                     * @member {string} region
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.region = "";

                    /**
                     * Instance state.
                     * @member {clutch.aws.ec2.v1.Instance.State} state
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.state = 0;

                    /**
                     * Instance instanceType.
                     * @member {string} instanceType
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.instanceType = "";

                    /**
                     * Instance publicIpAddress.
                     * @member {string} publicIpAddress
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.publicIpAddress = "";

                    /**
                     * Instance privateIpAddress.
                     * @member {string} privateIpAddress
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.privateIpAddress = "";

                    /**
                     * Instance availabilityZone.
                     * @member {string} availabilityZone
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.availabilityZone = "";

                    /**
                     * Instance tags.
                     * @member {Object.<string,string>} tags
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.tags = $util.emptyObject;

                    /**
                     * Instance account.
                     * @member {string} account
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.account = "";

                    /**
                     * Verifies an Instance message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Instance.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                            if (!$util.isString(message.instanceId))
                                return "instanceId: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.state != null && message.hasOwnProperty("state"))
                            switch (message.state) {
                            default:
                                return "state: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                                break;
                            }
                        if (message.instanceType != null && message.hasOwnProperty("instanceType"))
                            if (!$util.isString(message.instanceType))
                                return "instanceType: string expected";
                        if (message.publicIpAddress != null && message.hasOwnProperty("publicIpAddress"))
                            if (!$util.isString(message.publicIpAddress))
                                return "publicIpAddress: string expected";
                        if (message.privateIpAddress != null && message.hasOwnProperty("privateIpAddress"))
                            if (!$util.isString(message.privateIpAddress))
                                return "privateIpAddress: string expected";
                        if (message.availabilityZone != null && message.hasOwnProperty("availabilityZone"))
                            if (!$util.isString(message.availabilityZone))
                                return "availabilityZone: string expected";
                        if (message.tags != null && message.hasOwnProperty("tags")) {
                            if (!$util.isObject(message.tags))
                                return "tags: object expected";
                            let key = Object.keys(message.tags);
                            for (let i = 0; i < key.length; ++i)
                                if (!$util.isString(message.tags[key[i]]))
                                    return "tags: string{k:string} expected";
                        }
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates an Instance message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.Instance} Instance
                     */
                    Instance.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.Instance)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.Instance();
                        if (object.instanceId != null)
                            message.instanceId = String(object.instanceId);
                        if (object.region != null)
                            message.region = String(object.region);
                        switch (object.state) {
                        case "UNSPECIFIED":
                        case 0:
                            message.state = 0;
                            break;
                        case "UNKNOWN":
                        case 1:
                            message.state = 1;
                            break;
                        case "PENDING":
                        case 2:
                            message.state = 2;
                            break;
                        case "RUNNING":
                        case 3:
                            message.state = 3;
                            break;
                        case "STOPPING":
                        case 4:
                            message.state = 4;
                            break;
                        case "STOPPED":
                        case 5:
                            message.state = 5;
                            break;
                        case "SHUTTING_DOWN":
                        case 6:
                            message.state = 6;
                            break;
                        case "TERMINATED":
                        case 7:
                            message.state = 7;
                            break;
                        }
                        if (object.instanceType != null)
                            message.instanceType = String(object.instanceType);
                        if (object.publicIpAddress != null)
                            message.publicIpAddress = String(object.publicIpAddress);
                        if (object.privateIpAddress != null)
                            message.privateIpAddress = String(object.privateIpAddress);
                        if (object.availabilityZone != null)
                            message.availabilityZone = String(object.availabilityZone);
                        if (object.tags) {
                            if (typeof object.tags !== "object")
                                throw TypeError(".clutch.aws.ec2.v1.Instance.tags: object expected");
                            message.tags = {};
                            for (let keys = Object.keys(object.tags), i = 0; i < keys.length; ++i)
                                message.tags[keys[i]] = String(object.tags[keys[i]]);
                        }
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from an Instance message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @static
                     * @param {clutch.aws.ec2.v1.Instance} message Instance
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Instance.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.objects || options.defaults)
                            object.tags = {};
                        if (options.defaults) {
                            object.instanceId = "";
                            object.region = "";
                            object.state = options.enums === String ? "UNSPECIFIED" : 0;
                            object.instanceType = "";
                            object.publicIpAddress = "";
                            object.privateIpAddress = "";
                            object.availabilityZone = "";
                            object.account = "";
                        }
                        if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                            object.instanceId = message.instanceId;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.state != null && message.hasOwnProperty("state"))
                            object.state = options.enums === String ? $root.clutch.aws.ec2.v1.Instance.State[message.state] : message.state;
                        if (message.instanceType != null && message.hasOwnProperty("instanceType"))
                            object.instanceType = message.instanceType;
                        if (message.publicIpAddress != null && message.hasOwnProperty("publicIpAddress"))
                            object.publicIpAddress = message.publicIpAddress;
                        if (message.privateIpAddress != null && message.hasOwnProperty("privateIpAddress"))
                            object.privateIpAddress = message.privateIpAddress;
                        if (message.availabilityZone != null && message.hasOwnProperty("availabilityZone"))
                            object.availabilityZone = message.availabilityZone;
                        let keys2;
                        if (message.tags && (keys2 = Object.keys(message.tags)).length) {
                            object.tags = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.tags[keys2[j]] = message.tags[keys2[j]];
                        }
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this Instance to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Instance.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * State enum.
                     * @name clutch.aws.ec2.v1.Instance.State
                     * @enum {number}
                     * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                     * @property {number} UNKNOWN=1 UNKNOWN value
                     * @property {number} PENDING=2 PENDING value
                     * @property {number} RUNNING=3 RUNNING value
                     * @property {number} STOPPING=4 STOPPING value
                     * @property {number} STOPPED=5 STOPPED value
                     * @property {number} SHUTTING_DOWN=6 SHUTTING_DOWN value
                     * @property {number} TERMINATED=7 TERMINATED value
                     */
                    Instance.State = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNSPECIFIED"] = 0;
                        values[valuesById[1] = "UNKNOWN"] = 1;
                        values[valuesById[2] = "PENDING"] = 2;
                        values[valuesById[3] = "RUNNING"] = 3;
                        values[valuesById[4] = "STOPPING"] = 4;
                        values[valuesById[5] = "STOPPED"] = 5;
                        values[valuesById[6] = "SHUTTING_DOWN"] = 6;
                        values[valuesById[7] = "TERMINATED"] = 7;
                        return values;
                    })();

                    return Instance;
                })();

                return v1;
            })();

            return ec2;
        })();

        aws.kinesis = (function() {

            /**
             * Namespace kinesis.
             * @memberof clutch.aws
             * @namespace
             */
            const kinesis = {};

            kinesis.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.aws.kinesis
                 * @namespace
                 */
                const v1 = {};

                v1.KinesisAPI = (function() {

                    /**
                     * Constructs a new KinesisAPI service.
                     * @memberof clutch.aws.kinesis.v1
                     * @classdesc Represents a KinesisAPI
                     * @extends $protobuf.rpc.Service
                     * @constructor
                     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                     */
                    function KinesisAPI(rpcImpl, requestDelimited, responseDelimited) {
                        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                    }

                    (KinesisAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = KinesisAPI;

                    /**
                     * Callback as used by {@link clutch.aws.kinesis.v1.KinesisAPI#getStream}.
                     * @memberof clutch.aws.kinesis.v1.KinesisAPI
                     * @typedef GetStreamCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.aws.kinesis.v1.GetStreamResponse} [response] GetStreamResponse
                     */

                    /**
                     * Calls GetStream.
                     * @function getStream
                     * @memberof clutch.aws.kinesis.v1.KinesisAPI
                     * @instance
                     * @param {clutch.aws.kinesis.v1.IGetStreamRequest} request GetStreamRequest message or plain object
                     * @param {clutch.aws.kinesis.v1.KinesisAPI.GetStreamCallback} callback Node-style callback called with the error, if any, and GetStreamResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(KinesisAPI.prototype.getStream = function getStream(request, callback) {
                        return this.rpcCall(getStream, $root.clutch.aws.kinesis.v1.GetStreamRequest, $root.clutch.aws.kinesis.v1.GetStreamResponse, request, callback);
                    }, "name", { value: "GetStream" });

                    /**
                     * Calls GetStream.
                     * @function getStream
                     * @memberof clutch.aws.kinesis.v1.KinesisAPI
                     * @instance
                     * @param {clutch.aws.kinesis.v1.IGetStreamRequest} request GetStreamRequest message or plain object
                     * @returns {Promise<clutch.aws.kinesis.v1.GetStreamResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.aws.kinesis.v1.KinesisAPI#updateShardCount}.
                     * @memberof clutch.aws.kinesis.v1.KinesisAPI
                     * @typedef UpdateShardCountCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.aws.kinesis.v1.UpdateShardCountResponse} [response] UpdateShardCountResponse
                     */

                    /**
                     * Calls UpdateShardCount.
                     * @function updateShardCount
                     * @memberof clutch.aws.kinesis.v1.KinesisAPI
                     * @instance
                     * @param {clutch.aws.kinesis.v1.IUpdateShardCountRequest} request UpdateShardCountRequest message or plain object
                     * @param {clutch.aws.kinesis.v1.KinesisAPI.UpdateShardCountCallback} callback Node-style callback called with the error, if any, and UpdateShardCountResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(KinesisAPI.prototype.updateShardCount = function updateShardCount(request, callback) {
                        return this.rpcCall(updateShardCount, $root.clutch.aws.kinesis.v1.UpdateShardCountRequest, $root.clutch.aws.kinesis.v1.UpdateShardCountResponse, request, callback);
                    }, "name", { value: "UpdateShardCount" });

                    /**
                     * Calls UpdateShardCount.
                     * @function updateShardCount
                     * @memberof clutch.aws.kinesis.v1.KinesisAPI
                     * @instance
                     * @param {clutch.aws.kinesis.v1.IUpdateShardCountRequest} request UpdateShardCountRequest message or plain object
                     * @returns {Promise<clutch.aws.kinesis.v1.UpdateShardCountResponse>} Promise
                     * @variation 2
                     */

                    return KinesisAPI;
                })();

                v1.GetStreamRequest = (function() {

                    /**
                     * Properties of a GetStreamRequest.
                     * @memberof clutch.aws.kinesis.v1
                     * @interface IGetStreamRequest
                     * @property {string|null} [streamName] GetStreamRequest streamName
                     * @property {string|null} [region] GetStreamRequest region
                     * @property {string|null} [account] GetStreamRequest account
                     */

                    /**
                     * Constructs a new GetStreamRequest.
                     * @memberof clutch.aws.kinesis.v1
                     * @classdesc Represents a GetStreamRequest.
                     * @implements IGetStreamRequest
                     * @constructor
                     * @param {clutch.aws.kinesis.v1.IGetStreamRequest=} [properties] Properties to set
                     */
                    function GetStreamRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetStreamRequest streamName.
                     * @member {string} streamName
                     * @memberof clutch.aws.kinesis.v1.GetStreamRequest
                     * @instance
                     */
                    GetStreamRequest.prototype.streamName = "";

                    /**
                     * GetStreamRequest region.
                     * @member {string} region
                     * @memberof clutch.aws.kinesis.v1.GetStreamRequest
                     * @instance
                     */
                    GetStreamRequest.prototype.region = "";

                    /**
                     * GetStreamRequest account.
                     * @member {string} account
                     * @memberof clutch.aws.kinesis.v1.GetStreamRequest
                     * @instance
                     */
                    GetStreamRequest.prototype.account = "";

                    /**
                     * Verifies a GetStreamRequest message.
                     * @function verify
                     * @memberof clutch.aws.kinesis.v1.GetStreamRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetStreamRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.streamName != null && message.hasOwnProperty("streamName"))
                            if (!$util.isString(message.streamName))
                                return "streamName: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates a GetStreamRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.kinesis.v1.GetStreamRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.kinesis.v1.GetStreamRequest} GetStreamRequest
                     */
                    GetStreamRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.kinesis.v1.GetStreamRequest)
                            return object;
                        let message = new $root.clutch.aws.kinesis.v1.GetStreamRequest();
                        if (object.streamName != null)
                            message.streamName = String(object.streamName);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetStreamRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.kinesis.v1.GetStreamRequest
                     * @static
                     * @param {clutch.aws.kinesis.v1.GetStreamRequest} message GetStreamRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetStreamRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.streamName = "";
                            object.region = "";
                            object.account = "";
                        }
                        if (message.streamName != null && message.hasOwnProperty("streamName"))
                            object.streamName = message.streamName;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this GetStreamRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.kinesis.v1.GetStreamRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetStreamRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetStreamRequest;
                })();

                v1.GetStreamResponse = (function() {

                    /**
                     * Properties of a GetStreamResponse.
                     * @memberof clutch.aws.kinesis.v1
                     * @interface IGetStreamResponse
                     * @property {clutch.aws.kinesis.v1.IStream|null} [stream] GetStreamResponse stream
                     */

                    /**
                     * Constructs a new GetStreamResponse.
                     * @memberof clutch.aws.kinesis.v1
                     * @classdesc Represents a GetStreamResponse.
                     * @implements IGetStreamResponse
                     * @constructor
                     * @param {clutch.aws.kinesis.v1.IGetStreamResponse=} [properties] Properties to set
                     */
                    function GetStreamResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetStreamResponse stream.
                     * @member {clutch.aws.kinesis.v1.IStream|null|undefined} stream
                     * @memberof clutch.aws.kinesis.v1.GetStreamResponse
                     * @instance
                     */
                    GetStreamResponse.prototype.stream = null;

                    /**
                     * Verifies a GetStreamResponse message.
                     * @function verify
                     * @memberof clutch.aws.kinesis.v1.GetStreamResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetStreamResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.stream != null && message.hasOwnProperty("stream")) {
                            let error = $root.clutch.aws.kinesis.v1.Stream.verify(message.stream);
                            if (error)
                                return "stream." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a GetStreamResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.kinesis.v1.GetStreamResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.kinesis.v1.GetStreamResponse} GetStreamResponse
                     */
                    GetStreamResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.kinesis.v1.GetStreamResponse)
                            return object;
                        let message = new $root.clutch.aws.kinesis.v1.GetStreamResponse();
                        if (object.stream != null) {
                            if (typeof object.stream !== "object")
                                throw TypeError(".clutch.aws.kinesis.v1.GetStreamResponse.stream: object expected");
                            message.stream = $root.clutch.aws.kinesis.v1.Stream.fromObject(object.stream);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetStreamResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.kinesis.v1.GetStreamResponse
                     * @static
                     * @param {clutch.aws.kinesis.v1.GetStreamResponse} message GetStreamResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetStreamResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.stream = null;
                        if (message.stream != null && message.hasOwnProperty("stream"))
                            object.stream = $root.clutch.aws.kinesis.v1.Stream.toObject(message.stream, options);
                        return object;
                    };

                    /**
                     * Converts this GetStreamResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.kinesis.v1.GetStreamResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetStreamResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetStreamResponse;
                })();

                v1.UpdateShardCountRequest = (function() {

                    /**
                     * Properties of an UpdateShardCountRequest.
                     * @memberof clutch.aws.kinesis.v1
                     * @interface IUpdateShardCountRequest
                     * @property {string|null} [streamName] UpdateShardCountRequest streamName
                     * @property {string|null} [region] UpdateShardCountRequest region
                     * @property {number|null} [targetShardCount] UpdateShardCountRequest targetShardCount
                     * @property {string|null} [account] UpdateShardCountRequest account
                     */

                    /**
                     * Constructs a new UpdateShardCountRequest.
                     * @memberof clutch.aws.kinesis.v1
                     * @classdesc Represents an UpdateShardCountRequest.
                     * @implements IUpdateShardCountRequest
                     * @constructor
                     * @param {clutch.aws.kinesis.v1.IUpdateShardCountRequest=} [properties] Properties to set
                     */
                    function UpdateShardCountRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UpdateShardCountRequest streamName.
                     * @member {string} streamName
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @instance
                     */
                    UpdateShardCountRequest.prototype.streamName = "";

                    /**
                     * UpdateShardCountRequest region.
                     * @member {string} region
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @instance
                     */
                    UpdateShardCountRequest.prototype.region = "";

                    /**
                     * UpdateShardCountRequest targetShardCount.
                     * @member {number} targetShardCount
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @instance
                     */
                    UpdateShardCountRequest.prototype.targetShardCount = 0;

                    /**
                     * UpdateShardCountRequest account.
                     * @member {string} account
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @instance
                     */
                    UpdateShardCountRequest.prototype.account = "";

                    /**
                     * Verifies an UpdateShardCountRequest message.
                     * @function verify
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UpdateShardCountRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.streamName != null && message.hasOwnProperty("streamName"))
                            if (!$util.isString(message.streamName))
                                return "streamName: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.targetShardCount != null && message.hasOwnProperty("targetShardCount"))
                            if (!$util.isInteger(message.targetShardCount))
                                return "targetShardCount: integer expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates an UpdateShardCountRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.kinesis.v1.UpdateShardCountRequest} UpdateShardCountRequest
                     */
                    UpdateShardCountRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.kinesis.v1.UpdateShardCountRequest)
                            return object;
                        let message = new $root.clutch.aws.kinesis.v1.UpdateShardCountRequest();
                        if (object.streamName != null)
                            message.streamName = String(object.streamName);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.targetShardCount != null)
                            message.targetShardCount = object.targetShardCount | 0;
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from an UpdateShardCountRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @static
                     * @param {clutch.aws.kinesis.v1.UpdateShardCountRequest} message UpdateShardCountRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UpdateShardCountRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.streamName = "";
                            object.region = "";
                            object.targetShardCount = 0;
                            object.account = "";
                        }
                        if (message.streamName != null && message.hasOwnProperty("streamName"))
                            object.streamName = message.streamName;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.targetShardCount != null && message.hasOwnProperty("targetShardCount"))
                            object.targetShardCount = message.targetShardCount;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this UpdateShardCountRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UpdateShardCountRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UpdateShardCountRequest;
                })();

                v1.UpdateShardCountResponse = (function() {

                    /**
                     * Properties of an UpdateShardCountResponse.
                     * @memberof clutch.aws.kinesis.v1
                     * @interface IUpdateShardCountResponse
                     */

                    /**
                     * Constructs a new UpdateShardCountResponse.
                     * @memberof clutch.aws.kinesis.v1
                     * @classdesc Represents an UpdateShardCountResponse.
                     * @implements IUpdateShardCountResponse
                     * @constructor
                     * @param {clutch.aws.kinesis.v1.IUpdateShardCountResponse=} [properties] Properties to set
                     */
                    function UpdateShardCountResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Verifies an UpdateShardCountResponse message.
                     * @function verify
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UpdateShardCountResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates an UpdateShardCountResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.kinesis.v1.UpdateShardCountResponse} UpdateShardCountResponse
                     */
                    UpdateShardCountResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.kinesis.v1.UpdateShardCountResponse)
                            return object;
                        return new $root.clutch.aws.kinesis.v1.UpdateShardCountResponse();
                    };

                    /**
                     * Creates a plain object from an UpdateShardCountResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountResponse
                     * @static
                     * @param {clutch.aws.kinesis.v1.UpdateShardCountResponse} message UpdateShardCountResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UpdateShardCountResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this UpdateShardCountResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UpdateShardCountResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UpdateShardCountResponse;
                })();

                v1.Stream = (function() {

                    /**
                     * Properties of a Stream.
                     * @memberof clutch.aws.kinesis.v1
                     * @interface IStream
                     * @property {string|null} [streamName] Stream streamName
                     * @property {string|null} [region] Stream region
                     * @property {number|null} [currentShardCount] Stream currentShardCount
                     * @property {string|null} [account] Stream account
                     */

                    /**
                     * Constructs a new Stream.
                     * @memberof clutch.aws.kinesis.v1
                     * @classdesc Represents a Stream.
                     * @implements IStream
                     * @constructor
                     * @param {clutch.aws.kinesis.v1.IStream=} [properties] Properties to set
                     */
                    function Stream(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Stream streamName.
                     * @member {string} streamName
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @instance
                     */
                    Stream.prototype.streamName = "";

                    /**
                     * Stream region.
                     * @member {string} region
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @instance
                     */
                    Stream.prototype.region = "";

                    /**
                     * Stream currentShardCount.
                     * @member {number} currentShardCount
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @instance
                     */
                    Stream.prototype.currentShardCount = 0;

                    /**
                     * Stream account.
                     * @member {string} account
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @instance
                     */
                    Stream.prototype.account = "";

                    /**
                     * Verifies a Stream message.
                     * @function verify
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Stream.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.streamName != null && message.hasOwnProperty("streamName"))
                            if (!$util.isString(message.streamName))
                                return "streamName: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.currentShardCount != null && message.hasOwnProperty("currentShardCount"))
                            if (!$util.isInteger(message.currentShardCount))
                                return "currentShardCount: integer expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates a Stream message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.kinesis.v1.Stream} Stream
                     */
                    Stream.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.kinesis.v1.Stream)
                            return object;
                        let message = new $root.clutch.aws.kinesis.v1.Stream();
                        if (object.streamName != null)
                            message.streamName = String(object.streamName);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.currentShardCount != null)
                            message.currentShardCount = object.currentShardCount | 0;
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Stream message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @static
                     * @param {clutch.aws.kinesis.v1.Stream} message Stream
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Stream.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.streamName = "";
                            object.region = "";
                            object.currentShardCount = 0;
                            object.account = "";
                        }
                        if (message.streamName != null && message.hasOwnProperty("streamName"))
                            object.streamName = message.streamName;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.currentShardCount != null && message.hasOwnProperty("currentShardCount"))
                            object.currentShardCount = message.currentShardCount;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this Stream to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Stream.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Stream;
                })();

                return v1;
            })();

            return kinesis;
        })();

        return aws;
    })();

    clutch.bot = (function() {

        /**
         * Namespace bot.
         * @memberof clutch
         * @namespace
         */
        const bot = {};

        bot.slackbot = (function() {

            /**
             * Namespace slackbot.
             * @memberof clutch.bot
             * @namespace
             */
            const slackbot = {};

            slackbot.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.bot.slackbot
                 * @namespace
                 */
                const v1 = {};

                v1.SlackBotAPI = (function() {

                    /**
                     * Constructs a new SlackBotAPI service.
                     * @memberof clutch.bot.slackbot.v1
                     * @classdesc Represents a SlackBotAPI
                     * @extends $protobuf.rpc.Service
                     * @constructor
                     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                     */
                    function SlackBotAPI(rpcImpl, requestDelimited, responseDelimited) {
                        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                    }

                    (SlackBotAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = SlackBotAPI;

                    /**
                     * Callback as used by {@link clutch.bot.slackbot.v1.SlackBotAPI#event}.
                     * @memberof clutch.bot.slackbot.v1.SlackBotAPI
                     * @typedef EventCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.bot.slackbot.v1.EventResponse} [response] EventResponse
                     */

                    /**
                     * Calls Event.
                     * @function event
                     * @memberof clutch.bot.slackbot.v1.SlackBotAPI
                     * @instance
                     * @param {clutch.bot.slackbot.v1.IEventRequest} request EventRequest message or plain object
                     * @param {clutch.bot.slackbot.v1.SlackBotAPI.EventCallback} callback Node-style callback called with the error, if any, and EventResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(SlackBotAPI.prototype.event = function event(request, callback) {
                        return this.rpcCall(event, $root.clutch.bot.slackbot.v1.EventRequest, $root.clutch.bot.slackbot.v1.EventResponse, request, callback);
                    }, "name", { value: "Event" });

                    /**
                     * Calls Event.
                     * @function event
                     * @memberof clutch.bot.slackbot.v1.SlackBotAPI
                     * @instance
                     * @param {clutch.bot.slackbot.v1.IEventRequest} request EventRequest message or plain object
                     * @returns {Promise<clutch.bot.slackbot.v1.EventResponse>} Promise
                     * @variation 2
                     */

                    return SlackBotAPI;
                })();

                v1.Bot = (function() {

                    /**
                     * Properties of a Bot.
                     * @memberof clutch.bot.slackbot.v1
                     * @interface IBot
                     * @property {string|null} [id] Bot id
                     * @property {boolean|null} [deleted] Bot deleted
                     * @property {string|null} [name] Bot name
                     * @property {number|Long|null} [updated] Bot updated
                     * @property {string|null} [appId] Bot appId
                     * @property {Object.<string,string>|null} [icons] Bot icons
                     * @property {string|null} [teamId] Bot teamId
                     */

                    /**
                     * Constructs a new Bot.
                     * @memberof clutch.bot.slackbot.v1
                     * @classdesc Represents a Bot.
                     * @implements IBot
                     * @constructor
                     * @param {clutch.bot.slackbot.v1.IBot=} [properties] Properties to set
                     */
                    function Bot(properties) {
                        this.icons = {};
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Bot id.
                     * @member {string} id
                     * @memberof clutch.bot.slackbot.v1.Bot
                     * @instance
                     */
                    Bot.prototype.id = "";

                    /**
                     * Bot deleted.
                     * @member {boolean} deleted
                     * @memberof clutch.bot.slackbot.v1.Bot
                     * @instance
                     */
                    Bot.prototype.deleted = false;

                    /**
                     * Bot name.
                     * @member {string} name
                     * @memberof clutch.bot.slackbot.v1.Bot
                     * @instance
                     */
                    Bot.prototype.name = "";

                    /**
                     * Bot updated.
                     * @member {number|Long} updated
                     * @memberof clutch.bot.slackbot.v1.Bot
                     * @instance
                     */
                    Bot.prototype.updated = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Bot appId.
                     * @member {string} appId
                     * @memberof clutch.bot.slackbot.v1.Bot
                     * @instance
                     */
                    Bot.prototype.appId = "";

                    /**
                     * Bot icons.
                     * @member {Object.<string,string>} icons
                     * @memberof clutch.bot.slackbot.v1.Bot
                     * @instance
                     */
                    Bot.prototype.icons = $util.emptyObject;

                    /**
                     * Bot teamId.
                     * @member {string} teamId
                     * @memberof clutch.bot.slackbot.v1.Bot
                     * @instance
                     */
                    Bot.prototype.teamId = "";

                    /**
                     * Verifies a Bot message.
                     * @function verify
                     * @memberof clutch.bot.slackbot.v1.Bot
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Bot.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.deleted != null && message.hasOwnProperty("deleted"))
                            if (typeof message.deleted !== "boolean")
                                return "deleted: boolean expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.updated != null && message.hasOwnProperty("updated"))
                            if (!$util.isInteger(message.updated) && !(message.updated && $util.isInteger(message.updated.low) && $util.isInteger(message.updated.high)))
                                return "updated: integer|Long expected";
                        if (message.appId != null && message.hasOwnProperty("appId"))
                            if (!$util.isString(message.appId))
                                return "appId: string expected";
                        if (message.icons != null && message.hasOwnProperty("icons")) {
                            if (!$util.isObject(message.icons))
                                return "icons: object expected";
                            let key = Object.keys(message.icons);
                            for (let i = 0; i < key.length; ++i)
                                if (!$util.isString(message.icons[key[i]]))
                                    return "icons: string{k:string} expected";
                        }
                        if (message.teamId != null && message.hasOwnProperty("teamId"))
                            if (!$util.isString(message.teamId))
                                return "teamId: string expected";
                        return null;
                    };

                    /**
                     * Creates a Bot message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.bot.slackbot.v1.Bot
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.bot.slackbot.v1.Bot} Bot
                     */
                    Bot.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.bot.slackbot.v1.Bot)
                            return object;
                        let message = new $root.clutch.bot.slackbot.v1.Bot();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.deleted != null)
                            message.deleted = Boolean(object.deleted);
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.updated != null)
                            if ($util.Long)
                                (message.updated = $util.Long.fromValue(object.updated)).unsigned = false;
                            else if (typeof object.updated === "string")
                                message.updated = parseInt(object.updated, 10);
                            else if (typeof object.updated === "number")
                                message.updated = object.updated;
                            else if (typeof object.updated === "object")
                                message.updated = new $util.LongBits(object.updated.low >>> 0, object.updated.high >>> 0).toNumber();
                        if (object.appId != null)
                            message.appId = String(object.appId);
                        if (object.icons) {
                            if (typeof object.icons !== "object")
                                throw TypeError(".clutch.bot.slackbot.v1.Bot.icons: object expected");
                            message.icons = {};
                            for (let keys = Object.keys(object.icons), i = 0; i < keys.length; ++i)
                                message.icons[keys[i]] = String(object.icons[keys[i]]);
                        }
                        if (object.teamId != null)
                            message.teamId = String(object.teamId);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Bot message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.bot.slackbot.v1.Bot
                     * @static
                     * @param {clutch.bot.slackbot.v1.Bot} message Bot
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Bot.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.objects || options.defaults)
                            object.icons = {};
                        if (options.defaults) {
                            object.id = "";
                            object.deleted = false;
                            object.name = "";
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.updated = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.updated = options.longs === String ? "0" : 0;
                            object.appId = "";
                            object.teamId = "";
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.deleted != null && message.hasOwnProperty("deleted"))
                            object.deleted = message.deleted;
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.updated != null && message.hasOwnProperty("updated"))
                            if (typeof message.updated === "number")
                                object.updated = options.longs === String ? String(message.updated) : message.updated;
                            else
                                object.updated = options.longs === String ? $util.Long.prototype.toString.call(message.updated) : options.longs === Number ? new $util.LongBits(message.updated.low >>> 0, message.updated.high >>> 0).toNumber() : message.updated;
                        if (message.appId != null && message.hasOwnProperty("appId"))
                            object.appId = message.appId;
                        let keys2;
                        if (message.icons && (keys2 = Object.keys(message.icons)).length) {
                            object.icons = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.icons[keys2[j]] = message.icons[keys2[j]];
                        }
                        if (message.teamId != null && message.hasOwnProperty("teamId"))
                            object.teamId = message.teamId;
                        return object;
                    };

                    /**
                     * Converts this Bot to JSON.
                     * @function toJSON
                     * @memberof clutch.bot.slackbot.v1.Bot
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Bot.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Bot;
                })();

                v1.Event = (function() {

                    /**
                     * Properties of an Event.
                     * @memberof clutch.bot.slackbot.v1
                     * @interface IEvent
                     * @property {string|null} [type] Event type
                     * @property {string|null} [user] Event user
                     * @property {string|null} [botId] Event botId
                     * @property {clutch.bot.slackbot.v1.IBot|null} [botProfile] Event botProfile
                     * @property {string|null} [text] Event text
                     * @property {string|null} [ts] Event ts
                     * @property {string|null} [channel] Event channel
                     * @property {string|null} [channelType] Event channelType
                     * @property {string|null} [eventTs] Event eventTs
                     * @property {string|null} [clientMsgId] Event clientMsgId
                     * @property {string|null} [team] Event team
                     * @property {google.protobuf.IValue|null} [blocks] Event blocks
                     */

                    /**
                     * Constructs a new Event.
                     * @memberof clutch.bot.slackbot.v1
                     * @classdesc Represents an Event.
                     * @implements IEvent
                     * @constructor
                     * @param {clutch.bot.slackbot.v1.IEvent=} [properties] Properties to set
                     */
                    function Event(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Event type.
                     * @member {string} type
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @instance
                     */
                    Event.prototype.type = "";

                    /**
                     * Event user.
                     * @member {string} user
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @instance
                     */
                    Event.prototype.user = "";

                    /**
                     * Event botId.
                     * @member {string} botId
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @instance
                     */
                    Event.prototype.botId = "";

                    /**
                     * Event botProfile.
                     * @member {clutch.bot.slackbot.v1.IBot|null|undefined} botProfile
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @instance
                     */
                    Event.prototype.botProfile = null;

                    /**
                     * Event text.
                     * @member {string} text
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @instance
                     */
                    Event.prototype.text = "";

                    /**
                     * Event ts.
                     * @member {string} ts
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @instance
                     */
                    Event.prototype.ts = "";

                    /**
                     * Event channel.
                     * @member {string} channel
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @instance
                     */
                    Event.prototype.channel = "";

                    /**
                     * Event channelType.
                     * @member {string} channelType
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @instance
                     */
                    Event.prototype.channelType = "";

                    /**
                     * Event eventTs.
                     * @member {string} eventTs
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @instance
                     */
                    Event.prototype.eventTs = "";

                    /**
                     * Event clientMsgId.
                     * @member {string} clientMsgId
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @instance
                     */
                    Event.prototype.clientMsgId = "";

                    /**
                     * Event team.
                     * @member {string} team
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @instance
                     */
                    Event.prototype.team = "";

                    /**
                     * Event blocks.
                     * @member {google.protobuf.IValue|null|undefined} blocks
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @instance
                     */
                    Event.prototype.blocks = null;

                    /**
                     * Verifies an Event message.
                     * @function verify
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Event.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        if (message.user != null && message.hasOwnProperty("user"))
                            if (!$util.isString(message.user))
                                return "user: string expected";
                        if (message.botId != null && message.hasOwnProperty("botId"))
                            if (!$util.isString(message.botId))
                                return "botId: string expected";
                        if (message.botProfile != null && message.hasOwnProperty("botProfile")) {
                            let error = $root.clutch.bot.slackbot.v1.Bot.verify(message.botProfile);
                            if (error)
                                return "botProfile." + error;
                        }
                        if (message.text != null && message.hasOwnProperty("text"))
                            if (!$util.isString(message.text))
                                return "text: string expected";
                        if (message.ts != null && message.hasOwnProperty("ts"))
                            if (!$util.isString(message.ts))
                                return "ts: string expected";
                        if (message.channel != null && message.hasOwnProperty("channel"))
                            if (!$util.isString(message.channel))
                                return "channel: string expected";
                        if (message.channelType != null && message.hasOwnProperty("channelType"))
                            if (!$util.isString(message.channelType))
                                return "channelType: string expected";
                        if (message.eventTs != null && message.hasOwnProperty("eventTs"))
                            if (!$util.isString(message.eventTs))
                                return "eventTs: string expected";
                        if (message.clientMsgId != null && message.hasOwnProperty("clientMsgId"))
                            if (!$util.isString(message.clientMsgId))
                                return "clientMsgId: string expected";
                        if (message.team != null && message.hasOwnProperty("team"))
                            if (!$util.isString(message.team))
                                return "team: string expected";
                        if (message.blocks != null && message.hasOwnProperty("blocks")) {
                            let error = $root.google.protobuf.Value.verify(message.blocks);
                            if (error)
                                return "blocks." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an Event message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.bot.slackbot.v1.Event} Event
                     */
                    Event.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.bot.slackbot.v1.Event)
                            return object;
                        let message = new $root.clutch.bot.slackbot.v1.Event();
                        if (object.type != null)
                            message.type = String(object.type);
                        if (object.user != null)
                            message.user = String(object.user);
                        if (object.botId != null)
                            message.botId = String(object.botId);
                        if (object.botProfile != null) {
                            if (typeof object.botProfile !== "object")
                                throw TypeError(".clutch.bot.slackbot.v1.Event.botProfile: object expected");
                            message.botProfile = $root.clutch.bot.slackbot.v1.Bot.fromObject(object.botProfile);
                        }
                        if (object.text != null)
                            message.text = String(object.text);
                        if (object.ts != null)
                            message.ts = String(object.ts);
                        if (object.channel != null)
                            message.channel = String(object.channel);
                        if (object.channelType != null)
                            message.channelType = String(object.channelType);
                        if (object.eventTs != null)
                            message.eventTs = String(object.eventTs);
                        if (object.clientMsgId != null)
                            message.clientMsgId = String(object.clientMsgId);
                        if (object.team != null)
                            message.team = String(object.team);
                        if (object.blocks != null) {
                            if (typeof object.blocks !== "object")
                                throw TypeError(".clutch.bot.slackbot.v1.Event.blocks: object expected");
                            message.blocks = $root.google.protobuf.Value.fromObject(object.blocks);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an Event message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @static
                     * @param {clutch.bot.slackbot.v1.Event} message Event
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Event.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.type = "";
                            object.user = "";
                            object.botId = "";
                            object.botProfile = null;
                            object.text = "";
                            object.ts = "";
                            object.channel = "";
                            object.channelType = "";
                            object.eventTs = "";
                            object.clientMsgId = "";
                            object.team = "";
                            object.blocks = null;
                        }
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        if (message.user != null && message.hasOwnProperty("user"))
                            object.user = message.user;
                        if (message.botId != null && message.hasOwnProperty("botId"))
                            object.botId = message.botId;
                        if (message.botProfile != null && message.hasOwnProperty("botProfile"))
                            object.botProfile = $root.clutch.bot.slackbot.v1.Bot.toObject(message.botProfile, options);
                        if (message.text != null && message.hasOwnProperty("text"))
                            object.text = message.text;
                        if (message.ts != null && message.hasOwnProperty("ts"))
                            object.ts = message.ts;
                        if (message.channel != null && message.hasOwnProperty("channel"))
                            object.channel = message.channel;
                        if (message.channelType != null && message.hasOwnProperty("channelType"))
                            object.channelType = message.channelType;
                        if (message.eventTs != null && message.hasOwnProperty("eventTs"))
                            object.eventTs = message.eventTs;
                        if (message.clientMsgId != null && message.hasOwnProperty("clientMsgId"))
                            object.clientMsgId = message.clientMsgId;
                        if (message.team != null && message.hasOwnProperty("team"))
                            object.team = message.team;
                        if (message.blocks != null && message.hasOwnProperty("blocks"))
                            object.blocks = $root.google.protobuf.Value.toObject(message.blocks, options);
                        return object;
                    };

                    /**
                     * Converts this Event to JSON.
                     * @function toJSON
                     * @memberof clutch.bot.slackbot.v1.Event
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Event.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Event;
                })();

                v1.EventRequest = (function() {

                    /**
                     * Properties of an EventRequest.
                     * @memberof clutch.bot.slackbot.v1
                     * @interface IEventRequest
                     * @property {string|null} [token] EventRequest token
                     * @property {boolean|null} [isExtSharedChannel] EventRequest isExtSharedChannel
                     * @property {string|null} [teamId] EventRequest teamId
                     * @property {string|null} [apiAppId] EventRequest apiAppId
                     * @property {clutch.bot.slackbot.v1.IEvent|null} [event] EventRequest event
                     * @property {string|null} [type] EventRequest type
                     * @property {string|null} [eventId] EventRequest eventId
                     * @property {number|Long|null} [eventTime] EventRequest eventTime
                     * @property {string|null} [eventContext] EventRequest eventContext
                     * @property {google.protobuf.IValue|null} [authorizations] EventRequest authorizations
                     * @property {string|null} [challenge] EventRequest challenge
                     * @property {string|null} [minuteRateLimited] EventRequest minuteRateLimited
                     */

                    /**
                     * Constructs a new EventRequest.
                     * @memberof clutch.bot.slackbot.v1
                     * @classdesc Represents an EventRequest.
                     * @implements IEventRequest
                     * @constructor
                     * @param {clutch.bot.slackbot.v1.IEventRequest=} [properties] Properties to set
                     */
                    function EventRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * EventRequest token.
                     * @member {string} token
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @instance
                     */
                    EventRequest.prototype.token = "";

                    /**
                     * EventRequest isExtSharedChannel.
                     * @member {boolean} isExtSharedChannel
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @instance
                     */
                    EventRequest.prototype.isExtSharedChannel = false;

                    /**
                     * EventRequest teamId.
                     * @member {string} teamId
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @instance
                     */
                    EventRequest.prototype.teamId = "";

                    /**
                     * EventRequest apiAppId.
                     * @member {string} apiAppId
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @instance
                     */
                    EventRequest.prototype.apiAppId = "";

                    /**
                     * EventRequest event.
                     * @member {clutch.bot.slackbot.v1.IEvent|null|undefined} event
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @instance
                     */
                    EventRequest.prototype.event = null;

                    /**
                     * EventRequest type.
                     * @member {string} type
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @instance
                     */
                    EventRequest.prototype.type = "";

                    /**
                     * EventRequest eventId.
                     * @member {string} eventId
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @instance
                     */
                    EventRequest.prototype.eventId = "";

                    /**
                     * EventRequest eventTime.
                     * @member {number|Long} eventTime
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @instance
                     */
                    EventRequest.prototype.eventTime = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * EventRequest eventContext.
                     * @member {string} eventContext
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @instance
                     */
                    EventRequest.prototype.eventContext = "";

                    /**
                     * EventRequest authorizations.
                     * @member {google.protobuf.IValue|null|undefined} authorizations
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @instance
                     */
                    EventRequest.prototype.authorizations = null;

                    /**
                     * EventRequest challenge.
                     * @member {string} challenge
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @instance
                     */
                    EventRequest.prototype.challenge = "";

                    /**
                     * EventRequest minuteRateLimited.
                     * @member {string} minuteRateLimited
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @instance
                     */
                    EventRequest.prototype.minuteRateLimited = "";

                    /**
                     * Verifies an EventRequest message.
                     * @function verify
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    EventRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.token != null && message.hasOwnProperty("token"))
                            if (!$util.isString(message.token))
                                return "token: string expected";
                        if (message.isExtSharedChannel != null && message.hasOwnProperty("isExtSharedChannel"))
                            if (typeof message.isExtSharedChannel !== "boolean")
                                return "isExtSharedChannel: boolean expected";
                        if (message.teamId != null && message.hasOwnProperty("teamId"))
                            if (!$util.isString(message.teamId))
                                return "teamId: string expected";
                        if (message.apiAppId != null && message.hasOwnProperty("apiAppId"))
                            if (!$util.isString(message.apiAppId))
                                return "apiAppId: string expected";
                        if (message.event != null && message.hasOwnProperty("event")) {
                            let error = $root.clutch.bot.slackbot.v1.Event.verify(message.event);
                            if (error)
                                return "event." + error;
                        }
                        if (message.type != null && message.hasOwnProperty("type"))
                            if (!$util.isString(message.type))
                                return "type: string expected";
                        if (message.eventId != null && message.hasOwnProperty("eventId"))
                            if (!$util.isString(message.eventId))
                                return "eventId: string expected";
                        if (message.eventTime != null && message.hasOwnProperty("eventTime"))
                            if (!$util.isInteger(message.eventTime) && !(message.eventTime && $util.isInteger(message.eventTime.low) && $util.isInteger(message.eventTime.high)))
                                return "eventTime: integer|Long expected";
                        if (message.eventContext != null && message.hasOwnProperty("eventContext"))
                            if (!$util.isString(message.eventContext))
                                return "eventContext: string expected";
                        if (message.authorizations != null && message.hasOwnProperty("authorizations")) {
                            let error = $root.google.protobuf.Value.verify(message.authorizations);
                            if (error)
                                return "authorizations." + error;
                        }
                        if (message.challenge != null && message.hasOwnProperty("challenge"))
                            if (!$util.isString(message.challenge))
                                return "challenge: string expected";
                        if (message.minuteRateLimited != null && message.hasOwnProperty("minuteRateLimited"))
                            if (!$util.isString(message.minuteRateLimited))
                                return "minuteRateLimited: string expected";
                        return null;
                    };

                    /**
                     * Creates an EventRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.bot.slackbot.v1.EventRequest} EventRequest
                     */
                    EventRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.bot.slackbot.v1.EventRequest)
                            return object;
                        let message = new $root.clutch.bot.slackbot.v1.EventRequest();
                        if (object.token != null)
                            message.token = String(object.token);
                        if (object.isExtSharedChannel != null)
                            message.isExtSharedChannel = Boolean(object.isExtSharedChannel);
                        if (object.teamId != null)
                            message.teamId = String(object.teamId);
                        if (object.apiAppId != null)
                            message.apiAppId = String(object.apiAppId);
                        if (object.event != null) {
                            if (typeof object.event !== "object")
                                throw TypeError(".clutch.bot.slackbot.v1.EventRequest.event: object expected");
                            message.event = $root.clutch.bot.slackbot.v1.Event.fromObject(object.event);
                        }
                        if (object.type != null)
                            message.type = String(object.type);
                        if (object.eventId != null)
                            message.eventId = String(object.eventId);
                        if (object.eventTime != null)
                            if ($util.Long)
                                (message.eventTime = $util.Long.fromValue(object.eventTime)).unsigned = false;
                            else if (typeof object.eventTime === "string")
                                message.eventTime = parseInt(object.eventTime, 10);
                            else if (typeof object.eventTime === "number")
                                message.eventTime = object.eventTime;
                            else if (typeof object.eventTime === "object")
                                message.eventTime = new $util.LongBits(object.eventTime.low >>> 0, object.eventTime.high >>> 0).toNumber();
                        if (object.eventContext != null)
                            message.eventContext = String(object.eventContext);
                        if (object.authorizations != null) {
                            if (typeof object.authorizations !== "object")
                                throw TypeError(".clutch.bot.slackbot.v1.EventRequest.authorizations: object expected");
                            message.authorizations = $root.google.protobuf.Value.fromObject(object.authorizations);
                        }
                        if (object.challenge != null)
                            message.challenge = String(object.challenge);
                        if (object.minuteRateLimited != null)
                            message.minuteRateLimited = String(object.minuteRateLimited);
                        return message;
                    };

                    /**
                     * Creates a plain object from an EventRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @static
                     * @param {clutch.bot.slackbot.v1.EventRequest} message EventRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    EventRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.token = "";
                            object.isExtSharedChannel = false;
                            object.teamId = "";
                            object.apiAppId = "";
                            object.event = null;
                            object.type = "";
                            object.eventId = "";
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.eventTime = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.eventTime = options.longs === String ? "0" : 0;
                            object.eventContext = "";
                            object.authorizations = null;
                            object.challenge = "";
                            object.minuteRateLimited = "";
                        }
                        if (message.token != null && message.hasOwnProperty("token"))
                            object.token = message.token;
                        if (message.isExtSharedChannel != null && message.hasOwnProperty("isExtSharedChannel"))
                            object.isExtSharedChannel = message.isExtSharedChannel;
                        if (message.teamId != null && message.hasOwnProperty("teamId"))
                            object.teamId = message.teamId;
                        if (message.apiAppId != null && message.hasOwnProperty("apiAppId"))
                            object.apiAppId = message.apiAppId;
                        if (message.event != null && message.hasOwnProperty("event"))
                            object.event = $root.clutch.bot.slackbot.v1.Event.toObject(message.event, options);
                        if (message.type != null && message.hasOwnProperty("type"))
                            object.type = message.type;
                        if (message.eventId != null && message.hasOwnProperty("eventId"))
                            object.eventId = message.eventId;
                        if (message.eventTime != null && message.hasOwnProperty("eventTime"))
                            if (typeof message.eventTime === "number")
                                object.eventTime = options.longs === String ? String(message.eventTime) : message.eventTime;
                            else
                                object.eventTime = options.longs === String ? $util.Long.prototype.toString.call(message.eventTime) : options.longs === Number ? new $util.LongBits(message.eventTime.low >>> 0, message.eventTime.high >>> 0).toNumber() : message.eventTime;
                        if (message.eventContext != null && message.hasOwnProperty("eventContext"))
                            object.eventContext = message.eventContext;
                        if (message.authorizations != null && message.hasOwnProperty("authorizations"))
                            object.authorizations = $root.google.protobuf.Value.toObject(message.authorizations, options);
                        if (message.challenge != null && message.hasOwnProperty("challenge"))
                            object.challenge = message.challenge;
                        if (message.minuteRateLimited != null && message.hasOwnProperty("minuteRateLimited"))
                            object.minuteRateLimited = message.minuteRateLimited;
                        return object;
                    };

                    /**
                     * Converts this EventRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.bot.slackbot.v1.EventRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    EventRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return EventRequest;
                })();

                v1.EventResponse = (function() {

                    /**
                     * Properties of an EventResponse.
                     * @memberof clutch.bot.slackbot.v1
                     * @interface IEventResponse
                     * @property {string|null} [challenge] EventResponse challenge
                     */

                    /**
                     * Constructs a new EventResponse.
                     * @memberof clutch.bot.slackbot.v1
                     * @classdesc Represents an EventResponse.
                     * @implements IEventResponse
                     * @constructor
                     * @param {clutch.bot.slackbot.v1.IEventResponse=} [properties] Properties to set
                     */
                    function EventResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * EventResponse challenge.
                     * @member {string} challenge
                     * @memberof clutch.bot.slackbot.v1.EventResponse
                     * @instance
                     */
                    EventResponse.prototype.challenge = "";

                    /**
                     * Verifies an EventResponse message.
                     * @function verify
                     * @memberof clutch.bot.slackbot.v1.EventResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    EventResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.challenge != null && message.hasOwnProperty("challenge"))
                            if (!$util.isString(message.challenge))
                                return "challenge: string expected";
                        return null;
                    };

                    /**
                     * Creates an EventResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.bot.slackbot.v1.EventResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.bot.slackbot.v1.EventResponse} EventResponse
                     */
                    EventResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.bot.slackbot.v1.EventResponse)
                            return object;
                        let message = new $root.clutch.bot.slackbot.v1.EventResponse();
                        if (object.challenge != null)
                            message.challenge = String(object.challenge);
                        return message;
                    };

                    /**
                     * Creates a plain object from an EventResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.bot.slackbot.v1.EventResponse
                     * @static
                     * @param {clutch.bot.slackbot.v1.EventResponse} message EventResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    EventResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.challenge = "";
                        if (message.challenge != null && message.hasOwnProperty("challenge"))
                            object.challenge = message.challenge;
                        return object;
                    };

                    /**
                     * Converts this EventResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.bot.slackbot.v1.EventResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    EventResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return EventResponse;
                })();

                return v1;
            })();

            return slackbot;
        })();

        return bot;
    })();

    clutch.chaos = (function() {

        /**
         * Namespace chaos.
         * @memberof clutch
         * @namespace
         */
        const chaos = {};

        chaos.experimentation = (function() {

            /**
             * Namespace experimentation.
             * @memberof clutch.chaos
             * @namespace
             */
            const experimentation = {};

            experimentation.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.chaos.experimentation
                 * @namespace
                 */
                const v1 = {};

                v1.CreateExperimentData = (function() {

                    /**
                     * Properties of a CreateExperimentData.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface ICreateExperimentData
                     * @property {string|null} [runId] CreateExperimentData runId
                     * @property {google.protobuf.IAny|null} [config] CreateExperimentData config
                     * @property {google.protobuf.ITimestamp|null} [startTime] CreateExperimentData startTime
                     * @property {google.protobuf.ITimestamp|null} [endTime] CreateExperimentData endTime
                     */

                    /**
                     * Constructs a new CreateExperimentData.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a CreateExperimentData.
                     * @implements ICreateExperimentData
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.ICreateExperimentData=} [properties] Properties to set
                     */
                    function CreateExperimentData(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CreateExperimentData runId.
                     * @member {string} runId
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentData
                     * @instance
                     */
                    CreateExperimentData.prototype.runId = "";

                    /**
                     * CreateExperimentData config.
                     * @member {google.protobuf.IAny|null|undefined} config
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentData
                     * @instance
                     */
                    CreateExperimentData.prototype.config = null;

                    /**
                     * CreateExperimentData startTime.
                     * @member {google.protobuf.ITimestamp|null|undefined} startTime
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentData
                     * @instance
                     */
                    CreateExperimentData.prototype.startTime = null;

                    /**
                     * CreateExperimentData endTime.
                     * @member {google.protobuf.ITimestamp|null|undefined} endTime
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentData
                     * @instance
                     */
                    CreateExperimentData.prototype.endTime = null;

                    /**
                     * Verifies a CreateExperimentData message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentData
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateExperimentData.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.runId != null && message.hasOwnProperty("runId"))
                            if (!$util.isString(message.runId))
                                return "runId: string expected";
                        if (message.config != null && message.hasOwnProperty("config")) {
                            let error = $root.google.protobuf.Any.verify(message.config);
                            if (error)
                                return "config." + error;
                        }
                        if (message.startTime != null && message.hasOwnProperty("startTime")) {
                            let error = $root.google.protobuf.Timestamp.verify(message.startTime);
                            if (error)
                                return "startTime." + error;
                        }
                        if (message.endTime != null && message.hasOwnProperty("endTime")) {
                            let error = $root.google.protobuf.Timestamp.verify(message.endTime);
                            if (error)
                                return "endTime." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a CreateExperimentData message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentData
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.CreateExperimentData} CreateExperimentData
                     */
                    CreateExperimentData.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.CreateExperimentData)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.CreateExperimentData();
                        if (object.runId != null)
                            message.runId = String(object.runId);
                        if (object.config != null) {
                            if (typeof object.config !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.CreateExperimentData.config: object expected");
                            message.config = $root.google.protobuf.Any.fromObject(object.config);
                        }
                        if (object.startTime != null) {
                            if (typeof object.startTime !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.CreateExperimentData.startTime: object expected");
                            message.startTime = $root.google.protobuf.Timestamp.fromObject(object.startTime);
                        }
                        if (object.endTime != null) {
                            if (typeof object.endTime !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.CreateExperimentData.endTime: object expected");
                            message.endTime = $root.google.protobuf.Timestamp.fromObject(object.endTime);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a CreateExperimentData message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentData
                     * @static
                     * @param {clutch.chaos.experimentation.v1.CreateExperimentData} message CreateExperimentData
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateExperimentData.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.runId = "";
                            object.config = null;
                            object.startTime = null;
                            object.endTime = null;
                        }
                        if (message.runId != null && message.hasOwnProperty("runId"))
                            object.runId = message.runId;
                        if (message.config != null && message.hasOwnProperty("config"))
                            object.config = $root.google.protobuf.Any.toObject(message.config, options);
                        if (message.startTime != null && message.hasOwnProperty("startTime"))
                            object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
                        if (message.endTime != null && message.hasOwnProperty("endTime"))
                            object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
                        return object;
                    };

                    /**
                     * Converts this CreateExperimentData to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentData
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateExperimentData.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CreateExperimentData;
                })();

                v1.CreateExperimentRequest = (function() {

                    /**
                     * Properties of a CreateExperimentRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface ICreateExperimentRequest
                     * @property {clutch.chaos.experimentation.v1.ICreateExperimentData|null} [data] CreateExperimentRequest data
                     */

                    /**
                     * Constructs a new CreateExperimentRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a CreateExperimentRequest.
                     * @implements ICreateExperimentRequest
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.ICreateExperimentRequest=} [properties] Properties to set
                     */
                    function CreateExperimentRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CreateExperimentRequest data.
                     * @member {clutch.chaos.experimentation.v1.ICreateExperimentData|null|undefined} data
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentRequest
                     * @instance
                     */
                    CreateExperimentRequest.prototype.data = null;

                    /**
                     * Verifies a CreateExperimentRequest message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateExperimentRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.data != null && message.hasOwnProperty("data")) {
                            let error = $root.clutch.chaos.experimentation.v1.CreateExperimentData.verify(message.data);
                            if (error)
                                return "data." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a CreateExperimentRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.CreateExperimentRequest} CreateExperimentRequest
                     */
                    CreateExperimentRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.CreateExperimentRequest)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.CreateExperimentRequest();
                        if (object.data != null) {
                            if (typeof object.data !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.CreateExperimentRequest.data: object expected");
                            message.data = $root.clutch.chaos.experimentation.v1.CreateExperimentData.fromObject(object.data);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a CreateExperimentRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentRequest
                     * @static
                     * @param {clutch.chaos.experimentation.v1.CreateExperimentRequest} message CreateExperimentRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateExperimentRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.data = null;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = $root.clutch.chaos.experimentation.v1.CreateExperimentData.toObject(message.data, options);
                        return object;
                    };

                    /**
                     * Converts this CreateExperimentRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateExperimentRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CreateExperimentRequest;
                })();

                v1.CreateExperimentResponse = (function() {

                    /**
                     * Properties of a CreateExperimentResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface ICreateExperimentResponse
                     * @property {clutch.chaos.experimentation.v1.IExperiment|null} [experiment] CreateExperimentResponse experiment
                     */

                    /**
                     * Constructs a new CreateExperimentResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a CreateExperimentResponse.
                     * @implements ICreateExperimentResponse
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.ICreateExperimentResponse=} [properties] Properties to set
                     */
                    function CreateExperimentResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CreateExperimentResponse experiment.
                     * @member {clutch.chaos.experimentation.v1.IExperiment|null|undefined} experiment
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentResponse
                     * @instance
                     */
                    CreateExperimentResponse.prototype.experiment = null;

                    /**
                     * Verifies a CreateExperimentResponse message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateExperimentResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.experiment != null && message.hasOwnProperty("experiment")) {
                            let error = $root.clutch.chaos.experimentation.v1.Experiment.verify(message.experiment);
                            if (error)
                                return "experiment." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a CreateExperimentResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.CreateExperimentResponse} CreateExperimentResponse
                     */
                    CreateExperimentResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.CreateExperimentResponse)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.CreateExperimentResponse();
                        if (object.experiment != null) {
                            if (typeof object.experiment !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.CreateExperimentResponse.experiment: object expected");
                            message.experiment = $root.clutch.chaos.experimentation.v1.Experiment.fromObject(object.experiment);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a CreateExperimentResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentResponse
                     * @static
                     * @param {clutch.chaos.experimentation.v1.CreateExperimentResponse} message CreateExperimentResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateExperimentResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.experiment = null;
                        if (message.experiment != null && message.hasOwnProperty("experiment"))
                            object.experiment = $root.clutch.chaos.experimentation.v1.Experiment.toObject(message.experiment, options);
                        return object;
                    };

                    /**
                     * Converts this CreateExperimentResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateExperimentResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CreateExperimentResponse;
                })();

                v1.CreateOrGetExperimentRequest = (function() {

                    /**
                     * Properties of a CreateOrGetExperimentRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface ICreateOrGetExperimentRequest
                     * @property {clutch.chaos.experimentation.v1.ICreateExperimentData|null} [data] CreateOrGetExperimentRequest data
                     */

                    /**
                     * Constructs a new CreateOrGetExperimentRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a CreateOrGetExperimentRequest.
                     * @implements ICreateOrGetExperimentRequest
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.ICreateOrGetExperimentRequest=} [properties] Properties to set
                     */
                    function CreateOrGetExperimentRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CreateOrGetExperimentRequest data.
                     * @member {clutch.chaos.experimentation.v1.ICreateExperimentData|null|undefined} data
                     * @memberof clutch.chaos.experimentation.v1.CreateOrGetExperimentRequest
                     * @instance
                     */
                    CreateOrGetExperimentRequest.prototype.data = null;

                    /**
                     * Verifies a CreateOrGetExperimentRequest message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.CreateOrGetExperimentRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateOrGetExperimentRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.data != null && message.hasOwnProperty("data")) {
                            let error = $root.clutch.chaos.experimentation.v1.CreateExperimentData.verify(message.data);
                            if (error)
                                return "data." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a CreateOrGetExperimentRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.CreateOrGetExperimentRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.CreateOrGetExperimentRequest} CreateOrGetExperimentRequest
                     */
                    CreateOrGetExperimentRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.CreateOrGetExperimentRequest)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.CreateOrGetExperimentRequest();
                        if (object.data != null) {
                            if (typeof object.data !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.CreateOrGetExperimentRequest.data: object expected");
                            message.data = $root.clutch.chaos.experimentation.v1.CreateExperimentData.fromObject(object.data);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a CreateOrGetExperimentRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.CreateOrGetExperimentRequest
                     * @static
                     * @param {clutch.chaos.experimentation.v1.CreateOrGetExperimentRequest} message CreateOrGetExperimentRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateOrGetExperimentRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.data = null;
                        if (message.data != null && message.hasOwnProperty("data"))
                            object.data = $root.clutch.chaos.experimentation.v1.CreateExperimentData.toObject(message.data, options);
                        return object;
                    };

                    /**
                     * Converts this CreateOrGetExperimentRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.CreateOrGetExperimentRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateOrGetExperimentRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CreateOrGetExperimentRequest;
                })();

                v1.CreateOrGetExperimentResponse = (function() {

                    /**
                     * Properties of a CreateOrGetExperimentResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface ICreateOrGetExperimentResponse
                     * @property {clutch.chaos.experimentation.v1.IExperiment|null} [experiment] CreateOrGetExperimentResponse experiment
                     * @property {clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse.Origin|null} [origin] CreateOrGetExperimentResponse origin
                     */

                    /**
                     * Constructs a new CreateOrGetExperimentResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a CreateOrGetExperimentResponse.
                     * @implements ICreateOrGetExperimentResponse
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.ICreateOrGetExperimentResponse=} [properties] Properties to set
                     */
                    function CreateOrGetExperimentResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CreateOrGetExperimentResponse experiment.
                     * @member {clutch.chaos.experimentation.v1.IExperiment|null|undefined} experiment
                     * @memberof clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse
                     * @instance
                     */
                    CreateOrGetExperimentResponse.prototype.experiment = null;

                    /**
                     * CreateOrGetExperimentResponse origin.
                     * @member {clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse.Origin} origin
                     * @memberof clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse
                     * @instance
                     */
                    CreateOrGetExperimentResponse.prototype.origin = 0;

                    /**
                     * Verifies a CreateOrGetExperimentResponse message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateOrGetExperimentResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.experiment != null && message.hasOwnProperty("experiment")) {
                            let error = $root.clutch.chaos.experimentation.v1.Experiment.verify(message.experiment);
                            if (error)
                                return "experiment." + error;
                        }
                        if (message.origin != null && message.hasOwnProperty("origin"))
                            switch (message.origin) {
                            default:
                                return "origin: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a CreateOrGetExperimentResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse} CreateOrGetExperimentResponse
                     */
                    CreateOrGetExperimentResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse();
                        if (object.experiment != null) {
                            if (typeof object.experiment !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse.experiment: object expected");
                            message.experiment = $root.clutch.chaos.experimentation.v1.Experiment.fromObject(object.experiment);
                        }
                        switch (object.origin) {
                        case "ORIGIN_UNSPECIFIED":
                        case 0:
                            message.origin = 0;
                            break;
                        case "ORIGIN_EXISTING":
                        case 1:
                            message.origin = 1;
                            break;
                        case "ORIGIN_NEW":
                        case 2:
                            message.origin = 2;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a CreateOrGetExperimentResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse
                     * @static
                     * @param {clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse} message CreateOrGetExperimentResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateOrGetExperimentResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.experiment = null;
                            object.origin = options.enums === String ? "ORIGIN_UNSPECIFIED" : 0;
                        }
                        if (message.experiment != null && message.hasOwnProperty("experiment"))
                            object.experiment = $root.clutch.chaos.experimentation.v1.Experiment.toObject(message.experiment, options);
                        if (message.origin != null && message.hasOwnProperty("origin"))
                            object.origin = options.enums === String ? $root.clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse.Origin[message.origin] : message.origin;
                        return object;
                    };

                    /**
                     * Converts this CreateOrGetExperimentResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateOrGetExperimentResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Origin enum.
                     * @name clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse.Origin
                     * @enum {number}
                     * @property {number} ORIGIN_UNSPECIFIED=0 ORIGIN_UNSPECIFIED value
                     * @property {number} ORIGIN_EXISTING=1 ORIGIN_EXISTING value
                     * @property {number} ORIGIN_NEW=2 ORIGIN_NEW value
                     */
                    CreateOrGetExperimentResponse.Origin = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "ORIGIN_UNSPECIFIED"] = 0;
                        values[valuesById[1] = "ORIGIN_EXISTING"] = 1;
                        values[valuesById[2] = "ORIGIN_NEW"] = 2;
                        return values;
                    })();

                    return CreateOrGetExperimentResponse;
                })();

                v1.GetExperimentsRequest = (function() {

                    /**
                     * Properties of a GetExperimentsRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IGetExperimentsRequest
                     * @property {string|null} [configType] GetExperimentsRequest configType
                     * @property {clutch.chaos.experimentation.v1.GetExperimentsRequest.Status|null} [status] GetExperimentsRequest status
                     */

                    /**
                     * Constructs a new GetExperimentsRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a GetExperimentsRequest.
                     * @implements IGetExperimentsRequest
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentsRequest=} [properties] Properties to set
                     */
                    function GetExperimentsRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetExperimentsRequest configType.
                     * @member {string} configType
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsRequest
                     * @instance
                     */
                    GetExperimentsRequest.prototype.configType = "";

                    /**
                     * GetExperimentsRequest status.
                     * @member {clutch.chaos.experimentation.v1.GetExperimentsRequest.Status} status
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsRequest
                     * @instance
                     */
                    GetExperimentsRequest.prototype.status = 0;

                    /**
                     * Verifies a GetExperimentsRequest message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetExperimentsRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.configType != null && message.hasOwnProperty("configType"))
                            if (!$util.isString(message.configType))
                                return "configType: string expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a GetExperimentsRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.GetExperimentsRequest} GetExperimentsRequest
                     */
                    GetExperimentsRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.GetExperimentsRequest)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.GetExperimentsRequest();
                        if (object.configType != null)
                            message.configType = String(object.configType);
                        switch (object.status) {
                        case "STATUS_UNSPECIFIED":
                        case 0:
                            message.status = 0;
                            break;
                        case "STATUS_RUNNING":
                        case 1:
                            message.status = 1;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetExperimentsRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsRequest
                     * @static
                     * @param {clutch.chaos.experimentation.v1.GetExperimentsRequest} message GetExperimentsRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetExperimentsRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.configType = "";
                            object.status = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                        }
                        if (message.configType != null && message.hasOwnProperty("configType"))
                            object.configType = message.configType;
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.clutch.chaos.experimentation.v1.GetExperimentsRequest.Status[message.status] : message.status;
                        return object;
                    };

                    /**
                     * Converts this GetExperimentsRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetExperimentsRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Status enum.
                     * @name clutch.chaos.experimentation.v1.GetExperimentsRequest.Status
                     * @enum {number}
                     * @property {number} STATUS_UNSPECIFIED=0 STATUS_UNSPECIFIED value
                     * @property {number} STATUS_RUNNING=1 STATUS_RUNNING value
                     */
                    GetExperimentsRequest.Status = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "STATUS_UNSPECIFIED"] = 0;
                        values[valuesById[1] = "STATUS_RUNNING"] = 1;
                        return values;
                    })();

                    return GetExperimentsRequest;
                })();

                v1.GetExperimentsResponse = (function() {

                    /**
                     * Properties of a GetExperimentsResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IGetExperimentsResponse
                     * @property {Array.<clutch.chaos.experimentation.v1.IExperiment>|null} [experiments] GetExperimentsResponse experiments
                     */

                    /**
                     * Constructs a new GetExperimentsResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a GetExperimentsResponse.
                     * @implements IGetExperimentsResponse
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentsResponse=} [properties] Properties to set
                     */
                    function GetExperimentsResponse(properties) {
                        this.experiments = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetExperimentsResponse experiments.
                     * @member {Array.<clutch.chaos.experimentation.v1.IExperiment>} experiments
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsResponse
                     * @instance
                     */
                    GetExperimentsResponse.prototype.experiments = $util.emptyArray;

                    /**
                     * Verifies a GetExperimentsResponse message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetExperimentsResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.experiments != null && message.hasOwnProperty("experiments")) {
                            if (!Array.isArray(message.experiments))
                                return "experiments: array expected";
                            for (let i = 0; i < message.experiments.length; ++i) {
                                let error = $root.clutch.chaos.experimentation.v1.Experiment.verify(message.experiments[i]);
                                if (error)
                                    return "experiments." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a GetExperimentsResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.GetExperimentsResponse} GetExperimentsResponse
                     */
                    GetExperimentsResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.GetExperimentsResponse)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.GetExperimentsResponse();
                        if (object.experiments) {
                            if (!Array.isArray(object.experiments))
                                throw TypeError(".clutch.chaos.experimentation.v1.GetExperimentsResponse.experiments: array expected");
                            message.experiments = [];
                            for (let i = 0; i < object.experiments.length; ++i) {
                                if (typeof object.experiments[i] !== "object")
                                    throw TypeError(".clutch.chaos.experimentation.v1.GetExperimentsResponse.experiments: object expected");
                                message.experiments[i] = $root.clutch.chaos.experimentation.v1.Experiment.fromObject(object.experiments[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetExperimentsResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsResponse
                     * @static
                     * @param {clutch.chaos.experimentation.v1.GetExperimentsResponse} message GetExperimentsResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetExperimentsResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.experiments = [];
                        if (message.experiments && message.experiments.length) {
                            object.experiments = [];
                            for (let j = 0; j < message.experiments.length; ++j)
                                object.experiments[j] = $root.clutch.chaos.experimentation.v1.Experiment.toObject(message.experiments[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this GetExperimentsResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetExperimentsResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetExperimentsResponse;
                })();

                v1.CancelExperimentRunRequest = (function() {

                    /**
                     * Properties of a CancelExperimentRunRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface ICancelExperimentRunRequest
                     * @property {string|null} [id] CancelExperimentRunRequest id
                     * @property {string|null} [reason] CancelExperimentRunRequest reason
                     */

                    /**
                     * Constructs a new CancelExperimentRunRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a CancelExperimentRunRequest.
                     * @implements ICancelExperimentRunRequest
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.ICancelExperimentRunRequest=} [properties] Properties to set
                     */
                    function CancelExperimentRunRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CancelExperimentRunRequest id.
                     * @member {string} id
                     * @memberof clutch.chaos.experimentation.v1.CancelExperimentRunRequest
                     * @instance
                     */
                    CancelExperimentRunRequest.prototype.id = "";

                    /**
                     * CancelExperimentRunRequest reason.
                     * @member {string} reason
                     * @memberof clutch.chaos.experimentation.v1.CancelExperimentRunRequest
                     * @instance
                     */
                    CancelExperimentRunRequest.prototype.reason = "";

                    /**
                     * Verifies a CancelExperimentRunRequest message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.CancelExperimentRunRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CancelExperimentRunRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.reason != null && message.hasOwnProperty("reason"))
                            if (!$util.isString(message.reason))
                                return "reason: string expected";
                        return null;
                    };

                    /**
                     * Creates a CancelExperimentRunRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.CancelExperimentRunRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.CancelExperimentRunRequest} CancelExperimentRunRequest
                     */
                    CancelExperimentRunRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.CancelExperimentRunRequest)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.CancelExperimentRunRequest();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.reason != null)
                            message.reason = String(object.reason);
                        return message;
                    };

                    /**
                     * Creates a plain object from a CancelExperimentRunRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.CancelExperimentRunRequest
                     * @static
                     * @param {clutch.chaos.experimentation.v1.CancelExperimentRunRequest} message CancelExperimentRunRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CancelExperimentRunRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.id = "";
                            object.reason = "";
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.reason != null && message.hasOwnProperty("reason"))
                            object.reason = message.reason;
                        return object;
                    };

                    /**
                     * Converts this CancelExperimentRunRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.CancelExperimentRunRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CancelExperimentRunRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CancelExperimentRunRequest;
                })();

                v1.CancelExperimentRunResponse = (function() {

                    /**
                     * Properties of a CancelExperimentRunResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface ICancelExperimentRunResponse
                     */

                    /**
                     * Constructs a new CancelExperimentRunResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a CancelExperimentRunResponse.
                     * @implements ICancelExperimentRunResponse
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.ICancelExperimentRunResponse=} [properties] Properties to set
                     */
                    function CancelExperimentRunResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Verifies a CancelExperimentRunResponse message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.CancelExperimentRunResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CancelExperimentRunResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a CancelExperimentRunResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.CancelExperimentRunResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.CancelExperimentRunResponse} CancelExperimentRunResponse
                     */
                    CancelExperimentRunResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.CancelExperimentRunResponse)
                            return object;
                        return new $root.clutch.chaos.experimentation.v1.CancelExperimentRunResponse();
                    };

                    /**
                     * Creates a plain object from a CancelExperimentRunResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.CancelExperimentRunResponse
                     * @static
                     * @param {clutch.chaos.experimentation.v1.CancelExperimentRunResponse} message CancelExperimentRunResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CancelExperimentRunResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this CancelExperimentRunResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.CancelExperimentRunResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CancelExperimentRunResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CancelExperimentRunResponse;
                })();

                v1.GetListViewRequest = (function() {

                    /**
                     * Properties of a GetListViewRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IGetListViewRequest
                     */

                    /**
                     * Constructs a new GetListViewRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a GetListViewRequest.
                     * @implements IGetListViewRequest
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IGetListViewRequest=} [properties] Properties to set
                     */
                    function GetListViewRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Verifies a GetListViewRequest message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.GetListViewRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetListViewRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a GetListViewRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.GetListViewRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.GetListViewRequest} GetListViewRequest
                     */
                    GetListViewRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.GetListViewRequest)
                            return object;
                        return new $root.clutch.chaos.experimentation.v1.GetListViewRequest();
                    };

                    /**
                     * Creates a plain object from a GetListViewRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.GetListViewRequest
                     * @static
                     * @param {clutch.chaos.experimentation.v1.GetListViewRequest} message GetListViewRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetListViewRequest.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this GetListViewRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.GetListViewRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetListViewRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetListViewRequest;
                })();

                v1.GetListViewResponse = (function() {

                    /**
                     * Properties of a GetListViewResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IGetListViewResponse
                     * @property {Array.<clutch.chaos.experimentation.v1.IListViewItem>|null} [items] GetListViewResponse items
                     */

                    /**
                     * Constructs a new GetListViewResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a GetListViewResponse.
                     * @implements IGetListViewResponse
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IGetListViewResponse=} [properties] Properties to set
                     */
                    function GetListViewResponse(properties) {
                        this.items = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetListViewResponse items.
                     * @member {Array.<clutch.chaos.experimentation.v1.IListViewItem>} items
                     * @memberof clutch.chaos.experimentation.v1.GetListViewResponse
                     * @instance
                     */
                    GetListViewResponse.prototype.items = $util.emptyArray;

                    /**
                     * Verifies a GetListViewResponse message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.GetListViewResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetListViewResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.items != null && message.hasOwnProperty("items")) {
                            if (!Array.isArray(message.items))
                                return "items: array expected";
                            for (let i = 0; i < message.items.length; ++i) {
                                let error = $root.clutch.chaos.experimentation.v1.ListViewItem.verify(message.items[i]);
                                if (error)
                                    return "items." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a GetListViewResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.GetListViewResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.GetListViewResponse} GetListViewResponse
                     */
                    GetListViewResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.GetListViewResponse)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.GetListViewResponse();
                        if (object.items) {
                            if (!Array.isArray(object.items))
                                throw TypeError(".clutch.chaos.experimentation.v1.GetListViewResponse.items: array expected");
                            message.items = [];
                            for (let i = 0; i < object.items.length; ++i) {
                                if (typeof object.items[i] !== "object")
                                    throw TypeError(".clutch.chaos.experimentation.v1.GetListViewResponse.items: object expected");
                                message.items[i] = $root.clutch.chaos.experimentation.v1.ListViewItem.fromObject(object.items[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetListViewResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.GetListViewResponse
                     * @static
                     * @param {clutch.chaos.experimentation.v1.GetListViewResponse} message GetListViewResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetListViewResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.items = [];
                        if (message.items && message.items.length) {
                            object.items = [];
                            for (let j = 0; j < message.items.length; ++j)
                                object.items[j] = $root.clutch.chaos.experimentation.v1.ListViewItem.toObject(message.items[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this GetListViewResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.GetListViewResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetListViewResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetListViewResponse;
                })();

                v1.GetExperimentRunDetailsRequest = (function() {

                    /**
                     * Properties of a GetExperimentRunDetailsRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IGetExperimentRunDetailsRequest
                     * @property {string|null} [id] GetExperimentRunDetailsRequest id
                     */

                    /**
                     * Constructs a new GetExperimentRunDetailsRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a GetExperimentRunDetailsRequest.
                     * @implements IGetExperimentRunDetailsRequest
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentRunDetailsRequest=} [properties] Properties to set
                     */
                    function GetExperimentRunDetailsRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetExperimentRunDetailsRequest id.
                     * @member {string} id
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunDetailsRequest
                     * @instance
                     */
                    GetExperimentRunDetailsRequest.prototype.id = "";

                    /**
                     * Verifies a GetExperimentRunDetailsRequest message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunDetailsRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetExperimentRunDetailsRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        return null;
                    };

                    /**
                     * Creates a GetExperimentRunDetailsRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunDetailsRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.GetExperimentRunDetailsRequest} GetExperimentRunDetailsRequest
                     */
                    GetExperimentRunDetailsRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.GetExperimentRunDetailsRequest)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.GetExperimentRunDetailsRequest();
                        if (object.id != null)
                            message.id = String(object.id);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetExperimentRunDetailsRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunDetailsRequest
                     * @static
                     * @param {clutch.chaos.experimentation.v1.GetExperimentRunDetailsRequest} message GetExperimentRunDetailsRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetExperimentRunDetailsRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.id = "";
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        return object;
                    };

                    /**
                     * Converts this GetExperimentRunDetailsRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunDetailsRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetExperimentRunDetailsRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetExperimentRunDetailsRequest;
                })();

                v1.GetExperimentRunDetailsResponse = (function() {

                    /**
                     * Properties of a GetExperimentRunDetailsResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IGetExperimentRunDetailsResponse
                     * @property {clutch.chaos.experimentation.v1.IExperimentRunDetails|null} [runDetails] GetExperimentRunDetailsResponse runDetails
                     */

                    /**
                     * Constructs a new GetExperimentRunDetailsResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a GetExperimentRunDetailsResponse.
                     * @implements IGetExperimentRunDetailsResponse
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentRunDetailsResponse=} [properties] Properties to set
                     */
                    function GetExperimentRunDetailsResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetExperimentRunDetailsResponse runDetails.
                     * @member {clutch.chaos.experimentation.v1.IExperimentRunDetails|null|undefined} runDetails
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunDetailsResponse
                     * @instance
                     */
                    GetExperimentRunDetailsResponse.prototype.runDetails = null;

                    /**
                     * Verifies a GetExperimentRunDetailsResponse message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunDetailsResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetExperimentRunDetailsResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.runDetails != null && message.hasOwnProperty("runDetails")) {
                            let error = $root.clutch.chaos.experimentation.v1.ExperimentRunDetails.verify(message.runDetails);
                            if (error)
                                return "runDetails." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a GetExperimentRunDetailsResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunDetailsResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.GetExperimentRunDetailsResponse} GetExperimentRunDetailsResponse
                     */
                    GetExperimentRunDetailsResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.GetExperimentRunDetailsResponse)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.GetExperimentRunDetailsResponse();
                        if (object.runDetails != null) {
                            if (typeof object.runDetails !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.GetExperimentRunDetailsResponse.runDetails: object expected");
                            message.runDetails = $root.clutch.chaos.experimentation.v1.ExperimentRunDetails.fromObject(object.runDetails);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetExperimentRunDetailsResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunDetailsResponse
                     * @static
                     * @param {clutch.chaos.experimentation.v1.GetExperimentRunDetailsResponse} message GetExperimentRunDetailsResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetExperimentRunDetailsResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.runDetails = null;
                        if (message.runDetails != null && message.hasOwnProperty("runDetails"))
                            object.runDetails = $root.clutch.chaos.experimentation.v1.ExperimentRunDetails.toObject(message.runDetails, options);
                        return object;
                    };

                    /**
                     * Converts this GetExperimentRunDetailsResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunDetailsResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetExperimentRunDetailsResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetExperimentRunDetailsResponse;
                })();

                v1.ExperimentsAPI = (function() {

                    /**
                     * Constructs a new ExperimentsAPI service.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents an ExperimentsAPI
                     * @extends $protobuf.rpc.Service
                     * @constructor
                     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                     */
                    function ExperimentsAPI(rpcImpl, requestDelimited, responseDelimited) {
                        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                    }

                    (ExperimentsAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ExperimentsAPI;

                    /**
                     * Callback as used by {@link clutch.chaos.experimentation.v1.ExperimentsAPI#createExperiment}.
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @typedef CreateExperimentCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.chaos.experimentation.v1.CreateExperimentResponse} [response] CreateExperimentResponse
                     */

                    /**
                     * Calls CreateExperiment.
                     * @function createExperiment
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.ICreateExperimentRequest} request CreateExperimentRequest message or plain object
                     * @param {clutch.chaos.experimentation.v1.ExperimentsAPI.CreateExperimentCallback} callback Node-style callback called with the error, if any, and CreateExperimentResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(ExperimentsAPI.prototype.createExperiment = function createExperiment(request, callback) {
                        return this.rpcCall(createExperiment, $root.clutch.chaos.experimentation.v1.CreateExperimentRequest, $root.clutch.chaos.experimentation.v1.CreateExperimentResponse, request, callback);
                    }, "name", { value: "CreateExperiment" });

                    /**
                     * Calls CreateExperiment.
                     * @function createExperiment
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.ICreateExperimentRequest} request CreateExperimentRequest message or plain object
                     * @returns {Promise<clutch.chaos.experimentation.v1.CreateExperimentResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.chaos.experimentation.v1.ExperimentsAPI#createOrGetExperiment}.
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @typedef CreateOrGetExperimentCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse} [response] CreateOrGetExperimentResponse
                     */

                    /**
                     * Calls CreateOrGetExperiment.
                     * @function createOrGetExperiment
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.ICreateOrGetExperimentRequest} request CreateOrGetExperimentRequest message or plain object
                     * @param {clutch.chaos.experimentation.v1.ExperimentsAPI.CreateOrGetExperimentCallback} callback Node-style callback called with the error, if any, and CreateOrGetExperimentResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(ExperimentsAPI.prototype.createOrGetExperiment = function createOrGetExperiment(request, callback) {
                        return this.rpcCall(createOrGetExperiment, $root.clutch.chaos.experimentation.v1.CreateOrGetExperimentRequest, $root.clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse, request, callback);
                    }, "name", { value: "CreateOrGetExperiment" });

                    /**
                     * Calls CreateOrGetExperiment.
                     * @function createOrGetExperiment
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.ICreateOrGetExperimentRequest} request CreateOrGetExperimentRequest message or plain object
                     * @returns {Promise<clutch.chaos.experimentation.v1.CreateOrGetExperimentResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.chaos.experimentation.v1.ExperimentsAPI#cancelExperimentRun}.
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @typedef CancelExperimentRunCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.chaos.experimentation.v1.CancelExperimentRunResponse} [response] CancelExperimentRunResponse
                     */

                    /**
                     * Calls CancelExperimentRun.
                     * @function cancelExperimentRun
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.ICancelExperimentRunRequest} request CancelExperimentRunRequest message or plain object
                     * @param {clutch.chaos.experimentation.v1.ExperimentsAPI.CancelExperimentRunCallback} callback Node-style callback called with the error, if any, and CancelExperimentRunResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(ExperimentsAPI.prototype.cancelExperimentRun = function cancelExperimentRun(request, callback) {
                        return this.rpcCall(cancelExperimentRun, $root.clutch.chaos.experimentation.v1.CancelExperimentRunRequest, $root.clutch.chaos.experimentation.v1.CancelExperimentRunResponse, request, callback);
                    }, "name", { value: "CancelExperimentRun" });

                    /**
                     * Calls CancelExperimentRun.
                     * @function cancelExperimentRun
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.ICancelExperimentRunRequest} request CancelExperimentRunRequest message or plain object
                     * @returns {Promise<clutch.chaos.experimentation.v1.CancelExperimentRunResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.chaos.experimentation.v1.ExperimentsAPI#getExperiments}.
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @typedef GetExperimentsCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.chaos.experimentation.v1.GetExperimentsResponse} [response] GetExperimentsResponse
                     */

                    /**
                     * Calls GetExperiments.
                     * @function getExperiments
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentsRequest} request GetExperimentsRequest message or plain object
                     * @param {clutch.chaos.experimentation.v1.ExperimentsAPI.GetExperimentsCallback} callback Node-style callback called with the error, if any, and GetExperimentsResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(ExperimentsAPI.prototype.getExperiments = function getExperiments(request, callback) {
                        return this.rpcCall(getExperiments, $root.clutch.chaos.experimentation.v1.GetExperimentsRequest, $root.clutch.chaos.experimentation.v1.GetExperimentsResponse, request, callback);
                    }, "name", { value: "GetExperiments" });

                    /**
                     * Calls GetExperiments.
                     * @function getExperiments
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentsRequest} request GetExperimentsRequest message or plain object
                     * @returns {Promise<clutch.chaos.experimentation.v1.GetExperimentsResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.chaos.experimentation.v1.ExperimentsAPI#getListView}.
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @typedef GetListViewCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.chaos.experimentation.v1.GetListViewResponse} [response] GetListViewResponse
                     */

                    /**
                     * Calls GetListView.
                     * @function getListView
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.IGetListViewRequest} request GetListViewRequest message or plain object
                     * @param {clutch.chaos.experimentation.v1.ExperimentsAPI.GetListViewCallback} callback Node-style callback called with the error, if any, and GetListViewResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(ExperimentsAPI.prototype.getListView = function getListView(request, callback) {
                        return this.rpcCall(getListView, $root.clutch.chaos.experimentation.v1.GetListViewRequest, $root.clutch.chaos.experimentation.v1.GetListViewResponse, request, callback);
                    }, "name", { value: "GetListView" });

                    /**
                     * Calls GetListView.
                     * @function getListView
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.IGetListViewRequest} request GetListViewRequest message or plain object
                     * @returns {Promise<clutch.chaos.experimentation.v1.GetListViewResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.chaos.experimentation.v1.ExperimentsAPI#getExperimentRunDetails}.
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @typedef GetExperimentRunDetailsCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.chaos.experimentation.v1.GetExperimentRunDetailsResponse} [response] GetExperimentRunDetailsResponse
                     */

                    /**
                     * Calls GetExperimentRunDetails.
                     * @function getExperimentRunDetails
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentRunDetailsRequest} request GetExperimentRunDetailsRequest message or plain object
                     * @param {clutch.chaos.experimentation.v1.ExperimentsAPI.GetExperimentRunDetailsCallback} callback Node-style callback called with the error, if any, and GetExperimentRunDetailsResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(ExperimentsAPI.prototype.getExperimentRunDetails = function getExperimentRunDetails(request, callback) {
                        return this.rpcCall(getExperimentRunDetails, $root.clutch.chaos.experimentation.v1.GetExperimentRunDetailsRequest, $root.clutch.chaos.experimentation.v1.GetExperimentRunDetailsResponse, request, callback);
                    }, "name", { value: "GetExperimentRunDetails" });

                    /**
                     * Calls GetExperimentRunDetails.
                     * @function getExperimentRunDetails
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentRunDetailsRequest} request GetExperimentRunDetailsRequest message or plain object
                     * @returns {Promise<clutch.chaos.experimentation.v1.GetExperimentRunDetailsResponse>} Promise
                     * @variation 2
                     */

                    return ExperimentsAPI;
                })();

                v1.Experiment = (function() {

                    /**
                     * Properties of an Experiment.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IExperiment
                     * @property {string|null} [runId] Experiment runId
                     * @property {google.protobuf.IAny|null} [config] Experiment config
                     * @property {google.protobuf.ITimestamp|null} [startTime] Experiment startTime
                     * @property {google.protobuf.ITimestamp|null} [endTime] Experiment endTime
                     * @property {clutch.chaos.experimentation.v1.Experiment.Status|null} [status] Experiment status
                     */

                    /**
                     * Constructs a new Experiment.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents an Experiment.
                     * @implements IExperiment
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IExperiment=} [properties] Properties to set
                     */
                    function Experiment(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Experiment runId.
                     * @member {string} runId
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @instance
                     */
                    Experiment.prototype.runId = "";

                    /**
                     * Experiment config.
                     * @member {google.protobuf.IAny|null|undefined} config
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @instance
                     */
                    Experiment.prototype.config = null;

                    /**
                     * Experiment startTime.
                     * @member {google.protobuf.ITimestamp|null|undefined} startTime
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @instance
                     */
                    Experiment.prototype.startTime = null;

                    /**
                     * Experiment endTime.
                     * @member {google.protobuf.ITimestamp|null|undefined} endTime
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @instance
                     */
                    Experiment.prototype.endTime = null;

                    /**
                     * Experiment status.
                     * @member {clutch.chaos.experimentation.v1.Experiment.Status} status
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @instance
                     */
                    Experiment.prototype.status = 0;

                    /**
                     * Verifies an Experiment message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Experiment.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.runId != null && message.hasOwnProperty("runId"))
                            if (!$util.isString(message.runId))
                                return "runId: string expected";
                        if (message.config != null && message.hasOwnProperty("config")) {
                            let error = $root.google.protobuf.Any.verify(message.config);
                            if (error)
                                return "config." + error;
                        }
                        if (message.startTime != null && message.hasOwnProperty("startTime")) {
                            let error = $root.google.protobuf.Timestamp.verify(message.startTime);
                            if (error)
                                return "startTime." + error;
                        }
                        if (message.endTime != null && message.hasOwnProperty("endTime")) {
                            let error = $root.google.protobuf.Timestamp.verify(message.endTime);
                            if (error)
                                return "endTime." + error;
                        }
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates an Experiment message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.Experiment} Experiment
                     */
                    Experiment.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.Experiment)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.Experiment();
                        if (object.runId != null)
                            message.runId = String(object.runId);
                        if (object.config != null) {
                            if (typeof object.config !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.Experiment.config: object expected");
                            message.config = $root.google.protobuf.Any.fromObject(object.config);
                        }
                        if (object.startTime != null) {
                            if (typeof object.startTime !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.Experiment.startTime: object expected");
                            message.startTime = $root.google.protobuf.Timestamp.fromObject(object.startTime);
                        }
                        if (object.endTime != null) {
                            if (typeof object.endTime !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.Experiment.endTime: object expected");
                            message.endTime = $root.google.protobuf.Timestamp.fromObject(object.endTime);
                        }
                        switch (object.status) {
                        case "STATUS_UNSPECIFIED":
                        case 0:
                            message.status = 0;
                            break;
                        case "STATUS_SCHEDULED":
                        case 1:
                            message.status = 1;
                            break;
                        case "STATUS_RUNNING":
                        case 2:
                            message.status = 2;
                            break;
                        case "STATUS_COMPLETED":
                        case 3:
                            message.status = 3;
                            break;
                        case "STATUS_CANCELED":
                        case 4:
                            message.status = 4;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an Experiment message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @static
                     * @param {clutch.chaos.experimentation.v1.Experiment} message Experiment
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Experiment.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.runId = "";
                            object.config = null;
                            object.startTime = null;
                            object.endTime = null;
                            object.status = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                        }
                        if (message.runId != null && message.hasOwnProperty("runId"))
                            object.runId = message.runId;
                        if (message.config != null && message.hasOwnProperty("config"))
                            object.config = $root.google.protobuf.Any.toObject(message.config, options);
                        if (message.startTime != null && message.hasOwnProperty("startTime"))
                            object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
                        if (message.endTime != null && message.hasOwnProperty("endTime"))
                            object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.clutch.chaos.experimentation.v1.Experiment.Status[message.status] : message.status;
                        return object;
                    };

                    /**
                     * Converts this Experiment to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Experiment.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Status enum.
                     * @name clutch.chaos.experimentation.v1.Experiment.Status
                     * @enum {number}
                     * @property {number} STATUS_UNSPECIFIED=0 STATUS_UNSPECIFIED value
                     * @property {number} STATUS_SCHEDULED=1 STATUS_SCHEDULED value
                     * @property {number} STATUS_RUNNING=2 STATUS_RUNNING value
                     * @property {number} STATUS_COMPLETED=3 STATUS_COMPLETED value
                     * @property {number} STATUS_CANCELED=4 STATUS_CANCELED value
                     */
                    Experiment.Status = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "STATUS_UNSPECIFIED"] = 0;
                        values[valuesById[1] = "STATUS_SCHEDULED"] = 1;
                        values[valuesById[2] = "STATUS_RUNNING"] = 2;
                        values[valuesById[3] = "STATUS_COMPLETED"] = 3;
                        values[valuesById[4] = "STATUS_CANCELED"] = 4;
                        return values;
                    })();

                    return Experiment;
                })();

                v1.ListViewItem = (function() {

                    /**
                     * Properties of a ListViewItem.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IListViewItem
                     * @property {string|null} [id] ListViewItem id
                     * @property {clutch.chaos.experimentation.v1.IPropertiesMap|null} [properties] ListViewItem properties
                     */

                    /**
                     * Constructs a new ListViewItem.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a ListViewItem.
                     * @implements IListViewItem
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IListViewItem=} [properties] Properties to set
                     */
                    function ListViewItem(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ListViewItem id.
                     * @member {string} id
                     * @memberof clutch.chaos.experimentation.v1.ListViewItem
                     * @instance
                     */
                    ListViewItem.prototype.id = "";

                    /**
                     * ListViewItem properties.
                     * @member {clutch.chaos.experimentation.v1.IPropertiesMap|null|undefined} properties
                     * @memberof clutch.chaos.experimentation.v1.ListViewItem
                     * @instance
                     */
                    ListViewItem.prototype.properties = null;

                    /**
                     * Verifies a ListViewItem message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.ListViewItem
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ListViewItem.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.properties != null && message.hasOwnProperty("properties")) {
                            let error = $root.clutch.chaos.experimentation.v1.PropertiesMap.verify(message.properties);
                            if (error)
                                return "properties." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a ListViewItem message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.ListViewItem
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.ListViewItem} ListViewItem
                     */
                    ListViewItem.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.ListViewItem)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.ListViewItem();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.properties != null) {
                            if (typeof object.properties !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.ListViewItem.properties: object expected");
                            message.properties = $root.clutch.chaos.experimentation.v1.PropertiesMap.fromObject(object.properties);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ListViewItem message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.ListViewItem
                     * @static
                     * @param {clutch.chaos.experimentation.v1.ListViewItem} message ListViewItem
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ListViewItem.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.id = "";
                            object.properties = null;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.properties != null && message.hasOwnProperty("properties"))
                            object.properties = $root.clutch.chaos.experimentation.v1.PropertiesMap.toObject(message.properties, options);
                        return object;
                    };

                    /**
                     * Converts this ListViewItem to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.ListViewItem
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ListViewItem.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ListViewItem;
                })();

                v1.PropertiesList = (function() {

                    /**
                     * Properties of a PropertiesList.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IPropertiesList
                     * @property {Array.<clutch.chaos.experimentation.v1.IProperty>|null} [items] PropertiesList items
                     */

                    /**
                     * Constructs a new PropertiesList.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a PropertiesList.
                     * @implements IPropertiesList
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IPropertiesList=} [properties] Properties to set
                     */
                    function PropertiesList(properties) {
                        this.items = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PropertiesList items.
                     * @member {Array.<clutch.chaos.experimentation.v1.IProperty>} items
                     * @memberof clutch.chaos.experimentation.v1.PropertiesList
                     * @instance
                     */
                    PropertiesList.prototype.items = $util.emptyArray;

                    /**
                     * Verifies a PropertiesList message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.PropertiesList
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PropertiesList.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.items != null && message.hasOwnProperty("items")) {
                            if (!Array.isArray(message.items))
                                return "items: array expected";
                            for (let i = 0; i < message.items.length; ++i) {
                                let error = $root.clutch.chaos.experimentation.v1.Property.verify(message.items[i]);
                                if (error)
                                    return "items." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a PropertiesList message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.PropertiesList
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.PropertiesList} PropertiesList
                     */
                    PropertiesList.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.PropertiesList)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.PropertiesList();
                        if (object.items) {
                            if (!Array.isArray(object.items))
                                throw TypeError(".clutch.chaos.experimentation.v1.PropertiesList.items: array expected");
                            message.items = [];
                            for (let i = 0; i < object.items.length; ++i) {
                                if (typeof object.items[i] !== "object")
                                    throw TypeError(".clutch.chaos.experimentation.v1.PropertiesList.items: object expected");
                                message.items[i] = $root.clutch.chaos.experimentation.v1.Property.fromObject(object.items[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a PropertiesList message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.PropertiesList
                     * @static
                     * @param {clutch.chaos.experimentation.v1.PropertiesList} message PropertiesList
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PropertiesList.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.items = [];
                        if (message.items && message.items.length) {
                            object.items = [];
                            for (let j = 0; j < message.items.length; ++j)
                                object.items[j] = $root.clutch.chaos.experimentation.v1.Property.toObject(message.items[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this PropertiesList to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.PropertiesList
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PropertiesList.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return PropertiesList;
                })();

                v1.PropertiesMap = (function() {

                    /**
                     * Properties of a PropertiesMap.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IPropertiesMap
                     * @property {Object.<string,clutch.chaos.experimentation.v1.IProperty>|null} [items] PropertiesMap items
                     */

                    /**
                     * Constructs a new PropertiesMap.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a PropertiesMap.
                     * @implements IPropertiesMap
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IPropertiesMap=} [properties] Properties to set
                     */
                    function PropertiesMap(properties) {
                        this.items = {};
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PropertiesMap items.
                     * @member {Object.<string,clutch.chaos.experimentation.v1.IProperty>} items
                     * @memberof clutch.chaos.experimentation.v1.PropertiesMap
                     * @instance
                     */
                    PropertiesMap.prototype.items = $util.emptyObject;

                    /**
                     * Verifies a PropertiesMap message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.PropertiesMap
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PropertiesMap.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.items != null && message.hasOwnProperty("items")) {
                            if (!$util.isObject(message.items))
                                return "items: object expected";
                            let key = Object.keys(message.items);
                            for (let i = 0; i < key.length; ++i) {
                                let error = $root.clutch.chaos.experimentation.v1.Property.verify(message.items[key[i]]);
                                if (error)
                                    return "items." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a PropertiesMap message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.PropertiesMap
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.PropertiesMap} PropertiesMap
                     */
                    PropertiesMap.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.PropertiesMap)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.PropertiesMap();
                        if (object.items) {
                            if (typeof object.items !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.PropertiesMap.items: object expected");
                            message.items = {};
                            for (let keys = Object.keys(object.items), i = 0; i < keys.length; ++i) {
                                if (typeof object.items[keys[i]] !== "object")
                                    throw TypeError(".clutch.chaos.experimentation.v1.PropertiesMap.items: object expected");
                                message.items[keys[i]] = $root.clutch.chaos.experimentation.v1.Property.fromObject(object.items[keys[i]]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a PropertiesMap message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.PropertiesMap
                     * @static
                     * @param {clutch.chaos.experimentation.v1.PropertiesMap} message PropertiesMap
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PropertiesMap.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.objects || options.defaults)
                            object.items = {};
                        let keys2;
                        if (message.items && (keys2 = Object.keys(message.items)).length) {
                            object.items = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.items[keys2[j]] = $root.clutch.chaos.experimentation.v1.Property.toObject(message.items[keys2[j]], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this PropertiesMap to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.PropertiesMap
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PropertiesMap.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return PropertiesMap;
                })();

                v1.Property = (function() {

                    /**
                     * Properties of a Property.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IProperty
                     * @property {string|null} [id] Property id
                     * @property {string|null} [label] Property label
                     * @property {google.protobuf.IStringValue|null} [displayValue] Property displayValue
                     * @property {google.protobuf.ITimestamp|null} [dateValue] Property dateValue
                     * @property {string|null} [stringValue] Property stringValue
                     * @property {number|Long|null} [intValue] Property intValue
                     * @property {string|null} [urlValue] Property urlValue
                     */

                    /**
                     * Constructs a new Property.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a Property.
                     * @implements IProperty
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IProperty=} [properties] Properties to set
                     */
                    function Property(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Property id.
                     * @member {string} id
                     * @memberof clutch.chaos.experimentation.v1.Property
                     * @instance
                     */
                    Property.prototype.id = "";

                    /**
                     * Property label.
                     * @member {string} label
                     * @memberof clutch.chaos.experimentation.v1.Property
                     * @instance
                     */
                    Property.prototype.label = "";

                    /**
                     * Property displayValue.
                     * @member {google.protobuf.IStringValue|null|undefined} displayValue
                     * @memberof clutch.chaos.experimentation.v1.Property
                     * @instance
                     */
                    Property.prototype.displayValue = null;

                    /**
                     * Property dateValue.
                     * @member {google.protobuf.ITimestamp|null|undefined} dateValue
                     * @memberof clutch.chaos.experimentation.v1.Property
                     * @instance
                     */
                    Property.prototype.dateValue = null;

                    /**
                     * Property stringValue.
                     * @member {string|null|undefined} stringValue
                     * @memberof clutch.chaos.experimentation.v1.Property
                     * @instance
                     */
                    Property.prototype.stringValue = null;

                    /**
                     * Property intValue.
                     * @member {number|Long|null|undefined} intValue
                     * @memberof clutch.chaos.experimentation.v1.Property
                     * @instance
                     */
                    Property.prototype.intValue = null;

                    /**
                     * Property urlValue.
                     * @member {string|null|undefined} urlValue
                     * @memberof clutch.chaos.experimentation.v1.Property
                     * @instance
                     */
                    Property.prototype.urlValue = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Property value.
                     * @member {"dateValue"|"stringValue"|"intValue"|"urlValue"|undefined} value
                     * @memberof clutch.chaos.experimentation.v1.Property
                     * @instance
                     */
                    Object.defineProperty(Property.prototype, "value", {
                        get: $util.oneOfGetter($oneOfFields = ["dateValue", "stringValue", "intValue", "urlValue"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies a Property message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.Property
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Property.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.label != null && message.hasOwnProperty("label"))
                            if (!$util.isString(message.label))
                                return "label: string expected";
                        if (message.displayValue != null && message.hasOwnProperty("displayValue")) {
                            let error = $root.google.protobuf.StringValue.verify(message.displayValue);
                            if (error)
                                return "displayValue." + error;
                        }
                        if (message.dateValue != null && message.hasOwnProperty("dateValue")) {
                            properties.value = 1;
                            {
                                let error = $root.google.protobuf.Timestamp.verify(message.dateValue);
                                if (error)
                                    return "dateValue." + error;
                            }
                        }
                        if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (!$util.isString(message.stringValue))
                                return "stringValue: string expected";
                        }
                        if (message.intValue != null && message.hasOwnProperty("intValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (!$util.isInteger(message.intValue) && !(message.intValue && $util.isInteger(message.intValue.low) && $util.isInteger(message.intValue.high)))
                                return "intValue: integer|Long expected";
                        }
                        if (message.urlValue != null && message.hasOwnProperty("urlValue")) {
                            if (properties.value === 1)
                                return "value: multiple values";
                            properties.value = 1;
                            if (!$util.isString(message.urlValue))
                                return "urlValue: string expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Property message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.Property
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.Property} Property
                     */
                    Property.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.Property)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.Property();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.label != null)
                            message.label = String(object.label);
                        if (object.displayValue != null) {
                            if (typeof object.displayValue !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.Property.displayValue: object expected");
                            message.displayValue = $root.google.protobuf.StringValue.fromObject(object.displayValue);
                        }
                        if (object.dateValue != null) {
                            if (typeof object.dateValue !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.Property.dateValue: object expected");
                            message.dateValue = $root.google.protobuf.Timestamp.fromObject(object.dateValue);
                        }
                        if (object.stringValue != null)
                            message.stringValue = String(object.stringValue);
                        if (object.intValue != null)
                            if ($util.Long)
                                (message.intValue = $util.Long.fromValue(object.intValue)).unsigned = false;
                            else if (typeof object.intValue === "string")
                                message.intValue = parseInt(object.intValue, 10);
                            else if (typeof object.intValue === "number")
                                message.intValue = object.intValue;
                            else if (typeof object.intValue === "object")
                                message.intValue = new $util.LongBits(object.intValue.low >>> 0, object.intValue.high >>> 0).toNumber();
                        if (object.urlValue != null)
                            message.urlValue = String(object.urlValue);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Property message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.Property
                     * @static
                     * @param {clutch.chaos.experimentation.v1.Property} message Property
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Property.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.id = "";
                            object.label = "";
                            object.displayValue = null;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.label != null && message.hasOwnProperty("label"))
                            object.label = message.label;
                        if (message.displayValue != null && message.hasOwnProperty("displayValue"))
                            object.displayValue = $root.google.protobuf.StringValue.toObject(message.displayValue, options);
                        if (message.dateValue != null && message.hasOwnProperty("dateValue")) {
                            object.dateValue = $root.google.protobuf.Timestamp.toObject(message.dateValue, options);
                            if (options.oneofs)
                                object.value = "dateValue";
                        }
                        if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                            object.stringValue = message.stringValue;
                            if (options.oneofs)
                                object.value = "stringValue";
                        }
                        if (message.intValue != null && message.hasOwnProperty("intValue")) {
                            if (typeof message.intValue === "number")
                                object.intValue = options.longs === String ? String(message.intValue) : message.intValue;
                            else
                                object.intValue = options.longs === String ? $util.Long.prototype.toString.call(message.intValue) : options.longs === Number ? new $util.LongBits(message.intValue.low >>> 0, message.intValue.high >>> 0).toNumber() : message.intValue;
                            if (options.oneofs)
                                object.value = "intValue";
                        }
                        if (message.urlValue != null && message.hasOwnProperty("urlValue")) {
                            object.urlValue = message.urlValue;
                            if (options.oneofs)
                                object.value = "urlValue";
                        }
                        return object;
                    };

                    /**
                     * Converts this Property to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.Property
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Property.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Property;
                })();

                v1.ExperimentRunDetails = (function() {

                    /**
                     * Properties of an ExperimentRunDetails.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IExperimentRunDetails
                     * @property {string|null} [runId] ExperimentRunDetails runId
                     * @property {clutch.chaos.experimentation.v1.Experiment.Status|null} [status] ExperimentRunDetails status
                     * @property {clutch.chaos.experimentation.v1.IPropertiesList|null} [properties] ExperimentRunDetails properties
                     * @property {google.protobuf.IAny|null} [config] ExperimentRunDetails config
                     */

                    /**
                     * Constructs a new ExperimentRunDetails.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents an ExperimentRunDetails.
                     * @implements IExperimentRunDetails
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IExperimentRunDetails=} [properties] Properties to set
                     */
                    function ExperimentRunDetails(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ExperimentRunDetails runId.
                     * @member {string} runId
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunDetails
                     * @instance
                     */
                    ExperimentRunDetails.prototype.runId = "";

                    /**
                     * ExperimentRunDetails status.
                     * @member {clutch.chaos.experimentation.v1.Experiment.Status} status
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunDetails
                     * @instance
                     */
                    ExperimentRunDetails.prototype.status = 0;

                    /**
                     * ExperimentRunDetails properties.
                     * @member {clutch.chaos.experimentation.v1.IPropertiesList|null|undefined} properties
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunDetails
                     * @instance
                     */
                    ExperimentRunDetails.prototype.properties = null;

                    /**
                     * ExperimentRunDetails config.
                     * @member {google.protobuf.IAny|null|undefined} config
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunDetails
                     * @instance
                     */
                    ExperimentRunDetails.prototype.config = null;

                    /**
                     * Verifies an ExperimentRunDetails message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunDetails
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ExperimentRunDetails.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.runId != null && message.hasOwnProperty("runId"))
                            if (!$util.isString(message.runId))
                                return "runId: string expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                        if (message.properties != null && message.hasOwnProperty("properties")) {
                            let error = $root.clutch.chaos.experimentation.v1.PropertiesList.verify(message.properties);
                            if (error)
                                return "properties." + error;
                        }
                        if (message.config != null && message.hasOwnProperty("config")) {
                            let error = $root.google.protobuf.Any.verify(message.config);
                            if (error)
                                return "config." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an ExperimentRunDetails message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunDetails
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.ExperimentRunDetails} ExperimentRunDetails
                     */
                    ExperimentRunDetails.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.ExperimentRunDetails)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.ExperimentRunDetails();
                        if (object.runId != null)
                            message.runId = String(object.runId);
                        switch (object.status) {
                        case "STATUS_UNSPECIFIED":
                        case 0:
                            message.status = 0;
                            break;
                        case "STATUS_SCHEDULED":
                        case 1:
                            message.status = 1;
                            break;
                        case "STATUS_RUNNING":
                        case 2:
                            message.status = 2;
                            break;
                        case "STATUS_COMPLETED":
                        case 3:
                            message.status = 3;
                            break;
                        case "STATUS_CANCELED":
                        case 4:
                            message.status = 4;
                            break;
                        }
                        if (object.properties != null) {
                            if (typeof object.properties !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.ExperimentRunDetails.properties: object expected");
                            message.properties = $root.clutch.chaos.experimentation.v1.PropertiesList.fromObject(object.properties);
                        }
                        if (object.config != null) {
                            if (typeof object.config !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.ExperimentRunDetails.config: object expected");
                            message.config = $root.google.protobuf.Any.fromObject(object.config);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an ExperimentRunDetails message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunDetails
                     * @static
                     * @param {clutch.chaos.experimentation.v1.ExperimentRunDetails} message ExperimentRunDetails
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ExperimentRunDetails.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.runId = "";
                            object.status = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                            object.properties = null;
                            object.config = null;
                        }
                        if (message.runId != null && message.hasOwnProperty("runId"))
                            object.runId = message.runId;
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.clutch.chaos.experimentation.v1.Experiment.Status[message.status] : message.status;
                        if (message.properties != null && message.hasOwnProperty("properties"))
                            object.properties = $root.clutch.chaos.experimentation.v1.PropertiesList.toObject(message.properties, options);
                        if (message.config != null && message.hasOwnProperty("config"))
                            object.config = $root.google.protobuf.Any.toObject(message.config, options);
                        return object;
                    };

                    /**
                     * Converts this ExperimentRunDetails to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunDetails
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ExperimentRunDetails.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ExperimentRunDetails;
                })();

                return v1;
            })();

            return experimentation;
        })();

        chaos.redisexperimentation = (function() {

            /**
             * Namespace redisexperimentation.
             * @memberof clutch.chaos
             * @namespace
             */
            const redisexperimentation = {};

            redisexperimentation.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.chaos.redisexperimentation
                 * @namespace
                 */
                const v1 = {};

                v1.FaultConfig = (function() {

                    /**
                     * Properties of a FaultConfig.
                     * @memberof clutch.chaos.redisexperimentation.v1
                     * @interface IFaultConfig
                     * @property {clutch.chaos.redisexperimentation.v1.IFaultTargeting|null} [faultTargeting] FaultConfig faultTargeting
                     * @property {clutch.chaos.redisexperimentation.v1.IErrorFault|null} [errorFault] FaultConfig errorFault
                     * @property {clutch.chaos.redisexperimentation.v1.ILatencyFault|null} [latencyFault] FaultConfig latencyFault
                     */

                    /**
                     * Constructs a new FaultConfig.
                     * @memberof clutch.chaos.redisexperimentation.v1
                     * @classdesc Represents a FaultConfig.
                     * @implements IFaultConfig
                     * @constructor
                     * @param {clutch.chaos.redisexperimentation.v1.IFaultConfig=} [properties] Properties to set
                     */
                    function FaultConfig(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * FaultConfig faultTargeting.
                     * @member {clutch.chaos.redisexperimentation.v1.IFaultTargeting|null|undefined} faultTargeting
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultConfig
                     * @instance
                     */
                    FaultConfig.prototype.faultTargeting = null;

                    /**
                     * FaultConfig errorFault.
                     * @member {clutch.chaos.redisexperimentation.v1.IErrorFault|null|undefined} errorFault
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultConfig
                     * @instance
                     */
                    FaultConfig.prototype.errorFault = null;

                    /**
                     * FaultConfig latencyFault.
                     * @member {clutch.chaos.redisexperimentation.v1.ILatencyFault|null|undefined} latencyFault
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultConfig
                     * @instance
                     */
                    FaultConfig.prototype.latencyFault = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * FaultConfig fault.
                     * @member {"errorFault"|"latencyFault"|undefined} fault
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultConfig
                     * @instance
                     */
                    Object.defineProperty(FaultConfig.prototype, "fault", {
                        get: $util.oneOfGetter($oneOfFields = ["errorFault", "latencyFault"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies a FaultConfig message.
                     * @function verify
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultConfig
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    FaultConfig.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.faultTargeting != null && message.hasOwnProperty("faultTargeting")) {
                            let error = $root.clutch.chaos.redisexperimentation.v1.FaultTargeting.verify(message.faultTargeting);
                            if (error)
                                return "faultTargeting." + error;
                        }
                        if (message.errorFault != null && message.hasOwnProperty("errorFault")) {
                            properties.fault = 1;
                            {
                                let error = $root.clutch.chaos.redisexperimentation.v1.ErrorFault.verify(message.errorFault);
                                if (error)
                                    return "errorFault." + error;
                            }
                        }
                        if (message.latencyFault != null && message.hasOwnProperty("latencyFault")) {
                            if (properties.fault === 1)
                                return "fault: multiple values";
                            properties.fault = 1;
                            {
                                let error = $root.clutch.chaos.redisexperimentation.v1.LatencyFault.verify(message.latencyFault);
                                if (error)
                                    return "latencyFault." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a FaultConfig message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultConfig
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.redisexperimentation.v1.FaultConfig} FaultConfig
                     */
                    FaultConfig.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.redisexperimentation.v1.FaultConfig)
                            return object;
                        let message = new $root.clutch.chaos.redisexperimentation.v1.FaultConfig();
                        if (object.faultTargeting != null) {
                            if (typeof object.faultTargeting !== "object")
                                throw TypeError(".clutch.chaos.redisexperimentation.v1.FaultConfig.faultTargeting: object expected");
                            message.faultTargeting = $root.clutch.chaos.redisexperimentation.v1.FaultTargeting.fromObject(object.faultTargeting);
                        }
                        if (object.errorFault != null) {
                            if (typeof object.errorFault !== "object")
                                throw TypeError(".clutch.chaos.redisexperimentation.v1.FaultConfig.errorFault: object expected");
                            message.errorFault = $root.clutch.chaos.redisexperimentation.v1.ErrorFault.fromObject(object.errorFault);
                        }
                        if (object.latencyFault != null) {
                            if (typeof object.latencyFault !== "object")
                                throw TypeError(".clutch.chaos.redisexperimentation.v1.FaultConfig.latencyFault: object expected");
                            message.latencyFault = $root.clutch.chaos.redisexperimentation.v1.LatencyFault.fromObject(object.latencyFault);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a FaultConfig message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultConfig
                     * @static
                     * @param {clutch.chaos.redisexperimentation.v1.FaultConfig} message FaultConfig
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FaultConfig.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.faultTargeting = null;
                        if (message.faultTargeting != null && message.hasOwnProperty("faultTargeting"))
                            object.faultTargeting = $root.clutch.chaos.redisexperimentation.v1.FaultTargeting.toObject(message.faultTargeting, options);
                        if (message.errorFault != null && message.hasOwnProperty("errorFault")) {
                            object.errorFault = $root.clutch.chaos.redisexperimentation.v1.ErrorFault.toObject(message.errorFault, options);
                            if (options.oneofs)
                                object.fault = "errorFault";
                        }
                        if (message.latencyFault != null && message.hasOwnProperty("latencyFault")) {
                            object.latencyFault = $root.clutch.chaos.redisexperimentation.v1.LatencyFault.toObject(message.latencyFault, options);
                            if (options.oneofs)
                                object.fault = "latencyFault";
                        }
                        return object;
                    };

                    /**
                     * Converts this FaultConfig to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultConfig
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    FaultConfig.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return FaultConfig;
                })();

                v1.ErrorFault = (function() {

                    /**
                     * Properties of an ErrorFault.
                     * @memberof clutch.chaos.redisexperimentation.v1
                     * @interface IErrorFault
                     * @property {clutch.chaos.redisexperimentation.v1.IFaultPercentage|null} [percentage] ErrorFault percentage
                     */

                    /**
                     * Constructs a new ErrorFault.
                     * @memberof clutch.chaos.redisexperimentation.v1
                     * @classdesc Represents an ErrorFault.
                     * @implements IErrorFault
                     * @constructor
                     * @param {clutch.chaos.redisexperimentation.v1.IErrorFault=} [properties] Properties to set
                     */
                    function ErrorFault(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ErrorFault percentage.
                     * @member {clutch.chaos.redisexperimentation.v1.IFaultPercentage|null|undefined} percentage
                     * @memberof clutch.chaos.redisexperimentation.v1.ErrorFault
                     * @instance
                     */
                    ErrorFault.prototype.percentage = null;

                    /**
                     * Verifies an ErrorFault message.
                     * @function verify
                     * @memberof clutch.chaos.redisexperimentation.v1.ErrorFault
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ErrorFault.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.percentage != null && message.hasOwnProperty("percentage")) {
                            let error = $root.clutch.chaos.redisexperimentation.v1.FaultPercentage.verify(message.percentage);
                            if (error)
                                return "percentage." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an ErrorFault message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.redisexperimentation.v1.ErrorFault
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.redisexperimentation.v1.ErrorFault} ErrorFault
                     */
                    ErrorFault.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.redisexperimentation.v1.ErrorFault)
                            return object;
                        let message = new $root.clutch.chaos.redisexperimentation.v1.ErrorFault();
                        if (object.percentage != null) {
                            if (typeof object.percentage !== "object")
                                throw TypeError(".clutch.chaos.redisexperimentation.v1.ErrorFault.percentage: object expected");
                            message.percentage = $root.clutch.chaos.redisexperimentation.v1.FaultPercentage.fromObject(object.percentage);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an ErrorFault message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.redisexperimentation.v1.ErrorFault
                     * @static
                     * @param {clutch.chaos.redisexperimentation.v1.ErrorFault} message ErrorFault
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ErrorFault.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.percentage = null;
                        if (message.percentage != null && message.hasOwnProperty("percentage"))
                            object.percentage = $root.clutch.chaos.redisexperimentation.v1.FaultPercentage.toObject(message.percentage, options);
                        return object;
                    };

                    /**
                     * Converts this ErrorFault to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.redisexperimentation.v1.ErrorFault
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ErrorFault.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ErrorFault;
                })();

                v1.LatencyFault = (function() {

                    /**
                     * Properties of a LatencyFault.
                     * @memberof clutch.chaos.redisexperimentation.v1
                     * @interface ILatencyFault
                     * @property {clutch.chaos.redisexperimentation.v1.IFaultPercentage|null} [percentage] LatencyFault percentage
                     */

                    /**
                     * Constructs a new LatencyFault.
                     * @memberof clutch.chaos.redisexperimentation.v1
                     * @classdesc Represents a LatencyFault.
                     * @implements ILatencyFault
                     * @constructor
                     * @param {clutch.chaos.redisexperimentation.v1.ILatencyFault=} [properties] Properties to set
                     */
                    function LatencyFault(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * LatencyFault percentage.
                     * @member {clutch.chaos.redisexperimentation.v1.IFaultPercentage|null|undefined} percentage
                     * @memberof clutch.chaos.redisexperimentation.v1.LatencyFault
                     * @instance
                     */
                    LatencyFault.prototype.percentage = null;

                    /**
                     * Verifies a LatencyFault message.
                     * @function verify
                     * @memberof clutch.chaos.redisexperimentation.v1.LatencyFault
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    LatencyFault.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.percentage != null && message.hasOwnProperty("percentage")) {
                            let error = $root.clutch.chaos.redisexperimentation.v1.FaultPercentage.verify(message.percentage);
                            if (error)
                                return "percentage." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a LatencyFault message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.redisexperimentation.v1.LatencyFault
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.redisexperimentation.v1.LatencyFault} LatencyFault
                     */
                    LatencyFault.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.redisexperimentation.v1.LatencyFault)
                            return object;
                        let message = new $root.clutch.chaos.redisexperimentation.v1.LatencyFault();
                        if (object.percentage != null) {
                            if (typeof object.percentage !== "object")
                                throw TypeError(".clutch.chaos.redisexperimentation.v1.LatencyFault.percentage: object expected");
                            message.percentage = $root.clutch.chaos.redisexperimentation.v1.FaultPercentage.fromObject(object.percentage);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a LatencyFault message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.redisexperimentation.v1.LatencyFault
                     * @static
                     * @param {clutch.chaos.redisexperimentation.v1.LatencyFault} message LatencyFault
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    LatencyFault.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.percentage = null;
                        if (message.percentage != null && message.hasOwnProperty("percentage"))
                            object.percentage = $root.clutch.chaos.redisexperimentation.v1.FaultPercentage.toObject(message.percentage, options);
                        return object;
                    };

                    /**
                     * Converts this LatencyFault to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.redisexperimentation.v1.LatencyFault
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    LatencyFault.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return LatencyFault;
                })();

                v1.FaultTargeting = (function() {

                    /**
                     * Properties of a FaultTargeting.
                     * @memberof clutch.chaos.redisexperimentation.v1
                     * @interface IFaultTargeting
                     * @property {clutch.chaos.redisexperimentation.v1.ISingleCluster|null} [upstreamCluster] FaultTargeting upstreamCluster
                     * @property {clutch.chaos.redisexperimentation.v1.ISingleCluster|null} [downstreamCluster] FaultTargeting downstreamCluster
                     */

                    /**
                     * Constructs a new FaultTargeting.
                     * @memberof clutch.chaos.redisexperimentation.v1
                     * @classdesc Represents a FaultTargeting.
                     * @implements IFaultTargeting
                     * @constructor
                     * @param {clutch.chaos.redisexperimentation.v1.IFaultTargeting=} [properties] Properties to set
                     */
                    function FaultTargeting(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * FaultTargeting upstreamCluster.
                     * @member {clutch.chaos.redisexperimentation.v1.ISingleCluster|null|undefined} upstreamCluster
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultTargeting
                     * @instance
                     */
                    FaultTargeting.prototype.upstreamCluster = null;

                    /**
                     * FaultTargeting downstreamCluster.
                     * @member {clutch.chaos.redisexperimentation.v1.ISingleCluster|null|undefined} downstreamCluster
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultTargeting
                     * @instance
                     */
                    FaultTargeting.prototype.downstreamCluster = null;

                    /**
                     * Verifies a FaultTargeting message.
                     * @function verify
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultTargeting
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    FaultTargeting.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.upstreamCluster != null && message.hasOwnProperty("upstreamCluster")) {
                            let error = $root.clutch.chaos.redisexperimentation.v1.SingleCluster.verify(message.upstreamCluster);
                            if (error)
                                return "upstreamCluster." + error;
                        }
                        if (message.downstreamCluster != null && message.hasOwnProperty("downstreamCluster")) {
                            let error = $root.clutch.chaos.redisexperimentation.v1.SingleCluster.verify(message.downstreamCluster);
                            if (error)
                                return "downstreamCluster." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a FaultTargeting message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultTargeting
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.redisexperimentation.v1.FaultTargeting} FaultTargeting
                     */
                    FaultTargeting.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.redisexperimentation.v1.FaultTargeting)
                            return object;
                        let message = new $root.clutch.chaos.redisexperimentation.v1.FaultTargeting();
                        if (object.upstreamCluster != null) {
                            if (typeof object.upstreamCluster !== "object")
                                throw TypeError(".clutch.chaos.redisexperimentation.v1.FaultTargeting.upstreamCluster: object expected");
                            message.upstreamCluster = $root.clutch.chaos.redisexperimentation.v1.SingleCluster.fromObject(object.upstreamCluster);
                        }
                        if (object.downstreamCluster != null) {
                            if (typeof object.downstreamCluster !== "object")
                                throw TypeError(".clutch.chaos.redisexperimentation.v1.FaultTargeting.downstreamCluster: object expected");
                            message.downstreamCluster = $root.clutch.chaos.redisexperimentation.v1.SingleCluster.fromObject(object.downstreamCluster);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a FaultTargeting message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultTargeting
                     * @static
                     * @param {clutch.chaos.redisexperimentation.v1.FaultTargeting} message FaultTargeting
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FaultTargeting.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.upstreamCluster = null;
                            object.downstreamCluster = null;
                        }
                        if (message.upstreamCluster != null && message.hasOwnProperty("upstreamCluster"))
                            object.upstreamCluster = $root.clutch.chaos.redisexperimentation.v1.SingleCluster.toObject(message.upstreamCluster, options);
                        if (message.downstreamCluster != null && message.hasOwnProperty("downstreamCluster"))
                            object.downstreamCluster = $root.clutch.chaos.redisexperimentation.v1.SingleCluster.toObject(message.downstreamCluster, options);
                        return object;
                    };

                    /**
                     * Converts this FaultTargeting to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultTargeting
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    FaultTargeting.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return FaultTargeting;
                })();

                v1.SingleCluster = (function() {

                    /**
                     * Properties of a SingleCluster.
                     * @memberof clutch.chaos.redisexperimentation.v1
                     * @interface ISingleCluster
                     * @property {string|null} [name] SingleCluster name
                     */

                    /**
                     * Constructs a new SingleCluster.
                     * @memberof clutch.chaos.redisexperimentation.v1
                     * @classdesc Represents a SingleCluster.
                     * @implements ISingleCluster
                     * @constructor
                     * @param {clutch.chaos.redisexperimentation.v1.ISingleCluster=} [properties] Properties to set
                     */
                    function SingleCluster(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SingleCluster name.
                     * @member {string} name
                     * @memberof clutch.chaos.redisexperimentation.v1.SingleCluster
                     * @instance
                     */
                    SingleCluster.prototype.name = "";

                    /**
                     * Verifies a SingleCluster message.
                     * @function verify
                     * @memberof clutch.chaos.redisexperimentation.v1.SingleCluster
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SingleCluster.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        return null;
                    };

                    /**
                     * Creates a SingleCluster message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.redisexperimentation.v1.SingleCluster
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.redisexperimentation.v1.SingleCluster} SingleCluster
                     */
                    SingleCluster.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.redisexperimentation.v1.SingleCluster)
                            return object;
                        let message = new $root.clutch.chaos.redisexperimentation.v1.SingleCluster();
                        if (object.name != null)
                            message.name = String(object.name);
                        return message;
                    };

                    /**
                     * Creates a plain object from a SingleCluster message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.redisexperimentation.v1.SingleCluster
                     * @static
                     * @param {clutch.chaos.redisexperimentation.v1.SingleCluster} message SingleCluster
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SingleCluster.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.name = "";
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        return object;
                    };

                    /**
                     * Converts this SingleCluster to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.redisexperimentation.v1.SingleCluster
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SingleCluster.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return SingleCluster;
                })();

                v1.FaultPercentage = (function() {

                    /**
                     * Properties of a FaultPercentage.
                     * @memberof clutch.chaos.redisexperimentation.v1
                     * @interface IFaultPercentage
                     * @property {number|null} [percentage] FaultPercentage percentage
                     */

                    /**
                     * Constructs a new FaultPercentage.
                     * @memberof clutch.chaos.redisexperimentation.v1
                     * @classdesc Represents a FaultPercentage.
                     * @implements IFaultPercentage
                     * @constructor
                     * @param {clutch.chaos.redisexperimentation.v1.IFaultPercentage=} [properties] Properties to set
                     */
                    function FaultPercentage(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * FaultPercentage percentage.
                     * @member {number} percentage
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultPercentage
                     * @instance
                     */
                    FaultPercentage.prototype.percentage = 0;

                    /**
                     * Verifies a FaultPercentage message.
                     * @function verify
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultPercentage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    FaultPercentage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.percentage != null && message.hasOwnProperty("percentage"))
                            if (!$util.isInteger(message.percentage))
                                return "percentage: integer expected";
                        return null;
                    };

                    /**
                     * Creates a FaultPercentage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultPercentage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.redisexperimentation.v1.FaultPercentage} FaultPercentage
                     */
                    FaultPercentage.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.redisexperimentation.v1.FaultPercentage)
                            return object;
                        let message = new $root.clutch.chaos.redisexperimentation.v1.FaultPercentage();
                        if (object.percentage != null)
                            message.percentage = object.percentage >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a FaultPercentage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultPercentage
                     * @static
                     * @param {clutch.chaos.redisexperimentation.v1.FaultPercentage} message FaultPercentage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FaultPercentage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.percentage = 0;
                        if (message.percentage != null && message.hasOwnProperty("percentage"))
                            object.percentage = message.percentage;
                        return object;
                    };

                    /**
                     * Converts this FaultPercentage to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.redisexperimentation.v1.FaultPercentage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    FaultPercentage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return FaultPercentage;
                })();

                return v1;
            })();

            return redisexperimentation;
        })();

        chaos.serverexperimentation = (function() {

            /**
             * Namespace serverexperimentation.
             * @memberof clutch.chaos
             * @namespace
             */
            const serverexperimentation = {};

            serverexperimentation.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.chaos.serverexperimentation
                 * @namespace
                 */
                const v1 = {};

                v1.HTTPFaultConfig = (function() {

                    /**
                     * Properties of a HTTPFaultConfig.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface IHTTPFaultConfig
                     * @property {clutch.chaos.serverexperimentation.v1.IFaultTargeting|null} [faultTargeting] HTTPFaultConfig faultTargeting
                     * @property {clutch.chaos.serverexperimentation.v1.IAbortFault|null} [abortFault] HTTPFaultConfig abortFault
                     * @property {clutch.chaos.serverexperimentation.v1.ILatencyFault|null} [latencyFault] HTTPFaultConfig latencyFault
                     */

                    /**
                     * Constructs a new HTTPFaultConfig.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents a HTTPFaultConfig.
                     * @implements IHTTPFaultConfig
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.IHTTPFaultConfig=} [properties] Properties to set
                     */
                    function HTTPFaultConfig(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * HTTPFaultConfig faultTargeting.
                     * @member {clutch.chaos.serverexperimentation.v1.IFaultTargeting|null|undefined} faultTargeting
                     * @memberof clutch.chaos.serverexperimentation.v1.HTTPFaultConfig
                     * @instance
                     */
                    HTTPFaultConfig.prototype.faultTargeting = null;

                    /**
                     * HTTPFaultConfig abortFault.
                     * @member {clutch.chaos.serverexperimentation.v1.IAbortFault|null|undefined} abortFault
                     * @memberof clutch.chaos.serverexperimentation.v1.HTTPFaultConfig
                     * @instance
                     */
                    HTTPFaultConfig.prototype.abortFault = null;

                    /**
                     * HTTPFaultConfig latencyFault.
                     * @member {clutch.chaos.serverexperimentation.v1.ILatencyFault|null|undefined} latencyFault
                     * @memberof clutch.chaos.serverexperimentation.v1.HTTPFaultConfig
                     * @instance
                     */
                    HTTPFaultConfig.prototype.latencyFault = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * HTTPFaultConfig fault.
                     * @member {"abortFault"|"latencyFault"|undefined} fault
                     * @memberof clutch.chaos.serverexperimentation.v1.HTTPFaultConfig
                     * @instance
                     */
                    Object.defineProperty(HTTPFaultConfig.prototype, "fault", {
                        get: $util.oneOfGetter($oneOfFields = ["abortFault", "latencyFault"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies a HTTPFaultConfig message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.HTTPFaultConfig
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    HTTPFaultConfig.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.faultTargeting != null && message.hasOwnProperty("faultTargeting")) {
                            let error = $root.clutch.chaos.serverexperimentation.v1.FaultTargeting.verify(message.faultTargeting);
                            if (error)
                                return "faultTargeting." + error;
                        }
                        if (message.abortFault != null && message.hasOwnProperty("abortFault")) {
                            properties.fault = 1;
                            {
                                let error = $root.clutch.chaos.serverexperimentation.v1.AbortFault.verify(message.abortFault);
                                if (error)
                                    return "abortFault." + error;
                            }
                        }
                        if (message.latencyFault != null && message.hasOwnProperty("latencyFault")) {
                            if (properties.fault === 1)
                                return "fault: multiple values";
                            properties.fault = 1;
                            {
                                let error = $root.clutch.chaos.serverexperimentation.v1.LatencyFault.verify(message.latencyFault);
                                if (error)
                                    return "latencyFault." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a HTTPFaultConfig message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.HTTPFaultConfig
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.HTTPFaultConfig} HTTPFaultConfig
                     */
                    HTTPFaultConfig.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.HTTPFaultConfig)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.HTTPFaultConfig();
                        if (object.faultTargeting != null) {
                            if (typeof object.faultTargeting !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.HTTPFaultConfig.faultTargeting: object expected");
                            message.faultTargeting = $root.clutch.chaos.serverexperimentation.v1.FaultTargeting.fromObject(object.faultTargeting);
                        }
                        if (object.abortFault != null) {
                            if (typeof object.abortFault !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.HTTPFaultConfig.abortFault: object expected");
                            message.abortFault = $root.clutch.chaos.serverexperimentation.v1.AbortFault.fromObject(object.abortFault);
                        }
                        if (object.latencyFault != null) {
                            if (typeof object.latencyFault !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.HTTPFaultConfig.latencyFault: object expected");
                            message.latencyFault = $root.clutch.chaos.serverexperimentation.v1.LatencyFault.fromObject(object.latencyFault);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a HTTPFaultConfig message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.HTTPFaultConfig
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.HTTPFaultConfig} message HTTPFaultConfig
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    HTTPFaultConfig.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.faultTargeting = null;
                        if (message.faultTargeting != null && message.hasOwnProperty("faultTargeting"))
                            object.faultTargeting = $root.clutch.chaos.serverexperimentation.v1.FaultTargeting.toObject(message.faultTargeting, options);
                        if (message.abortFault != null && message.hasOwnProperty("abortFault")) {
                            object.abortFault = $root.clutch.chaos.serverexperimentation.v1.AbortFault.toObject(message.abortFault, options);
                            if (options.oneofs)
                                object.fault = "abortFault";
                        }
                        if (message.latencyFault != null && message.hasOwnProperty("latencyFault")) {
                            object.latencyFault = $root.clutch.chaos.serverexperimentation.v1.LatencyFault.toObject(message.latencyFault, options);
                            if (options.oneofs)
                                object.fault = "latencyFault";
                        }
                        return object;
                    };

                    /**
                     * Converts this HTTPFaultConfig to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.HTTPFaultConfig
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    HTTPFaultConfig.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return HTTPFaultConfig;
                })();

                v1.AbortFault = (function() {

                    /**
                     * Properties of an AbortFault.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface IAbortFault
                     * @property {clutch.chaos.serverexperimentation.v1.IFaultPercentage|null} [percentage] AbortFault percentage
                     * @property {clutch.chaos.serverexperimentation.v1.IFaultAbortStatus|null} [abortStatus] AbortFault abortStatus
                     */

                    /**
                     * Constructs a new AbortFault.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents an AbortFault.
                     * @implements IAbortFault
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.IAbortFault=} [properties] Properties to set
                     */
                    function AbortFault(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * AbortFault percentage.
                     * @member {clutch.chaos.serverexperimentation.v1.IFaultPercentage|null|undefined} percentage
                     * @memberof clutch.chaos.serverexperimentation.v1.AbortFault
                     * @instance
                     */
                    AbortFault.prototype.percentage = null;

                    /**
                     * AbortFault abortStatus.
                     * @member {clutch.chaos.serverexperimentation.v1.IFaultAbortStatus|null|undefined} abortStatus
                     * @memberof clutch.chaos.serverexperimentation.v1.AbortFault
                     * @instance
                     */
                    AbortFault.prototype.abortStatus = null;

                    /**
                     * Verifies an AbortFault message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.AbortFault
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AbortFault.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.percentage != null && message.hasOwnProperty("percentage")) {
                            let error = $root.clutch.chaos.serverexperimentation.v1.FaultPercentage.verify(message.percentage);
                            if (error)
                                return "percentage." + error;
                        }
                        if (message.abortStatus != null && message.hasOwnProperty("abortStatus")) {
                            let error = $root.clutch.chaos.serverexperimentation.v1.FaultAbortStatus.verify(message.abortStatus);
                            if (error)
                                return "abortStatus." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an AbortFault message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.AbortFault
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.AbortFault} AbortFault
                     */
                    AbortFault.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.AbortFault)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.AbortFault();
                        if (object.percentage != null) {
                            if (typeof object.percentage !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.AbortFault.percentage: object expected");
                            message.percentage = $root.clutch.chaos.serverexperimentation.v1.FaultPercentage.fromObject(object.percentage);
                        }
                        if (object.abortStatus != null) {
                            if (typeof object.abortStatus !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.AbortFault.abortStatus: object expected");
                            message.abortStatus = $root.clutch.chaos.serverexperimentation.v1.FaultAbortStatus.fromObject(object.abortStatus);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an AbortFault message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.AbortFault
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.AbortFault} message AbortFault
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AbortFault.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.percentage = null;
                            object.abortStatus = null;
                        }
                        if (message.percentage != null && message.hasOwnProperty("percentage"))
                            object.percentage = $root.clutch.chaos.serverexperimentation.v1.FaultPercentage.toObject(message.percentage, options);
                        if (message.abortStatus != null && message.hasOwnProperty("abortStatus"))
                            object.abortStatus = $root.clutch.chaos.serverexperimentation.v1.FaultAbortStatus.toObject(message.abortStatus, options);
                        return object;
                    };

                    /**
                     * Converts this AbortFault to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.AbortFault
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AbortFault.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return AbortFault;
                })();

                v1.LatencyFault = (function() {

                    /**
                     * Properties of a LatencyFault.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface ILatencyFault
                     * @property {clutch.chaos.serverexperimentation.v1.IFaultPercentage|null} [percentage] LatencyFault percentage
                     * @property {clutch.chaos.serverexperimentation.v1.IFaultLatencyDuration|null} [latencyDuration] LatencyFault latencyDuration
                     */

                    /**
                     * Constructs a new LatencyFault.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents a LatencyFault.
                     * @implements ILatencyFault
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.ILatencyFault=} [properties] Properties to set
                     */
                    function LatencyFault(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * LatencyFault percentage.
                     * @member {clutch.chaos.serverexperimentation.v1.IFaultPercentage|null|undefined} percentage
                     * @memberof clutch.chaos.serverexperimentation.v1.LatencyFault
                     * @instance
                     */
                    LatencyFault.prototype.percentage = null;

                    /**
                     * LatencyFault latencyDuration.
                     * @member {clutch.chaos.serverexperimentation.v1.IFaultLatencyDuration|null|undefined} latencyDuration
                     * @memberof clutch.chaos.serverexperimentation.v1.LatencyFault
                     * @instance
                     */
                    LatencyFault.prototype.latencyDuration = null;

                    /**
                     * Verifies a LatencyFault message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.LatencyFault
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    LatencyFault.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.percentage != null && message.hasOwnProperty("percentage")) {
                            let error = $root.clutch.chaos.serverexperimentation.v1.FaultPercentage.verify(message.percentage);
                            if (error)
                                return "percentage." + error;
                        }
                        if (message.latencyDuration != null && message.hasOwnProperty("latencyDuration")) {
                            let error = $root.clutch.chaos.serverexperimentation.v1.FaultLatencyDuration.verify(message.latencyDuration);
                            if (error)
                                return "latencyDuration." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a LatencyFault message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.LatencyFault
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.LatencyFault} LatencyFault
                     */
                    LatencyFault.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.LatencyFault)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.LatencyFault();
                        if (object.percentage != null) {
                            if (typeof object.percentage !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.LatencyFault.percentage: object expected");
                            message.percentage = $root.clutch.chaos.serverexperimentation.v1.FaultPercentage.fromObject(object.percentage);
                        }
                        if (object.latencyDuration != null) {
                            if (typeof object.latencyDuration !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.LatencyFault.latencyDuration: object expected");
                            message.latencyDuration = $root.clutch.chaos.serverexperimentation.v1.FaultLatencyDuration.fromObject(object.latencyDuration);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a LatencyFault message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.LatencyFault
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.LatencyFault} message LatencyFault
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    LatencyFault.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.percentage = null;
                            object.latencyDuration = null;
                        }
                        if (message.percentage != null && message.hasOwnProperty("percentage"))
                            object.percentage = $root.clutch.chaos.serverexperimentation.v1.FaultPercentage.toObject(message.percentage, options);
                        if (message.latencyDuration != null && message.hasOwnProperty("latencyDuration"))
                            object.latencyDuration = $root.clutch.chaos.serverexperimentation.v1.FaultLatencyDuration.toObject(message.latencyDuration, options);
                        return object;
                    };

                    /**
                     * Converts this LatencyFault to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.LatencyFault
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    LatencyFault.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return LatencyFault;
                })();

                v1.FaultTargeting = (function() {

                    /**
                     * Properties of a FaultTargeting.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface IFaultTargeting
                     * @property {clutch.chaos.serverexperimentation.v1.IUpstreamEnforcing|null} [upstreamEnforcing] FaultTargeting upstreamEnforcing
                     * @property {clutch.chaos.serverexperimentation.v1.IDownstreamEnforcing|null} [downstreamEnforcing] FaultTargeting downstreamEnforcing
                     */

                    /**
                     * Constructs a new FaultTargeting.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents a FaultTargeting.
                     * @implements IFaultTargeting
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.IFaultTargeting=} [properties] Properties to set
                     */
                    function FaultTargeting(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * FaultTargeting upstreamEnforcing.
                     * @member {clutch.chaos.serverexperimentation.v1.IUpstreamEnforcing|null|undefined} upstreamEnforcing
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultTargeting
                     * @instance
                     */
                    FaultTargeting.prototype.upstreamEnforcing = null;

                    /**
                     * FaultTargeting downstreamEnforcing.
                     * @member {clutch.chaos.serverexperimentation.v1.IDownstreamEnforcing|null|undefined} downstreamEnforcing
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultTargeting
                     * @instance
                     */
                    FaultTargeting.prototype.downstreamEnforcing = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * FaultTargeting enforcer.
                     * @member {"upstreamEnforcing"|"downstreamEnforcing"|undefined} enforcer
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultTargeting
                     * @instance
                     */
                    Object.defineProperty(FaultTargeting.prototype, "enforcer", {
                        get: $util.oneOfGetter($oneOfFields = ["upstreamEnforcing", "downstreamEnforcing"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies a FaultTargeting message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultTargeting
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    FaultTargeting.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.upstreamEnforcing != null && message.hasOwnProperty("upstreamEnforcing")) {
                            properties.enforcer = 1;
                            {
                                let error = $root.clutch.chaos.serverexperimentation.v1.UpstreamEnforcing.verify(message.upstreamEnforcing);
                                if (error)
                                    return "upstreamEnforcing." + error;
                            }
                        }
                        if (message.downstreamEnforcing != null && message.hasOwnProperty("downstreamEnforcing")) {
                            if (properties.enforcer === 1)
                                return "enforcer: multiple values";
                            properties.enforcer = 1;
                            {
                                let error = $root.clutch.chaos.serverexperimentation.v1.DownstreamEnforcing.verify(message.downstreamEnforcing);
                                if (error)
                                    return "downstreamEnforcing." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a FaultTargeting message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultTargeting
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.FaultTargeting} FaultTargeting
                     */
                    FaultTargeting.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.FaultTargeting)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.FaultTargeting();
                        if (object.upstreamEnforcing != null) {
                            if (typeof object.upstreamEnforcing !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.FaultTargeting.upstreamEnforcing: object expected");
                            message.upstreamEnforcing = $root.clutch.chaos.serverexperimentation.v1.UpstreamEnforcing.fromObject(object.upstreamEnforcing);
                        }
                        if (object.downstreamEnforcing != null) {
                            if (typeof object.downstreamEnforcing !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.FaultTargeting.downstreamEnforcing: object expected");
                            message.downstreamEnforcing = $root.clutch.chaos.serverexperimentation.v1.DownstreamEnforcing.fromObject(object.downstreamEnforcing);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a FaultTargeting message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultTargeting
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.FaultTargeting} message FaultTargeting
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FaultTargeting.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (message.upstreamEnforcing != null && message.hasOwnProperty("upstreamEnforcing")) {
                            object.upstreamEnforcing = $root.clutch.chaos.serverexperimentation.v1.UpstreamEnforcing.toObject(message.upstreamEnforcing, options);
                            if (options.oneofs)
                                object.enforcer = "upstreamEnforcing";
                        }
                        if (message.downstreamEnforcing != null && message.hasOwnProperty("downstreamEnforcing")) {
                            object.downstreamEnforcing = $root.clutch.chaos.serverexperimentation.v1.DownstreamEnforcing.toObject(message.downstreamEnforcing, options);
                            if (options.oneofs)
                                object.enforcer = "downstreamEnforcing";
                        }
                        return object;
                    };

                    /**
                     * Converts this FaultTargeting to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultTargeting
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    FaultTargeting.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return FaultTargeting;
                })();

                v1.UpstreamEnforcing = (function() {

                    /**
                     * Properties of an UpstreamEnforcing.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface IUpstreamEnforcing
                     * @property {clutch.chaos.serverexperimentation.v1.ISingleCluster|null} [upstreamCluster] UpstreamEnforcing upstreamCluster
                     * @property {clutch.chaos.serverexperimentation.v1.ISingleCluster|null} [downstreamCluster] UpstreamEnforcing downstreamCluster
                     */

                    /**
                     * Constructs a new UpstreamEnforcing.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents an UpstreamEnforcing.
                     * @implements IUpstreamEnforcing
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.IUpstreamEnforcing=} [properties] Properties to set
                     */
                    function UpstreamEnforcing(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UpstreamEnforcing upstreamCluster.
                     * @member {clutch.chaos.serverexperimentation.v1.ISingleCluster|null|undefined} upstreamCluster
                     * @memberof clutch.chaos.serverexperimentation.v1.UpstreamEnforcing
                     * @instance
                     */
                    UpstreamEnforcing.prototype.upstreamCluster = null;

                    /**
                     * UpstreamEnforcing downstreamCluster.
                     * @member {clutch.chaos.serverexperimentation.v1.ISingleCluster|null|undefined} downstreamCluster
                     * @memberof clutch.chaos.serverexperimentation.v1.UpstreamEnforcing
                     * @instance
                     */
                    UpstreamEnforcing.prototype.downstreamCluster = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * UpstreamEnforcing upstreamType.
                     * @member {"upstreamCluster"|undefined} upstreamType
                     * @memberof clutch.chaos.serverexperimentation.v1.UpstreamEnforcing
                     * @instance
                     */
                    Object.defineProperty(UpstreamEnforcing.prototype, "upstreamType", {
                        get: $util.oneOfGetter($oneOfFields = ["upstreamCluster"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * UpstreamEnforcing downstreamType.
                     * @member {"downstreamCluster"|undefined} downstreamType
                     * @memberof clutch.chaos.serverexperimentation.v1.UpstreamEnforcing
                     * @instance
                     */
                    Object.defineProperty(UpstreamEnforcing.prototype, "downstreamType", {
                        get: $util.oneOfGetter($oneOfFields = ["downstreamCluster"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies an UpstreamEnforcing message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.UpstreamEnforcing
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UpstreamEnforcing.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.upstreamCluster != null && message.hasOwnProperty("upstreamCluster")) {
                            properties.upstreamType = 1;
                            {
                                let error = $root.clutch.chaos.serverexperimentation.v1.SingleCluster.verify(message.upstreamCluster);
                                if (error)
                                    return "upstreamCluster." + error;
                            }
                        }
                        if (message.downstreamCluster != null && message.hasOwnProperty("downstreamCluster")) {
                            properties.downstreamType = 1;
                            {
                                let error = $root.clutch.chaos.serverexperimentation.v1.SingleCluster.verify(message.downstreamCluster);
                                if (error)
                                    return "downstreamCluster." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates an UpstreamEnforcing message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.UpstreamEnforcing
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.UpstreamEnforcing} UpstreamEnforcing
                     */
                    UpstreamEnforcing.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.UpstreamEnforcing)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.UpstreamEnforcing();
                        if (object.upstreamCluster != null) {
                            if (typeof object.upstreamCluster !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.UpstreamEnforcing.upstreamCluster: object expected");
                            message.upstreamCluster = $root.clutch.chaos.serverexperimentation.v1.SingleCluster.fromObject(object.upstreamCluster);
                        }
                        if (object.downstreamCluster != null) {
                            if (typeof object.downstreamCluster !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.UpstreamEnforcing.downstreamCluster: object expected");
                            message.downstreamCluster = $root.clutch.chaos.serverexperimentation.v1.SingleCluster.fromObject(object.downstreamCluster);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an UpstreamEnforcing message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.UpstreamEnforcing
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.UpstreamEnforcing} message UpstreamEnforcing
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UpstreamEnforcing.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (message.upstreamCluster != null && message.hasOwnProperty("upstreamCluster")) {
                            object.upstreamCluster = $root.clutch.chaos.serverexperimentation.v1.SingleCluster.toObject(message.upstreamCluster, options);
                            if (options.oneofs)
                                object.upstreamType = "upstreamCluster";
                        }
                        if (message.downstreamCluster != null && message.hasOwnProperty("downstreamCluster")) {
                            object.downstreamCluster = $root.clutch.chaos.serverexperimentation.v1.SingleCluster.toObject(message.downstreamCluster, options);
                            if (options.oneofs)
                                object.downstreamType = "downstreamCluster";
                        }
                        return object;
                    };

                    /**
                     * Converts this UpstreamEnforcing to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.UpstreamEnforcing
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UpstreamEnforcing.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UpstreamEnforcing;
                })();

                v1.DownstreamEnforcing = (function() {

                    /**
                     * Properties of a DownstreamEnforcing.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface IDownstreamEnforcing
                     * @property {clutch.chaos.serverexperimentation.v1.ISingleCluster|null} [upstreamCluster] DownstreamEnforcing upstreamCluster
                     * @property {clutch.chaos.serverexperimentation.v1.ISingleCluster|null} [downstreamCluster] DownstreamEnforcing downstreamCluster
                     */

                    /**
                     * Constructs a new DownstreamEnforcing.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents a DownstreamEnforcing.
                     * @implements IDownstreamEnforcing
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.IDownstreamEnforcing=} [properties] Properties to set
                     */
                    function DownstreamEnforcing(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * DownstreamEnforcing upstreamCluster.
                     * @member {clutch.chaos.serverexperimentation.v1.ISingleCluster|null|undefined} upstreamCluster
                     * @memberof clutch.chaos.serverexperimentation.v1.DownstreamEnforcing
                     * @instance
                     */
                    DownstreamEnforcing.prototype.upstreamCluster = null;

                    /**
                     * DownstreamEnforcing downstreamCluster.
                     * @member {clutch.chaos.serverexperimentation.v1.ISingleCluster|null|undefined} downstreamCluster
                     * @memberof clutch.chaos.serverexperimentation.v1.DownstreamEnforcing
                     * @instance
                     */
                    DownstreamEnforcing.prototype.downstreamCluster = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * DownstreamEnforcing upstreamType.
                     * @member {"upstreamCluster"|undefined} upstreamType
                     * @memberof clutch.chaos.serverexperimentation.v1.DownstreamEnforcing
                     * @instance
                     */
                    Object.defineProperty(DownstreamEnforcing.prototype, "upstreamType", {
                        get: $util.oneOfGetter($oneOfFields = ["upstreamCluster"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * DownstreamEnforcing downstreamType.
                     * @member {"downstreamCluster"|undefined} downstreamType
                     * @memberof clutch.chaos.serverexperimentation.v1.DownstreamEnforcing
                     * @instance
                     */
                    Object.defineProperty(DownstreamEnforcing.prototype, "downstreamType", {
                        get: $util.oneOfGetter($oneOfFields = ["downstreamCluster"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies a DownstreamEnforcing message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.DownstreamEnforcing
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DownstreamEnforcing.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.upstreamCluster != null && message.hasOwnProperty("upstreamCluster")) {
                            properties.upstreamType = 1;
                            {
                                let error = $root.clutch.chaos.serverexperimentation.v1.SingleCluster.verify(message.upstreamCluster);
                                if (error)
                                    return "upstreamCluster." + error;
                            }
                        }
                        if (message.downstreamCluster != null && message.hasOwnProperty("downstreamCluster")) {
                            properties.downstreamType = 1;
                            {
                                let error = $root.clutch.chaos.serverexperimentation.v1.SingleCluster.verify(message.downstreamCluster);
                                if (error)
                                    return "downstreamCluster." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a DownstreamEnforcing message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.DownstreamEnforcing
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.DownstreamEnforcing} DownstreamEnforcing
                     */
                    DownstreamEnforcing.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.DownstreamEnforcing)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.DownstreamEnforcing();
                        if (object.upstreamCluster != null) {
                            if (typeof object.upstreamCluster !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.DownstreamEnforcing.upstreamCluster: object expected");
                            message.upstreamCluster = $root.clutch.chaos.serverexperimentation.v1.SingleCluster.fromObject(object.upstreamCluster);
                        }
                        if (object.downstreamCluster != null) {
                            if (typeof object.downstreamCluster !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.DownstreamEnforcing.downstreamCluster: object expected");
                            message.downstreamCluster = $root.clutch.chaos.serverexperimentation.v1.SingleCluster.fromObject(object.downstreamCluster);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a DownstreamEnforcing message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.DownstreamEnforcing
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.DownstreamEnforcing} message DownstreamEnforcing
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DownstreamEnforcing.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (message.upstreamCluster != null && message.hasOwnProperty("upstreamCluster")) {
                            object.upstreamCluster = $root.clutch.chaos.serverexperimentation.v1.SingleCluster.toObject(message.upstreamCluster, options);
                            if (options.oneofs)
                                object.upstreamType = "upstreamCluster";
                        }
                        if (message.downstreamCluster != null && message.hasOwnProperty("downstreamCluster")) {
                            object.downstreamCluster = $root.clutch.chaos.serverexperimentation.v1.SingleCluster.toObject(message.downstreamCluster, options);
                            if (options.oneofs)
                                object.downstreamType = "downstreamCluster";
                        }
                        return object;
                    };

                    /**
                     * Converts this DownstreamEnforcing to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.DownstreamEnforcing
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DownstreamEnforcing.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return DownstreamEnforcing;
                })();

                v1.SingleCluster = (function() {

                    /**
                     * Properties of a SingleCluster.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface ISingleCluster
                     * @property {string|null} [name] SingleCluster name
                     */

                    /**
                     * Constructs a new SingleCluster.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents a SingleCluster.
                     * @implements ISingleCluster
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.ISingleCluster=} [properties] Properties to set
                     */
                    function SingleCluster(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * SingleCluster name.
                     * @member {string} name
                     * @memberof clutch.chaos.serverexperimentation.v1.SingleCluster
                     * @instance
                     */
                    SingleCluster.prototype.name = "";

                    /**
                     * Verifies a SingleCluster message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.SingleCluster
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    SingleCluster.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        return null;
                    };

                    /**
                     * Creates a SingleCluster message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.SingleCluster
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.SingleCluster} SingleCluster
                     */
                    SingleCluster.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.SingleCluster)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.SingleCluster();
                        if (object.name != null)
                            message.name = String(object.name);
                        return message;
                    };

                    /**
                     * Creates a plain object from a SingleCluster message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.SingleCluster
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.SingleCluster} message SingleCluster
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    SingleCluster.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.name = "";
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        return object;
                    };

                    /**
                     * Converts this SingleCluster to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.SingleCluster
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    SingleCluster.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return SingleCluster;
                })();

                v1.ClusterPercentage = (function() {

                    /**
                     * Properties of a ClusterPercentage.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface IClusterPercentage
                     * @property {number|null} [percentage] ClusterPercentage percentage
                     */

                    /**
                     * Constructs a new ClusterPercentage.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents a ClusterPercentage.
                     * @implements IClusterPercentage
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.IClusterPercentage=} [properties] Properties to set
                     */
                    function ClusterPercentage(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ClusterPercentage percentage.
                     * @member {number} percentage
                     * @memberof clutch.chaos.serverexperimentation.v1.ClusterPercentage
                     * @instance
                     */
                    ClusterPercentage.prototype.percentage = 0;

                    /**
                     * Verifies a ClusterPercentage message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.ClusterPercentage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ClusterPercentage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.percentage != null && message.hasOwnProperty("percentage"))
                            if (!$util.isInteger(message.percentage))
                                return "percentage: integer expected";
                        return null;
                    };

                    /**
                     * Creates a ClusterPercentage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.ClusterPercentage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.ClusterPercentage} ClusterPercentage
                     */
                    ClusterPercentage.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.ClusterPercentage)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.ClusterPercentage();
                        if (object.percentage != null)
                            message.percentage = object.percentage >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a ClusterPercentage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.ClusterPercentage
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.ClusterPercentage} message ClusterPercentage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ClusterPercentage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.percentage = 0;
                        if (message.percentage != null && message.hasOwnProperty("percentage"))
                            object.percentage = message.percentage;
                        return object;
                    };

                    /**
                     * Converts this ClusterPercentage to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.ClusterPercentage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ClusterPercentage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ClusterPercentage;
                })();

                v1.FaultPercentage = (function() {

                    /**
                     * Properties of a FaultPercentage.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface IFaultPercentage
                     * @property {number|null} [percentage] FaultPercentage percentage
                     * @property {clutch.chaos.serverexperimentation.v1.FaultPercentage.DenominatorType|null} [denominator] FaultPercentage denominator
                     */

                    /**
                     * Constructs a new FaultPercentage.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents a FaultPercentage.
                     * @implements IFaultPercentage
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.IFaultPercentage=} [properties] Properties to set
                     */
                    function FaultPercentage(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * FaultPercentage percentage.
                     * @member {number} percentage
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultPercentage
                     * @instance
                     */
                    FaultPercentage.prototype.percentage = 0;

                    /**
                     * FaultPercentage denominator.
                     * @member {clutch.chaos.serverexperimentation.v1.FaultPercentage.DenominatorType} denominator
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultPercentage
                     * @instance
                     */
                    FaultPercentage.prototype.denominator = 0;

                    /**
                     * Verifies a FaultPercentage message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultPercentage
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    FaultPercentage.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.percentage != null && message.hasOwnProperty("percentage"))
                            if (!$util.isInteger(message.percentage))
                                return "percentage: integer expected";
                        if (message.denominator != null && message.hasOwnProperty("denominator"))
                            switch (message.denominator) {
                            default:
                                return "denominator: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a FaultPercentage message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultPercentage
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.FaultPercentage} FaultPercentage
                     */
                    FaultPercentage.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.FaultPercentage)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.FaultPercentage();
                        if (object.percentage != null)
                            message.percentage = object.percentage >>> 0;
                        switch (object.denominator) {
                        case "DENOMINATOR_UNSPECIFIED":
                        case 0:
                            message.denominator = 0;
                            break;
                        case "DENOMINATOR_HUNDRED":
                        case 1:
                            message.denominator = 1;
                            break;
                        case "DENOMINATOR_TEN_THOUSAND":
                        case 2:
                            message.denominator = 2;
                            break;
                        case "DENOMINATOR_MILLION":
                        case 3:
                            message.denominator = 3;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a FaultPercentage message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultPercentage
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.FaultPercentage} message FaultPercentage
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FaultPercentage.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.percentage = 0;
                            object.denominator = options.enums === String ? "DENOMINATOR_UNSPECIFIED" : 0;
                        }
                        if (message.percentage != null && message.hasOwnProperty("percentage"))
                            object.percentage = message.percentage;
                        if (message.denominator != null && message.hasOwnProperty("denominator"))
                            object.denominator = options.enums === String ? $root.clutch.chaos.serverexperimentation.v1.FaultPercentage.DenominatorType[message.denominator] : message.denominator;
                        return object;
                    };

                    /**
                     * Converts this FaultPercentage to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultPercentage
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    FaultPercentage.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * DenominatorType enum.
                     * @name clutch.chaos.serverexperimentation.v1.FaultPercentage.DenominatorType
                     * @enum {number}
                     * @property {number} DENOMINATOR_UNSPECIFIED=0 DENOMINATOR_UNSPECIFIED value
                     * @property {number} DENOMINATOR_HUNDRED=1 DENOMINATOR_HUNDRED value
                     * @property {number} DENOMINATOR_TEN_THOUSAND=2 DENOMINATOR_TEN_THOUSAND value
                     * @property {number} DENOMINATOR_MILLION=3 DENOMINATOR_MILLION value
                     */
                    FaultPercentage.DenominatorType = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "DENOMINATOR_UNSPECIFIED"] = 0;
                        values[valuesById[1] = "DENOMINATOR_HUNDRED"] = 1;
                        values[valuesById[2] = "DENOMINATOR_TEN_THOUSAND"] = 2;
                        values[valuesById[3] = "DENOMINATOR_MILLION"] = 3;
                        return values;
                    })();

                    return FaultPercentage;
                })();

                v1.FaultAbortStatus = (function() {

                    /**
                     * Properties of a FaultAbortStatus.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface IFaultAbortStatus
                     * @property {number|null} [httpStatusCode] FaultAbortStatus httpStatusCode
                     */

                    /**
                     * Constructs a new FaultAbortStatus.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents a FaultAbortStatus.
                     * @implements IFaultAbortStatus
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.IFaultAbortStatus=} [properties] Properties to set
                     */
                    function FaultAbortStatus(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * FaultAbortStatus httpStatusCode.
                     * @member {number} httpStatusCode
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultAbortStatus
                     * @instance
                     */
                    FaultAbortStatus.prototype.httpStatusCode = 0;

                    /**
                     * Verifies a FaultAbortStatus message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultAbortStatus
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    FaultAbortStatus.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.httpStatusCode != null && message.hasOwnProperty("httpStatusCode"))
                            if (!$util.isInteger(message.httpStatusCode))
                                return "httpStatusCode: integer expected";
                        return null;
                    };

                    /**
                     * Creates a FaultAbortStatus message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultAbortStatus
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.FaultAbortStatus} FaultAbortStatus
                     */
                    FaultAbortStatus.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.FaultAbortStatus)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.FaultAbortStatus();
                        if (object.httpStatusCode != null)
                            message.httpStatusCode = object.httpStatusCode >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a FaultAbortStatus message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultAbortStatus
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.FaultAbortStatus} message FaultAbortStatus
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FaultAbortStatus.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.httpStatusCode = 0;
                        if (message.httpStatusCode != null && message.hasOwnProperty("httpStatusCode"))
                            object.httpStatusCode = message.httpStatusCode;
                        return object;
                    };

                    /**
                     * Converts this FaultAbortStatus to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultAbortStatus
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    FaultAbortStatus.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return FaultAbortStatus;
                })();

                v1.FaultLatencyDuration = (function() {

                    /**
                     * Properties of a FaultLatencyDuration.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface IFaultLatencyDuration
                     * @property {number|null} [fixedDurationMs] FaultLatencyDuration fixedDurationMs
                     */

                    /**
                     * Constructs a new FaultLatencyDuration.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents a FaultLatencyDuration.
                     * @implements IFaultLatencyDuration
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.IFaultLatencyDuration=} [properties] Properties to set
                     */
                    function FaultLatencyDuration(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * FaultLatencyDuration fixedDurationMs.
                     * @member {number} fixedDurationMs
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultLatencyDuration
                     * @instance
                     */
                    FaultLatencyDuration.prototype.fixedDurationMs = 0;

                    /**
                     * Verifies a FaultLatencyDuration message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultLatencyDuration
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    FaultLatencyDuration.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fixedDurationMs != null && message.hasOwnProperty("fixedDurationMs"))
                            if (!$util.isInteger(message.fixedDurationMs))
                                return "fixedDurationMs: integer expected";
                        return null;
                    };

                    /**
                     * Creates a FaultLatencyDuration message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultLatencyDuration
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.FaultLatencyDuration} FaultLatencyDuration
                     */
                    FaultLatencyDuration.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.FaultLatencyDuration)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.FaultLatencyDuration();
                        if (object.fixedDurationMs != null)
                            message.fixedDurationMs = object.fixedDurationMs >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a FaultLatencyDuration message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultLatencyDuration
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.FaultLatencyDuration} message FaultLatencyDuration
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    FaultLatencyDuration.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.fixedDurationMs = 0;
                        if (message.fixedDurationMs != null && message.hasOwnProperty("fixedDurationMs"))
                            object.fixedDurationMs = message.fixedDurationMs;
                        return object;
                    };

                    /**
                     * Converts this FaultLatencyDuration to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.FaultLatencyDuration
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    FaultLatencyDuration.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return FaultLatencyDuration;
                })();

                return v1;
            })();

            return serverexperimentation;
        })();

        return chaos;
    })();

    clutch.config = (function() {

        /**
         * Namespace config.
         * @memberof clutch
         * @namespace
         */
        const config = {};

        config.gateway = (function() {

            /**
             * Namespace gateway.
             * @memberof clutch.config
             * @namespace
             */
            const gateway = {};

            gateway.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.config.gateway
                 * @namespace
                 */
                const v1 = {};

                v1.Config = (function() {

                    /**
                     * Properties of a Config.
                     * @memberof clutch.config.gateway.v1
                     * @interface IConfig
                     * @property {clutch.config.gateway.v1.IGatewayOptions|null} [gateway] Config gateway
                     * @property {Array.<clutch.config.gateway.v1.IService>|null} [services] Config services
                     * @property {Array.<clutch.config.gateway.v1.IResolver>|null} [resolvers] Config resolvers
                     * @property {Array.<clutch.config.gateway.v1.IModule>|null} [modules] Config modules
                     * @property {Array.<string>|null} ["extends"] Config extends
                     */

                    /**
                     * Constructs a new Config.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Config.
                     * @implements IConfig
                     * @constructor
                     * @param {clutch.config.gateway.v1.IConfig=} [properties] Properties to set
                     */
                    function Config(properties) {
                        this.services = [];
                        this.resolvers = [];
                        this.modules = [];
                        this["extends"] = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Config gateway.
                     * @member {clutch.config.gateway.v1.IGatewayOptions|null|undefined} gateway
                     * @memberof clutch.config.gateway.v1.Config
                     * @instance
                     */
                    Config.prototype.gateway = null;

                    /**
                     * Config services.
                     * @member {Array.<clutch.config.gateway.v1.IService>} services
                     * @memberof clutch.config.gateway.v1.Config
                     * @instance
                     */
                    Config.prototype.services = $util.emptyArray;

                    /**
                     * Config resolvers.
                     * @member {Array.<clutch.config.gateway.v1.IResolver>} resolvers
                     * @memberof clutch.config.gateway.v1.Config
                     * @instance
                     */
                    Config.prototype.resolvers = $util.emptyArray;

                    /**
                     * Config modules.
                     * @member {Array.<clutch.config.gateway.v1.IModule>} modules
                     * @memberof clutch.config.gateway.v1.Config
                     * @instance
                     */
                    Config.prototype.modules = $util.emptyArray;

                    /**
                     * Config extends.
                     * @member {Array.<string>} extends
                     * @memberof clutch.config.gateway.v1.Config
                     * @instance
                     */
                    Config.prototype["extends"] = $util.emptyArray;

                    /**
                     * Verifies a Config message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Config
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Config.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.gateway != null && message.hasOwnProperty("gateway")) {
                            let error = $root.clutch.config.gateway.v1.GatewayOptions.verify(message.gateway);
                            if (error)
                                return "gateway." + error;
                        }
                        if (message.services != null && message.hasOwnProperty("services")) {
                            if (!Array.isArray(message.services))
                                return "services: array expected";
                            for (let i = 0; i < message.services.length; ++i) {
                                let error = $root.clutch.config.gateway.v1.Service.verify(message.services[i]);
                                if (error)
                                    return "services." + error;
                            }
                        }
                        if (message.resolvers != null && message.hasOwnProperty("resolvers")) {
                            if (!Array.isArray(message.resolvers))
                                return "resolvers: array expected";
                            for (let i = 0; i < message.resolvers.length; ++i) {
                                let error = $root.clutch.config.gateway.v1.Resolver.verify(message.resolvers[i]);
                                if (error)
                                    return "resolvers." + error;
                            }
                        }
                        if (message.modules != null && message.hasOwnProperty("modules")) {
                            if (!Array.isArray(message.modules))
                                return "modules: array expected";
                            for (let i = 0; i < message.modules.length; ++i) {
                                let error = $root.clutch.config.gateway.v1.Module.verify(message.modules[i]);
                                if (error)
                                    return "modules." + error;
                            }
                        }
                        if (message["extends"] != null && message.hasOwnProperty("extends")) {
                            if (!Array.isArray(message["extends"]))
                                return "extends: array expected";
                            for (let i = 0; i < message["extends"].length; ++i)
                                if (!$util.isString(message["extends"][i]))
                                    return "extends: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Config message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Config
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Config} Config
                     */
                    Config.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Config)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Config();
                        if (object.gateway != null) {
                            if (typeof object.gateway !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Config.gateway: object expected");
                            message.gateway = $root.clutch.config.gateway.v1.GatewayOptions.fromObject(object.gateway);
                        }
                        if (object.services) {
                            if (!Array.isArray(object.services))
                                throw TypeError(".clutch.config.gateway.v1.Config.services: array expected");
                            message.services = [];
                            for (let i = 0; i < object.services.length; ++i) {
                                if (typeof object.services[i] !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.Config.services: object expected");
                                message.services[i] = $root.clutch.config.gateway.v1.Service.fromObject(object.services[i]);
                            }
                        }
                        if (object.resolvers) {
                            if (!Array.isArray(object.resolvers))
                                throw TypeError(".clutch.config.gateway.v1.Config.resolvers: array expected");
                            message.resolvers = [];
                            for (let i = 0; i < object.resolvers.length; ++i) {
                                if (typeof object.resolvers[i] !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.Config.resolvers: object expected");
                                message.resolvers[i] = $root.clutch.config.gateway.v1.Resolver.fromObject(object.resolvers[i]);
                            }
                        }
                        if (object.modules) {
                            if (!Array.isArray(object.modules))
                                throw TypeError(".clutch.config.gateway.v1.Config.modules: array expected");
                            message.modules = [];
                            for (let i = 0; i < object.modules.length; ++i) {
                                if (typeof object.modules[i] !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.Config.modules: object expected");
                                message.modules[i] = $root.clutch.config.gateway.v1.Module.fromObject(object.modules[i]);
                            }
                        }
                        if (object["extends"]) {
                            if (!Array.isArray(object["extends"]))
                                throw TypeError(".clutch.config.gateway.v1.Config.extends: array expected");
                            message["extends"] = [];
                            for (let i = 0; i < object["extends"].length; ++i)
                                message["extends"][i] = String(object["extends"][i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Config message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Config
                     * @static
                     * @param {clutch.config.gateway.v1.Config} message Config
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Config.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults) {
                            object.services = [];
                            object.resolvers = [];
                            object.modules = [];
                            object["extends"] = [];
                        }
                        if (options.defaults)
                            object.gateway = null;
                        if (message.gateway != null && message.hasOwnProperty("gateway"))
                            object.gateway = $root.clutch.config.gateway.v1.GatewayOptions.toObject(message.gateway, options);
                        if (message.services && message.services.length) {
                            object.services = [];
                            for (let j = 0; j < message.services.length; ++j)
                                object.services[j] = $root.clutch.config.gateway.v1.Service.toObject(message.services[j], options);
                        }
                        if (message.resolvers && message.resolvers.length) {
                            object.resolvers = [];
                            for (let j = 0; j < message.resolvers.length; ++j)
                                object.resolvers[j] = $root.clutch.config.gateway.v1.Resolver.toObject(message.resolvers[j], options);
                        }
                        if (message.modules && message.modules.length) {
                            object.modules = [];
                            for (let j = 0; j < message.modules.length; ++j)
                                object.modules[j] = $root.clutch.config.gateway.v1.Module.toObject(message.modules[j], options);
                        }
                        if (message["extends"] && message["extends"].length) {
                            object["extends"] = [];
                            for (let j = 0; j < message["extends"].length; ++j)
                                object["extends"][j] = message["extends"][j];
                        }
                        return object;
                    };

                    /**
                     * Converts this Config to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Config
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Config.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Config;
                })();

                v1.TCPSocket = (function() {

                    /**
                     * Properties of a TCPSocket.
                     * @memberof clutch.config.gateway.v1
                     * @interface ITCPSocket
                     * @property {string|null} [address] TCPSocket address
                     * @property {number|null} [port] TCPSocket port
                     * @property {boolean|null} [secure] TCPSocket secure
                     */

                    /**
                     * Constructs a new TCPSocket.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a TCPSocket.
                     * @implements ITCPSocket
                     * @constructor
                     * @param {clutch.config.gateway.v1.ITCPSocket=} [properties] Properties to set
                     */
                    function TCPSocket(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TCPSocket address.
                     * @member {string} address
                     * @memberof clutch.config.gateway.v1.TCPSocket
                     * @instance
                     */
                    TCPSocket.prototype.address = "";

                    /**
                     * TCPSocket port.
                     * @member {number} port
                     * @memberof clutch.config.gateway.v1.TCPSocket
                     * @instance
                     */
                    TCPSocket.prototype.port = 0;

                    /**
                     * TCPSocket secure.
                     * @member {boolean} secure
                     * @memberof clutch.config.gateway.v1.TCPSocket
                     * @instance
                     */
                    TCPSocket.prototype.secure = false;

                    /**
                     * Verifies a TCPSocket message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.TCPSocket
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TCPSocket.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.address != null && message.hasOwnProperty("address"))
                            if (!$util.isString(message.address))
                                return "address: string expected";
                        if (message.port != null && message.hasOwnProperty("port"))
                            if (!$util.isInteger(message.port))
                                return "port: integer expected";
                        if (message.secure != null && message.hasOwnProperty("secure"))
                            if (typeof message.secure !== "boolean")
                                return "secure: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a TCPSocket message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.TCPSocket
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.TCPSocket} TCPSocket
                     */
                    TCPSocket.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.TCPSocket)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.TCPSocket();
                        if (object.address != null)
                            message.address = String(object.address);
                        if (object.port != null)
                            message.port = object.port >>> 0;
                        if (object.secure != null)
                            message.secure = Boolean(object.secure);
                        return message;
                    };

                    /**
                     * Creates a plain object from a TCPSocket message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.TCPSocket
                     * @static
                     * @param {clutch.config.gateway.v1.TCPSocket} message TCPSocket
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TCPSocket.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.address = "";
                            object.port = 0;
                            object.secure = false;
                        }
                        if (message.address != null && message.hasOwnProperty("address"))
                            object.address = message.address;
                        if (message.port != null && message.hasOwnProperty("port"))
                            object.port = message.port;
                        if (message.secure != null && message.hasOwnProperty("secure"))
                            object.secure = message.secure;
                        return object;
                    };

                    /**
                     * Converts this TCPSocket to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.TCPSocket
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TCPSocket.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return TCPSocket;
                })();

                v1.Listener = (function() {

                    /**
                     * Properties of a Listener.
                     * @memberof clutch.config.gateway.v1
                     * @interface IListener
                     * @property {clutch.config.gateway.v1.ITCPSocket|null} [tcp] Listener tcp
                     */

                    /**
                     * Constructs a new Listener.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Listener.
                     * @implements IListener
                     * @constructor
                     * @param {clutch.config.gateway.v1.IListener=} [properties] Properties to set
                     */
                    function Listener(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Listener tcp.
                     * @member {clutch.config.gateway.v1.ITCPSocket|null|undefined} tcp
                     * @memberof clutch.config.gateway.v1.Listener
                     * @instance
                     */
                    Listener.prototype.tcp = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Listener socket.
                     * @member {"tcp"|undefined} socket
                     * @memberof clutch.config.gateway.v1.Listener
                     * @instance
                     */
                    Object.defineProperty(Listener.prototype, "socket", {
                        get: $util.oneOfGetter($oneOfFields = ["tcp"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies a Listener message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Listener
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Listener.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.tcp != null && message.hasOwnProperty("tcp")) {
                            properties.socket = 1;
                            {
                                let error = $root.clutch.config.gateway.v1.TCPSocket.verify(message.tcp);
                                if (error)
                                    return "tcp." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Listener message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Listener
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Listener} Listener
                     */
                    Listener.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Listener)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Listener();
                        if (object.tcp != null) {
                            if (typeof object.tcp !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Listener.tcp: object expected");
                            message.tcp = $root.clutch.config.gateway.v1.TCPSocket.fromObject(object.tcp);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Listener message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Listener
                     * @static
                     * @param {clutch.config.gateway.v1.Listener} message Listener
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Listener.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (message.tcp != null && message.hasOwnProperty("tcp")) {
                            object.tcp = $root.clutch.config.gateway.v1.TCPSocket.toObject(message.tcp, options);
                            if (options.oneofs)
                                object.socket = "tcp";
                        }
                        return object;
                    };

                    /**
                     * Converts this Listener to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Listener
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Listener.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Listener;
                })();

                v1.Stats = (function() {

                    /**
                     * Properties of a Stats.
                     * @memberof clutch.config.gateway.v1
                     * @interface IStats
                     * @property {google.protobuf.IDuration|null} [flushInterval] Stats flushInterval
                     * @property {clutch.config.gateway.v1.Stats.ILogReporter|null} [logReporter] Stats logReporter
                     * @property {clutch.config.gateway.v1.Stats.IStatsdReporter|null} [statsdReporter] Stats statsdReporter
                     * @property {clutch.config.gateway.v1.Stats.IPrometheusReporter|null} [prometheusReporter] Stats prometheusReporter
                     * @property {clutch.config.gateway.v1.Stats.IGoRuntimeStats|null} [goRuntimeStats] Stats goRuntimeStats
                     */

                    /**
                     * Constructs a new Stats.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Stats.
                     * @implements IStats
                     * @constructor
                     * @param {clutch.config.gateway.v1.IStats=} [properties] Properties to set
                     */
                    function Stats(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Stats flushInterval.
                     * @member {google.protobuf.IDuration|null|undefined} flushInterval
                     * @memberof clutch.config.gateway.v1.Stats
                     * @instance
                     */
                    Stats.prototype.flushInterval = null;

                    /**
                     * Stats logReporter.
                     * @member {clutch.config.gateway.v1.Stats.ILogReporter|null|undefined} logReporter
                     * @memberof clutch.config.gateway.v1.Stats
                     * @instance
                     */
                    Stats.prototype.logReporter = null;

                    /**
                     * Stats statsdReporter.
                     * @member {clutch.config.gateway.v1.Stats.IStatsdReporter|null|undefined} statsdReporter
                     * @memberof clutch.config.gateway.v1.Stats
                     * @instance
                     */
                    Stats.prototype.statsdReporter = null;

                    /**
                     * Stats prometheusReporter.
                     * @member {clutch.config.gateway.v1.Stats.IPrometheusReporter|null|undefined} prometheusReporter
                     * @memberof clutch.config.gateway.v1.Stats
                     * @instance
                     */
                    Stats.prototype.prometheusReporter = null;

                    /**
                     * Stats goRuntimeStats.
                     * @member {clutch.config.gateway.v1.Stats.IGoRuntimeStats|null|undefined} goRuntimeStats
                     * @memberof clutch.config.gateway.v1.Stats
                     * @instance
                     */
                    Stats.prototype.goRuntimeStats = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Stats reporter.
                     * @member {"logReporter"|"statsdReporter"|"prometheusReporter"|undefined} reporter
                     * @memberof clutch.config.gateway.v1.Stats
                     * @instance
                     */
                    Object.defineProperty(Stats.prototype, "reporter", {
                        get: $util.oneOfGetter($oneOfFields = ["logReporter", "statsdReporter", "prometheusReporter"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies a Stats message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Stats
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Stats.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.flushInterval != null && message.hasOwnProperty("flushInterval")) {
                            let error = $root.google.protobuf.Duration.verify(message.flushInterval);
                            if (error)
                                return "flushInterval." + error;
                        }
                        if (message.logReporter != null && message.hasOwnProperty("logReporter")) {
                            properties.reporter = 1;
                            {
                                let error = $root.clutch.config.gateway.v1.Stats.LogReporter.verify(message.logReporter);
                                if (error)
                                    return "logReporter." + error;
                            }
                        }
                        if (message.statsdReporter != null && message.hasOwnProperty("statsdReporter")) {
                            if (properties.reporter === 1)
                                return "reporter: multiple values";
                            properties.reporter = 1;
                            {
                                let error = $root.clutch.config.gateway.v1.Stats.StatsdReporter.verify(message.statsdReporter);
                                if (error)
                                    return "statsdReporter." + error;
                            }
                        }
                        if (message.prometheusReporter != null && message.hasOwnProperty("prometheusReporter")) {
                            if (properties.reporter === 1)
                                return "reporter: multiple values";
                            properties.reporter = 1;
                            {
                                let error = $root.clutch.config.gateway.v1.Stats.PrometheusReporter.verify(message.prometheusReporter);
                                if (error)
                                    return "prometheusReporter." + error;
                            }
                        }
                        if (message.goRuntimeStats != null && message.hasOwnProperty("goRuntimeStats")) {
                            let error = $root.clutch.config.gateway.v1.Stats.GoRuntimeStats.verify(message.goRuntimeStats);
                            if (error)
                                return "goRuntimeStats." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Stats message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Stats
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Stats} Stats
                     */
                    Stats.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Stats)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Stats();
                        if (object.flushInterval != null) {
                            if (typeof object.flushInterval !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Stats.flushInterval: object expected");
                            message.flushInterval = $root.google.protobuf.Duration.fromObject(object.flushInterval);
                        }
                        if (object.logReporter != null) {
                            if (typeof object.logReporter !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Stats.logReporter: object expected");
                            message.logReporter = $root.clutch.config.gateway.v1.Stats.LogReporter.fromObject(object.logReporter);
                        }
                        if (object.statsdReporter != null) {
                            if (typeof object.statsdReporter !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Stats.statsdReporter: object expected");
                            message.statsdReporter = $root.clutch.config.gateway.v1.Stats.StatsdReporter.fromObject(object.statsdReporter);
                        }
                        if (object.prometheusReporter != null) {
                            if (typeof object.prometheusReporter !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Stats.prometheusReporter: object expected");
                            message.prometheusReporter = $root.clutch.config.gateway.v1.Stats.PrometheusReporter.fromObject(object.prometheusReporter);
                        }
                        if (object.goRuntimeStats != null) {
                            if (typeof object.goRuntimeStats !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Stats.goRuntimeStats: object expected");
                            message.goRuntimeStats = $root.clutch.config.gateway.v1.Stats.GoRuntimeStats.fromObject(object.goRuntimeStats);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Stats message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Stats
                     * @static
                     * @param {clutch.config.gateway.v1.Stats} message Stats
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Stats.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.flushInterval = null;
                            object.goRuntimeStats = null;
                        }
                        if (message.flushInterval != null && message.hasOwnProperty("flushInterval"))
                            object.flushInterval = $root.google.protobuf.Duration.toObject(message.flushInterval, options);
                        if (message.logReporter != null && message.hasOwnProperty("logReporter")) {
                            object.logReporter = $root.clutch.config.gateway.v1.Stats.LogReporter.toObject(message.logReporter, options);
                            if (options.oneofs)
                                object.reporter = "logReporter";
                        }
                        if (message.statsdReporter != null && message.hasOwnProperty("statsdReporter")) {
                            object.statsdReporter = $root.clutch.config.gateway.v1.Stats.StatsdReporter.toObject(message.statsdReporter, options);
                            if (options.oneofs)
                                object.reporter = "statsdReporter";
                        }
                        if (message.goRuntimeStats != null && message.hasOwnProperty("goRuntimeStats"))
                            object.goRuntimeStats = $root.clutch.config.gateway.v1.Stats.GoRuntimeStats.toObject(message.goRuntimeStats, options);
                        if (message.prometheusReporter != null && message.hasOwnProperty("prometheusReporter")) {
                            object.prometheusReporter = $root.clutch.config.gateway.v1.Stats.PrometheusReporter.toObject(message.prometheusReporter, options);
                            if (options.oneofs)
                                object.reporter = "prometheusReporter";
                        }
                        return object;
                    };

                    /**
                     * Converts this Stats to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Stats
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Stats.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Stats.LogReporter = (function() {

                        /**
                         * Properties of a LogReporter.
                         * @memberof clutch.config.gateway.v1.Stats
                         * @interface ILogReporter
                         */

                        /**
                         * Constructs a new LogReporter.
                         * @memberof clutch.config.gateway.v1.Stats
                         * @classdesc Represents a LogReporter.
                         * @implements ILogReporter
                         * @constructor
                         * @param {clutch.config.gateway.v1.Stats.ILogReporter=} [properties] Properties to set
                         */
                        function LogReporter(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Verifies a LogReporter message.
                         * @function verify
                         * @memberof clutch.config.gateway.v1.Stats.LogReporter
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        LogReporter.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a LogReporter message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.gateway.v1.Stats.LogReporter
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.gateway.v1.Stats.LogReporter} LogReporter
                         */
                        LogReporter.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.gateway.v1.Stats.LogReporter)
                                return object;
                            return new $root.clutch.config.gateway.v1.Stats.LogReporter();
                        };

                        /**
                         * Creates a plain object from a LogReporter message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.gateway.v1.Stats.LogReporter
                         * @static
                         * @param {clutch.config.gateway.v1.Stats.LogReporter} message LogReporter
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        LogReporter.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this LogReporter to JSON.
                         * @function toJSON
                         * @memberof clutch.config.gateway.v1.Stats.LogReporter
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        LogReporter.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return LogReporter;
                    })();

                    Stats.StatsdReporter = (function() {

                        /**
                         * Properties of a StatsdReporter.
                         * @memberof clutch.config.gateway.v1.Stats
                         * @interface IStatsdReporter
                         * @property {string|null} [address] StatsdReporter address
                         * @property {clutch.config.gateway.v1.Stats.StatsdReporter.IPointTags|null} [pointTags] StatsdReporter pointTags
                         */

                        /**
                         * Constructs a new StatsdReporter.
                         * @memberof clutch.config.gateway.v1.Stats
                         * @classdesc Represents a StatsdReporter.
                         * @implements IStatsdReporter
                         * @constructor
                         * @param {clutch.config.gateway.v1.Stats.IStatsdReporter=} [properties] Properties to set
                         */
                        function StatsdReporter(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * StatsdReporter address.
                         * @member {string} address
                         * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                         * @instance
                         */
                        StatsdReporter.prototype.address = "";

                        /**
                         * StatsdReporter pointTags.
                         * @member {clutch.config.gateway.v1.Stats.StatsdReporter.IPointTags|null|undefined} pointTags
                         * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                         * @instance
                         */
                        StatsdReporter.prototype.pointTags = null;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * StatsdReporter tagMode.
                         * @member {"pointTags"|undefined} tagMode
                         * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                         * @instance
                         */
                        Object.defineProperty(StatsdReporter.prototype, "tagMode", {
                            get: $util.oneOfGetter($oneOfFields = ["pointTags"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Verifies a StatsdReporter message.
                         * @function verify
                         * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        StatsdReporter.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.address != null && message.hasOwnProperty("address"))
                                if (!$util.isString(message.address))
                                    return "address: string expected";
                            if (message.pointTags != null && message.hasOwnProperty("pointTags")) {
                                properties.tagMode = 1;
                                {
                                    let error = $root.clutch.config.gateway.v1.Stats.StatsdReporter.PointTags.verify(message.pointTags);
                                    if (error)
                                        return "pointTags." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a StatsdReporter message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.gateway.v1.Stats.StatsdReporter} StatsdReporter
                         */
                        StatsdReporter.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.gateway.v1.Stats.StatsdReporter)
                                return object;
                            let message = new $root.clutch.config.gateway.v1.Stats.StatsdReporter();
                            if (object.address != null)
                                message.address = String(object.address);
                            if (object.pointTags != null) {
                                if (typeof object.pointTags !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.Stats.StatsdReporter.pointTags: object expected");
                                message.pointTags = $root.clutch.config.gateway.v1.Stats.StatsdReporter.PointTags.fromObject(object.pointTags);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a StatsdReporter message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                         * @static
                         * @param {clutch.config.gateway.v1.Stats.StatsdReporter} message StatsdReporter
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        StatsdReporter.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.address = "";
                            if (message.address != null && message.hasOwnProperty("address"))
                                object.address = message.address;
                            if (message.pointTags != null && message.hasOwnProperty("pointTags")) {
                                object.pointTags = $root.clutch.config.gateway.v1.Stats.StatsdReporter.PointTags.toObject(message.pointTags, options);
                                if (options.oneofs)
                                    object.tagMode = "pointTags";
                            }
                            return object;
                        };

                        /**
                         * Converts this StatsdReporter to JSON.
                         * @function toJSON
                         * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        StatsdReporter.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        StatsdReporter.PointTags = (function() {

                            /**
                             * Properties of a PointTags.
                             * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                             * @interface IPointTags
                             * @property {string|null} [separator] PointTags separator
                             */

                            /**
                             * Constructs a new PointTags.
                             * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                             * @classdesc Represents a PointTags.
                             * @implements IPointTags
                             * @constructor
                             * @param {clutch.config.gateway.v1.Stats.StatsdReporter.IPointTags=} [properties] Properties to set
                             */
                            function PointTags(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * PointTags separator.
                             * @member {string} separator
                             * @memberof clutch.config.gateway.v1.Stats.StatsdReporter.PointTags
                             * @instance
                             */
                            PointTags.prototype.separator = "";

                            /**
                             * Verifies a PointTags message.
                             * @function verify
                             * @memberof clutch.config.gateway.v1.Stats.StatsdReporter.PointTags
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            PointTags.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.separator != null && message.hasOwnProperty("separator"))
                                    if (!$util.isString(message.separator))
                                        return "separator: string expected";
                                return null;
                            };

                            /**
                             * Creates a PointTags message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof clutch.config.gateway.v1.Stats.StatsdReporter.PointTags
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {clutch.config.gateway.v1.Stats.StatsdReporter.PointTags} PointTags
                             */
                            PointTags.fromObject = function fromObject(object) {
                                if (object instanceof $root.clutch.config.gateway.v1.Stats.StatsdReporter.PointTags)
                                    return object;
                                let message = new $root.clutch.config.gateway.v1.Stats.StatsdReporter.PointTags();
                                if (object.separator != null)
                                    message.separator = String(object.separator);
                                return message;
                            };

                            /**
                             * Creates a plain object from a PointTags message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof clutch.config.gateway.v1.Stats.StatsdReporter.PointTags
                             * @static
                             * @param {clutch.config.gateway.v1.Stats.StatsdReporter.PointTags} message PointTags
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            PointTags.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults)
                                    object.separator = "";
                                if (message.separator != null && message.hasOwnProperty("separator"))
                                    object.separator = message.separator;
                                return object;
                            };

                            /**
                             * Converts this PointTags to JSON.
                             * @function toJSON
                             * @memberof clutch.config.gateway.v1.Stats.StatsdReporter.PointTags
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            PointTags.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return PointTags;
                        })();

                        return StatsdReporter;
                    })();

                    Stats.PrometheusReporter = (function() {

                        /**
                         * Properties of a PrometheusReporter.
                         * @memberof clutch.config.gateway.v1.Stats
                         * @interface IPrometheusReporter
                         * @property {string|null} [handlerPath] PrometheusReporter handlerPath
                         */

                        /**
                         * Constructs a new PrometheusReporter.
                         * @memberof clutch.config.gateway.v1.Stats
                         * @classdesc Represents a PrometheusReporter.
                         * @implements IPrometheusReporter
                         * @constructor
                         * @param {clutch.config.gateway.v1.Stats.IPrometheusReporter=} [properties] Properties to set
                         */
                        function PrometheusReporter(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * PrometheusReporter handlerPath.
                         * @member {string} handlerPath
                         * @memberof clutch.config.gateway.v1.Stats.PrometheusReporter
                         * @instance
                         */
                        PrometheusReporter.prototype.handlerPath = "";

                        /**
                         * Verifies a PrometheusReporter message.
                         * @function verify
                         * @memberof clutch.config.gateway.v1.Stats.PrometheusReporter
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        PrometheusReporter.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.handlerPath != null && message.hasOwnProperty("handlerPath"))
                                if (!$util.isString(message.handlerPath))
                                    return "handlerPath: string expected";
                            return null;
                        };

                        /**
                         * Creates a PrometheusReporter message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.gateway.v1.Stats.PrometheusReporter
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.gateway.v1.Stats.PrometheusReporter} PrometheusReporter
                         */
                        PrometheusReporter.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.gateway.v1.Stats.PrometheusReporter)
                                return object;
                            let message = new $root.clutch.config.gateway.v1.Stats.PrometheusReporter();
                            if (object.handlerPath != null)
                                message.handlerPath = String(object.handlerPath);
                            return message;
                        };

                        /**
                         * Creates a plain object from a PrometheusReporter message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.gateway.v1.Stats.PrometheusReporter
                         * @static
                         * @param {clutch.config.gateway.v1.Stats.PrometheusReporter} message PrometheusReporter
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        PrometheusReporter.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.handlerPath = "";
                            if (message.handlerPath != null && message.hasOwnProperty("handlerPath"))
                                object.handlerPath = message.handlerPath;
                            return object;
                        };

                        /**
                         * Converts this PrometheusReporter to JSON.
                         * @function toJSON
                         * @memberof clutch.config.gateway.v1.Stats.PrometheusReporter
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        PrometheusReporter.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return PrometheusReporter;
                    })();

                    Stats.GoRuntimeStats = (function() {

                        /**
                         * Properties of a GoRuntimeStats.
                         * @memberof clutch.config.gateway.v1.Stats
                         * @interface IGoRuntimeStats
                         * @property {google.protobuf.IDuration|null} [collectionInterval] GoRuntimeStats collectionInterval
                         */

                        /**
                         * Constructs a new GoRuntimeStats.
                         * @memberof clutch.config.gateway.v1.Stats
                         * @classdesc Represents a GoRuntimeStats.
                         * @implements IGoRuntimeStats
                         * @constructor
                         * @param {clutch.config.gateway.v1.Stats.IGoRuntimeStats=} [properties] Properties to set
                         */
                        function GoRuntimeStats(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * GoRuntimeStats collectionInterval.
                         * @member {google.protobuf.IDuration|null|undefined} collectionInterval
                         * @memberof clutch.config.gateway.v1.Stats.GoRuntimeStats
                         * @instance
                         */
                        GoRuntimeStats.prototype.collectionInterval = null;

                        /**
                         * Verifies a GoRuntimeStats message.
                         * @function verify
                         * @memberof clutch.config.gateway.v1.Stats.GoRuntimeStats
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        GoRuntimeStats.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.collectionInterval != null && message.hasOwnProperty("collectionInterval")) {
                                let error = $root.google.protobuf.Duration.verify(message.collectionInterval);
                                if (error)
                                    return "collectionInterval." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a GoRuntimeStats message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.gateway.v1.Stats.GoRuntimeStats
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.gateway.v1.Stats.GoRuntimeStats} GoRuntimeStats
                         */
                        GoRuntimeStats.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.gateway.v1.Stats.GoRuntimeStats)
                                return object;
                            let message = new $root.clutch.config.gateway.v1.Stats.GoRuntimeStats();
                            if (object.collectionInterval != null) {
                                if (typeof object.collectionInterval !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.Stats.GoRuntimeStats.collectionInterval: object expected");
                                message.collectionInterval = $root.google.protobuf.Duration.fromObject(object.collectionInterval);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a GoRuntimeStats message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.gateway.v1.Stats.GoRuntimeStats
                         * @static
                         * @param {clutch.config.gateway.v1.Stats.GoRuntimeStats} message GoRuntimeStats
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        GoRuntimeStats.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.collectionInterval = null;
                            if (message.collectionInterval != null && message.hasOwnProperty("collectionInterval"))
                                object.collectionInterval = $root.google.protobuf.Duration.toObject(message.collectionInterval, options);
                            return object;
                        };

                        /**
                         * Converts this GoRuntimeStats to JSON.
                         * @function toJSON
                         * @memberof clutch.config.gateway.v1.Stats.GoRuntimeStats
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        GoRuntimeStats.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return GoRuntimeStats;
                    })();

                    return Stats;
                })();

                v1.Timeouts = (function() {

                    /**
                     * Properties of a Timeouts.
                     * @memberof clutch.config.gateway.v1
                     * @interface ITimeouts
                     * @property {google.protobuf.IDuration|null} ["default"] Timeouts default
                     * @property {Array.<clutch.config.gateway.v1.Timeouts.IEntry>|null} [overrides] Timeouts overrides
                     */

                    /**
                     * Constructs a new Timeouts.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Timeouts.
                     * @implements ITimeouts
                     * @constructor
                     * @param {clutch.config.gateway.v1.ITimeouts=} [properties] Properties to set
                     */
                    function Timeouts(properties) {
                        this.overrides = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Timeouts default.
                     * @member {google.protobuf.IDuration|null|undefined} default
                     * @memberof clutch.config.gateway.v1.Timeouts
                     * @instance
                     */
                    Timeouts.prototype["default"] = null;

                    /**
                     * Timeouts overrides.
                     * @member {Array.<clutch.config.gateway.v1.Timeouts.IEntry>} overrides
                     * @memberof clutch.config.gateway.v1.Timeouts
                     * @instance
                     */
                    Timeouts.prototype.overrides = $util.emptyArray;

                    /**
                     * Verifies a Timeouts message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Timeouts
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Timeouts.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message["default"] != null && message.hasOwnProperty("default")) {
                            let error = $root.google.protobuf.Duration.verify(message["default"]);
                            if (error)
                                return "default." + error;
                        }
                        if (message.overrides != null && message.hasOwnProperty("overrides")) {
                            if (!Array.isArray(message.overrides))
                                return "overrides: array expected";
                            for (let i = 0; i < message.overrides.length; ++i) {
                                let error = $root.clutch.config.gateway.v1.Timeouts.Entry.verify(message.overrides[i]);
                                if (error)
                                    return "overrides." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Timeouts message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Timeouts
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Timeouts} Timeouts
                     */
                    Timeouts.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Timeouts)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Timeouts();
                        if (object["default"] != null) {
                            if (typeof object["default"] !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Timeouts.default: object expected");
                            message["default"] = $root.google.protobuf.Duration.fromObject(object["default"]);
                        }
                        if (object.overrides) {
                            if (!Array.isArray(object.overrides))
                                throw TypeError(".clutch.config.gateway.v1.Timeouts.overrides: array expected");
                            message.overrides = [];
                            for (let i = 0; i < object.overrides.length; ++i) {
                                if (typeof object.overrides[i] !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.Timeouts.overrides: object expected");
                                message.overrides[i] = $root.clutch.config.gateway.v1.Timeouts.Entry.fromObject(object.overrides[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Timeouts message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Timeouts
                     * @static
                     * @param {clutch.config.gateway.v1.Timeouts} message Timeouts
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Timeouts.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.overrides = [];
                        if (options.defaults)
                            object["default"] = null;
                        if (message["default"] != null && message.hasOwnProperty("default"))
                            object["default"] = $root.google.protobuf.Duration.toObject(message["default"], options);
                        if (message.overrides && message.overrides.length) {
                            object.overrides = [];
                            for (let j = 0; j < message.overrides.length; ++j)
                                object.overrides[j] = $root.clutch.config.gateway.v1.Timeouts.Entry.toObject(message.overrides[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Timeouts to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Timeouts
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Timeouts.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Timeouts.Entry = (function() {

                        /**
                         * Properties of an Entry.
                         * @memberof clutch.config.gateway.v1.Timeouts
                         * @interface IEntry
                         * @property {string|null} [service] Entry service
                         * @property {string|null} [method] Entry method
                         * @property {google.protobuf.IDuration|null} [timeout] Entry timeout
                         */

                        /**
                         * Constructs a new Entry.
                         * @memberof clutch.config.gateway.v1.Timeouts
                         * @classdesc Represents an Entry.
                         * @implements IEntry
                         * @constructor
                         * @param {clutch.config.gateway.v1.Timeouts.IEntry=} [properties] Properties to set
                         */
                        function Entry(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Entry service.
                         * @member {string} service
                         * @memberof clutch.config.gateway.v1.Timeouts.Entry
                         * @instance
                         */
                        Entry.prototype.service = "";

                        /**
                         * Entry method.
                         * @member {string} method
                         * @memberof clutch.config.gateway.v1.Timeouts.Entry
                         * @instance
                         */
                        Entry.prototype.method = "";

                        /**
                         * Entry timeout.
                         * @member {google.protobuf.IDuration|null|undefined} timeout
                         * @memberof clutch.config.gateway.v1.Timeouts.Entry
                         * @instance
                         */
                        Entry.prototype.timeout = null;

                        /**
                         * Verifies an Entry message.
                         * @function verify
                         * @memberof clutch.config.gateway.v1.Timeouts.Entry
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Entry.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.service != null && message.hasOwnProperty("service"))
                                if (!$util.isString(message.service))
                                    return "service: string expected";
                            if (message.method != null && message.hasOwnProperty("method"))
                                if (!$util.isString(message.method))
                                    return "method: string expected";
                            if (message.timeout != null && message.hasOwnProperty("timeout")) {
                                let error = $root.google.protobuf.Duration.verify(message.timeout);
                                if (error)
                                    return "timeout." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates an Entry message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.gateway.v1.Timeouts.Entry
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.gateway.v1.Timeouts.Entry} Entry
                         */
                        Entry.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.gateway.v1.Timeouts.Entry)
                                return object;
                            let message = new $root.clutch.config.gateway.v1.Timeouts.Entry();
                            if (object.service != null)
                                message.service = String(object.service);
                            if (object.method != null)
                                message.method = String(object.method);
                            if (object.timeout != null) {
                                if (typeof object.timeout !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.Timeouts.Entry.timeout: object expected");
                                message.timeout = $root.google.protobuf.Duration.fromObject(object.timeout);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an Entry message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.gateway.v1.Timeouts.Entry
                         * @static
                         * @param {clutch.config.gateway.v1.Timeouts.Entry} message Entry
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Entry.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.service = "";
                                object.method = "";
                                object.timeout = null;
                            }
                            if (message.service != null && message.hasOwnProperty("service"))
                                object.service = message.service;
                            if (message.method != null && message.hasOwnProperty("method"))
                                object.method = message.method;
                            if (message.timeout != null && message.hasOwnProperty("timeout"))
                                object.timeout = $root.google.protobuf.Duration.toObject(message.timeout, options);
                            return object;
                        };

                        /**
                         * Converts this Entry to JSON.
                         * @function toJSON
                         * @memberof clutch.config.gateway.v1.Timeouts.Entry
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Entry.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Entry;
                    })();

                    return Timeouts;
                })();

                v1.GatewayOptions = (function() {

                    /**
                     * Properties of a GatewayOptions.
                     * @memberof clutch.config.gateway.v1
                     * @interface IGatewayOptions
                     * @property {clutch.config.gateway.v1.IListener|null} [listener] GatewayOptions listener
                     * @property {clutch.config.gateway.v1.IListener|null} [jsonGrpcLoopbackListener] GatewayOptions jsonGrpcLoopbackListener
                     * @property {clutch.config.gateway.v1.ILogger|null} [logger] GatewayOptions logger
                     * @property {clutch.config.gateway.v1.IStats|null} [stats] GatewayOptions stats
                     * @property {clutch.config.gateway.v1.ITimeouts|null} [timeouts] GatewayOptions timeouts
                     * @property {Array.<clutch.config.gateway.v1.IMiddleware>|null} [middleware] GatewayOptions middleware
                     * @property {clutch.config.gateway.v1.IAssets|null} [assets] GatewayOptions assets
                     * @property {boolean|null} [enablePprof] GatewayOptions enablePprof
                     * @property {clutch.config.middleware.accesslog.v1.IConfig|null} [accesslog] GatewayOptions accesslog
                     * @property {number|null} [maxResponseSizeBytes] GatewayOptions maxResponseSizeBytes
                     * @property {google.protobuf.IBoolValue|null} [secureCookies] GatewayOptions secureCookies
                     */

                    /**
                     * Constructs a new GatewayOptions.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a GatewayOptions.
                     * @implements IGatewayOptions
                     * @constructor
                     * @param {clutch.config.gateway.v1.IGatewayOptions=} [properties] Properties to set
                     */
                    function GatewayOptions(properties) {
                        this.middleware = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GatewayOptions listener.
                     * @member {clutch.config.gateway.v1.IListener|null|undefined} listener
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.listener = null;

                    /**
                     * GatewayOptions jsonGrpcLoopbackListener.
                     * @member {clutch.config.gateway.v1.IListener|null|undefined} jsonGrpcLoopbackListener
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.jsonGrpcLoopbackListener = null;

                    /**
                     * GatewayOptions logger.
                     * @member {clutch.config.gateway.v1.ILogger|null|undefined} logger
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.logger = null;

                    /**
                     * GatewayOptions stats.
                     * @member {clutch.config.gateway.v1.IStats|null|undefined} stats
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.stats = null;

                    /**
                     * GatewayOptions timeouts.
                     * @member {clutch.config.gateway.v1.ITimeouts|null|undefined} timeouts
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.timeouts = null;

                    /**
                     * GatewayOptions middleware.
                     * @member {Array.<clutch.config.gateway.v1.IMiddleware>} middleware
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.middleware = $util.emptyArray;

                    /**
                     * GatewayOptions assets.
                     * @member {clutch.config.gateway.v1.IAssets|null|undefined} assets
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.assets = null;

                    /**
                     * GatewayOptions enablePprof.
                     * @member {boolean} enablePprof
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.enablePprof = false;

                    /**
                     * GatewayOptions accesslog.
                     * @member {clutch.config.middleware.accesslog.v1.IConfig|null|undefined} accesslog
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.accesslog = null;

                    /**
                     * GatewayOptions maxResponseSizeBytes.
                     * @member {number} maxResponseSizeBytes
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.maxResponseSizeBytes = 0;

                    /**
                     * GatewayOptions secureCookies.
                     * @member {google.protobuf.IBoolValue|null|undefined} secureCookies
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.secureCookies = null;

                    /**
                     * Verifies a GatewayOptions message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GatewayOptions.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.listener != null && message.hasOwnProperty("listener")) {
                            let error = $root.clutch.config.gateway.v1.Listener.verify(message.listener);
                            if (error)
                                return "listener." + error;
                        }
                        if (message.jsonGrpcLoopbackListener != null && message.hasOwnProperty("jsonGrpcLoopbackListener")) {
                            let error = $root.clutch.config.gateway.v1.Listener.verify(message.jsonGrpcLoopbackListener);
                            if (error)
                                return "jsonGrpcLoopbackListener." + error;
                        }
                        if (message.logger != null && message.hasOwnProperty("logger")) {
                            let error = $root.clutch.config.gateway.v1.Logger.verify(message.logger);
                            if (error)
                                return "logger." + error;
                        }
                        if (message.stats != null && message.hasOwnProperty("stats")) {
                            let error = $root.clutch.config.gateway.v1.Stats.verify(message.stats);
                            if (error)
                                return "stats." + error;
                        }
                        if (message.timeouts != null && message.hasOwnProperty("timeouts")) {
                            let error = $root.clutch.config.gateway.v1.Timeouts.verify(message.timeouts);
                            if (error)
                                return "timeouts." + error;
                        }
                        if (message.middleware != null && message.hasOwnProperty("middleware")) {
                            if (!Array.isArray(message.middleware))
                                return "middleware: array expected";
                            for (let i = 0; i < message.middleware.length; ++i) {
                                let error = $root.clutch.config.gateway.v1.Middleware.verify(message.middleware[i]);
                                if (error)
                                    return "middleware." + error;
                            }
                        }
                        if (message.assets != null && message.hasOwnProperty("assets")) {
                            let error = $root.clutch.config.gateway.v1.Assets.verify(message.assets);
                            if (error)
                                return "assets." + error;
                        }
                        if (message.enablePprof != null && message.hasOwnProperty("enablePprof"))
                            if (typeof message.enablePprof !== "boolean")
                                return "enablePprof: boolean expected";
                        if (message.accesslog != null && message.hasOwnProperty("accesslog")) {
                            let error = $root.clutch.config.middleware.accesslog.v1.Config.verify(message.accesslog);
                            if (error)
                                return "accesslog." + error;
                        }
                        if (message.maxResponseSizeBytes != null && message.hasOwnProperty("maxResponseSizeBytes"))
                            if (!$util.isInteger(message.maxResponseSizeBytes))
                                return "maxResponseSizeBytes: integer expected";
                        if (message.secureCookies != null && message.hasOwnProperty("secureCookies")) {
                            let error = $root.google.protobuf.BoolValue.verify(message.secureCookies);
                            if (error)
                                return "secureCookies." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a GatewayOptions message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.GatewayOptions} GatewayOptions
                     */
                    GatewayOptions.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.GatewayOptions)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.GatewayOptions();
                        if (object.listener != null) {
                            if (typeof object.listener !== "object")
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.listener: object expected");
                            message.listener = $root.clutch.config.gateway.v1.Listener.fromObject(object.listener);
                        }
                        if (object.jsonGrpcLoopbackListener != null) {
                            if (typeof object.jsonGrpcLoopbackListener !== "object")
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.jsonGrpcLoopbackListener: object expected");
                            message.jsonGrpcLoopbackListener = $root.clutch.config.gateway.v1.Listener.fromObject(object.jsonGrpcLoopbackListener);
                        }
                        if (object.logger != null) {
                            if (typeof object.logger !== "object")
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.logger: object expected");
                            message.logger = $root.clutch.config.gateway.v1.Logger.fromObject(object.logger);
                        }
                        if (object.stats != null) {
                            if (typeof object.stats !== "object")
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.stats: object expected");
                            message.stats = $root.clutch.config.gateway.v1.Stats.fromObject(object.stats);
                        }
                        if (object.timeouts != null) {
                            if (typeof object.timeouts !== "object")
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.timeouts: object expected");
                            message.timeouts = $root.clutch.config.gateway.v1.Timeouts.fromObject(object.timeouts);
                        }
                        if (object.middleware) {
                            if (!Array.isArray(object.middleware))
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.middleware: array expected");
                            message.middleware = [];
                            for (let i = 0; i < object.middleware.length; ++i) {
                                if (typeof object.middleware[i] !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.GatewayOptions.middleware: object expected");
                                message.middleware[i] = $root.clutch.config.gateway.v1.Middleware.fromObject(object.middleware[i]);
                            }
                        }
                        if (object.assets != null) {
                            if (typeof object.assets !== "object")
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.assets: object expected");
                            message.assets = $root.clutch.config.gateway.v1.Assets.fromObject(object.assets);
                        }
                        if (object.enablePprof != null)
                            message.enablePprof = Boolean(object.enablePprof);
                        if (object.accesslog != null) {
                            if (typeof object.accesslog !== "object")
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.accesslog: object expected");
                            message.accesslog = $root.clutch.config.middleware.accesslog.v1.Config.fromObject(object.accesslog);
                        }
                        if (object.maxResponseSizeBytes != null)
                            message.maxResponseSizeBytes = object.maxResponseSizeBytes >>> 0;
                        if (object.secureCookies != null) {
                            if (typeof object.secureCookies !== "object")
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.secureCookies: object expected");
                            message.secureCookies = $root.google.protobuf.BoolValue.fromObject(object.secureCookies);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GatewayOptions message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @static
                     * @param {clutch.config.gateway.v1.GatewayOptions} message GatewayOptions
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GatewayOptions.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.middleware = [];
                        if (options.defaults) {
                            object.listener = null;
                            object.jsonGrpcLoopbackListener = null;
                            object.logger = null;
                            object.stats = null;
                            object.timeouts = null;
                            object.assets = null;
                            object.enablePprof = false;
                            object.accesslog = null;
                            object.maxResponseSizeBytes = 0;
                            object.secureCookies = null;
                        }
                        if (message.listener != null && message.hasOwnProperty("listener"))
                            object.listener = $root.clutch.config.gateway.v1.Listener.toObject(message.listener, options);
                        if (message.jsonGrpcLoopbackListener != null && message.hasOwnProperty("jsonGrpcLoopbackListener"))
                            object.jsonGrpcLoopbackListener = $root.clutch.config.gateway.v1.Listener.toObject(message.jsonGrpcLoopbackListener, options);
                        if (message.logger != null && message.hasOwnProperty("logger"))
                            object.logger = $root.clutch.config.gateway.v1.Logger.toObject(message.logger, options);
                        if (message.stats != null && message.hasOwnProperty("stats"))
                            object.stats = $root.clutch.config.gateway.v1.Stats.toObject(message.stats, options);
                        if (message.timeouts != null && message.hasOwnProperty("timeouts"))
                            object.timeouts = $root.clutch.config.gateway.v1.Timeouts.toObject(message.timeouts, options);
                        if (message.middleware && message.middleware.length) {
                            object.middleware = [];
                            for (let j = 0; j < message.middleware.length; ++j)
                                object.middleware[j] = $root.clutch.config.gateway.v1.Middleware.toObject(message.middleware[j], options);
                        }
                        if (message.assets != null && message.hasOwnProperty("assets"))
                            object.assets = $root.clutch.config.gateway.v1.Assets.toObject(message.assets, options);
                        if (message.enablePprof != null && message.hasOwnProperty("enablePprof"))
                            object.enablePprof = message.enablePprof;
                        if (message.accesslog != null && message.hasOwnProperty("accesslog"))
                            object.accesslog = $root.clutch.config.middleware.accesslog.v1.Config.toObject(message.accesslog, options);
                        if (message.maxResponseSizeBytes != null && message.hasOwnProperty("maxResponseSizeBytes"))
                            object.maxResponseSizeBytes = message.maxResponseSizeBytes;
                        if (message.secureCookies != null && message.hasOwnProperty("secureCookies"))
                            object.secureCookies = $root.google.protobuf.BoolValue.toObject(message.secureCookies, options);
                        return object;
                    };

                    /**
                     * Converts this GatewayOptions to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GatewayOptions.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GatewayOptions;
                })();

                v1.Assets = (function() {

                    /**
                     * Properties of an Assets.
                     * @memberof clutch.config.gateway.v1
                     * @interface IAssets
                     * @property {clutch.config.gateway.v1.Assets.IS3Provider|null} [s3] Assets s3
                     */

                    /**
                     * Constructs a new Assets.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents an Assets.
                     * @implements IAssets
                     * @constructor
                     * @param {clutch.config.gateway.v1.IAssets=} [properties] Properties to set
                     */
                    function Assets(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Assets s3.
                     * @member {clutch.config.gateway.v1.Assets.IS3Provider|null|undefined} s3
                     * @memberof clutch.config.gateway.v1.Assets
                     * @instance
                     */
                    Assets.prototype.s3 = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Assets provider.
                     * @member {"s3"|undefined} provider
                     * @memberof clutch.config.gateway.v1.Assets
                     * @instance
                     */
                    Object.defineProperty(Assets.prototype, "provider", {
                        get: $util.oneOfGetter($oneOfFields = ["s3"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies an Assets message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Assets
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Assets.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.s3 != null && message.hasOwnProperty("s3")) {
                            properties.provider = 1;
                            {
                                let error = $root.clutch.config.gateway.v1.Assets.S3Provider.verify(message.s3);
                                if (error)
                                    return "s3." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates an Assets message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Assets
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Assets} Assets
                     */
                    Assets.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Assets)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Assets();
                        if (object.s3 != null) {
                            if (typeof object.s3 !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Assets.s3: object expected");
                            message.s3 = $root.clutch.config.gateway.v1.Assets.S3Provider.fromObject(object.s3);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an Assets message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Assets
                     * @static
                     * @param {clutch.config.gateway.v1.Assets} message Assets
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Assets.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (message.s3 != null && message.hasOwnProperty("s3")) {
                            object.s3 = $root.clutch.config.gateway.v1.Assets.S3Provider.toObject(message.s3, options);
                            if (options.oneofs)
                                object.provider = "s3";
                        }
                        return object;
                    };

                    /**
                     * Converts this Assets to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Assets
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Assets.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Assets.S3Provider = (function() {

                        /**
                         * Properties of a S3Provider.
                         * @memberof clutch.config.gateway.v1.Assets
                         * @interface IS3Provider
                         * @property {string|null} [region] S3Provider region
                         * @property {string|null} [bucket] S3Provider bucket
                         * @property {string|null} [key] S3Provider key
                         */

                        /**
                         * Constructs a new S3Provider.
                         * @memberof clutch.config.gateway.v1.Assets
                         * @classdesc Represents a S3Provider.
                         * @implements IS3Provider
                         * @constructor
                         * @param {clutch.config.gateway.v1.Assets.IS3Provider=} [properties] Properties to set
                         */
                        function S3Provider(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * S3Provider region.
                         * @member {string} region
                         * @memberof clutch.config.gateway.v1.Assets.S3Provider
                         * @instance
                         */
                        S3Provider.prototype.region = "";

                        /**
                         * S3Provider bucket.
                         * @member {string} bucket
                         * @memberof clutch.config.gateway.v1.Assets.S3Provider
                         * @instance
                         */
                        S3Provider.prototype.bucket = "";

                        /**
                         * S3Provider key.
                         * @member {string} key
                         * @memberof clutch.config.gateway.v1.Assets.S3Provider
                         * @instance
                         */
                        S3Provider.prototype.key = "";

                        /**
                         * Verifies a S3Provider message.
                         * @function verify
                         * @memberof clutch.config.gateway.v1.Assets.S3Provider
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        S3Provider.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.region != null && message.hasOwnProperty("region"))
                                if (!$util.isString(message.region))
                                    return "region: string expected";
                            if (message.bucket != null && message.hasOwnProperty("bucket"))
                                if (!$util.isString(message.bucket))
                                    return "bucket: string expected";
                            if (message.key != null && message.hasOwnProperty("key"))
                                if (!$util.isString(message.key))
                                    return "key: string expected";
                            return null;
                        };

                        /**
                         * Creates a S3Provider message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.gateway.v1.Assets.S3Provider
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.gateway.v1.Assets.S3Provider} S3Provider
                         */
                        S3Provider.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.gateway.v1.Assets.S3Provider)
                                return object;
                            let message = new $root.clutch.config.gateway.v1.Assets.S3Provider();
                            if (object.region != null)
                                message.region = String(object.region);
                            if (object.bucket != null)
                                message.bucket = String(object.bucket);
                            if (object.key != null)
                                message.key = String(object.key);
                            return message;
                        };

                        /**
                         * Creates a plain object from a S3Provider message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.gateway.v1.Assets.S3Provider
                         * @static
                         * @param {clutch.config.gateway.v1.Assets.S3Provider} message S3Provider
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        S3Provider.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.region = "";
                                object.bucket = "";
                                object.key = "";
                            }
                            if (message.region != null && message.hasOwnProperty("region"))
                                object.region = message.region;
                            if (message.bucket != null && message.hasOwnProperty("bucket"))
                                object.bucket = message.bucket;
                            if (message.key != null && message.hasOwnProperty("key"))
                                object.key = message.key;
                            return object;
                        };

                        /**
                         * Converts this S3Provider to JSON.
                         * @function toJSON
                         * @memberof clutch.config.gateway.v1.Assets.S3Provider
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        S3Provider.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return S3Provider;
                    })();

                    return Assets;
                })();

                v1.Logger = (function() {

                    /**
                     * Properties of a Logger.
                     * @memberof clutch.config.gateway.v1
                     * @interface ILogger
                     * @property {clutch.config.gateway.v1.Logger.Level|null} [level] Logger level
                     * @property {boolean|null} [pretty] Logger pretty
                     * @property {string|null} [namespace] Logger namespace
                     */

                    /**
                     * Constructs a new Logger.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Logger.
                     * @implements ILogger
                     * @constructor
                     * @param {clutch.config.gateway.v1.ILogger=} [properties] Properties to set
                     */
                    function Logger(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Logger level.
                     * @member {clutch.config.gateway.v1.Logger.Level} level
                     * @memberof clutch.config.gateway.v1.Logger
                     * @instance
                     */
                    Logger.prototype.level = 0;

                    /**
                     * Logger pretty.
                     * @member {boolean|null|undefined} pretty
                     * @memberof clutch.config.gateway.v1.Logger
                     * @instance
                     */
                    Logger.prototype.pretty = null;

                    /**
                     * Logger namespace.
                     * @member {string} namespace
                     * @memberof clutch.config.gateway.v1.Logger
                     * @instance
                     */
                    Logger.prototype.namespace = "";

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Logger format.
                     * @member {"pretty"|undefined} format
                     * @memberof clutch.config.gateway.v1.Logger
                     * @instance
                     */
                    Object.defineProperty(Logger.prototype, "format", {
                        get: $util.oneOfGetter($oneOfFields = ["pretty"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies a Logger message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Logger
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Logger.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.level != null && message.hasOwnProperty("level"))
                            switch (message.level) {
                            default:
                                return "level: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                                break;
                            }
                        if (message.pretty != null && message.hasOwnProperty("pretty")) {
                            properties.format = 1;
                            if (typeof message.pretty !== "boolean")
                                return "pretty: boolean expected";
                        }
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            if (!$util.isString(message.namespace))
                                return "namespace: string expected";
                        return null;
                    };

                    /**
                     * Creates a Logger message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Logger
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Logger} Logger
                     */
                    Logger.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Logger)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Logger();
                        switch (object.level) {
                        case "UNSPECIFIED":
                        case 0:
                            message.level = 0;
                            break;
                        case "DEBUG":
                        case 1:
                            message.level = 1;
                            break;
                        case "INFO":
                        case 2:
                            message.level = 2;
                            break;
                        case "WARN":
                        case 3:
                            message.level = 3;
                            break;
                        case "ERROR":
                        case 4:
                            message.level = 4;
                            break;
                        case "PANIC":
                        case 5:
                            message.level = 5;
                            break;
                        case "FATAL":
                        case 6:
                            message.level = 6;
                            break;
                        }
                        if (object.pretty != null)
                            message.pretty = Boolean(object.pretty);
                        if (object.namespace != null)
                            message.namespace = String(object.namespace);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Logger message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Logger
                     * @static
                     * @param {clutch.config.gateway.v1.Logger} message Logger
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Logger.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.level = options.enums === String ? "UNSPECIFIED" : 0;
                            object.namespace = "";
                        }
                        if (message.level != null && message.hasOwnProperty("level"))
                            object.level = options.enums === String ? $root.clutch.config.gateway.v1.Logger.Level[message.level] : message.level;
                        if (message.pretty != null && message.hasOwnProperty("pretty")) {
                            object.pretty = message.pretty;
                            if (options.oneofs)
                                object.format = "pretty";
                        }
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            object.namespace = message.namespace;
                        return object;
                    };

                    /**
                     * Converts this Logger to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Logger
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Logger.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Level enum.
                     * @name clutch.config.gateway.v1.Logger.Level
                     * @enum {number}
                     * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                     * @property {number} DEBUG=1 DEBUG value
                     * @property {number} INFO=2 INFO value
                     * @property {number} WARN=3 WARN value
                     * @property {number} ERROR=4 ERROR value
                     * @property {number} PANIC=5 PANIC value
                     * @property {number} FATAL=6 FATAL value
                     */
                    Logger.Level = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNSPECIFIED"] = 0;
                        values[valuesById[1] = "DEBUG"] = 1;
                        values[valuesById[2] = "INFO"] = 2;
                        values[valuesById[3] = "WARN"] = 3;
                        values[valuesById[4] = "ERROR"] = 4;
                        values[valuesById[5] = "PANIC"] = 5;
                        values[valuesById[6] = "FATAL"] = 6;
                        return values;
                    })();

                    return Logger;
                })();

                v1.Middleware = (function() {

                    /**
                     * Properties of a Middleware.
                     * @memberof clutch.config.gateway.v1
                     * @interface IMiddleware
                     * @property {string|null} [name] Middleware name
                     * @property {google.protobuf.IAny|null} [typedConfig] Middleware typedConfig
                     */

                    /**
                     * Constructs a new Middleware.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Middleware.
                     * @implements IMiddleware
                     * @constructor
                     * @param {clutch.config.gateway.v1.IMiddleware=} [properties] Properties to set
                     */
                    function Middleware(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Middleware name.
                     * @member {string} name
                     * @memberof clutch.config.gateway.v1.Middleware
                     * @instance
                     */
                    Middleware.prototype.name = "";

                    /**
                     * Middleware typedConfig.
                     * @member {google.protobuf.IAny|null|undefined} typedConfig
                     * @memberof clutch.config.gateway.v1.Middleware
                     * @instance
                     */
                    Middleware.prototype.typedConfig = null;

                    /**
                     * Verifies a Middleware message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Middleware
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Middleware.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig")) {
                            let error = $root.google.protobuf.Any.verify(message.typedConfig);
                            if (error)
                                return "typedConfig." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Middleware message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Middleware
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Middleware} Middleware
                     */
                    Middleware.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Middleware)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Middleware();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.typedConfig != null) {
                            if (typeof object.typedConfig !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Middleware.typedConfig: object expected");
                            message.typedConfig = $root.google.protobuf.Any.fromObject(object.typedConfig);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Middleware message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Middleware
                     * @static
                     * @param {clutch.config.gateway.v1.Middleware} message Middleware
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Middleware.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.typedConfig = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig"))
                            object.typedConfig = $root.google.protobuf.Any.toObject(message.typedConfig, options);
                        return object;
                    };

                    /**
                     * Converts this Middleware to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Middleware
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Middleware.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Middleware;
                })();

                v1.Service = (function() {

                    /**
                     * Properties of a Service.
                     * @memberof clutch.config.gateway.v1
                     * @interface IService
                     * @property {string|null} [name] Service name
                     * @property {google.protobuf.IAny|null} [typedConfig] Service typedConfig
                     */

                    /**
                     * Constructs a new Service.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Service.
                     * @implements IService
                     * @constructor
                     * @param {clutch.config.gateway.v1.IService=} [properties] Properties to set
                     */
                    function Service(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Service name.
                     * @member {string} name
                     * @memberof clutch.config.gateway.v1.Service
                     * @instance
                     */
                    Service.prototype.name = "";

                    /**
                     * Service typedConfig.
                     * @member {google.protobuf.IAny|null|undefined} typedConfig
                     * @memberof clutch.config.gateway.v1.Service
                     * @instance
                     */
                    Service.prototype.typedConfig = null;

                    /**
                     * Verifies a Service message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Service
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Service.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig")) {
                            let error = $root.google.protobuf.Any.verify(message.typedConfig);
                            if (error)
                                return "typedConfig." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Service message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Service
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Service} Service
                     */
                    Service.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Service)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Service();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.typedConfig != null) {
                            if (typeof object.typedConfig !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Service.typedConfig: object expected");
                            message.typedConfig = $root.google.protobuf.Any.fromObject(object.typedConfig);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Service message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Service
                     * @static
                     * @param {clutch.config.gateway.v1.Service} message Service
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Service.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.typedConfig = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig"))
                            object.typedConfig = $root.google.protobuf.Any.toObject(message.typedConfig, options);
                        return object;
                    };

                    /**
                     * Converts this Service to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Service
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Service.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Service;
                })();

                v1.Resolver = (function() {

                    /**
                     * Properties of a Resolver.
                     * @memberof clutch.config.gateway.v1
                     * @interface IResolver
                     * @property {string|null} [name] Resolver name
                     * @property {google.protobuf.IAny|null} [typedConfig] Resolver typedConfig
                     */

                    /**
                     * Constructs a new Resolver.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Resolver.
                     * @implements IResolver
                     * @constructor
                     * @param {clutch.config.gateway.v1.IResolver=} [properties] Properties to set
                     */
                    function Resolver(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Resolver name.
                     * @member {string} name
                     * @memberof clutch.config.gateway.v1.Resolver
                     * @instance
                     */
                    Resolver.prototype.name = "";

                    /**
                     * Resolver typedConfig.
                     * @member {google.protobuf.IAny|null|undefined} typedConfig
                     * @memberof clutch.config.gateway.v1.Resolver
                     * @instance
                     */
                    Resolver.prototype.typedConfig = null;

                    /**
                     * Verifies a Resolver message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Resolver
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Resolver.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig")) {
                            let error = $root.google.protobuf.Any.verify(message.typedConfig);
                            if (error)
                                return "typedConfig." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Resolver message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Resolver
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Resolver} Resolver
                     */
                    Resolver.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Resolver)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Resolver();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.typedConfig != null) {
                            if (typeof object.typedConfig !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Resolver.typedConfig: object expected");
                            message.typedConfig = $root.google.protobuf.Any.fromObject(object.typedConfig);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Resolver message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Resolver
                     * @static
                     * @param {clutch.config.gateway.v1.Resolver} message Resolver
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Resolver.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.typedConfig = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig"))
                            object.typedConfig = $root.google.protobuf.Any.toObject(message.typedConfig, options);
                        return object;
                    };

                    /**
                     * Converts this Resolver to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Resolver
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Resolver.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Resolver;
                })();

                v1.Module = (function() {

                    /**
                     * Properties of a Module.
                     * @memberof clutch.config.gateway.v1
                     * @interface IModule
                     * @property {string|null} [name] Module name
                     * @property {google.protobuf.IAny|null} [typedConfig] Module typedConfig
                     */

                    /**
                     * Constructs a new Module.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Module.
                     * @implements IModule
                     * @constructor
                     * @param {clutch.config.gateway.v1.IModule=} [properties] Properties to set
                     */
                    function Module(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Module name.
                     * @member {string} name
                     * @memberof clutch.config.gateway.v1.Module
                     * @instance
                     */
                    Module.prototype.name = "";

                    /**
                     * Module typedConfig.
                     * @member {google.protobuf.IAny|null|undefined} typedConfig
                     * @memberof clutch.config.gateway.v1.Module
                     * @instance
                     */
                    Module.prototype.typedConfig = null;

                    /**
                     * Verifies a Module message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Module
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Module.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig")) {
                            let error = $root.google.protobuf.Any.verify(message.typedConfig);
                            if (error)
                                return "typedConfig." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Module message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Module
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Module} Module
                     */
                    Module.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Module)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Module();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.typedConfig != null) {
                            if (typeof object.typedConfig !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Module.typedConfig: object expected");
                            message.typedConfig = $root.google.protobuf.Any.fromObject(object.typedConfig);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Module message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Module
                     * @static
                     * @param {clutch.config.gateway.v1.Module} message Module
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Module.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.typedConfig = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig"))
                            object.typedConfig = $root.google.protobuf.Any.toObject(message.typedConfig, options);
                        return object;
                    };

                    /**
                     * Converts this Module to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Module
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Module.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Module;
                })();

                return v1;
            })();

            return gateway;
        })();

        config.middleware = (function() {

            /**
             * Namespace middleware.
             * @memberof clutch.config
             * @namespace
             */
            const middleware = {};

            middleware.accesslog = (function() {

                /**
                 * Namespace accesslog.
                 * @memberof clutch.config.middleware
                 * @namespace
                 */
                const accesslog = {};

                accesslog.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.middleware.accesslog
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.middleware.accesslog.v1
                         * @interface IConfig
                         * @property {Array.<clutch.config.middleware.accesslog.v1.Config.IStatusCodeFilter>|null} [statusCodeFilters] Config statusCodeFilters
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.middleware.accesslog.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.middleware.accesslog.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            this.statusCodeFilters = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config statusCodeFilters.
                         * @member {Array.<clutch.config.middleware.accesslog.v1.Config.IStatusCodeFilter>} statusCodeFilters
                         * @memberof clutch.config.middleware.accesslog.v1.Config
                         * @instance
                         */
                        Config.prototype.statusCodeFilters = $util.emptyArray;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.middleware.accesslog.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.statusCodeFilters != null && message.hasOwnProperty("statusCodeFilters")) {
                                if (!Array.isArray(message.statusCodeFilters))
                                    return "statusCodeFilters: array expected";
                                for (let i = 0; i < message.statusCodeFilters.length; ++i) {
                                    let error = $root.clutch.config.middleware.accesslog.v1.Config.StatusCodeFilter.verify(message.statusCodeFilters[i]);
                                    if (error)
                                        return "statusCodeFilters." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.middleware.accesslog.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.middleware.accesslog.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.middleware.accesslog.v1.Config)
                                return object;
                            let message = new $root.clutch.config.middleware.accesslog.v1.Config();
                            if (object.statusCodeFilters) {
                                if (!Array.isArray(object.statusCodeFilters))
                                    throw TypeError(".clutch.config.middleware.accesslog.v1.Config.statusCodeFilters: array expected");
                                message.statusCodeFilters = [];
                                for (let i = 0; i < object.statusCodeFilters.length; ++i) {
                                    if (typeof object.statusCodeFilters[i] !== "object")
                                        throw TypeError(".clutch.config.middleware.accesslog.v1.Config.statusCodeFilters: object expected");
                                    message.statusCodeFilters[i] = $root.clutch.config.middleware.accesslog.v1.Config.StatusCodeFilter.fromObject(object.statusCodeFilters[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.middleware.accesslog.v1.Config
                         * @static
                         * @param {clutch.config.middleware.accesslog.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.statusCodeFilters = [];
                            if (message.statusCodeFilters && message.statusCodeFilters.length) {
                                object.statusCodeFilters = [];
                                for (let j = 0; j < message.statusCodeFilters.length; ++j)
                                    object.statusCodeFilters[j] = $root.clutch.config.middleware.accesslog.v1.Config.StatusCodeFilter.toObject(message.statusCodeFilters[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.middleware.accesslog.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        Config.StatusCodeFilter = (function() {

                            /**
                             * Properties of a StatusCodeFilter.
                             * @memberof clutch.config.middleware.accesslog.v1.Config
                             * @interface IStatusCodeFilter
                             * @property {number|null} [equals] StatusCodeFilter equals
                             */

                            /**
                             * Constructs a new StatusCodeFilter.
                             * @memberof clutch.config.middleware.accesslog.v1.Config
                             * @classdesc Represents a StatusCodeFilter.
                             * @implements IStatusCodeFilter
                             * @constructor
                             * @param {clutch.config.middleware.accesslog.v1.Config.IStatusCodeFilter=} [properties] Properties to set
                             */
                            function StatusCodeFilter(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * StatusCodeFilter equals.
                             * @member {number|null|undefined} equals
                             * @memberof clutch.config.middleware.accesslog.v1.Config.StatusCodeFilter
                             * @instance
                             */
                            StatusCodeFilter.prototype.equals = null;

                            // OneOf field names bound to virtual getters and setters
                            let $oneOfFields;

                            /**
                             * StatusCodeFilter filterType.
                             * @member {"equals"|undefined} filterType
                             * @memberof clutch.config.middleware.accesslog.v1.Config.StatusCodeFilter
                             * @instance
                             */
                            Object.defineProperty(StatusCodeFilter.prototype, "filterType", {
                                get: $util.oneOfGetter($oneOfFields = ["equals"]),
                                set: $util.oneOfSetter($oneOfFields)
                            });

                            /**
                             * Verifies a StatusCodeFilter message.
                             * @function verify
                             * @memberof clutch.config.middleware.accesslog.v1.Config.StatusCodeFilter
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            StatusCodeFilter.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                let properties = {};
                                if (message.equals != null && message.hasOwnProperty("equals")) {
                                    properties.filterType = 1;
                                    if (!$util.isInteger(message.equals))
                                        return "equals: integer expected";
                                }
                                return null;
                            };

                            /**
                             * Creates a StatusCodeFilter message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof clutch.config.middleware.accesslog.v1.Config.StatusCodeFilter
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {clutch.config.middleware.accesslog.v1.Config.StatusCodeFilter} StatusCodeFilter
                             */
                            StatusCodeFilter.fromObject = function fromObject(object) {
                                if (object instanceof $root.clutch.config.middleware.accesslog.v1.Config.StatusCodeFilter)
                                    return object;
                                let message = new $root.clutch.config.middleware.accesslog.v1.Config.StatusCodeFilter();
                                if (object.equals != null)
                                    message.equals = object.equals >>> 0;
                                return message;
                            };

                            /**
                             * Creates a plain object from a StatusCodeFilter message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof clutch.config.middleware.accesslog.v1.Config.StatusCodeFilter
                             * @static
                             * @param {clutch.config.middleware.accesslog.v1.Config.StatusCodeFilter} message StatusCodeFilter
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            StatusCodeFilter.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (message.equals != null && message.hasOwnProperty("equals")) {
                                    object.equals = message.equals;
                                    if (options.oneofs)
                                        object.filterType = "equals";
                                }
                                return object;
                            };

                            /**
                             * Converts this StatusCodeFilter to JSON.
                             * @function toJSON
                             * @memberof clutch.config.middleware.accesslog.v1.Config.StatusCodeFilter
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            StatusCodeFilter.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return StatusCodeFilter;
                        })();

                        return Config;
                    })();

                    return v1;
                })();

                return accesslog;
            })();

            return middleware;
        })();

        config.module = (function() {

            /**
             * Namespace module.
             * @memberof clutch.config
             * @namespace
             */
            const module = {};

            module.bot = (function() {

                /**
                 * Namespace bot.
                 * @memberof clutch.config.module
                 * @namespace
                 */
                const bot = {};

                bot.slackbot = (function() {

                    /**
                     * Namespace slackbot.
                     * @memberof clutch.config.module.bot
                     * @namespace
                     */
                    const slackbot = {};

                    slackbot.v1 = (function() {

                        /**
                         * Namespace v1.
                         * @memberof clutch.config.module.bot.slackbot
                         * @namespace
                         */
                        const v1 = {};

                        v1.Config = (function() {

                            /**
                             * Properties of a Config.
                             * @memberof clutch.config.module.bot.slackbot.v1
                             * @interface IConfig
                             * @property {string|null} [botToken] Config botToken
                             * @property {string|null} [signingSecret] Config signingSecret
                             * @property {string|null} [verificationToken] Config verificationToken
                             */

                            /**
                             * Constructs a new Config.
                             * @memberof clutch.config.module.bot.slackbot.v1
                             * @classdesc Represents a Config.
                             * @implements IConfig
                             * @constructor
                             * @param {clutch.config.module.bot.slackbot.v1.IConfig=} [properties] Properties to set
                             */
                            function Config(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Config botToken.
                             * @member {string} botToken
                             * @memberof clutch.config.module.bot.slackbot.v1.Config
                             * @instance
                             */
                            Config.prototype.botToken = "";

                            /**
                             * Config signingSecret.
                             * @member {string} signingSecret
                             * @memberof clutch.config.module.bot.slackbot.v1.Config
                             * @instance
                             */
                            Config.prototype.signingSecret = "";

                            /**
                             * Config verificationToken.
                             * @member {string} verificationToken
                             * @memberof clutch.config.module.bot.slackbot.v1.Config
                             * @instance
                             */
                            Config.prototype.verificationToken = "";

                            /**
                             * Verifies a Config message.
                             * @function verify
                             * @memberof clutch.config.module.bot.slackbot.v1.Config
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Config.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.botToken != null && message.hasOwnProperty("botToken"))
                                    if (!$util.isString(message.botToken))
                                        return "botToken: string expected";
                                if (message.signingSecret != null && message.hasOwnProperty("signingSecret"))
                                    if (!$util.isString(message.signingSecret))
                                        return "signingSecret: string expected";
                                if (message.verificationToken != null && message.hasOwnProperty("verificationToken"))
                                    if (!$util.isString(message.verificationToken))
                                        return "verificationToken: string expected";
                                return null;
                            };

                            /**
                             * Creates a Config message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof clutch.config.module.bot.slackbot.v1.Config
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {clutch.config.module.bot.slackbot.v1.Config} Config
                             */
                            Config.fromObject = function fromObject(object) {
                                if (object instanceof $root.clutch.config.module.bot.slackbot.v1.Config)
                                    return object;
                                let message = new $root.clutch.config.module.bot.slackbot.v1.Config();
                                if (object.botToken != null)
                                    message.botToken = String(object.botToken);
                                if (object.signingSecret != null)
                                    message.signingSecret = String(object.signingSecret);
                                if (object.verificationToken != null)
                                    message.verificationToken = String(object.verificationToken);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Config message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof clutch.config.module.bot.slackbot.v1.Config
                             * @static
                             * @param {clutch.config.module.bot.slackbot.v1.Config} message Config
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Config.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.botToken = "";
                                    object.signingSecret = "";
                                    object.verificationToken = "";
                                }
                                if (message.botToken != null && message.hasOwnProperty("botToken"))
                                    object.botToken = message.botToken;
                                if (message.signingSecret != null && message.hasOwnProperty("signingSecret"))
                                    object.signingSecret = message.signingSecret;
                                if (message.verificationToken != null && message.hasOwnProperty("verificationToken"))
                                    object.verificationToken = message.verificationToken;
                                return object;
                            };

                            /**
                             * Converts this Config to JSON.
                             * @function toJSON
                             * @memberof clutch.config.module.bot.slackbot.v1.Config
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Config.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Config;
                        })();

                        return v1;
                    })();

                    return slackbot;
                })();

                return bot;
            })();

            module.chaos = (function() {

                /**
                 * Namespace chaos.
                 * @memberof clutch.config.module
                 * @namespace
                 */
                const chaos = {};

                chaos.experimentation = (function() {

                    /**
                     * Namespace experimentation.
                     * @memberof clutch.config.module.chaos
                     * @namespace
                     */
                    const experimentation = {};

                    experimentation.xds = (function() {

                        /**
                         * Namespace xds.
                         * @memberof clutch.config.module.chaos.experimentation
                         * @namespace
                         */
                        const xds = {};

                        xds.v1 = (function() {

                            /**
                             * Namespace v1.
                             * @memberof clutch.config.module.chaos.experimentation.xds
                             * @namespace
                             */
                            const v1 = {};

                            v1.Config = (function() {

                                /**
                                 * Properties of a Config.
                                 * @memberof clutch.config.module.chaos.experimentation.xds.v1
                                 * @interface IConfig
                                 * @property {google.protobuf.IDuration|null} [cacheRefreshInterval] Config cacheRefreshInterval
                                 * @property {string|null} [rtdsLayerName] Config rtdsLayerName
                                 * @property {google.protobuf.IDuration|null} [resourceTtl] Config resourceTtl
                                 * @property {google.protobuf.IDuration|null} [heartbeatInterval] Config heartbeatInterval
                                 * @property {clutch.config.module.chaos.experimentation.xds.v1.Config.IECDSAllowList|null} [ecdsAllowList] Config ecdsAllowList
                                 */

                                /**
                                 * Constructs a new Config.
                                 * @memberof clutch.config.module.chaos.experimentation.xds.v1
                                 * @classdesc Represents a Config.
                                 * @implements IConfig
                                 * @constructor
                                 * @param {clutch.config.module.chaos.experimentation.xds.v1.IConfig=} [properties] Properties to set
                                 */
                                function Config(properties) {
                                    if (properties)
                                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Config cacheRefreshInterval.
                                 * @member {google.protobuf.IDuration|null|undefined} cacheRefreshInterval
                                 * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config
                                 * @instance
                                 */
                                Config.prototype.cacheRefreshInterval = null;

                                /**
                                 * Config rtdsLayerName.
                                 * @member {string} rtdsLayerName
                                 * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config
                                 * @instance
                                 */
                                Config.prototype.rtdsLayerName = "";

                                /**
                                 * Config resourceTtl.
                                 * @member {google.protobuf.IDuration|null|undefined} resourceTtl
                                 * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config
                                 * @instance
                                 */
                                Config.prototype.resourceTtl = null;

                                /**
                                 * Config heartbeatInterval.
                                 * @member {google.protobuf.IDuration|null|undefined} heartbeatInterval
                                 * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config
                                 * @instance
                                 */
                                Config.prototype.heartbeatInterval = null;

                                /**
                                 * Config ecdsAllowList.
                                 * @member {clutch.config.module.chaos.experimentation.xds.v1.Config.IECDSAllowList|null|undefined} ecdsAllowList
                                 * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config
                                 * @instance
                                 */
                                Config.prototype.ecdsAllowList = null;

                                /**
                                 * Verifies a Config message.
                                 * @function verify
                                 * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Config.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.cacheRefreshInterval != null && message.hasOwnProperty("cacheRefreshInterval")) {
                                        let error = $root.google.protobuf.Duration.verify(message.cacheRefreshInterval);
                                        if (error)
                                            return "cacheRefreshInterval." + error;
                                    }
                                    if (message.rtdsLayerName != null && message.hasOwnProperty("rtdsLayerName"))
                                        if (!$util.isString(message.rtdsLayerName))
                                            return "rtdsLayerName: string expected";
                                    if (message.resourceTtl != null && message.hasOwnProperty("resourceTtl")) {
                                        let error = $root.google.protobuf.Duration.verify(message.resourceTtl);
                                        if (error)
                                            return "resourceTtl." + error;
                                    }
                                    if (message.heartbeatInterval != null && message.hasOwnProperty("heartbeatInterval")) {
                                        let error = $root.google.protobuf.Duration.verify(message.heartbeatInterval);
                                        if (error)
                                            return "heartbeatInterval." + error;
                                    }
                                    if (message.ecdsAllowList != null && message.hasOwnProperty("ecdsAllowList")) {
                                        let error = $root.clutch.config.module.chaos.experimentation.xds.v1.Config.ECDSAllowList.verify(message.ecdsAllowList);
                                        if (error)
                                            return "ecdsAllowList." + error;
                                    }
                                    return null;
                                };

                                /**
                                 * Creates a Config message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {clutch.config.module.chaos.experimentation.xds.v1.Config} Config
                                 */
                                Config.fromObject = function fromObject(object) {
                                    if (object instanceof $root.clutch.config.module.chaos.experimentation.xds.v1.Config)
                                        return object;
                                    let message = new $root.clutch.config.module.chaos.experimentation.xds.v1.Config();
                                    if (object.cacheRefreshInterval != null) {
                                        if (typeof object.cacheRefreshInterval !== "object")
                                            throw TypeError(".clutch.config.module.chaos.experimentation.xds.v1.Config.cacheRefreshInterval: object expected");
                                        message.cacheRefreshInterval = $root.google.protobuf.Duration.fromObject(object.cacheRefreshInterval);
                                    }
                                    if (object.rtdsLayerName != null)
                                        message.rtdsLayerName = String(object.rtdsLayerName);
                                    if (object.resourceTtl != null) {
                                        if (typeof object.resourceTtl !== "object")
                                            throw TypeError(".clutch.config.module.chaos.experimentation.xds.v1.Config.resourceTtl: object expected");
                                        message.resourceTtl = $root.google.protobuf.Duration.fromObject(object.resourceTtl);
                                    }
                                    if (object.heartbeatInterval != null) {
                                        if (typeof object.heartbeatInterval !== "object")
                                            throw TypeError(".clutch.config.module.chaos.experimentation.xds.v1.Config.heartbeatInterval: object expected");
                                        message.heartbeatInterval = $root.google.protobuf.Duration.fromObject(object.heartbeatInterval);
                                    }
                                    if (object.ecdsAllowList != null) {
                                        if (typeof object.ecdsAllowList !== "object")
                                            throw TypeError(".clutch.config.module.chaos.experimentation.xds.v1.Config.ecdsAllowList: object expected");
                                        message.ecdsAllowList = $root.clutch.config.module.chaos.experimentation.xds.v1.Config.ECDSAllowList.fromObject(object.ecdsAllowList);
                                    }
                                    return message;
                                };

                                /**
                                 * Creates a plain object from a Config message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config
                                 * @static
                                 * @param {clutch.config.module.chaos.experimentation.xds.v1.Config} message Config
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Config.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    let object = {};
                                    if (options.defaults) {
                                        object.cacheRefreshInterval = null;
                                        object.rtdsLayerName = "";
                                        object.resourceTtl = null;
                                        object.heartbeatInterval = null;
                                        object.ecdsAllowList = null;
                                    }
                                    if (message.cacheRefreshInterval != null && message.hasOwnProperty("cacheRefreshInterval"))
                                        object.cacheRefreshInterval = $root.google.protobuf.Duration.toObject(message.cacheRefreshInterval, options);
                                    if (message.rtdsLayerName != null && message.hasOwnProperty("rtdsLayerName"))
                                        object.rtdsLayerName = message.rtdsLayerName;
                                    if (message.resourceTtl != null && message.hasOwnProperty("resourceTtl"))
                                        object.resourceTtl = $root.google.protobuf.Duration.toObject(message.resourceTtl, options);
                                    if (message.heartbeatInterval != null && message.hasOwnProperty("heartbeatInterval"))
                                        object.heartbeatInterval = $root.google.protobuf.Duration.toObject(message.heartbeatInterval, options);
                                    if (message.ecdsAllowList != null && message.hasOwnProperty("ecdsAllowList"))
                                        object.ecdsAllowList = $root.clutch.config.module.chaos.experimentation.xds.v1.Config.ECDSAllowList.toObject(message.ecdsAllowList, options);
                                    return object;
                                };

                                /**
                                 * Converts this Config to JSON.
                                 * @function toJSON
                                 * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Config.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                Config.ECDSAllowList = (function() {

                                    /**
                                     * Properties of a ECDSAllowList.
                                     * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config
                                     * @interface IECDSAllowList
                                     * @property {Array.<string>|null} [enabledClusters] ECDSAllowList enabledClusters
                                     */

                                    /**
                                     * Constructs a new ECDSAllowList.
                                     * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config
                                     * @classdesc Represents a ECDSAllowList.
                                     * @implements IECDSAllowList
                                     * @constructor
                                     * @param {clutch.config.module.chaos.experimentation.xds.v1.Config.IECDSAllowList=} [properties] Properties to set
                                     */
                                    function ECDSAllowList(properties) {
                                        this.enabledClusters = [];
                                        if (properties)
                                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                                if (properties[keys[i]] != null)
                                                    this[keys[i]] = properties[keys[i]];
                                    }

                                    /**
                                     * ECDSAllowList enabledClusters.
                                     * @member {Array.<string>} enabledClusters
                                     * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config.ECDSAllowList
                                     * @instance
                                     */
                                    ECDSAllowList.prototype.enabledClusters = $util.emptyArray;

                                    /**
                                     * Verifies a ECDSAllowList message.
                                     * @function verify
                                     * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config.ECDSAllowList
                                     * @static
                                     * @param {Object.<string,*>} message Plain object to verify
                                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                     */
                                    ECDSAllowList.verify = function verify(message) {
                                        if (typeof message !== "object" || message === null)
                                            return "object expected";
                                        if (message.enabledClusters != null && message.hasOwnProperty("enabledClusters")) {
                                            if (!Array.isArray(message.enabledClusters))
                                                return "enabledClusters: array expected";
                                            for (let i = 0; i < message.enabledClusters.length; ++i)
                                                if (!$util.isString(message.enabledClusters[i]))
                                                    return "enabledClusters: string[] expected";
                                        }
                                        return null;
                                    };

                                    /**
                                     * Creates a ECDSAllowList message from a plain object. Also converts values to their respective internal types.
                                     * @function fromObject
                                     * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config.ECDSAllowList
                                     * @static
                                     * @param {Object.<string,*>} object Plain object
                                     * @returns {clutch.config.module.chaos.experimentation.xds.v1.Config.ECDSAllowList} ECDSAllowList
                                     */
                                    ECDSAllowList.fromObject = function fromObject(object) {
                                        if (object instanceof $root.clutch.config.module.chaos.experimentation.xds.v1.Config.ECDSAllowList)
                                            return object;
                                        let message = new $root.clutch.config.module.chaos.experimentation.xds.v1.Config.ECDSAllowList();
                                        if (object.enabledClusters) {
                                            if (!Array.isArray(object.enabledClusters))
                                                throw TypeError(".clutch.config.module.chaos.experimentation.xds.v1.Config.ECDSAllowList.enabledClusters: array expected");
                                            message.enabledClusters = [];
                                            for (let i = 0; i < object.enabledClusters.length; ++i)
                                                message.enabledClusters[i] = String(object.enabledClusters[i]);
                                        }
                                        return message;
                                    };

                                    /**
                                     * Creates a plain object from a ECDSAllowList message. Also converts values to other types if specified.
                                     * @function toObject
                                     * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config.ECDSAllowList
                                     * @static
                                     * @param {clutch.config.module.chaos.experimentation.xds.v1.Config.ECDSAllowList} message ECDSAllowList
                                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                                     * @returns {Object.<string,*>} Plain object
                                     */
                                    ECDSAllowList.toObject = function toObject(message, options) {
                                        if (!options)
                                            options = {};
                                        let object = {};
                                        if (options.arrays || options.defaults)
                                            object.enabledClusters = [];
                                        if (message.enabledClusters && message.enabledClusters.length) {
                                            object.enabledClusters = [];
                                            for (let j = 0; j < message.enabledClusters.length; ++j)
                                                object.enabledClusters[j] = message.enabledClusters[j];
                                        }
                                        return object;
                                    };

                                    /**
                                     * Converts this ECDSAllowList to JSON.
                                     * @function toJSON
                                     * @memberof clutch.config.module.chaos.experimentation.xds.v1.Config.ECDSAllowList
                                     * @instance
                                     * @returns {Object.<string,*>} JSON object
                                     */
                                    ECDSAllowList.prototype.toJSON = function toJSON() {
                                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                    };

                                    return ECDSAllowList;
                                })();

                                return Config;
                            })();

                            return v1;
                        })();

                        return xds;
                    })();

                    return experimentation;
                })();

                chaos.redisexperimentation = (function() {

                    /**
                     * Namespace redisexperimentation.
                     * @memberof clutch.config.module.chaos
                     * @namespace
                     */
                    const redisexperimentation = {};

                    redisexperimentation.v1 = (function() {

                        /**
                         * Namespace v1.
                         * @memberof clutch.config.module.chaos.redisexperimentation
                         * @namespace
                         */
                        const v1 = {};

                        v1.Config = (function() {

                            /**
                             * Properties of a Config.
                             * @memberof clutch.config.module.chaos.redisexperimentation.v1
                             * @interface IConfig
                             * @property {string|null} [faultRuntimePrefix] Config faultRuntimePrefix
                             */

                            /**
                             * Constructs a new Config.
                             * @memberof clutch.config.module.chaos.redisexperimentation.v1
                             * @classdesc Represents a Config.
                             * @implements IConfig
                             * @constructor
                             * @param {clutch.config.module.chaos.redisexperimentation.v1.IConfig=} [properties] Properties to set
                             */
                            function Config(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Config faultRuntimePrefix.
                             * @member {string} faultRuntimePrefix
                             * @memberof clutch.config.module.chaos.redisexperimentation.v1.Config
                             * @instance
                             */
                            Config.prototype.faultRuntimePrefix = "";

                            /**
                             * Verifies a Config message.
                             * @function verify
                             * @memberof clutch.config.module.chaos.redisexperimentation.v1.Config
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Config.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.faultRuntimePrefix != null && message.hasOwnProperty("faultRuntimePrefix"))
                                    if (!$util.isString(message.faultRuntimePrefix))
                                        return "faultRuntimePrefix: string expected";
                                return null;
                            };

                            /**
                             * Creates a Config message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof clutch.config.module.chaos.redisexperimentation.v1.Config
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {clutch.config.module.chaos.redisexperimentation.v1.Config} Config
                             */
                            Config.fromObject = function fromObject(object) {
                                if (object instanceof $root.clutch.config.module.chaos.redisexperimentation.v1.Config)
                                    return object;
                                let message = new $root.clutch.config.module.chaos.redisexperimentation.v1.Config();
                                if (object.faultRuntimePrefix != null)
                                    message.faultRuntimePrefix = String(object.faultRuntimePrefix);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Config message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof clutch.config.module.chaos.redisexperimentation.v1.Config
                             * @static
                             * @param {clutch.config.module.chaos.redisexperimentation.v1.Config} message Config
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Config.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults)
                                    object.faultRuntimePrefix = "";
                                if (message.faultRuntimePrefix != null && message.hasOwnProperty("faultRuntimePrefix"))
                                    object.faultRuntimePrefix = message.faultRuntimePrefix;
                                return object;
                            };

                            /**
                             * Converts this Config to JSON.
                             * @function toJSON
                             * @memberof clutch.config.module.chaos.redisexperimentation.v1.Config
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Config.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Config;
                        })();

                        return v1;
                    })();

                    return redisexperimentation;
                })();

                chaos.serverexperimentation = (function() {

                    /**
                     * Namespace serverexperimentation.
                     * @memberof clutch.config.module.chaos
                     * @namespace
                     */
                    const serverexperimentation = {};

                    serverexperimentation.v1 = (function() {

                        /**
                         * Namespace v1.
                         * @memberof clutch.config.module.chaos.serverexperimentation
                         * @namespace
                         */
                        const v1 = {};

                        v1.Config = (function() {

                            /**
                             * Properties of a Config.
                             * @memberof clutch.config.module.chaos.serverexperimentation.v1
                             * @interface IConfig
                             * @property {string|null} [ingressFaultRuntimePrefix] Config ingressFaultRuntimePrefix
                             * @property {string|null} [egressFaultRuntimePrefix] Config egressFaultRuntimePrefix
                             */

                            /**
                             * Constructs a new Config.
                             * @memberof clutch.config.module.chaos.serverexperimentation.v1
                             * @classdesc Represents a Config.
                             * @implements IConfig
                             * @constructor
                             * @param {clutch.config.module.chaos.serverexperimentation.v1.IConfig=} [properties] Properties to set
                             */
                            function Config(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Config ingressFaultRuntimePrefix.
                             * @member {string} ingressFaultRuntimePrefix
                             * @memberof clutch.config.module.chaos.serverexperimentation.v1.Config
                             * @instance
                             */
                            Config.prototype.ingressFaultRuntimePrefix = "";

                            /**
                             * Config egressFaultRuntimePrefix.
                             * @member {string} egressFaultRuntimePrefix
                             * @memberof clutch.config.module.chaos.serverexperimentation.v1.Config
                             * @instance
                             */
                            Config.prototype.egressFaultRuntimePrefix = "";

                            /**
                             * Verifies a Config message.
                             * @function verify
                             * @memberof clutch.config.module.chaos.serverexperimentation.v1.Config
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Config.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.ingressFaultRuntimePrefix != null && message.hasOwnProperty("ingressFaultRuntimePrefix"))
                                    if (!$util.isString(message.ingressFaultRuntimePrefix))
                                        return "ingressFaultRuntimePrefix: string expected";
                                if (message.egressFaultRuntimePrefix != null && message.hasOwnProperty("egressFaultRuntimePrefix"))
                                    if (!$util.isString(message.egressFaultRuntimePrefix))
                                        return "egressFaultRuntimePrefix: string expected";
                                return null;
                            };

                            /**
                             * Creates a Config message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof clutch.config.module.chaos.serverexperimentation.v1.Config
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {clutch.config.module.chaos.serverexperimentation.v1.Config} Config
                             */
                            Config.fromObject = function fromObject(object) {
                                if (object instanceof $root.clutch.config.module.chaos.serverexperimentation.v1.Config)
                                    return object;
                                let message = new $root.clutch.config.module.chaos.serverexperimentation.v1.Config();
                                if (object.ingressFaultRuntimePrefix != null)
                                    message.ingressFaultRuntimePrefix = String(object.ingressFaultRuntimePrefix);
                                if (object.egressFaultRuntimePrefix != null)
                                    message.egressFaultRuntimePrefix = String(object.egressFaultRuntimePrefix);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Config message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof clutch.config.module.chaos.serverexperimentation.v1.Config
                             * @static
                             * @param {clutch.config.module.chaos.serverexperimentation.v1.Config} message Config
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Config.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.ingressFaultRuntimePrefix = "";
                                    object.egressFaultRuntimePrefix = "";
                                }
                                if (message.ingressFaultRuntimePrefix != null && message.hasOwnProperty("ingressFaultRuntimePrefix"))
                                    object.ingressFaultRuntimePrefix = message.ingressFaultRuntimePrefix;
                                if (message.egressFaultRuntimePrefix != null && message.hasOwnProperty("egressFaultRuntimePrefix"))
                                    object.egressFaultRuntimePrefix = message.egressFaultRuntimePrefix;
                                return object;
                            };

                            /**
                             * Converts this Config to JSON.
                             * @function toJSON
                             * @memberof clutch.config.module.chaos.serverexperimentation.v1.Config
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Config.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Config;
                        })();

                        return v1;
                    })();

                    return serverexperimentation;
                })();

                return chaos;
            })();

            module.featureflag = (function() {

                /**
                 * Namespace featureflag.
                 * @memberof clutch.config.module
                 * @namespace
                 */
                const featureflag = {};

                featureflag.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.module.featureflag
                     * @namespace
                     */
                    const v1 = {};

                    v1.Simple = (function() {

                        /**
                         * Properties of a Simple.
                         * @memberof clutch.config.module.featureflag.v1
                         * @interface ISimple
                         * @property {Object.<string,boolean>|null} [flags] Simple flags
                         */

                        /**
                         * Constructs a new Simple.
                         * @memberof clutch.config.module.featureflag.v1
                         * @classdesc Represents a Simple.
                         * @implements ISimple
                         * @constructor
                         * @param {clutch.config.module.featureflag.v1.ISimple=} [properties] Properties to set
                         */
                        function Simple(properties) {
                            this.flags = {};
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Simple flags.
                         * @member {Object.<string,boolean>} flags
                         * @memberof clutch.config.module.featureflag.v1.Simple
                         * @instance
                         */
                        Simple.prototype.flags = $util.emptyObject;

                        /**
                         * Verifies a Simple message.
                         * @function verify
                         * @memberof clutch.config.module.featureflag.v1.Simple
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Simple.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.flags != null && message.hasOwnProperty("flags")) {
                                if (!$util.isObject(message.flags))
                                    return "flags: object expected";
                                let key = Object.keys(message.flags);
                                for (let i = 0; i < key.length; ++i)
                                    if (typeof message.flags[key[i]] !== "boolean")
                                        return "flags: boolean{k:string} expected";
                            }
                            return null;
                        };

                        /**
                         * Creates a Simple message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.module.featureflag.v1.Simple
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.module.featureflag.v1.Simple} Simple
                         */
                        Simple.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.module.featureflag.v1.Simple)
                                return object;
                            let message = new $root.clutch.config.module.featureflag.v1.Simple();
                            if (object.flags) {
                                if (typeof object.flags !== "object")
                                    throw TypeError(".clutch.config.module.featureflag.v1.Simple.flags: object expected");
                                message.flags = {};
                                for (let keys = Object.keys(object.flags), i = 0; i < keys.length; ++i)
                                    message.flags[keys[i]] = Boolean(object.flags[keys[i]]);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Simple message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.module.featureflag.v1.Simple
                         * @static
                         * @param {clutch.config.module.featureflag.v1.Simple} message Simple
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Simple.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.objects || options.defaults)
                                object.flags = {};
                            let keys2;
                            if (message.flags && (keys2 = Object.keys(message.flags)).length) {
                                object.flags = {};
                                for (let j = 0; j < keys2.length; ++j)
                                    object.flags[keys2[j]] = message.flags[keys2[j]];
                            }
                            return object;
                        };

                        /**
                         * Converts this Simple to JSON.
                         * @function toJSON
                         * @memberof clutch.config.module.featureflag.v1.Simple
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Simple.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Simple;
                    })();

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.module.featureflag.v1
                         * @interface IConfig
                         * @property {clutch.config.module.featureflag.v1.ISimple|null} [simple] Config simple
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.module.featureflag.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.module.featureflag.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config simple.
                         * @member {clutch.config.module.featureflag.v1.ISimple|null|undefined} simple
                         * @memberof clutch.config.module.featureflag.v1.Config
                         * @instance
                         */
                        Config.prototype.simple = null;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * Config type.
                         * @member {"simple"|undefined} type
                         * @memberof clutch.config.module.featureflag.v1.Config
                         * @instance
                         */
                        Object.defineProperty(Config.prototype, "type", {
                            get: $util.oneOfGetter($oneOfFields = ["simple"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.module.featureflag.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.simple != null && message.hasOwnProperty("simple")) {
                                properties.type = 1;
                                {
                                    let error = $root.clutch.config.module.featureflag.v1.Simple.verify(message.simple);
                                    if (error)
                                        return "simple." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.module.featureflag.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.module.featureflag.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.module.featureflag.v1.Config)
                                return object;
                            let message = new $root.clutch.config.module.featureflag.v1.Config();
                            if (object.simple != null) {
                                if (typeof object.simple !== "object")
                                    throw TypeError(".clutch.config.module.featureflag.v1.Config.simple: object expected");
                                message.simple = $root.clutch.config.module.featureflag.v1.Simple.fromObject(object.simple);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.module.featureflag.v1.Config
                         * @static
                         * @param {clutch.config.module.featureflag.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (message.simple != null && message.hasOwnProperty("simple")) {
                                object.simple = $root.clutch.config.module.featureflag.v1.Simple.toObject(message.simple, options);
                                if (options.oneofs)
                                    object.type = "simple";
                            }
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.module.featureflag.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return featureflag;
            })();

            module.feedback = (function() {

                /**
                 * Namespace feedback.
                 * @memberof clutch.config.module
                 * @namespace
                 */
                const feedback = {};

                feedback.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.module.feedback
                     * @namespace
                     */
                    const v1 = {};

                    v1.Survey = (function() {

                        /**
                         * Properties of a Survey.
                         * @memberof clutch.config.module.feedback.v1
                         * @interface ISurvey
                         * @property {string|null} [prompt] Survey prompt
                         * @property {string|null} [freeformPrompt] Survey freeformPrompt
                         * @property {Array.<clutch.feedback.v1.IRatingLabel>|null} [ratingLabels] Survey ratingLabels
                         */

                        /**
                         * Constructs a new Survey.
                         * @memberof clutch.config.module.feedback.v1
                         * @classdesc Represents a Survey.
                         * @implements ISurvey
                         * @constructor
                         * @param {clutch.config.module.feedback.v1.ISurvey=} [properties] Properties to set
                         */
                        function Survey(properties) {
                            this.ratingLabels = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Survey prompt.
                         * @member {string} prompt
                         * @memberof clutch.config.module.feedback.v1.Survey
                         * @instance
                         */
                        Survey.prototype.prompt = "";

                        /**
                         * Survey freeformPrompt.
                         * @member {string} freeformPrompt
                         * @memberof clutch.config.module.feedback.v1.Survey
                         * @instance
                         */
                        Survey.prototype.freeformPrompt = "";

                        /**
                         * Survey ratingLabels.
                         * @member {Array.<clutch.feedback.v1.IRatingLabel>} ratingLabels
                         * @memberof clutch.config.module.feedback.v1.Survey
                         * @instance
                         */
                        Survey.prototype.ratingLabels = $util.emptyArray;

                        /**
                         * Verifies a Survey message.
                         * @function verify
                         * @memberof clutch.config.module.feedback.v1.Survey
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Survey.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.prompt != null && message.hasOwnProperty("prompt"))
                                if (!$util.isString(message.prompt))
                                    return "prompt: string expected";
                            if (message.freeformPrompt != null && message.hasOwnProperty("freeformPrompt"))
                                if (!$util.isString(message.freeformPrompt))
                                    return "freeformPrompt: string expected";
                            if (message.ratingLabels != null && message.hasOwnProperty("ratingLabels")) {
                                if (!Array.isArray(message.ratingLabels))
                                    return "ratingLabels: array expected";
                                for (let i = 0; i < message.ratingLabels.length; ++i) {
                                    let error = $root.clutch.feedback.v1.RatingLabel.verify(message.ratingLabels[i]);
                                    if (error)
                                        return "ratingLabels." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Survey message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.module.feedback.v1.Survey
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.module.feedback.v1.Survey} Survey
                         */
                        Survey.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.module.feedback.v1.Survey)
                                return object;
                            let message = new $root.clutch.config.module.feedback.v1.Survey();
                            if (object.prompt != null)
                                message.prompt = String(object.prompt);
                            if (object.freeformPrompt != null)
                                message.freeformPrompt = String(object.freeformPrompt);
                            if (object.ratingLabels) {
                                if (!Array.isArray(object.ratingLabels))
                                    throw TypeError(".clutch.config.module.feedback.v1.Survey.ratingLabels: array expected");
                                message.ratingLabels = [];
                                for (let i = 0; i < object.ratingLabels.length; ++i) {
                                    if (typeof object.ratingLabels[i] !== "object")
                                        throw TypeError(".clutch.config.module.feedback.v1.Survey.ratingLabels: object expected");
                                    message.ratingLabels[i] = $root.clutch.feedback.v1.RatingLabel.fromObject(object.ratingLabels[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Survey message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.module.feedback.v1.Survey
                         * @static
                         * @param {clutch.config.module.feedback.v1.Survey} message Survey
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Survey.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.ratingLabels = [];
                            if (options.defaults) {
                                object.prompt = "";
                                object.freeformPrompt = "";
                            }
                            if (message.prompt != null && message.hasOwnProperty("prompt"))
                                object.prompt = message.prompt;
                            if (message.freeformPrompt != null && message.hasOwnProperty("freeformPrompt"))
                                object.freeformPrompt = message.freeformPrompt;
                            if (message.ratingLabels && message.ratingLabels.length) {
                                object.ratingLabels = [];
                                for (let j = 0; j < message.ratingLabels.length; ++j)
                                    object.ratingLabels[j] = $root.clutch.feedback.v1.RatingLabel.toObject(message.ratingLabels[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Survey to JSON.
                         * @function toJSON
                         * @memberof clutch.config.module.feedback.v1.Survey
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Survey.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Survey;
                    })();

                    v1.SurveyOrigin = (function() {

                        /**
                         * Properties of a SurveyOrigin.
                         * @memberof clutch.config.module.feedback.v1
                         * @interface ISurveyOrigin
                         * @property {clutch.feedback.v1.Origin|null} [origin] SurveyOrigin origin
                         * @property {clutch.config.module.feedback.v1.ISurvey|null} [survey] SurveyOrigin survey
                         */

                        /**
                         * Constructs a new SurveyOrigin.
                         * @memberof clutch.config.module.feedback.v1
                         * @classdesc Represents a SurveyOrigin.
                         * @implements ISurveyOrigin
                         * @constructor
                         * @param {clutch.config.module.feedback.v1.ISurveyOrigin=} [properties] Properties to set
                         */
                        function SurveyOrigin(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * SurveyOrigin origin.
                         * @member {clutch.feedback.v1.Origin} origin
                         * @memberof clutch.config.module.feedback.v1.SurveyOrigin
                         * @instance
                         */
                        SurveyOrigin.prototype.origin = 0;

                        /**
                         * SurveyOrigin survey.
                         * @member {clutch.config.module.feedback.v1.ISurvey|null|undefined} survey
                         * @memberof clutch.config.module.feedback.v1.SurveyOrigin
                         * @instance
                         */
                        SurveyOrigin.prototype.survey = null;

                        /**
                         * Verifies a SurveyOrigin message.
                         * @function verify
                         * @memberof clutch.config.module.feedback.v1.SurveyOrigin
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        SurveyOrigin.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.origin != null && message.hasOwnProperty("origin"))
                                switch (message.origin) {
                                default:
                                    return "origin: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                    break;
                                }
                            if (message.survey != null && message.hasOwnProperty("survey")) {
                                let error = $root.clutch.config.module.feedback.v1.Survey.verify(message.survey);
                                if (error)
                                    return "survey." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a SurveyOrigin message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.module.feedback.v1.SurveyOrigin
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.module.feedback.v1.SurveyOrigin} SurveyOrigin
                         */
                        SurveyOrigin.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.module.feedback.v1.SurveyOrigin)
                                return object;
                            let message = new $root.clutch.config.module.feedback.v1.SurveyOrigin();
                            switch (object.origin) {
                            case "ORIGIN_UNSPECIFIED":
                            case 0:
                                message.origin = 0;
                                break;
                            case "HEADER":
                            case 1:
                                message.origin = 1;
                                break;
                            case "WIZARD":
                            case 2:
                                message.origin = 2;
                                break;
                            }
                            if (object.survey != null) {
                                if (typeof object.survey !== "object")
                                    throw TypeError(".clutch.config.module.feedback.v1.SurveyOrigin.survey: object expected");
                                message.survey = $root.clutch.config.module.feedback.v1.Survey.fromObject(object.survey);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a SurveyOrigin message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.module.feedback.v1.SurveyOrigin
                         * @static
                         * @param {clutch.config.module.feedback.v1.SurveyOrigin} message SurveyOrigin
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        SurveyOrigin.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.origin = options.enums === String ? "ORIGIN_UNSPECIFIED" : 0;
                                object.survey = null;
                            }
                            if (message.origin != null && message.hasOwnProperty("origin"))
                                object.origin = options.enums === String ? $root.clutch.feedback.v1.Origin[message.origin] : message.origin;
                            if (message.survey != null && message.hasOwnProperty("survey"))
                                object.survey = $root.clutch.config.module.feedback.v1.Survey.toObject(message.survey, options);
                            return object;
                        };

                        /**
                         * Converts this SurveyOrigin to JSON.
                         * @function toJSON
                         * @memberof clutch.config.module.feedback.v1.SurveyOrigin
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        SurveyOrigin.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return SurveyOrigin;
                    })();

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.module.feedback.v1
                         * @interface IConfig
                         * @property {Array.<clutch.config.module.feedback.v1.ISurveyOrigin>|null} [origins] Config origins
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.module.feedback.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.module.feedback.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            this.origins = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config origins.
                         * @member {Array.<clutch.config.module.feedback.v1.ISurveyOrigin>} origins
                         * @memberof clutch.config.module.feedback.v1.Config
                         * @instance
                         */
                        Config.prototype.origins = $util.emptyArray;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.module.feedback.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.origins != null && message.hasOwnProperty("origins")) {
                                if (!Array.isArray(message.origins))
                                    return "origins: array expected";
                                for (let i = 0; i < message.origins.length; ++i) {
                                    let error = $root.clutch.config.module.feedback.v1.SurveyOrigin.verify(message.origins[i]);
                                    if (error)
                                        return "origins." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.module.feedback.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.module.feedback.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.module.feedback.v1.Config)
                                return object;
                            let message = new $root.clutch.config.module.feedback.v1.Config();
                            if (object.origins) {
                                if (!Array.isArray(object.origins))
                                    throw TypeError(".clutch.config.module.feedback.v1.Config.origins: array expected");
                                message.origins = [];
                                for (let i = 0; i < object.origins.length; ++i) {
                                    if (typeof object.origins[i] !== "object")
                                        throw TypeError(".clutch.config.module.feedback.v1.Config.origins: object expected");
                                    message.origins[i] = $root.clutch.config.module.feedback.v1.SurveyOrigin.fromObject(object.origins[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.module.feedback.v1.Config
                         * @static
                         * @param {clutch.config.module.feedback.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.origins = [];
                            if (message.origins && message.origins.length) {
                                object.origins = [];
                                for (let j = 0; j < message.origins.length; ++j)
                                    object.origins[j] = $root.clutch.config.module.feedback.v1.SurveyOrigin.toObject(message.origins[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.module.feedback.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return feedback;
            })();

            module.project = (function() {

                /**
                 * Namespace project.
                 * @memberof clutch.config.module
                 * @namespace
                 */
                const project = {};

                project.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.module.project
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.module.project.v1
                         * @interface IConfig
                         * @property {string|null} [projectServiceOverride] Config projectServiceOverride
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.module.project.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.module.project.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config projectServiceOverride.
                         * @member {string} projectServiceOverride
                         * @memberof clutch.config.module.project.v1.Config
                         * @instance
                         */
                        Config.prototype.projectServiceOverride = "";

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.module.project.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.projectServiceOverride != null && message.hasOwnProperty("projectServiceOverride"))
                                if (!$util.isString(message.projectServiceOverride))
                                    return "projectServiceOverride: string expected";
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.module.project.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.module.project.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.module.project.v1.Config)
                                return object;
                            let message = new $root.clutch.config.module.project.v1.Config();
                            if (object.projectServiceOverride != null)
                                message.projectServiceOverride = String(object.projectServiceOverride);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.module.project.v1.Config
                         * @static
                         * @param {clutch.config.module.project.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.projectServiceOverride = "";
                            if (message.projectServiceOverride != null && message.hasOwnProperty("projectServiceOverride"))
                                object.projectServiceOverride = message.projectServiceOverride;
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.module.project.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return project;
            })();

            module.proxy = (function() {

                /**
                 * Namespace proxy.
                 * @memberof clutch.config.module
                 * @namespace
                 */
                const proxy = {};

                proxy.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.module.proxy
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.module.proxy.v1
                         * @interface IConfig
                         * @property {Array.<clutch.config.module.proxy.v1.IService>|null} [services] Config services
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.module.proxy.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.module.proxy.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            this.services = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config services.
                         * @member {Array.<clutch.config.module.proxy.v1.IService>} services
                         * @memberof clutch.config.module.proxy.v1.Config
                         * @instance
                         */
                        Config.prototype.services = $util.emptyArray;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.module.proxy.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.services != null && message.hasOwnProperty("services")) {
                                if (!Array.isArray(message.services))
                                    return "services: array expected";
                                for (let i = 0; i < message.services.length; ++i) {
                                    let error = $root.clutch.config.module.proxy.v1.Service.verify(message.services[i]);
                                    if (error)
                                        return "services." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.module.proxy.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.module.proxy.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.module.proxy.v1.Config)
                                return object;
                            let message = new $root.clutch.config.module.proxy.v1.Config();
                            if (object.services) {
                                if (!Array.isArray(object.services))
                                    throw TypeError(".clutch.config.module.proxy.v1.Config.services: array expected");
                                message.services = [];
                                for (let i = 0; i < object.services.length; ++i) {
                                    if (typeof object.services[i] !== "object")
                                        throw TypeError(".clutch.config.module.proxy.v1.Config.services: object expected");
                                    message.services[i] = $root.clutch.config.module.proxy.v1.Service.fromObject(object.services[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.module.proxy.v1.Config
                         * @static
                         * @param {clutch.config.module.proxy.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.services = [];
                            if (message.services && message.services.length) {
                                object.services = [];
                                for (let j = 0; j < message.services.length; ++j)
                                    object.services[j] = $root.clutch.config.module.proxy.v1.Service.toObject(message.services[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.module.proxy.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    v1.Service = (function() {

                        /**
                         * Properties of a Service.
                         * @memberof clutch.config.module.proxy.v1
                         * @interface IService
                         * @property {string|null} [name] Service name
                         * @property {string|null} [host] Service host
                         * @property {Array.<clutch.config.module.proxy.v1.IAllowRequest>|null} [allowedRequests] Service allowedRequests
                         * @property {Object.<string,string>|null} [headers] Service headers
                         */

                        /**
                         * Constructs a new Service.
                         * @memberof clutch.config.module.proxy.v1
                         * @classdesc Represents a Service.
                         * @implements IService
                         * @constructor
                         * @param {clutch.config.module.proxy.v1.IService=} [properties] Properties to set
                         */
                        function Service(properties) {
                            this.allowedRequests = [];
                            this.headers = {};
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Service name.
                         * @member {string} name
                         * @memberof clutch.config.module.proxy.v1.Service
                         * @instance
                         */
                        Service.prototype.name = "";

                        /**
                         * Service host.
                         * @member {string} host
                         * @memberof clutch.config.module.proxy.v1.Service
                         * @instance
                         */
                        Service.prototype.host = "";

                        /**
                         * Service allowedRequests.
                         * @member {Array.<clutch.config.module.proxy.v1.IAllowRequest>} allowedRequests
                         * @memberof clutch.config.module.proxy.v1.Service
                         * @instance
                         */
                        Service.prototype.allowedRequests = $util.emptyArray;

                        /**
                         * Service headers.
                         * @member {Object.<string,string>} headers
                         * @memberof clutch.config.module.proxy.v1.Service
                         * @instance
                         */
                        Service.prototype.headers = $util.emptyObject;

                        /**
                         * Verifies a Service message.
                         * @function verify
                         * @memberof clutch.config.module.proxy.v1.Service
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Service.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.name != null && message.hasOwnProperty("name"))
                                if (!$util.isString(message.name))
                                    return "name: string expected";
                            if (message.host != null && message.hasOwnProperty("host"))
                                if (!$util.isString(message.host))
                                    return "host: string expected";
                            if (message.allowedRequests != null && message.hasOwnProperty("allowedRequests")) {
                                if (!Array.isArray(message.allowedRequests))
                                    return "allowedRequests: array expected";
                                for (let i = 0; i < message.allowedRequests.length; ++i) {
                                    let error = $root.clutch.config.module.proxy.v1.AllowRequest.verify(message.allowedRequests[i]);
                                    if (error)
                                        return "allowedRequests." + error;
                                }
                            }
                            if (message.headers != null && message.hasOwnProperty("headers")) {
                                if (!$util.isObject(message.headers))
                                    return "headers: object expected";
                                let key = Object.keys(message.headers);
                                for (let i = 0; i < key.length; ++i)
                                    if (!$util.isString(message.headers[key[i]]))
                                        return "headers: string{k:string} expected";
                            }
                            return null;
                        };

                        /**
                         * Creates a Service message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.module.proxy.v1.Service
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.module.proxy.v1.Service} Service
                         */
                        Service.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.module.proxy.v1.Service)
                                return object;
                            let message = new $root.clutch.config.module.proxy.v1.Service();
                            if (object.name != null)
                                message.name = String(object.name);
                            if (object.host != null)
                                message.host = String(object.host);
                            if (object.allowedRequests) {
                                if (!Array.isArray(object.allowedRequests))
                                    throw TypeError(".clutch.config.module.proxy.v1.Service.allowedRequests: array expected");
                                message.allowedRequests = [];
                                for (let i = 0; i < object.allowedRequests.length; ++i) {
                                    if (typeof object.allowedRequests[i] !== "object")
                                        throw TypeError(".clutch.config.module.proxy.v1.Service.allowedRequests: object expected");
                                    message.allowedRequests[i] = $root.clutch.config.module.proxy.v1.AllowRequest.fromObject(object.allowedRequests[i]);
                                }
                            }
                            if (object.headers) {
                                if (typeof object.headers !== "object")
                                    throw TypeError(".clutch.config.module.proxy.v1.Service.headers: object expected");
                                message.headers = {};
                                for (let keys = Object.keys(object.headers), i = 0; i < keys.length; ++i)
                                    message.headers[keys[i]] = String(object.headers[keys[i]]);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Service message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.module.proxy.v1.Service
                         * @static
                         * @param {clutch.config.module.proxy.v1.Service} message Service
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Service.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.allowedRequests = [];
                            if (options.objects || options.defaults)
                                object.headers = {};
                            if (options.defaults) {
                                object.name = "";
                                object.host = "";
                            }
                            if (message.name != null && message.hasOwnProperty("name"))
                                object.name = message.name;
                            if (message.host != null && message.hasOwnProperty("host"))
                                object.host = message.host;
                            if (message.allowedRequests && message.allowedRequests.length) {
                                object.allowedRequests = [];
                                for (let j = 0; j < message.allowedRequests.length; ++j)
                                    object.allowedRequests[j] = $root.clutch.config.module.proxy.v1.AllowRequest.toObject(message.allowedRequests[j], options);
                            }
                            let keys2;
                            if (message.headers && (keys2 = Object.keys(message.headers)).length) {
                                object.headers = {};
                                for (let j = 0; j < keys2.length; ++j)
                                    object.headers[keys2[j]] = message.headers[keys2[j]];
                            }
                            return object;
                        };

                        /**
                         * Converts this Service to JSON.
                         * @function toJSON
                         * @memberof clutch.config.module.proxy.v1.Service
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Service.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Service;
                    })();

                    v1.AllowRequest = (function() {

                        /**
                         * Properties of an AllowRequest.
                         * @memberof clutch.config.module.proxy.v1
                         * @interface IAllowRequest
                         * @property {string|null} [path] AllowRequest path
                         * @property {string|null} [method] AllowRequest method
                         */

                        /**
                         * Constructs a new AllowRequest.
                         * @memberof clutch.config.module.proxy.v1
                         * @classdesc Represents an AllowRequest.
                         * @implements IAllowRequest
                         * @constructor
                         * @param {clutch.config.module.proxy.v1.IAllowRequest=} [properties] Properties to set
                         */
                        function AllowRequest(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * AllowRequest path.
                         * @member {string} path
                         * @memberof clutch.config.module.proxy.v1.AllowRequest
                         * @instance
                         */
                        AllowRequest.prototype.path = "";

                        /**
                         * AllowRequest method.
                         * @member {string} method
                         * @memberof clutch.config.module.proxy.v1.AllowRequest
                         * @instance
                         */
                        AllowRequest.prototype.method = "";

                        /**
                         * Verifies an AllowRequest message.
                         * @function verify
                         * @memberof clutch.config.module.proxy.v1.AllowRequest
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        AllowRequest.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.path != null && message.hasOwnProperty("path"))
                                if (!$util.isString(message.path))
                                    return "path: string expected";
                            if (message.method != null && message.hasOwnProperty("method"))
                                if (!$util.isString(message.method))
                                    return "method: string expected";
                            return null;
                        };

                        /**
                         * Creates an AllowRequest message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.module.proxy.v1.AllowRequest
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.module.proxy.v1.AllowRequest} AllowRequest
                         */
                        AllowRequest.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.module.proxy.v1.AllowRequest)
                                return object;
                            let message = new $root.clutch.config.module.proxy.v1.AllowRequest();
                            if (object.path != null)
                                message.path = String(object.path);
                            if (object.method != null)
                                message.method = String(object.method);
                            return message;
                        };

                        /**
                         * Creates a plain object from an AllowRequest message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.module.proxy.v1.AllowRequest
                         * @static
                         * @param {clutch.config.module.proxy.v1.AllowRequest} message AllowRequest
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        AllowRequest.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.path = "";
                                object.method = "";
                            }
                            if (message.path != null && message.hasOwnProperty("path"))
                                object.path = message.path;
                            if (message.method != null && message.hasOwnProperty("method"))
                                object.method = message.method;
                            return object;
                        };

                        /**
                         * Converts this AllowRequest to JSON.
                         * @function toJSON
                         * @memberof clutch.config.module.proxy.v1.AllowRequest
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        AllowRequest.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return AllowRequest;
                    })();

                    return v1;
                })();

                return proxy;
            })();

            module.sourcecontrol = (function() {

                /**
                 * Namespace sourcecontrol.
                 * @memberof clutch.config.module
                 * @namespace
                 */
                const sourcecontrol = {};

                sourcecontrol.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.module.sourcecontrol
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.module.sourcecontrol.v1
                         * @interface IConfig
                         * @property {Array.<string>|null} [owners] Config owners
                         * @property {Array.<clutch.sourcecontrol.v1.Visibility>|null} [visibilityOptions] Config visibilityOptions
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.module.sourcecontrol.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.module.sourcecontrol.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            this.owners = [];
                            this.visibilityOptions = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config owners.
                         * @member {Array.<string>} owners
                         * @memberof clutch.config.module.sourcecontrol.v1.Config
                         * @instance
                         */
                        Config.prototype.owners = $util.emptyArray;

                        /**
                         * Config visibilityOptions.
                         * @member {Array.<clutch.sourcecontrol.v1.Visibility>} visibilityOptions
                         * @memberof clutch.config.module.sourcecontrol.v1.Config
                         * @instance
                         */
                        Config.prototype.visibilityOptions = $util.emptyArray;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.module.sourcecontrol.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.owners != null && message.hasOwnProperty("owners")) {
                                if (!Array.isArray(message.owners))
                                    return "owners: array expected";
                                for (let i = 0; i < message.owners.length; ++i)
                                    if (!$util.isString(message.owners[i]))
                                        return "owners: string[] expected";
                            }
                            if (message.visibilityOptions != null && message.hasOwnProperty("visibilityOptions")) {
                                if (!Array.isArray(message.visibilityOptions))
                                    return "visibilityOptions: array expected";
                                for (let i = 0; i < message.visibilityOptions.length; ++i)
                                    switch (message.visibilityOptions[i]) {
                                    default:
                                        return "visibilityOptions: enum value[] expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                        break;
                                    }
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.module.sourcecontrol.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.module.sourcecontrol.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.module.sourcecontrol.v1.Config)
                                return object;
                            let message = new $root.clutch.config.module.sourcecontrol.v1.Config();
                            if (object.owners) {
                                if (!Array.isArray(object.owners))
                                    throw TypeError(".clutch.config.module.sourcecontrol.v1.Config.owners: array expected");
                                message.owners = [];
                                for (let i = 0; i < object.owners.length; ++i)
                                    message.owners[i] = String(object.owners[i]);
                            }
                            if (object.visibilityOptions) {
                                if (!Array.isArray(object.visibilityOptions))
                                    throw TypeError(".clutch.config.module.sourcecontrol.v1.Config.visibilityOptions: array expected");
                                message.visibilityOptions = [];
                                for (let i = 0; i < object.visibilityOptions.length; ++i)
                                    switch (object.visibilityOptions[i]) {
                                    default:
                                    case "UNSPECIFIED":
                                    case 0:
                                        message.visibilityOptions[i] = 0;
                                        break;
                                    case "PUBLIC":
                                    case 1:
                                        message.visibilityOptions[i] = 1;
                                        break;
                                    case "PRIVATE":
                                    case 2:
                                        message.visibilityOptions[i] = 2;
                                        break;
                                    }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.module.sourcecontrol.v1.Config
                         * @static
                         * @param {clutch.config.module.sourcecontrol.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.owners = [];
                                object.visibilityOptions = [];
                            }
                            if (message.owners && message.owners.length) {
                                object.owners = [];
                                for (let j = 0; j < message.owners.length; ++j)
                                    object.owners[j] = message.owners[j];
                            }
                            if (message.visibilityOptions && message.visibilityOptions.length) {
                                object.visibilityOptions = [];
                                for (let j = 0; j < message.visibilityOptions.length; ++j)
                                    object.visibilityOptions[j] = options.enums === String ? $root.clutch.sourcecontrol.v1.Visibility[message.visibilityOptions[j]] : message.visibilityOptions[j];
                            }
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.module.sourcecontrol.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return sourcecontrol;
            })();

            return module;
        })();

        config.service = (function() {

            /**
             * Namespace service.
             * @memberof clutch.config
             * @namespace
             */
            const service = {};

            service.auditsink = (function() {

                /**
                 * Namespace auditsink.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const auditsink = {};

                auditsink.slack = (function() {

                    /**
                     * Namespace slack.
                     * @memberof clutch.config.service.auditsink
                     * @namespace
                     */
                    const slack = {};

                    slack.v1 = (function() {

                        /**
                         * Namespace v1.
                         * @memberof clutch.config.service.auditsink.slack
                         * @namespace
                         */
                        const v1 = {};

                        v1.SlackConfig = (function() {

                            /**
                             * Properties of a SlackConfig.
                             * @memberof clutch.config.service.auditsink.slack.v1
                             * @interface ISlackConfig
                             * @property {string|null} [token] SlackConfig token
                             * @property {string|null} [channel] SlackConfig channel
                             * @property {clutch.config.service.audit.v1.IFilter|null} [filter] SlackConfig filter
                             * @property {Array.<clutch.config.service.auditsink.slack.v1.ICustomMessage>|null} [overrides] SlackConfig overrides
                             */

                            /**
                             * Constructs a new SlackConfig.
                             * @memberof clutch.config.service.auditsink.slack.v1
                             * @classdesc Represents a SlackConfig.
                             * @implements ISlackConfig
                             * @constructor
                             * @param {clutch.config.service.auditsink.slack.v1.ISlackConfig=} [properties] Properties to set
                             */
                            function SlackConfig(properties) {
                                this.overrides = [];
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * SlackConfig token.
                             * @member {string} token
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @instance
                             */
                            SlackConfig.prototype.token = "";

                            /**
                             * SlackConfig channel.
                             * @member {string} channel
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @instance
                             */
                            SlackConfig.prototype.channel = "";

                            /**
                             * SlackConfig filter.
                             * @member {clutch.config.service.audit.v1.IFilter|null|undefined} filter
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @instance
                             */
                            SlackConfig.prototype.filter = null;

                            /**
                             * SlackConfig overrides.
                             * @member {Array.<clutch.config.service.auditsink.slack.v1.ICustomMessage>} overrides
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @instance
                             */
                            SlackConfig.prototype.overrides = $util.emptyArray;

                            /**
                             * Verifies a SlackConfig message.
                             * @function verify
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            SlackConfig.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.token != null && message.hasOwnProperty("token"))
                                    if (!$util.isString(message.token))
                                        return "token: string expected";
                                if (message.channel != null && message.hasOwnProperty("channel"))
                                    if (!$util.isString(message.channel))
                                        return "channel: string expected";
                                if (message.filter != null && message.hasOwnProperty("filter")) {
                                    let error = $root.clutch.config.service.audit.v1.Filter.verify(message.filter);
                                    if (error)
                                        return "filter." + error;
                                }
                                if (message.overrides != null && message.hasOwnProperty("overrides")) {
                                    if (!Array.isArray(message.overrides))
                                        return "overrides: array expected";
                                    for (let i = 0; i < message.overrides.length; ++i) {
                                        let error = $root.clutch.config.service.auditsink.slack.v1.CustomMessage.verify(message.overrides[i]);
                                        if (error)
                                            return "overrides." + error;
                                    }
                                }
                                return null;
                            };

                            /**
                             * Creates a SlackConfig message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {clutch.config.service.auditsink.slack.v1.SlackConfig} SlackConfig
                             */
                            SlackConfig.fromObject = function fromObject(object) {
                                if (object instanceof $root.clutch.config.service.auditsink.slack.v1.SlackConfig)
                                    return object;
                                let message = new $root.clutch.config.service.auditsink.slack.v1.SlackConfig();
                                if (object.token != null)
                                    message.token = String(object.token);
                                if (object.channel != null)
                                    message.channel = String(object.channel);
                                if (object.filter != null) {
                                    if (typeof object.filter !== "object")
                                        throw TypeError(".clutch.config.service.auditsink.slack.v1.SlackConfig.filter: object expected");
                                    message.filter = $root.clutch.config.service.audit.v1.Filter.fromObject(object.filter);
                                }
                                if (object.overrides) {
                                    if (!Array.isArray(object.overrides))
                                        throw TypeError(".clutch.config.service.auditsink.slack.v1.SlackConfig.overrides: array expected");
                                    message.overrides = [];
                                    for (let i = 0; i < object.overrides.length; ++i) {
                                        if (typeof object.overrides[i] !== "object")
                                            throw TypeError(".clutch.config.service.auditsink.slack.v1.SlackConfig.overrides: object expected");
                                        message.overrides[i] = $root.clutch.config.service.auditsink.slack.v1.CustomMessage.fromObject(object.overrides[i]);
                                    }
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a SlackConfig message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @static
                             * @param {clutch.config.service.auditsink.slack.v1.SlackConfig} message SlackConfig
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            SlackConfig.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.arrays || options.defaults)
                                    object.overrides = [];
                                if (options.defaults) {
                                    object.token = "";
                                    object.channel = "";
                                    object.filter = null;
                                }
                                if (message.token != null && message.hasOwnProperty("token"))
                                    object.token = message.token;
                                if (message.channel != null && message.hasOwnProperty("channel"))
                                    object.channel = message.channel;
                                if (message.filter != null && message.hasOwnProperty("filter"))
                                    object.filter = $root.clutch.config.service.audit.v1.Filter.toObject(message.filter, options);
                                if (message.overrides && message.overrides.length) {
                                    object.overrides = [];
                                    for (let j = 0; j < message.overrides.length; ++j)
                                        object.overrides[j] = $root.clutch.config.service.auditsink.slack.v1.CustomMessage.toObject(message.overrides[j], options);
                                }
                                return object;
                            };

                            /**
                             * Converts this SlackConfig to JSON.
                             * @function toJSON
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            SlackConfig.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return SlackConfig;
                        })();

                        v1.CustomMessage = (function() {

                            /**
                             * Properties of a CustomMessage.
                             * @memberof clutch.config.service.auditsink.slack.v1
                             * @interface ICustomMessage
                             * @property {string|null} [fullMethod] CustomMessage fullMethod
                             * @property {string|null} [message] CustomMessage message
                             */

                            /**
                             * Constructs a new CustomMessage.
                             * @memberof clutch.config.service.auditsink.slack.v1
                             * @classdesc Represents a CustomMessage.
                             * @implements ICustomMessage
                             * @constructor
                             * @param {clutch.config.service.auditsink.slack.v1.ICustomMessage=} [properties] Properties to set
                             */
                            function CustomMessage(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * CustomMessage fullMethod.
                             * @member {string} fullMethod
                             * @memberof clutch.config.service.auditsink.slack.v1.CustomMessage
                             * @instance
                             */
                            CustomMessage.prototype.fullMethod = "";

                            /**
                             * CustomMessage message.
                             * @member {string} message
                             * @memberof clutch.config.service.auditsink.slack.v1.CustomMessage
                             * @instance
                             */
                            CustomMessage.prototype.message = "";

                            /**
                             * Verifies a CustomMessage message.
                             * @function verify
                             * @memberof clutch.config.service.auditsink.slack.v1.CustomMessage
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            CustomMessage.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.fullMethod != null && message.hasOwnProperty("fullMethod"))
                                    if (!$util.isString(message.fullMethod))
                                        return "fullMethod: string expected";
                                if (message.message != null && message.hasOwnProperty("message"))
                                    if (!$util.isString(message.message))
                                        return "message: string expected";
                                return null;
                            };

                            /**
                             * Creates a CustomMessage message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof clutch.config.service.auditsink.slack.v1.CustomMessage
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {clutch.config.service.auditsink.slack.v1.CustomMessage} CustomMessage
                             */
                            CustomMessage.fromObject = function fromObject(object) {
                                if (object instanceof $root.clutch.config.service.auditsink.slack.v1.CustomMessage)
                                    return object;
                                let message = new $root.clutch.config.service.auditsink.slack.v1.CustomMessage();
                                if (object.fullMethod != null)
                                    message.fullMethod = String(object.fullMethod);
                                if (object.message != null)
                                    message.message = String(object.message);
                                return message;
                            };

                            /**
                             * Creates a plain object from a CustomMessage message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof clutch.config.service.auditsink.slack.v1.CustomMessage
                             * @static
                             * @param {clutch.config.service.auditsink.slack.v1.CustomMessage} message CustomMessage
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            CustomMessage.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.fullMethod = "";
                                    object.message = "";
                                }
                                if (message.fullMethod != null && message.hasOwnProperty("fullMethod"))
                                    object.fullMethod = message.fullMethod;
                                if (message.message != null && message.hasOwnProperty("message"))
                                    object.message = message.message;
                                return object;
                            };

                            /**
                             * Converts this CustomMessage to JSON.
                             * @function toJSON
                             * @memberof clutch.config.service.auditsink.slack.v1.CustomMessage
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            CustomMessage.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return CustomMessage;
                        })();

                        return v1;
                    })();

                    return slack;
                })();

                return auditsink;
            })();

            service.audit = (function() {

                /**
                 * Namespace audit.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const audit = {};

                audit.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.audit
                     * @namespace
                     */
                    const v1 = {};

                    v1.EventFilter = (function() {

                        /**
                         * Properties of an EventFilter.
                         * @memberof clutch.config.service.audit.v1
                         * @interface IEventFilter
                         * @property {clutch.config.service.audit.v1.EventFilter.FilterType|null} [field] EventFilter field
                         * @property {string|null} [text] EventFilter text
                         */

                        /**
                         * Constructs a new EventFilter.
                         * @memberof clutch.config.service.audit.v1
                         * @classdesc Represents an EventFilter.
                         * @implements IEventFilter
                         * @constructor
                         * @param {clutch.config.service.audit.v1.IEventFilter=} [properties] Properties to set
                         */
                        function EventFilter(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * EventFilter field.
                         * @member {clutch.config.service.audit.v1.EventFilter.FilterType} field
                         * @memberof clutch.config.service.audit.v1.EventFilter
                         * @instance
                         */
                        EventFilter.prototype.field = 0;

                        /**
                         * EventFilter text.
                         * @member {string|null|undefined} text
                         * @memberof clutch.config.service.audit.v1.EventFilter
                         * @instance
                         */
                        EventFilter.prototype.text = null;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * EventFilter value.
                         * @member {"text"|undefined} value
                         * @memberof clutch.config.service.audit.v1.EventFilter
                         * @instance
                         */
                        Object.defineProperty(EventFilter.prototype, "value", {
                            get: $util.oneOfGetter($oneOfFields = ["text"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Verifies an EventFilter message.
                         * @function verify
                         * @memberof clutch.config.service.audit.v1.EventFilter
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        EventFilter.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.field != null && message.hasOwnProperty("field"))
                                switch (message.field) {
                                default:
                                    return "field: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                    break;
                                }
                            if (message.text != null && message.hasOwnProperty("text")) {
                                properties.value = 1;
                                if (!$util.isString(message.text))
                                    return "text: string expected";
                            }
                            return null;
                        };

                        /**
                         * Creates an EventFilter message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.audit.v1.EventFilter
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.audit.v1.EventFilter} EventFilter
                         */
                        EventFilter.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.audit.v1.EventFilter)
                                return object;
                            let message = new $root.clutch.config.service.audit.v1.EventFilter();
                            switch (object.field) {
                            case "UNSPECIFIED":
                            case 0:
                                message.field = 0;
                                break;
                            case "SERVICE":
                            case 1:
                                message.field = 1;
                                break;
                            case "METHOD":
                            case 2:
                                message.field = 2;
                                break;
                            case "TYPE":
                            case 3:
                                message.field = 3;
                                break;
                            }
                            if (object.text != null)
                                message.text = String(object.text);
                            return message;
                        };

                        /**
                         * Creates a plain object from an EventFilter message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.audit.v1.EventFilter
                         * @static
                         * @param {clutch.config.service.audit.v1.EventFilter} message EventFilter
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        EventFilter.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.field = options.enums === String ? "UNSPECIFIED" : 0;
                            if (message.field != null && message.hasOwnProperty("field"))
                                object.field = options.enums === String ? $root.clutch.config.service.audit.v1.EventFilter.FilterType[message.field] : message.field;
                            if (message.text != null && message.hasOwnProperty("text")) {
                                object.text = message.text;
                                if (options.oneofs)
                                    object.value = "text";
                            }
                            return object;
                        };

                        /**
                         * Converts this EventFilter to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.audit.v1.EventFilter
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        EventFilter.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * FilterType enum.
                         * @name clutch.config.service.audit.v1.EventFilter.FilterType
                         * @enum {number}
                         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                         * @property {number} SERVICE=1 SERVICE value
                         * @property {number} METHOD=2 METHOD value
                         * @property {number} TYPE=3 TYPE value
                         */
                        EventFilter.FilterType = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "UNSPECIFIED"] = 0;
                            values[valuesById[1] = "SERVICE"] = 1;
                            values[valuesById[2] = "METHOD"] = 2;
                            values[valuesById[3] = "TYPE"] = 3;
                            return values;
                        })();

                        return EventFilter;
                    })();

                    v1.Filter = (function() {

                        /**
                         * Properties of a Filter.
                         * @memberof clutch.config.service.audit.v1
                         * @interface IFilter
                         * @property {boolean|null} [denylist] Filter denylist
                         * @property {Array.<clutch.config.service.audit.v1.IEventFilter>|null} [rules] Filter rules
                         */

                        /**
                         * Constructs a new Filter.
                         * @memberof clutch.config.service.audit.v1
                         * @classdesc Represents a Filter.
                         * @implements IFilter
                         * @constructor
                         * @param {clutch.config.service.audit.v1.IFilter=} [properties] Properties to set
                         */
                        function Filter(properties) {
                            this.rules = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Filter denylist.
                         * @member {boolean} denylist
                         * @memberof clutch.config.service.audit.v1.Filter
                         * @instance
                         */
                        Filter.prototype.denylist = false;

                        /**
                         * Filter rules.
                         * @member {Array.<clutch.config.service.audit.v1.IEventFilter>} rules
                         * @memberof clutch.config.service.audit.v1.Filter
                         * @instance
                         */
                        Filter.prototype.rules = $util.emptyArray;

                        /**
                         * Verifies a Filter message.
                         * @function verify
                         * @memberof clutch.config.service.audit.v1.Filter
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Filter.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.denylist != null && message.hasOwnProperty("denylist"))
                                if (typeof message.denylist !== "boolean")
                                    return "denylist: boolean expected";
                            if (message.rules != null && message.hasOwnProperty("rules")) {
                                if (!Array.isArray(message.rules))
                                    return "rules: array expected";
                                for (let i = 0; i < message.rules.length; ++i) {
                                    let error = $root.clutch.config.service.audit.v1.EventFilter.verify(message.rules[i]);
                                    if (error)
                                        return "rules." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Filter message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.audit.v1.Filter
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.audit.v1.Filter} Filter
                         */
                        Filter.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.audit.v1.Filter)
                                return object;
                            let message = new $root.clutch.config.service.audit.v1.Filter();
                            if (object.denylist != null)
                                message.denylist = Boolean(object.denylist);
                            if (object.rules) {
                                if (!Array.isArray(object.rules))
                                    throw TypeError(".clutch.config.service.audit.v1.Filter.rules: array expected");
                                message.rules = [];
                                for (let i = 0; i < object.rules.length; ++i) {
                                    if (typeof object.rules[i] !== "object")
                                        throw TypeError(".clutch.config.service.audit.v1.Filter.rules: object expected");
                                    message.rules[i] = $root.clutch.config.service.audit.v1.EventFilter.fromObject(object.rules[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Filter message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.audit.v1.Filter
                         * @static
                         * @param {clutch.config.service.audit.v1.Filter} message Filter
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Filter.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.rules = [];
                            if (options.defaults)
                                object.denylist = false;
                            if (message.denylist != null && message.hasOwnProperty("denylist"))
                                object.denylist = message.denylist;
                            if (message.rules && message.rules.length) {
                                object.rules = [];
                                for (let j = 0; j < message.rules.length; ++j)
                                    object.rules[j] = $root.clutch.config.service.audit.v1.EventFilter.toObject(message.rules[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Filter to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.audit.v1.Filter
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Filter.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Filter;
                    })();

                    v1.SinkConfig = (function() {

                        /**
                         * Properties of a SinkConfig.
                         * @memberof clutch.config.service.audit.v1
                         * @interface ISinkConfig
                         * @property {clutch.config.service.audit.v1.IFilter|null} [filter] SinkConfig filter
                         */

                        /**
                         * Constructs a new SinkConfig.
                         * @memberof clutch.config.service.audit.v1
                         * @classdesc Represents a SinkConfig.
                         * @implements ISinkConfig
                         * @constructor
                         * @param {clutch.config.service.audit.v1.ISinkConfig=} [properties] Properties to set
                         */
                        function SinkConfig(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * SinkConfig filter.
                         * @member {clutch.config.service.audit.v1.IFilter|null|undefined} filter
                         * @memberof clutch.config.service.audit.v1.SinkConfig
                         * @instance
                         */
                        SinkConfig.prototype.filter = null;

                        /**
                         * Verifies a SinkConfig message.
                         * @function verify
                         * @memberof clutch.config.service.audit.v1.SinkConfig
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        SinkConfig.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.filter != null && message.hasOwnProperty("filter")) {
                                let error = $root.clutch.config.service.audit.v1.Filter.verify(message.filter);
                                if (error)
                                    return "filter." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a SinkConfig message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.audit.v1.SinkConfig
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.audit.v1.SinkConfig} SinkConfig
                         */
                        SinkConfig.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.audit.v1.SinkConfig)
                                return object;
                            let message = new $root.clutch.config.service.audit.v1.SinkConfig();
                            if (object.filter != null) {
                                if (typeof object.filter !== "object")
                                    throw TypeError(".clutch.config.service.audit.v1.SinkConfig.filter: object expected");
                                message.filter = $root.clutch.config.service.audit.v1.Filter.fromObject(object.filter);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a SinkConfig message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.audit.v1.SinkConfig
                         * @static
                         * @param {clutch.config.service.audit.v1.SinkConfig} message SinkConfig
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        SinkConfig.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.filter = null;
                            if (message.filter != null && message.hasOwnProperty("filter"))
                                object.filter = $root.clutch.config.service.audit.v1.Filter.toObject(message.filter, options);
                            return object;
                        };

                        /**
                         * Converts this SinkConfig to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.audit.v1.SinkConfig
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        SinkConfig.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return SinkConfig;
                    })();

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.audit.v1
                         * @interface IConfig
                         * @property {string|null} [dbProvider] Config dbProvider
                         * @property {boolean|null} [inMemory] Config inMemory
                         * @property {clutch.config.service.audit.v1.IFilter|null} [filter] Config filter
                         * @property {Array.<string>|null} [sinks] Config sinks
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.audit.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.audit.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            this.sinks = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config dbProvider.
                         * @member {string|null|undefined} dbProvider
                         * @memberof clutch.config.service.audit.v1.Config
                         * @instance
                         */
                        Config.prototype.dbProvider = null;

                        /**
                         * Config inMemory.
                         * @member {boolean|null|undefined} inMemory
                         * @memberof clutch.config.service.audit.v1.Config
                         * @instance
                         */
                        Config.prototype.inMemory = null;

                        /**
                         * Config filter.
                         * @member {clutch.config.service.audit.v1.IFilter|null|undefined} filter
                         * @memberof clutch.config.service.audit.v1.Config
                         * @instance
                         */
                        Config.prototype.filter = null;

                        /**
                         * Config sinks.
                         * @member {Array.<string>} sinks
                         * @memberof clutch.config.service.audit.v1.Config
                         * @instance
                         */
                        Config.prototype.sinks = $util.emptyArray;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * Config storageProvider.
                         * @member {"dbProvider"|"inMemory"|undefined} storageProvider
                         * @memberof clutch.config.service.audit.v1.Config
                         * @instance
                         */
                        Object.defineProperty(Config.prototype, "storageProvider", {
                            get: $util.oneOfGetter($oneOfFields = ["dbProvider", "inMemory"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.audit.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.dbProvider != null && message.hasOwnProperty("dbProvider")) {
                                properties.storageProvider = 1;
                                if (!$util.isString(message.dbProvider))
                                    return "dbProvider: string expected";
                            }
                            if (message.inMemory != null && message.hasOwnProperty("inMemory")) {
                                if (properties.storageProvider === 1)
                                    return "storageProvider: multiple values";
                                properties.storageProvider = 1;
                                if (typeof message.inMemory !== "boolean")
                                    return "inMemory: boolean expected";
                            }
                            if (message.filter != null && message.hasOwnProperty("filter")) {
                                let error = $root.clutch.config.service.audit.v1.Filter.verify(message.filter);
                                if (error)
                                    return "filter." + error;
                            }
                            if (message.sinks != null && message.hasOwnProperty("sinks")) {
                                if (!Array.isArray(message.sinks))
                                    return "sinks: array expected";
                                for (let i = 0; i < message.sinks.length; ++i)
                                    if (!$util.isString(message.sinks[i]))
                                        return "sinks: string[] expected";
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.audit.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.audit.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.audit.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.audit.v1.Config();
                            if (object.dbProvider != null)
                                message.dbProvider = String(object.dbProvider);
                            if (object.inMemory != null)
                                message.inMemory = Boolean(object.inMemory);
                            if (object.filter != null) {
                                if (typeof object.filter !== "object")
                                    throw TypeError(".clutch.config.service.audit.v1.Config.filter: object expected");
                                message.filter = $root.clutch.config.service.audit.v1.Filter.fromObject(object.filter);
                            }
                            if (object.sinks) {
                                if (!Array.isArray(object.sinks))
                                    throw TypeError(".clutch.config.service.audit.v1.Config.sinks: array expected");
                                message.sinks = [];
                                for (let i = 0; i < object.sinks.length; ++i)
                                    message.sinks[i] = String(object.sinks[i]);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.audit.v1.Config
                         * @static
                         * @param {clutch.config.service.audit.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.sinks = [];
                            if (options.defaults)
                                object.filter = null;
                            if (message.dbProvider != null && message.hasOwnProperty("dbProvider")) {
                                object.dbProvider = message.dbProvider;
                                if (options.oneofs)
                                    object.storageProvider = "dbProvider";
                            }
                            if (message.inMemory != null && message.hasOwnProperty("inMemory")) {
                                object.inMemory = message.inMemory;
                                if (options.oneofs)
                                    object.storageProvider = "inMemory";
                            }
                            if (message.filter != null && message.hasOwnProperty("filter"))
                                object.filter = $root.clutch.config.service.audit.v1.Filter.toObject(message.filter, options);
                            if (message.sinks && message.sinks.length) {
                                object.sinks = [];
                                for (let j = 0; j < message.sinks.length; ++j)
                                    object.sinks[j] = message.sinks[j];
                            }
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.audit.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return audit;
            })();

            service.authn = (function() {

                /**
                 * Namespace authn.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const authn = {};

                authn.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.authn
                     * @namespace
                     */
                    const v1 = {};

                    v1.OIDC = (function() {

                        /**
                         * Properties of a OIDC.
                         * @memberof clutch.config.service.authn.v1
                         * @interface IOIDC
                         * @property {string|null} [issuer] OIDC issuer
                         * @property {string|null} [clientId] OIDC clientId
                         * @property {string|null} [clientSecret] OIDC clientSecret
                         * @property {string|null} [redirectUrl] OIDC redirectUrl
                         * @property {Array.<string>|null} [scopes] OIDC scopes
                         */

                        /**
                         * Constructs a new OIDC.
                         * @memberof clutch.config.service.authn.v1
                         * @classdesc Represents a OIDC.
                         * @implements IOIDC
                         * @constructor
                         * @param {clutch.config.service.authn.v1.IOIDC=} [properties] Properties to set
                         */
                        function OIDC(properties) {
                            this.scopes = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * OIDC issuer.
                         * @member {string} issuer
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @instance
                         */
                        OIDC.prototype.issuer = "";

                        /**
                         * OIDC clientId.
                         * @member {string} clientId
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @instance
                         */
                        OIDC.prototype.clientId = "";

                        /**
                         * OIDC clientSecret.
                         * @member {string} clientSecret
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @instance
                         */
                        OIDC.prototype.clientSecret = "";

                        /**
                         * OIDC redirectUrl.
                         * @member {string} redirectUrl
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @instance
                         */
                        OIDC.prototype.redirectUrl = "";

                        /**
                         * OIDC scopes.
                         * @member {Array.<string>} scopes
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @instance
                         */
                        OIDC.prototype.scopes = $util.emptyArray;

                        /**
                         * Verifies a OIDC message.
                         * @function verify
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        OIDC.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.issuer != null && message.hasOwnProperty("issuer"))
                                if (!$util.isString(message.issuer))
                                    return "issuer: string expected";
                            if (message.clientId != null && message.hasOwnProperty("clientId"))
                                if (!$util.isString(message.clientId))
                                    return "clientId: string expected";
                            if (message.clientSecret != null && message.hasOwnProperty("clientSecret"))
                                if (!$util.isString(message.clientSecret))
                                    return "clientSecret: string expected";
                            if (message.redirectUrl != null && message.hasOwnProperty("redirectUrl"))
                                if (!$util.isString(message.redirectUrl))
                                    return "redirectUrl: string expected";
                            if (message.scopes != null && message.hasOwnProperty("scopes")) {
                                if (!Array.isArray(message.scopes))
                                    return "scopes: array expected";
                                for (let i = 0; i < message.scopes.length; ++i)
                                    if (!$util.isString(message.scopes[i]))
                                        return "scopes: string[] expected";
                            }
                            return null;
                        };

                        /**
                         * Creates a OIDC message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authn.v1.OIDC} OIDC
                         */
                        OIDC.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authn.v1.OIDC)
                                return object;
                            let message = new $root.clutch.config.service.authn.v1.OIDC();
                            if (object.issuer != null)
                                message.issuer = String(object.issuer);
                            if (object.clientId != null)
                                message.clientId = String(object.clientId);
                            if (object.clientSecret != null)
                                message.clientSecret = String(object.clientSecret);
                            if (object.redirectUrl != null)
                                message.redirectUrl = String(object.redirectUrl);
                            if (object.scopes) {
                                if (!Array.isArray(object.scopes))
                                    throw TypeError(".clutch.config.service.authn.v1.OIDC.scopes: array expected");
                                message.scopes = [];
                                for (let i = 0; i < object.scopes.length; ++i)
                                    message.scopes[i] = String(object.scopes[i]);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a OIDC message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @static
                         * @param {clutch.config.service.authn.v1.OIDC} message OIDC
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        OIDC.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.scopes = [];
                            if (options.defaults) {
                                object.issuer = "";
                                object.clientId = "";
                                object.clientSecret = "";
                                object.redirectUrl = "";
                            }
                            if (message.issuer != null && message.hasOwnProperty("issuer"))
                                object.issuer = message.issuer;
                            if (message.clientId != null && message.hasOwnProperty("clientId"))
                                object.clientId = message.clientId;
                            if (message.clientSecret != null && message.hasOwnProperty("clientSecret"))
                                object.clientSecret = message.clientSecret;
                            if (message.redirectUrl != null && message.hasOwnProperty("redirectUrl"))
                                object.redirectUrl = message.redirectUrl;
                            if (message.scopes && message.scopes.length) {
                                object.scopes = [];
                                for (let j = 0; j < message.scopes.length; ++j)
                                    object.scopes[j] = message.scopes[j];
                            }
                            return object;
                        };

                        /**
                         * Converts this OIDC to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        OIDC.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return OIDC;
                    })();

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.authn.v1
                         * @interface IConfig
                         * @property {string|null} [sessionSecret] Config sessionSecret
                         * @property {clutch.config.service.authn.v1.IOIDC|null} [oidc] Config oidc
                         * @property {boolean|null} [enableServiceTokenCreation] Config enableServiceTokenCreation
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.authn.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.authn.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config sessionSecret.
                         * @member {string} sessionSecret
                         * @memberof clutch.config.service.authn.v1.Config
                         * @instance
                         */
                        Config.prototype.sessionSecret = "";

                        /**
                         * Config oidc.
                         * @member {clutch.config.service.authn.v1.IOIDC|null|undefined} oidc
                         * @memberof clutch.config.service.authn.v1.Config
                         * @instance
                         */
                        Config.prototype.oidc = null;

                        /**
                         * Config enableServiceTokenCreation.
                         * @member {boolean} enableServiceTokenCreation
                         * @memberof clutch.config.service.authn.v1.Config
                         * @instance
                         */
                        Config.prototype.enableServiceTokenCreation = false;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * Config type.
                         * @member {"oidc"|undefined} type
                         * @memberof clutch.config.service.authn.v1.Config
                         * @instance
                         */
                        Object.defineProperty(Config.prototype, "type", {
                            get: $util.oneOfGetter($oneOfFields = ["oidc"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.authn.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.sessionSecret != null && message.hasOwnProperty("sessionSecret"))
                                if (!$util.isString(message.sessionSecret))
                                    return "sessionSecret: string expected";
                            if (message.oidc != null && message.hasOwnProperty("oidc")) {
                                properties.type = 1;
                                {
                                    let error = $root.clutch.config.service.authn.v1.OIDC.verify(message.oidc);
                                    if (error)
                                        return "oidc." + error;
                                }
                            }
                            if (message.enableServiceTokenCreation != null && message.hasOwnProperty("enableServiceTokenCreation"))
                                if (typeof message.enableServiceTokenCreation !== "boolean")
                                    return "enableServiceTokenCreation: boolean expected";
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authn.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authn.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authn.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.authn.v1.Config();
                            if (object.sessionSecret != null)
                                message.sessionSecret = String(object.sessionSecret);
                            if (object.oidc != null) {
                                if (typeof object.oidc !== "object")
                                    throw TypeError(".clutch.config.service.authn.v1.Config.oidc: object expected");
                                message.oidc = $root.clutch.config.service.authn.v1.OIDC.fromObject(object.oidc);
                            }
                            if (object.enableServiceTokenCreation != null)
                                message.enableServiceTokenCreation = Boolean(object.enableServiceTokenCreation);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authn.v1.Config
                         * @static
                         * @param {clutch.config.service.authn.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.sessionSecret = "";
                                object.enableServiceTokenCreation = false;
                            }
                            if (message.sessionSecret != null && message.hasOwnProperty("sessionSecret"))
                                object.sessionSecret = message.sessionSecret;
                            if (message.oidc != null && message.hasOwnProperty("oidc")) {
                                object.oidc = $root.clutch.config.service.authn.v1.OIDC.toObject(message.oidc, options);
                                if (options.oneofs)
                                    object.type = "oidc";
                            }
                            if (message.enableServiceTokenCreation != null && message.hasOwnProperty("enableServiceTokenCreation"))
                                object.enableServiceTokenCreation = message.enableServiceTokenCreation;
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authn.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    v1.StorageConfig = (function() {

                        /**
                         * Properties of a StorageConfig.
                         * @memberof clutch.config.service.authn.v1
                         * @interface IStorageConfig
                         * @property {string|null} [encryptionPassphrase] StorageConfig encryptionPassphrase
                         */

                        /**
                         * Constructs a new StorageConfig.
                         * @memberof clutch.config.service.authn.v1
                         * @classdesc Represents a StorageConfig.
                         * @implements IStorageConfig
                         * @constructor
                         * @param {clutch.config.service.authn.v1.IStorageConfig=} [properties] Properties to set
                         */
                        function StorageConfig(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * StorageConfig encryptionPassphrase.
                         * @member {string} encryptionPassphrase
                         * @memberof clutch.config.service.authn.v1.StorageConfig
                         * @instance
                         */
                        StorageConfig.prototype.encryptionPassphrase = "";

                        /**
                         * Verifies a StorageConfig message.
                         * @function verify
                         * @memberof clutch.config.service.authn.v1.StorageConfig
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        StorageConfig.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.encryptionPassphrase != null && message.hasOwnProperty("encryptionPassphrase"))
                                if (!$util.isString(message.encryptionPassphrase))
                                    return "encryptionPassphrase: string expected";
                            return null;
                        };

                        /**
                         * Creates a StorageConfig message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authn.v1.StorageConfig
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authn.v1.StorageConfig} StorageConfig
                         */
                        StorageConfig.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authn.v1.StorageConfig)
                                return object;
                            let message = new $root.clutch.config.service.authn.v1.StorageConfig();
                            if (object.encryptionPassphrase != null)
                                message.encryptionPassphrase = String(object.encryptionPassphrase);
                            return message;
                        };

                        /**
                         * Creates a plain object from a StorageConfig message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authn.v1.StorageConfig
                         * @static
                         * @param {clutch.config.service.authn.v1.StorageConfig} message StorageConfig
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        StorageConfig.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.encryptionPassphrase = "";
                            if (message.encryptionPassphrase != null && message.hasOwnProperty("encryptionPassphrase"))
                                object.encryptionPassphrase = message.encryptionPassphrase;
                            return object;
                        };

                        /**
                         * Converts this StorageConfig to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authn.v1.StorageConfig
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        StorageConfig.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return StorageConfig;
                    })();

                    return v1;
                })();

                return authn;
            })();

            service.authz = (function() {

                /**
                 * Namespace authz.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const authz = {};

                authz.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.authz
                     * @namespace
                     */
                    const v1 = {};

                    v1.Principal = (function() {

                        /**
                         * Properties of a Principal.
                         * @memberof clutch.config.service.authz.v1
                         * @interface IPrincipal
                         * @property {string|null} [user] Principal user
                         * @property {string|null} [group] Principal group
                         */

                        /**
                         * Constructs a new Principal.
                         * @memberof clutch.config.service.authz.v1
                         * @classdesc Represents a Principal.
                         * @implements IPrincipal
                         * @constructor
                         * @param {clutch.config.service.authz.v1.IPrincipal=} [properties] Properties to set
                         */
                        function Principal(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Principal user.
                         * @member {string|null|undefined} user
                         * @memberof clutch.config.service.authz.v1.Principal
                         * @instance
                         */
                        Principal.prototype.user = null;

                        /**
                         * Principal group.
                         * @member {string|null|undefined} group
                         * @memberof clutch.config.service.authz.v1.Principal
                         * @instance
                         */
                        Principal.prototype.group = null;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * Principal type.
                         * @member {"user"|"group"|undefined} type
                         * @memberof clutch.config.service.authz.v1.Principal
                         * @instance
                         */
                        Object.defineProperty(Principal.prototype, "type", {
                            get: $util.oneOfGetter($oneOfFields = ["user", "group"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Verifies a Principal message.
                         * @function verify
                         * @memberof clutch.config.service.authz.v1.Principal
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Principal.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.user != null && message.hasOwnProperty("user")) {
                                properties.type = 1;
                                if (!$util.isString(message.user))
                                    return "user: string expected";
                            }
                            if (message.group != null && message.hasOwnProperty("group")) {
                                if (properties.type === 1)
                                    return "type: multiple values";
                                properties.type = 1;
                                if (!$util.isString(message.group))
                                    return "group: string expected";
                            }
                            return null;
                        };

                        /**
                         * Creates a Principal message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authz.v1.Principal
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authz.v1.Principal} Principal
                         */
                        Principal.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authz.v1.Principal)
                                return object;
                            let message = new $root.clutch.config.service.authz.v1.Principal();
                            if (object.user != null)
                                message.user = String(object.user);
                            if (object.group != null)
                                message.group = String(object.group);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Principal message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authz.v1.Principal
                         * @static
                         * @param {clutch.config.service.authz.v1.Principal} message Principal
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Principal.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (message.user != null && message.hasOwnProperty("user")) {
                                object.user = message.user;
                                if (options.oneofs)
                                    object.type = "user";
                            }
                            if (message.group != null && message.hasOwnProperty("group")) {
                                object.group = message.group;
                                if (options.oneofs)
                                    object.type = "group";
                            }
                            return object;
                        };

                        /**
                         * Converts this Principal to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authz.v1.Principal
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Principal.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Principal;
                    })();

                    v1.RoleBinding = (function() {

                        /**
                         * Properties of a RoleBinding.
                         * @memberof clutch.config.service.authz.v1
                         * @interface IRoleBinding
                         * @property {Array.<string>|null} [to] RoleBinding to
                         * @property {Array.<clutch.config.service.authz.v1.IPrincipal>|null} [principals] RoleBinding principals
                         */

                        /**
                         * Constructs a new RoleBinding.
                         * @memberof clutch.config.service.authz.v1
                         * @classdesc Represents a RoleBinding.
                         * @implements IRoleBinding
                         * @constructor
                         * @param {clutch.config.service.authz.v1.IRoleBinding=} [properties] Properties to set
                         */
                        function RoleBinding(properties) {
                            this.to = [];
                            this.principals = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * RoleBinding to.
                         * @member {Array.<string>} to
                         * @memberof clutch.config.service.authz.v1.RoleBinding
                         * @instance
                         */
                        RoleBinding.prototype.to = $util.emptyArray;

                        /**
                         * RoleBinding principals.
                         * @member {Array.<clutch.config.service.authz.v1.IPrincipal>} principals
                         * @memberof clutch.config.service.authz.v1.RoleBinding
                         * @instance
                         */
                        RoleBinding.prototype.principals = $util.emptyArray;

                        /**
                         * Verifies a RoleBinding message.
                         * @function verify
                         * @memberof clutch.config.service.authz.v1.RoleBinding
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        RoleBinding.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.to != null && message.hasOwnProperty("to")) {
                                if (!Array.isArray(message.to))
                                    return "to: array expected";
                                for (let i = 0; i < message.to.length; ++i)
                                    if (!$util.isString(message.to[i]))
                                        return "to: string[] expected";
                            }
                            if (message.principals != null && message.hasOwnProperty("principals")) {
                                if (!Array.isArray(message.principals))
                                    return "principals: array expected";
                                for (let i = 0; i < message.principals.length; ++i) {
                                    let error = $root.clutch.config.service.authz.v1.Principal.verify(message.principals[i]);
                                    if (error)
                                        return "principals." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a RoleBinding message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authz.v1.RoleBinding
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authz.v1.RoleBinding} RoleBinding
                         */
                        RoleBinding.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authz.v1.RoleBinding)
                                return object;
                            let message = new $root.clutch.config.service.authz.v1.RoleBinding();
                            if (object.to) {
                                if (!Array.isArray(object.to))
                                    throw TypeError(".clutch.config.service.authz.v1.RoleBinding.to: array expected");
                                message.to = [];
                                for (let i = 0; i < object.to.length; ++i)
                                    message.to[i] = String(object.to[i]);
                            }
                            if (object.principals) {
                                if (!Array.isArray(object.principals))
                                    throw TypeError(".clutch.config.service.authz.v1.RoleBinding.principals: array expected");
                                message.principals = [];
                                for (let i = 0; i < object.principals.length; ++i) {
                                    if (typeof object.principals[i] !== "object")
                                        throw TypeError(".clutch.config.service.authz.v1.RoleBinding.principals: object expected");
                                    message.principals[i] = $root.clutch.config.service.authz.v1.Principal.fromObject(object.principals[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a RoleBinding message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authz.v1.RoleBinding
                         * @static
                         * @param {clutch.config.service.authz.v1.RoleBinding} message RoleBinding
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        RoleBinding.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.to = [];
                                object.principals = [];
                            }
                            if (message.to && message.to.length) {
                                object.to = [];
                                for (let j = 0; j < message.to.length; ++j)
                                    object.to[j] = message.to[j];
                            }
                            if (message.principals && message.principals.length) {
                                object.principals = [];
                                for (let j = 0; j < message.principals.length; ++j)
                                    object.principals[j] = $root.clutch.config.service.authz.v1.Principal.toObject(message.principals[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this RoleBinding to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authz.v1.RoleBinding
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        RoleBinding.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return RoleBinding;
                    })();

                    v1.Policy = (function() {

                        /**
                         * Properties of a Policy.
                         * @memberof clutch.config.service.authz.v1
                         * @interface IPolicy
                         * @property {string|null} [policyName] Policy policyName
                         * @property {Array.<clutch.api.v1.ActionType>|null} [actionTypes] Policy actionTypes
                         * @property {string|null} [method] Policy method
                         * @property {Array.<string>|null} [resources] Policy resources
                         */

                        /**
                         * Constructs a new Policy.
                         * @memberof clutch.config.service.authz.v1
                         * @classdesc Represents a Policy.
                         * @implements IPolicy
                         * @constructor
                         * @param {clutch.config.service.authz.v1.IPolicy=} [properties] Properties to set
                         */
                        function Policy(properties) {
                            this.actionTypes = [];
                            this.resources = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Policy policyName.
                         * @member {string} policyName
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @instance
                         */
                        Policy.prototype.policyName = "";

                        /**
                         * Policy actionTypes.
                         * @member {Array.<clutch.api.v1.ActionType>} actionTypes
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @instance
                         */
                        Policy.prototype.actionTypes = $util.emptyArray;

                        /**
                         * Policy method.
                         * @member {string} method
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @instance
                         */
                        Policy.prototype.method = "";

                        /**
                         * Policy resources.
                         * @member {Array.<string>} resources
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @instance
                         */
                        Policy.prototype.resources = $util.emptyArray;

                        /**
                         * Verifies a Policy message.
                         * @function verify
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Policy.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.policyName != null && message.hasOwnProperty("policyName"))
                                if (!$util.isString(message.policyName))
                                    return "policyName: string expected";
                            if (message.actionTypes != null && message.hasOwnProperty("actionTypes")) {
                                if (!Array.isArray(message.actionTypes))
                                    return "actionTypes: array expected";
                                for (let i = 0; i < message.actionTypes.length; ++i)
                                    switch (message.actionTypes[i]) {
                                    default:
                                        return "actionTypes: enum value[] expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                    case 4:
                                        break;
                                    }
                            }
                            if (message.method != null && message.hasOwnProperty("method"))
                                if (!$util.isString(message.method))
                                    return "method: string expected";
                            if (message.resources != null && message.hasOwnProperty("resources")) {
                                if (!Array.isArray(message.resources))
                                    return "resources: array expected";
                                for (let i = 0; i < message.resources.length; ++i)
                                    if (!$util.isString(message.resources[i]))
                                        return "resources: string[] expected";
                            }
                            return null;
                        };

                        /**
                         * Creates a Policy message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authz.v1.Policy} Policy
                         */
                        Policy.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authz.v1.Policy)
                                return object;
                            let message = new $root.clutch.config.service.authz.v1.Policy();
                            if (object.policyName != null)
                                message.policyName = String(object.policyName);
                            if (object.actionTypes) {
                                if (!Array.isArray(object.actionTypes))
                                    throw TypeError(".clutch.config.service.authz.v1.Policy.actionTypes: array expected");
                                message.actionTypes = [];
                                for (let i = 0; i < object.actionTypes.length; ++i)
                                    switch (object.actionTypes[i]) {
                                    default:
                                    case "UNSPECIFIED":
                                    case 0:
                                        message.actionTypes[i] = 0;
                                        break;
                                    case "CREATE":
                                    case 1:
                                        message.actionTypes[i] = 1;
                                        break;
                                    case "READ":
                                    case 2:
                                        message.actionTypes[i] = 2;
                                        break;
                                    case "UPDATE":
                                    case 3:
                                        message.actionTypes[i] = 3;
                                        break;
                                    case "DELETE":
                                    case 4:
                                        message.actionTypes[i] = 4;
                                        break;
                                    }
                            }
                            if (object.method != null)
                                message.method = String(object.method);
                            if (object.resources) {
                                if (!Array.isArray(object.resources))
                                    throw TypeError(".clutch.config.service.authz.v1.Policy.resources: array expected");
                                message.resources = [];
                                for (let i = 0; i < object.resources.length; ++i)
                                    message.resources[i] = String(object.resources[i]);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Policy message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @static
                         * @param {clutch.config.service.authz.v1.Policy} message Policy
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Policy.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.actionTypes = [];
                                object.resources = [];
                            }
                            if (options.defaults) {
                                object.policyName = "";
                                object.method = "";
                            }
                            if (message.policyName != null && message.hasOwnProperty("policyName"))
                                object.policyName = message.policyName;
                            if (message.actionTypes && message.actionTypes.length) {
                                object.actionTypes = [];
                                for (let j = 0; j < message.actionTypes.length; ++j)
                                    object.actionTypes[j] = options.enums === String ? $root.clutch.api.v1.ActionType[message.actionTypes[j]] : message.actionTypes[j];
                            }
                            if (message.method != null && message.hasOwnProperty("method"))
                                object.method = message.method;
                            if (message.resources && message.resources.length) {
                                object.resources = [];
                                for (let j = 0; j < message.resources.length; ++j)
                                    object.resources[j] = message.resources[j];
                            }
                            return object;
                        };

                        /**
                         * Converts this Policy to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Policy.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Policy;
                    })();

                    v1.Role = (function() {

                        /**
                         * Properties of a Role.
                         * @memberof clutch.config.service.authz.v1
                         * @interface IRole
                         * @property {string|null} [roleName] Role roleName
                         * @property {Array.<clutch.config.service.authz.v1.IPolicy>|null} [policies] Role policies
                         */

                        /**
                         * Constructs a new Role.
                         * @memberof clutch.config.service.authz.v1
                         * @classdesc Represents a Role.
                         * @implements IRole
                         * @constructor
                         * @param {clutch.config.service.authz.v1.IRole=} [properties] Properties to set
                         */
                        function Role(properties) {
                            this.policies = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Role roleName.
                         * @member {string} roleName
                         * @memberof clutch.config.service.authz.v1.Role
                         * @instance
                         */
                        Role.prototype.roleName = "";

                        /**
                         * Role policies.
                         * @member {Array.<clutch.config.service.authz.v1.IPolicy>} policies
                         * @memberof clutch.config.service.authz.v1.Role
                         * @instance
                         */
                        Role.prototype.policies = $util.emptyArray;

                        /**
                         * Verifies a Role message.
                         * @function verify
                         * @memberof clutch.config.service.authz.v1.Role
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Role.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.roleName != null && message.hasOwnProperty("roleName"))
                                if (!$util.isString(message.roleName))
                                    return "roleName: string expected";
                            if (message.policies != null && message.hasOwnProperty("policies")) {
                                if (!Array.isArray(message.policies))
                                    return "policies: array expected";
                                for (let i = 0; i < message.policies.length; ++i) {
                                    let error = $root.clutch.config.service.authz.v1.Policy.verify(message.policies[i]);
                                    if (error)
                                        return "policies." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Role message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authz.v1.Role
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authz.v1.Role} Role
                         */
                        Role.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authz.v1.Role)
                                return object;
                            let message = new $root.clutch.config.service.authz.v1.Role();
                            if (object.roleName != null)
                                message.roleName = String(object.roleName);
                            if (object.policies) {
                                if (!Array.isArray(object.policies))
                                    throw TypeError(".clutch.config.service.authz.v1.Role.policies: array expected");
                                message.policies = [];
                                for (let i = 0; i < object.policies.length; ++i) {
                                    if (typeof object.policies[i] !== "object")
                                        throw TypeError(".clutch.config.service.authz.v1.Role.policies: object expected");
                                    message.policies[i] = $root.clutch.config.service.authz.v1.Policy.fromObject(object.policies[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Role message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authz.v1.Role
                         * @static
                         * @param {clutch.config.service.authz.v1.Role} message Role
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Role.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.policies = [];
                            if (options.defaults)
                                object.roleName = "";
                            if (message.roleName != null && message.hasOwnProperty("roleName"))
                                object.roleName = message.roleName;
                            if (message.policies && message.policies.length) {
                                object.policies = [];
                                for (let j = 0; j < message.policies.length; ++j)
                                    object.policies[j] = $root.clutch.config.service.authz.v1.Policy.toObject(message.policies[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Role to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authz.v1.Role
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Role.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Role;
                    })();

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.authz.v1
                         * @interface IConfig
                         * @property {Array.<clutch.config.service.authz.v1.IRoleBinding>|null} [roleBindings] Config roleBindings
                         * @property {Array.<clutch.config.service.authz.v1.IRole>|null} [roles] Config roles
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.authz.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.authz.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            this.roleBindings = [];
                            this.roles = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config roleBindings.
                         * @member {Array.<clutch.config.service.authz.v1.IRoleBinding>} roleBindings
                         * @memberof clutch.config.service.authz.v1.Config
                         * @instance
                         */
                        Config.prototype.roleBindings = $util.emptyArray;

                        /**
                         * Config roles.
                         * @member {Array.<clutch.config.service.authz.v1.IRole>} roles
                         * @memberof clutch.config.service.authz.v1.Config
                         * @instance
                         */
                        Config.prototype.roles = $util.emptyArray;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.authz.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.roleBindings != null && message.hasOwnProperty("roleBindings")) {
                                if (!Array.isArray(message.roleBindings))
                                    return "roleBindings: array expected";
                                for (let i = 0; i < message.roleBindings.length; ++i) {
                                    let error = $root.clutch.config.service.authz.v1.RoleBinding.verify(message.roleBindings[i]);
                                    if (error)
                                        return "roleBindings." + error;
                                }
                            }
                            if (message.roles != null && message.hasOwnProperty("roles")) {
                                if (!Array.isArray(message.roles))
                                    return "roles: array expected";
                                for (let i = 0; i < message.roles.length; ++i) {
                                    let error = $root.clutch.config.service.authz.v1.Role.verify(message.roles[i]);
                                    if (error)
                                        return "roles." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authz.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authz.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authz.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.authz.v1.Config();
                            if (object.roleBindings) {
                                if (!Array.isArray(object.roleBindings))
                                    throw TypeError(".clutch.config.service.authz.v1.Config.roleBindings: array expected");
                                message.roleBindings = [];
                                for (let i = 0; i < object.roleBindings.length; ++i) {
                                    if (typeof object.roleBindings[i] !== "object")
                                        throw TypeError(".clutch.config.service.authz.v1.Config.roleBindings: object expected");
                                    message.roleBindings[i] = $root.clutch.config.service.authz.v1.RoleBinding.fromObject(object.roleBindings[i]);
                                }
                            }
                            if (object.roles) {
                                if (!Array.isArray(object.roles))
                                    throw TypeError(".clutch.config.service.authz.v1.Config.roles: array expected");
                                message.roles = [];
                                for (let i = 0; i < object.roles.length; ++i) {
                                    if (typeof object.roles[i] !== "object")
                                        throw TypeError(".clutch.config.service.authz.v1.Config.roles: object expected");
                                    message.roles[i] = $root.clutch.config.service.authz.v1.Role.fromObject(object.roles[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authz.v1.Config
                         * @static
                         * @param {clutch.config.service.authz.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.roleBindings = [];
                                object.roles = [];
                            }
                            if (message.roleBindings && message.roleBindings.length) {
                                object.roleBindings = [];
                                for (let j = 0; j < message.roleBindings.length; ++j)
                                    object.roleBindings[j] = $root.clutch.config.service.authz.v1.RoleBinding.toObject(message.roleBindings[j], options);
                            }
                            if (message.roles && message.roles.length) {
                                object.roles = [];
                                for (let j = 0; j < message.roles.length; ++j)
                                    object.roles[j] = $root.clutch.config.service.authz.v1.Role.toObject(message.roles[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authz.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return authz;
            })();

            service.aws = (function() {

                /**
                 * Namespace aws.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const aws = {};

                aws.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.aws
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.aws.v1
                         * @interface IConfig
                         * @property {Array.<string>|null} [regions] Config regions
                         * @property {clutch.config.service.aws.v1.IClientConfig|null} [clientConfig] Config clientConfig
                         * @property {clutch.config.service.aws.v1.IDynamodbConfig|null} [dynamodbConfig] Config dynamodbConfig
                         * @property {string|null} [primaryAccountAliasDisplayName] Config primaryAccountAliasDisplayName
                         * @property {string|null} [awsConfigProfileName] Config awsConfigProfileName
                         * @property {Array.<clutch.config.service.aws.v1.IAWSAccount>|null} [additionalAccounts] Config additionalAccounts
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.aws.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.aws.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            this.regions = [];
                            this.additionalAccounts = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config regions.
                         * @member {Array.<string>} regions
                         * @memberof clutch.config.service.aws.v1.Config
                         * @instance
                         */
                        Config.prototype.regions = $util.emptyArray;

                        /**
                         * Config clientConfig.
                         * @member {clutch.config.service.aws.v1.IClientConfig|null|undefined} clientConfig
                         * @memberof clutch.config.service.aws.v1.Config
                         * @instance
                         */
                        Config.prototype.clientConfig = null;

                        /**
                         * Config dynamodbConfig.
                         * @member {clutch.config.service.aws.v1.IDynamodbConfig|null|undefined} dynamodbConfig
                         * @memberof clutch.config.service.aws.v1.Config
                         * @instance
                         */
                        Config.prototype.dynamodbConfig = null;

                        /**
                         * Config primaryAccountAliasDisplayName.
                         * @member {string} primaryAccountAliasDisplayName
                         * @memberof clutch.config.service.aws.v1.Config
                         * @instance
                         */
                        Config.prototype.primaryAccountAliasDisplayName = "";

                        /**
                         * Config awsConfigProfileName.
                         * @member {string} awsConfigProfileName
                         * @memberof clutch.config.service.aws.v1.Config
                         * @instance
                         */
                        Config.prototype.awsConfigProfileName = "";

                        /**
                         * Config additionalAccounts.
                         * @member {Array.<clutch.config.service.aws.v1.IAWSAccount>} additionalAccounts
                         * @memberof clutch.config.service.aws.v1.Config
                         * @instance
                         */
                        Config.prototype.additionalAccounts = $util.emptyArray;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.aws.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.regions != null && message.hasOwnProperty("regions")) {
                                if (!Array.isArray(message.regions))
                                    return "regions: array expected";
                                for (let i = 0; i < message.regions.length; ++i)
                                    if (!$util.isString(message.regions[i]))
                                        return "regions: string[] expected";
                            }
                            if (message.clientConfig != null && message.hasOwnProperty("clientConfig")) {
                                let error = $root.clutch.config.service.aws.v1.ClientConfig.verify(message.clientConfig);
                                if (error)
                                    return "clientConfig." + error;
                            }
                            if (message.dynamodbConfig != null && message.hasOwnProperty("dynamodbConfig")) {
                                let error = $root.clutch.config.service.aws.v1.DynamodbConfig.verify(message.dynamodbConfig);
                                if (error)
                                    return "dynamodbConfig." + error;
                            }
                            if (message.primaryAccountAliasDisplayName != null && message.hasOwnProperty("primaryAccountAliasDisplayName"))
                                if (!$util.isString(message.primaryAccountAliasDisplayName))
                                    return "primaryAccountAliasDisplayName: string expected";
                            if (message.awsConfigProfileName != null && message.hasOwnProperty("awsConfigProfileName"))
                                if (!$util.isString(message.awsConfigProfileName))
                                    return "awsConfigProfileName: string expected";
                            if (message.additionalAccounts != null && message.hasOwnProperty("additionalAccounts")) {
                                if (!Array.isArray(message.additionalAccounts))
                                    return "additionalAccounts: array expected";
                                for (let i = 0; i < message.additionalAccounts.length; ++i) {
                                    let error = $root.clutch.config.service.aws.v1.AWSAccount.verify(message.additionalAccounts[i]);
                                    if (error)
                                        return "additionalAccounts." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.aws.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.aws.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.aws.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.aws.v1.Config();
                            if (object.regions) {
                                if (!Array.isArray(object.regions))
                                    throw TypeError(".clutch.config.service.aws.v1.Config.regions: array expected");
                                message.regions = [];
                                for (let i = 0; i < object.regions.length; ++i)
                                    message.regions[i] = String(object.regions[i]);
                            }
                            if (object.clientConfig != null) {
                                if (typeof object.clientConfig !== "object")
                                    throw TypeError(".clutch.config.service.aws.v1.Config.clientConfig: object expected");
                                message.clientConfig = $root.clutch.config.service.aws.v1.ClientConfig.fromObject(object.clientConfig);
                            }
                            if (object.dynamodbConfig != null) {
                                if (typeof object.dynamodbConfig !== "object")
                                    throw TypeError(".clutch.config.service.aws.v1.Config.dynamodbConfig: object expected");
                                message.dynamodbConfig = $root.clutch.config.service.aws.v1.DynamodbConfig.fromObject(object.dynamodbConfig);
                            }
                            if (object.primaryAccountAliasDisplayName != null)
                                message.primaryAccountAliasDisplayName = String(object.primaryAccountAliasDisplayName);
                            if (object.awsConfigProfileName != null)
                                message.awsConfigProfileName = String(object.awsConfigProfileName);
                            if (object.additionalAccounts) {
                                if (!Array.isArray(object.additionalAccounts))
                                    throw TypeError(".clutch.config.service.aws.v1.Config.additionalAccounts: array expected");
                                message.additionalAccounts = [];
                                for (let i = 0; i < object.additionalAccounts.length; ++i) {
                                    if (typeof object.additionalAccounts[i] !== "object")
                                        throw TypeError(".clutch.config.service.aws.v1.Config.additionalAccounts: object expected");
                                    message.additionalAccounts[i] = $root.clutch.config.service.aws.v1.AWSAccount.fromObject(object.additionalAccounts[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.aws.v1.Config
                         * @static
                         * @param {clutch.config.service.aws.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.regions = [];
                                object.additionalAccounts = [];
                            }
                            if (options.defaults) {
                                object.clientConfig = null;
                                object.dynamodbConfig = null;
                                object.primaryAccountAliasDisplayName = "";
                                object.awsConfigProfileName = "";
                            }
                            if (message.regions && message.regions.length) {
                                object.regions = [];
                                for (let j = 0; j < message.regions.length; ++j)
                                    object.regions[j] = message.regions[j];
                            }
                            if (message.clientConfig != null && message.hasOwnProperty("clientConfig"))
                                object.clientConfig = $root.clutch.config.service.aws.v1.ClientConfig.toObject(message.clientConfig, options);
                            if (message.dynamodbConfig != null && message.hasOwnProperty("dynamodbConfig"))
                                object.dynamodbConfig = $root.clutch.config.service.aws.v1.DynamodbConfig.toObject(message.dynamodbConfig, options);
                            if (message.primaryAccountAliasDisplayName != null && message.hasOwnProperty("primaryAccountAliasDisplayName"))
                                object.primaryAccountAliasDisplayName = message.primaryAccountAliasDisplayName;
                            if (message.awsConfigProfileName != null && message.hasOwnProperty("awsConfigProfileName"))
                                object.awsConfigProfileName = message.awsConfigProfileName;
                            if (message.additionalAccounts && message.additionalAccounts.length) {
                                object.additionalAccounts = [];
                                for (let j = 0; j < message.additionalAccounts.length; ++j)
                                    object.additionalAccounts[j] = $root.clutch.config.service.aws.v1.AWSAccount.toObject(message.additionalAccounts[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.aws.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    v1.ClientConfig = (function() {

                        /**
                         * Properties of a ClientConfig.
                         * @memberof clutch.config.service.aws.v1
                         * @interface IClientConfig
                         * @property {number|null} [retries] ClientConfig retries
                         */

                        /**
                         * Constructs a new ClientConfig.
                         * @memberof clutch.config.service.aws.v1
                         * @classdesc Represents a ClientConfig.
                         * @implements IClientConfig
                         * @constructor
                         * @param {clutch.config.service.aws.v1.IClientConfig=} [properties] Properties to set
                         */
                        function ClientConfig(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ClientConfig retries.
                         * @member {number} retries
                         * @memberof clutch.config.service.aws.v1.ClientConfig
                         * @instance
                         */
                        ClientConfig.prototype.retries = 0;

                        /**
                         * Verifies a ClientConfig message.
                         * @function verify
                         * @memberof clutch.config.service.aws.v1.ClientConfig
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ClientConfig.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.retries != null && message.hasOwnProperty("retries"))
                                if (!$util.isInteger(message.retries))
                                    return "retries: integer expected";
                            return null;
                        };

                        /**
                         * Creates a ClientConfig message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.aws.v1.ClientConfig
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.aws.v1.ClientConfig} ClientConfig
                         */
                        ClientConfig.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.aws.v1.ClientConfig)
                                return object;
                            let message = new $root.clutch.config.service.aws.v1.ClientConfig();
                            if (object.retries != null)
                                message.retries = object.retries | 0;
                            return message;
                        };

                        /**
                         * Creates a plain object from a ClientConfig message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.aws.v1.ClientConfig
                         * @static
                         * @param {clutch.config.service.aws.v1.ClientConfig} message ClientConfig
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ClientConfig.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.retries = 0;
                            if (message.retries != null && message.hasOwnProperty("retries"))
                                object.retries = message.retries;
                            return object;
                        };

                        /**
                         * Converts this ClientConfig to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.aws.v1.ClientConfig
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ClientConfig.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return ClientConfig;
                    })();

                    v1.DynamodbConfig = (function() {

                        /**
                         * Properties of a DynamodbConfig.
                         * @memberof clutch.config.service.aws.v1
                         * @interface IDynamodbConfig
                         * @property {clutch.config.service.aws.v1.IScalingLimits|null} [scalingLimits] DynamodbConfig scalingLimits
                         */

                        /**
                         * Constructs a new DynamodbConfig.
                         * @memberof clutch.config.service.aws.v1
                         * @classdesc Represents a DynamodbConfig.
                         * @implements IDynamodbConfig
                         * @constructor
                         * @param {clutch.config.service.aws.v1.IDynamodbConfig=} [properties] Properties to set
                         */
                        function DynamodbConfig(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * DynamodbConfig scalingLimits.
                         * @member {clutch.config.service.aws.v1.IScalingLimits|null|undefined} scalingLimits
                         * @memberof clutch.config.service.aws.v1.DynamodbConfig
                         * @instance
                         */
                        DynamodbConfig.prototype.scalingLimits = null;

                        /**
                         * Verifies a DynamodbConfig message.
                         * @function verify
                         * @memberof clutch.config.service.aws.v1.DynamodbConfig
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        DynamodbConfig.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.scalingLimits != null && message.hasOwnProperty("scalingLimits")) {
                                let error = $root.clutch.config.service.aws.v1.ScalingLimits.verify(message.scalingLimits);
                                if (error)
                                    return "scalingLimits." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a DynamodbConfig message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.aws.v1.DynamodbConfig
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.aws.v1.DynamodbConfig} DynamodbConfig
                         */
                        DynamodbConfig.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.aws.v1.DynamodbConfig)
                                return object;
                            let message = new $root.clutch.config.service.aws.v1.DynamodbConfig();
                            if (object.scalingLimits != null) {
                                if (typeof object.scalingLimits !== "object")
                                    throw TypeError(".clutch.config.service.aws.v1.DynamodbConfig.scalingLimits: object expected");
                                message.scalingLimits = $root.clutch.config.service.aws.v1.ScalingLimits.fromObject(object.scalingLimits);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a DynamodbConfig message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.aws.v1.DynamodbConfig
                         * @static
                         * @param {clutch.config.service.aws.v1.DynamodbConfig} message DynamodbConfig
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        DynamodbConfig.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.scalingLimits = null;
                            if (message.scalingLimits != null && message.hasOwnProperty("scalingLimits"))
                                object.scalingLimits = $root.clutch.config.service.aws.v1.ScalingLimits.toObject(message.scalingLimits, options);
                            return object;
                        };

                        /**
                         * Converts this DynamodbConfig to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.aws.v1.DynamodbConfig
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        DynamodbConfig.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return DynamodbConfig;
                    })();

                    v1.ScalingLimits = (function() {

                        /**
                         * Properties of a ScalingLimits.
                         * @memberof clutch.config.service.aws.v1
                         * @interface IScalingLimits
                         * @property {number|Long|null} [maxReadCapacityUnits] ScalingLimits maxReadCapacityUnits
                         * @property {number|Long|null} [maxWriteCapacityUnits] ScalingLimits maxWriteCapacityUnits
                         * @property {number|null} [maxScaleFactor] ScalingLimits maxScaleFactor
                         * @property {boolean|null} [enableOverride] ScalingLimits enableOverride
                         */

                        /**
                         * Constructs a new ScalingLimits.
                         * @memberof clutch.config.service.aws.v1
                         * @classdesc Represents a ScalingLimits.
                         * @implements IScalingLimits
                         * @constructor
                         * @param {clutch.config.service.aws.v1.IScalingLimits=} [properties] Properties to set
                         */
                        function ScalingLimits(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ScalingLimits maxReadCapacityUnits.
                         * @member {number|Long} maxReadCapacityUnits
                         * @memberof clutch.config.service.aws.v1.ScalingLimits
                         * @instance
                         */
                        ScalingLimits.prototype.maxReadCapacityUnits = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                        /**
                         * ScalingLimits maxWriteCapacityUnits.
                         * @member {number|Long} maxWriteCapacityUnits
                         * @memberof clutch.config.service.aws.v1.ScalingLimits
                         * @instance
                         */
                        ScalingLimits.prototype.maxWriteCapacityUnits = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                        /**
                         * ScalingLimits maxScaleFactor.
                         * @member {number} maxScaleFactor
                         * @memberof clutch.config.service.aws.v1.ScalingLimits
                         * @instance
                         */
                        ScalingLimits.prototype.maxScaleFactor = 0;

                        /**
                         * ScalingLimits enableOverride.
                         * @member {boolean} enableOverride
                         * @memberof clutch.config.service.aws.v1.ScalingLimits
                         * @instance
                         */
                        ScalingLimits.prototype.enableOverride = false;

                        /**
                         * Verifies a ScalingLimits message.
                         * @function verify
                         * @memberof clutch.config.service.aws.v1.ScalingLimits
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ScalingLimits.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.maxReadCapacityUnits != null && message.hasOwnProperty("maxReadCapacityUnits"))
                                if (!$util.isInteger(message.maxReadCapacityUnits) && !(message.maxReadCapacityUnits && $util.isInteger(message.maxReadCapacityUnits.low) && $util.isInteger(message.maxReadCapacityUnits.high)))
                                    return "maxReadCapacityUnits: integer|Long expected";
                            if (message.maxWriteCapacityUnits != null && message.hasOwnProperty("maxWriteCapacityUnits"))
                                if (!$util.isInteger(message.maxWriteCapacityUnits) && !(message.maxWriteCapacityUnits && $util.isInteger(message.maxWriteCapacityUnits.low) && $util.isInteger(message.maxWriteCapacityUnits.high)))
                                    return "maxWriteCapacityUnits: integer|Long expected";
                            if (message.maxScaleFactor != null && message.hasOwnProperty("maxScaleFactor"))
                                if (typeof message.maxScaleFactor !== "number")
                                    return "maxScaleFactor: number expected";
                            if (message.enableOverride != null && message.hasOwnProperty("enableOverride"))
                                if (typeof message.enableOverride !== "boolean")
                                    return "enableOverride: boolean expected";
                            return null;
                        };

                        /**
                         * Creates a ScalingLimits message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.aws.v1.ScalingLimits
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.aws.v1.ScalingLimits} ScalingLimits
                         */
                        ScalingLimits.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.aws.v1.ScalingLimits)
                                return object;
                            let message = new $root.clutch.config.service.aws.v1.ScalingLimits();
                            if (object.maxReadCapacityUnits != null)
                                if ($util.Long)
                                    (message.maxReadCapacityUnits = $util.Long.fromValue(object.maxReadCapacityUnits)).unsigned = false;
                                else if (typeof object.maxReadCapacityUnits === "string")
                                    message.maxReadCapacityUnits = parseInt(object.maxReadCapacityUnits, 10);
                                else if (typeof object.maxReadCapacityUnits === "number")
                                    message.maxReadCapacityUnits = object.maxReadCapacityUnits;
                                else if (typeof object.maxReadCapacityUnits === "object")
                                    message.maxReadCapacityUnits = new $util.LongBits(object.maxReadCapacityUnits.low >>> 0, object.maxReadCapacityUnits.high >>> 0).toNumber();
                            if (object.maxWriteCapacityUnits != null)
                                if ($util.Long)
                                    (message.maxWriteCapacityUnits = $util.Long.fromValue(object.maxWriteCapacityUnits)).unsigned = false;
                                else if (typeof object.maxWriteCapacityUnits === "string")
                                    message.maxWriteCapacityUnits = parseInt(object.maxWriteCapacityUnits, 10);
                                else if (typeof object.maxWriteCapacityUnits === "number")
                                    message.maxWriteCapacityUnits = object.maxWriteCapacityUnits;
                                else if (typeof object.maxWriteCapacityUnits === "object")
                                    message.maxWriteCapacityUnits = new $util.LongBits(object.maxWriteCapacityUnits.low >>> 0, object.maxWriteCapacityUnits.high >>> 0).toNumber();
                            if (object.maxScaleFactor != null)
                                message.maxScaleFactor = Number(object.maxScaleFactor);
                            if (object.enableOverride != null)
                                message.enableOverride = Boolean(object.enableOverride);
                            return message;
                        };

                        /**
                         * Creates a plain object from a ScalingLimits message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.aws.v1.ScalingLimits
                         * @static
                         * @param {clutch.config.service.aws.v1.ScalingLimits} message ScalingLimits
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ScalingLimits.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                if ($util.Long) {
                                    let long = new $util.Long(0, 0, false);
                                    object.maxReadCapacityUnits = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.maxReadCapacityUnits = options.longs === String ? "0" : 0;
                                if ($util.Long) {
                                    let long = new $util.Long(0, 0, false);
                                    object.maxWriteCapacityUnits = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.maxWriteCapacityUnits = options.longs === String ? "0" : 0;
                                object.maxScaleFactor = 0;
                                object.enableOverride = false;
                            }
                            if (message.maxReadCapacityUnits != null && message.hasOwnProperty("maxReadCapacityUnits"))
                                if (typeof message.maxReadCapacityUnits === "number")
                                    object.maxReadCapacityUnits = options.longs === String ? String(message.maxReadCapacityUnits) : message.maxReadCapacityUnits;
                                else
                                    object.maxReadCapacityUnits = options.longs === String ? $util.Long.prototype.toString.call(message.maxReadCapacityUnits) : options.longs === Number ? new $util.LongBits(message.maxReadCapacityUnits.low >>> 0, message.maxReadCapacityUnits.high >>> 0).toNumber() : message.maxReadCapacityUnits;
                            if (message.maxWriteCapacityUnits != null && message.hasOwnProperty("maxWriteCapacityUnits"))
                                if (typeof message.maxWriteCapacityUnits === "number")
                                    object.maxWriteCapacityUnits = options.longs === String ? String(message.maxWriteCapacityUnits) : message.maxWriteCapacityUnits;
                                else
                                    object.maxWriteCapacityUnits = options.longs === String ? $util.Long.prototype.toString.call(message.maxWriteCapacityUnits) : options.longs === Number ? new $util.LongBits(message.maxWriteCapacityUnits.low >>> 0, message.maxWriteCapacityUnits.high >>> 0).toNumber() : message.maxWriteCapacityUnits;
                            if (message.maxScaleFactor != null && message.hasOwnProperty("maxScaleFactor"))
                                object.maxScaleFactor = options.json && !isFinite(message.maxScaleFactor) ? String(message.maxScaleFactor) : message.maxScaleFactor;
                            if (message.enableOverride != null && message.hasOwnProperty("enableOverride"))
                                object.enableOverride = message.enableOverride;
                            return object;
                        };

                        /**
                         * Converts this ScalingLimits to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.aws.v1.ScalingLimits
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ScalingLimits.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return ScalingLimits;
                    })();

                    v1.AWSAccount = (function() {

                        /**
                         * Properties of a AWSAccount.
                         * @memberof clutch.config.service.aws.v1
                         * @interface IAWSAccount
                         * @property {string|null} [alias] AWSAccount alias
                         * @property {string|null} [accountNumber] AWSAccount accountNumber
                         * @property {string|null} [iamRole] AWSAccount iamRole
                         * @property {Array.<string>|null} [regions] AWSAccount regions
                         */

                        /**
                         * Constructs a new AWSAccount.
                         * @memberof clutch.config.service.aws.v1
                         * @classdesc Represents a AWSAccount.
                         * @implements IAWSAccount
                         * @constructor
                         * @param {clutch.config.service.aws.v1.IAWSAccount=} [properties] Properties to set
                         */
                        function AWSAccount(properties) {
                            this.regions = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * AWSAccount alias.
                         * @member {string} alias
                         * @memberof clutch.config.service.aws.v1.AWSAccount
                         * @instance
                         */
                        AWSAccount.prototype.alias = "";

                        /**
                         * AWSAccount accountNumber.
                         * @member {string} accountNumber
                         * @memberof clutch.config.service.aws.v1.AWSAccount
                         * @instance
                         */
                        AWSAccount.prototype.accountNumber = "";

                        /**
                         * AWSAccount iamRole.
                         * @member {string} iamRole
                         * @memberof clutch.config.service.aws.v1.AWSAccount
                         * @instance
                         */
                        AWSAccount.prototype.iamRole = "";

                        /**
                         * AWSAccount regions.
                         * @member {Array.<string>} regions
                         * @memberof clutch.config.service.aws.v1.AWSAccount
                         * @instance
                         */
                        AWSAccount.prototype.regions = $util.emptyArray;

                        /**
                         * Verifies a AWSAccount message.
                         * @function verify
                         * @memberof clutch.config.service.aws.v1.AWSAccount
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        AWSAccount.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.alias != null && message.hasOwnProperty("alias"))
                                if (!$util.isString(message.alias))
                                    return "alias: string expected";
                            if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                                if (!$util.isString(message.accountNumber))
                                    return "accountNumber: string expected";
                            if (message.iamRole != null && message.hasOwnProperty("iamRole"))
                                if (!$util.isString(message.iamRole))
                                    return "iamRole: string expected";
                            if (message.regions != null && message.hasOwnProperty("regions")) {
                                if (!Array.isArray(message.regions))
                                    return "regions: array expected";
                                for (let i = 0; i < message.regions.length; ++i)
                                    if (!$util.isString(message.regions[i]))
                                        return "regions: string[] expected";
                            }
                            return null;
                        };

                        /**
                         * Creates a AWSAccount message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.aws.v1.AWSAccount
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.aws.v1.AWSAccount} AWSAccount
                         */
                        AWSAccount.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.aws.v1.AWSAccount)
                                return object;
                            let message = new $root.clutch.config.service.aws.v1.AWSAccount();
                            if (object.alias != null)
                                message.alias = String(object.alias);
                            if (object.accountNumber != null)
                                message.accountNumber = String(object.accountNumber);
                            if (object.iamRole != null)
                                message.iamRole = String(object.iamRole);
                            if (object.regions) {
                                if (!Array.isArray(object.regions))
                                    throw TypeError(".clutch.config.service.aws.v1.AWSAccount.regions: array expected");
                                message.regions = [];
                                for (let i = 0; i < object.regions.length; ++i)
                                    message.regions[i] = String(object.regions[i]);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a AWSAccount message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.aws.v1.AWSAccount
                         * @static
                         * @param {clutch.config.service.aws.v1.AWSAccount} message AWSAccount
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        AWSAccount.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.regions = [];
                            if (options.defaults) {
                                object.alias = "";
                                object.accountNumber = "";
                                object.iamRole = "";
                            }
                            if (message.alias != null && message.hasOwnProperty("alias"))
                                object.alias = message.alias;
                            if (message.accountNumber != null && message.hasOwnProperty("accountNumber"))
                                object.accountNumber = message.accountNumber;
                            if (message.iamRole != null && message.hasOwnProperty("iamRole"))
                                object.iamRole = message.iamRole;
                            if (message.regions && message.regions.length) {
                                object.regions = [];
                                for (let j = 0; j < message.regions.length; ++j)
                                    object.regions[j] = message.regions[j];
                            }
                            return object;
                        };

                        /**
                         * Converts this AWSAccount to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.aws.v1.AWSAccount
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        AWSAccount.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return AWSAccount;
                    })();

                    return v1;
                })();

                return aws;
            })();

            service.bot = (function() {

                /**
                 * Namespace bot.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const bot = {};

                bot.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.bot
                     * @namespace
                     */
                    const v1 = {};

                    /**
                     * Bot enum.
                     * @name clutch.config.service.bot.v1.Bot
                     * @enum {number}
                     * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                     * @property {number} SLACK=1 SLACK value
                     */
                    v1.Bot = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNSPECIFIED"] = 0;
                        values[valuesById[1] = "SLACK"] = 1;
                        return values;
                    })();

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.bot.v1
                         * @interface IConfig
                         * @property {clutch.config.service.bot.v1.Bot|null} [botProvider] Config botProvider
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.bot.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.bot.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config botProvider.
                         * @member {clutch.config.service.bot.v1.Bot} botProvider
                         * @memberof clutch.config.service.bot.v1.Config
                         * @instance
                         */
                        Config.prototype.botProvider = 0;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.bot.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.botProvider != null && message.hasOwnProperty("botProvider"))
                                switch (message.botProvider) {
                                default:
                                    return "botProvider: enum value expected";
                                case 0:
                                case 1:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.bot.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.bot.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.bot.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.bot.v1.Config();
                            switch (object.botProvider) {
                            case "UNSPECIFIED":
                            case 0:
                                message.botProvider = 0;
                                break;
                            case "SLACK":
                            case 1:
                                message.botProvider = 1;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.bot.v1.Config
                         * @static
                         * @param {clutch.config.service.bot.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.botProvider = options.enums === String ? "UNSPECIFIED" : 0;
                            if (message.botProvider != null && message.hasOwnProperty("botProvider"))
                                object.botProvider = options.enums === String ? $root.clutch.config.service.bot.v1.Bot[message.botProvider] : message.botProvider;
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.bot.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return bot;
            })();

            service.chaos = (function() {

                /**
                 * Namespace chaos.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const chaos = {};

                chaos.experimentation = (function() {

                    /**
                     * Namespace experimentation.
                     * @memberof clutch.config.service.chaos
                     * @namespace
                     */
                    const experimentation = {};

                    experimentation.terminator = (function() {

                        /**
                         * Namespace terminator.
                         * @memberof clutch.config.service.chaos.experimentation
                         * @namespace
                         */
                        const terminator = {};

                        terminator.v1 = (function() {

                            /**
                             * Namespace v1.
                             * @memberof clutch.config.service.chaos.experimentation.terminator
                             * @namespace
                             */
                            const v1 = {};

                            v1.Config = (function() {

                                /**
                                 * Properties of a Config.
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1
                                 * @interface IConfig
                                 * @property {Object.<string,clutch.config.service.chaos.experimentation.terminator.v1.Config.IPerConfigTypeConfig>|null} [perConfigTypeConfiguration] Config perConfigTypeConfiguration
                                 * @property {google.protobuf.IDuration|null} [outerLoopInterval] Config outerLoopInterval
                                 * @property {google.protobuf.IDuration|null} [perExperimentCheckInterval] Config perExperimentCheckInterval
                                 */

                                /**
                                 * Constructs a new Config.
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1
                                 * @classdesc Represents a Config.
                                 * @implements IConfig
                                 * @constructor
                                 * @param {clutch.config.service.chaos.experimentation.terminator.v1.IConfig=} [properties] Properties to set
                                 */
                                function Config(properties) {
                                    this.perConfigTypeConfiguration = {};
                                    if (properties)
                                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Config perConfigTypeConfiguration.
                                 * @member {Object.<string,clutch.config.service.chaos.experimentation.terminator.v1.Config.IPerConfigTypeConfig>} perConfigTypeConfiguration
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1.Config
                                 * @instance
                                 */
                                Config.prototype.perConfigTypeConfiguration = $util.emptyObject;

                                /**
                                 * Config outerLoopInterval.
                                 * @member {google.protobuf.IDuration|null|undefined} outerLoopInterval
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1.Config
                                 * @instance
                                 */
                                Config.prototype.outerLoopInterval = null;

                                /**
                                 * Config perExperimentCheckInterval.
                                 * @member {google.protobuf.IDuration|null|undefined} perExperimentCheckInterval
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1.Config
                                 * @instance
                                 */
                                Config.prototype.perExperimentCheckInterval = null;

                                /**
                                 * Verifies a Config message.
                                 * @function verify
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1.Config
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Config.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.perConfigTypeConfiguration != null && message.hasOwnProperty("perConfigTypeConfiguration")) {
                                        if (!$util.isObject(message.perConfigTypeConfiguration))
                                            return "perConfigTypeConfiguration: object expected";
                                        let key = Object.keys(message.perConfigTypeConfiguration);
                                        for (let i = 0; i < key.length; ++i) {
                                            let error = $root.clutch.config.service.chaos.experimentation.terminator.v1.Config.PerConfigTypeConfig.verify(message.perConfigTypeConfiguration[key[i]]);
                                            if (error)
                                                return "perConfigTypeConfiguration." + error;
                                        }
                                    }
                                    if (message.outerLoopInterval != null && message.hasOwnProperty("outerLoopInterval")) {
                                        let error = $root.google.protobuf.Duration.verify(message.outerLoopInterval);
                                        if (error)
                                            return "outerLoopInterval." + error;
                                    }
                                    if (message.perExperimentCheckInterval != null && message.hasOwnProperty("perExperimentCheckInterval")) {
                                        let error = $root.google.protobuf.Duration.verify(message.perExperimentCheckInterval);
                                        if (error)
                                            return "perExperimentCheckInterval." + error;
                                    }
                                    return null;
                                };

                                /**
                                 * Creates a Config message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1.Config
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {clutch.config.service.chaos.experimentation.terminator.v1.Config} Config
                                 */
                                Config.fromObject = function fromObject(object) {
                                    if (object instanceof $root.clutch.config.service.chaos.experimentation.terminator.v1.Config)
                                        return object;
                                    let message = new $root.clutch.config.service.chaos.experimentation.terminator.v1.Config();
                                    if (object.perConfigTypeConfiguration) {
                                        if (typeof object.perConfigTypeConfiguration !== "object")
                                            throw TypeError(".clutch.config.service.chaos.experimentation.terminator.v1.Config.perConfigTypeConfiguration: object expected");
                                        message.perConfigTypeConfiguration = {};
                                        for (let keys = Object.keys(object.perConfigTypeConfiguration), i = 0; i < keys.length; ++i) {
                                            if (typeof object.perConfigTypeConfiguration[keys[i]] !== "object")
                                                throw TypeError(".clutch.config.service.chaos.experimentation.terminator.v1.Config.perConfigTypeConfiguration: object expected");
                                            message.perConfigTypeConfiguration[keys[i]] = $root.clutch.config.service.chaos.experimentation.terminator.v1.Config.PerConfigTypeConfig.fromObject(object.perConfigTypeConfiguration[keys[i]]);
                                        }
                                    }
                                    if (object.outerLoopInterval != null) {
                                        if (typeof object.outerLoopInterval !== "object")
                                            throw TypeError(".clutch.config.service.chaos.experimentation.terminator.v1.Config.outerLoopInterval: object expected");
                                        message.outerLoopInterval = $root.google.protobuf.Duration.fromObject(object.outerLoopInterval);
                                    }
                                    if (object.perExperimentCheckInterval != null) {
                                        if (typeof object.perExperimentCheckInterval !== "object")
                                            throw TypeError(".clutch.config.service.chaos.experimentation.terminator.v1.Config.perExperimentCheckInterval: object expected");
                                        message.perExperimentCheckInterval = $root.google.protobuf.Duration.fromObject(object.perExperimentCheckInterval);
                                    }
                                    return message;
                                };

                                /**
                                 * Creates a plain object from a Config message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1.Config
                                 * @static
                                 * @param {clutch.config.service.chaos.experimentation.terminator.v1.Config} message Config
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Config.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    let object = {};
                                    if (options.objects || options.defaults)
                                        object.perConfigTypeConfiguration = {};
                                    if (options.defaults) {
                                        object.outerLoopInterval = null;
                                        object.perExperimentCheckInterval = null;
                                    }
                                    let keys2;
                                    if (message.perConfigTypeConfiguration && (keys2 = Object.keys(message.perConfigTypeConfiguration)).length) {
                                        object.perConfigTypeConfiguration = {};
                                        for (let j = 0; j < keys2.length; ++j)
                                            object.perConfigTypeConfiguration[keys2[j]] = $root.clutch.config.service.chaos.experimentation.terminator.v1.Config.PerConfigTypeConfig.toObject(message.perConfigTypeConfiguration[keys2[j]], options);
                                    }
                                    if (message.outerLoopInterval != null && message.hasOwnProperty("outerLoopInterval"))
                                        object.outerLoopInterval = $root.google.protobuf.Duration.toObject(message.outerLoopInterval, options);
                                    if (message.perExperimentCheckInterval != null && message.hasOwnProperty("perExperimentCheckInterval"))
                                        object.perExperimentCheckInterval = $root.google.protobuf.Duration.toObject(message.perExperimentCheckInterval, options);
                                    return object;
                                };

                                /**
                                 * Converts this Config to JSON.
                                 * @function toJSON
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1.Config
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Config.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                Config.PerConfigTypeConfig = (function() {

                                    /**
                                     * Properties of a PerConfigTypeConfig.
                                     * @memberof clutch.config.service.chaos.experimentation.terminator.v1.Config
                                     * @interface IPerConfigTypeConfig
                                     * @property {Array.<google.protobuf.IAny>|null} [terminationCriteria] PerConfigTypeConfig terminationCriteria
                                     */

                                    /**
                                     * Constructs a new PerConfigTypeConfig.
                                     * @memberof clutch.config.service.chaos.experimentation.terminator.v1.Config
                                     * @classdesc Represents a PerConfigTypeConfig.
                                     * @implements IPerConfigTypeConfig
                                     * @constructor
                                     * @param {clutch.config.service.chaos.experimentation.terminator.v1.Config.IPerConfigTypeConfig=} [properties] Properties to set
                                     */
                                    function PerConfigTypeConfig(properties) {
                                        this.terminationCriteria = [];
                                        if (properties)
                                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                                if (properties[keys[i]] != null)
                                                    this[keys[i]] = properties[keys[i]];
                                    }

                                    /**
                                     * PerConfigTypeConfig terminationCriteria.
                                     * @member {Array.<google.protobuf.IAny>} terminationCriteria
                                     * @memberof clutch.config.service.chaos.experimentation.terminator.v1.Config.PerConfigTypeConfig
                                     * @instance
                                     */
                                    PerConfigTypeConfig.prototype.terminationCriteria = $util.emptyArray;

                                    /**
                                     * Verifies a PerConfigTypeConfig message.
                                     * @function verify
                                     * @memberof clutch.config.service.chaos.experimentation.terminator.v1.Config.PerConfigTypeConfig
                                     * @static
                                     * @param {Object.<string,*>} message Plain object to verify
                                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                     */
                                    PerConfigTypeConfig.verify = function verify(message) {
                                        if (typeof message !== "object" || message === null)
                                            return "object expected";
                                        if (message.terminationCriteria != null && message.hasOwnProperty("terminationCriteria")) {
                                            if (!Array.isArray(message.terminationCriteria))
                                                return "terminationCriteria: array expected";
                                            for (let i = 0; i < message.terminationCriteria.length; ++i) {
                                                let error = $root.google.protobuf.Any.verify(message.terminationCriteria[i]);
                                                if (error)
                                                    return "terminationCriteria." + error;
                                            }
                                        }
                                        return null;
                                    };

                                    /**
                                     * Creates a PerConfigTypeConfig message from a plain object. Also converts values to their respective internal types.
                                     * @function fromObject
                                     * @memberof clutch.config.service.chaos.experimentation.terminator.v1.Config.PerConfigTypeConfig
                                     * @static
                                     * @param {Object.<string,*>} object Plain object
                                     * @returns {clutch.config.service.chaos.experimentation.terminator.v1.Config.PerConfigTypeConfig} PerConfigTypeConfig
                                     */
                                    PerConfigTypeConfig.fromObject = function fromObject(object) {
                                        if (object instanceof $root.clutch.config.service.chaos.experimentation.terminator.v1.Config.PerConfigTypeConfig)
                                            return object;
                                        let message = new $root.clutch.config.service.chaos.experimentation.terminator.v1.Config.PerConfigTypeConfig();
                                        if (object.terminationCriteria) {
                                            if (!Array.isArray(object.terminationCriteria))
                                                throw TypeError(".clutch.config.service.chaos.experimentation.terminator.v1.Config.PerConfigTypeConfig.terminationCriteria: array expected");
                                            message.terminationCriteria = [];
                                            for (let i = 0; i < object.terminationCriteria.length; ++i) {
                                                if (typeof object.terminationCriteria[i] !== "object")
                                                    throw TypeError(".clutch.config.service.chaos.experimentation.terminator.v1.Config.PerConfigTypeConfig.terminationCriteria: object expected");
                                                message.terminationCriteria[i] = $root.google.protobuf.Any.fromObject(object.terminationCriteria[i]);
                                            }
                                        }
                                        return message;
                                    };

                                    /**
                                     * Creates a plain object from a PerConfigTypeConfig message. Also converts values to other types if specified.
                                     * @function toObject
                                     * @memberof clutch.config.service.chaos.experimentation.terminator.v1.Config.PerConfigTypeConfig
                                     * @static
                                     * @param {clutch.config.service.chaos.experimentation.terminator.v1.Config.PerConfigTypeConfig} message PerConfigTypeConfig
                                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                                     * @returns {Object.<string,*>} Plain object
                                     */
                                    PerConfigTypeConfig.toObject = function toObject(message, options) {
                                        if (!options)
                                            options = {};
                                        let object = {};
                                        if (options.arrays || options.defaults)
                                            object.terminationCriteria = [];
                                        if (message.terminationCriteria && message.terminationCriteria.length) {
                                            object.terminationCriteria = [];
                                            for (let j = 0; j < message.terminationCriteria.length; ++j)
                                                object.terminationCriteria[j] = $root.google.protobuf.Any.toObject(message.terminationCriteria[j], options);
                                        }
                                        return object;
                                    };

                                    /**
                                     * Converts this PerConfigTypeConfig to JSON.
                                     * @function toJSON
                                     * @memberof clutch.config.service.chaos.experimentation.terminator.v1.Config.PerConfigTypeConfig
                                     * @instance
                                     * @returns {Object.<string,*>} JSON object
                                     */
                                    PerConfigTypeConfig.prototype.toJSON = function toJSON() {
                                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                    };

                                    return PerConfigTypeConfig;
                                })();

                                return Config;
                            })();

                            v1.MaxTimeTerminationCriterion = (function() {

                                /**
                                 * Properties of a MaxTimeTerminationCriterion.
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1
                                 * @interface IMaxTimeTerminationCriterion
                                 * @property {google.protobuf.IDuration|null} [maxDuration] MaxTimeTerminationCriterion maxDuration
                                 */

                                /**
                                 * Constructs a new MaxTimeTerminationCriterion.
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1
                                 * @classdesc Represents a MaxTimeTerminationCriterion.
                                 * @implements IMaxTimeTerminationCriterion
                                 * @constructor
                                 * @param {clutch.config.service.chaos.experimentation.terminator.v1.IMaxTimeTerminationCriterion=} [properties] Properties to set
                                 */
                                function MaxTimeTerminationCriterion(properties) {
                                    if (properties)
                                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * MaxTimeTerminationCriterion maxDuration.
                                 * @member {google.protobuf.IDuration|null|undefined} maxDuration
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1.MaxTimeTerminationCriterion
                                 * @instance
                                 */
                                MaxTimeTerminationCriterion.prototype.maxDuration = null;

                                /**
                                 * Verifies a MaxTimeTerminationCriterion message.
                                 * @function verify
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1.MaxTimeTerminationCriterion
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                MaxTimeTerminationCriterion.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.maxDuration != null && message.hasOwnProperty("maxDuration")) {
                                        let error = $root.google.protobuf.Duration.verify(message.maxDuration);
                                        if (error)
                                            return "maxDuration." + error;
                                    }
                                    return null;
                                };

                                /**
                                 * Creates a MaxTimeTerminationCriterion message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1.MaxTimeTerminationCriterion
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {clutch.config.service.chaos.experimentation.terminator.v1.MaxTimeTerminationCriterion} MaxTimeTerminationCriterion
                                 */
                                MaxTimeTerminationCriterion.fromObject = function fromObject(object) {
                                    if (object instanceof $root.clutch.config.service.chaos.experimentation.terminator.v1.MaxTimeTerminationCriterion)
                                        return object;
                                    let message = new $root.clutch.config.service.chaos.experimentation.terminator.v1.MaxTimeTerminationCriterion();
                                    if (object.maxDuration != null) {
                                        if (typeof object.maxDuration !== "object")
                                            throw TypeError(".clutch.config.service.chaos.experimentation.terminator.v1.MaxTimeTerminationCriterion.maxDuration: object expected");
                                        message.maxDuration = $root.google.protobuf.Duration.fromObject(object.maxDuration);
                                    }
                                    return message;
                                };

                                /**
                                 * Creates a plain object from a MaxTimeTerminationCriterion message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1.MaxTimeTerminationCriterion
                                 * @static
                                 * @param {clutch.config.service.chaos.experimentation.terminator.v1.MaxTimeTerminationCriterion} message MaxTimeTerminationCriterion
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                MaxTimeTerminationCriterion.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    let object = {};
                                    if (options.defaults)
                                        object.maxDuration = null;
                                    if (message.maxDuration != null && message.hasOwnProperty("maxDuration"))
                                        object.maxDuration = $root.google.protobuf.Duration.toObject(message.maxDuration, options);
                                    return object;
                                };

                                /**
                                 * Converts this MaxTimeTerminationCriterion to JSON.
                                 * @function toJSON
                                 * @memberof clutch.config.service.chaos.experimentation.terminator.v1.MaxTimeTerminationCriterion
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                MaxTimeTerminationCriterion.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                return MaxTimeTerminationCriterion;
                            })();

                            return v1;
                        })();

                        return terminator;
                    })();

                    return experimentation;
                })();

                return chaos;
            })();

            service.db = (function() {

                /**
                 * Namespace db.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const db = {};

                db.postgres = (function() {

                    /**
                     * Namespace postgres.
                     * @memberof clutch.config.service.db
                     * @namespace
                     */
                    const postgres = {};

                    postgres.v1 = (function() {

                        /**
                         * Namespace v1.
                         * @memberof clutch.config.service.db.postgres
                         * @namespace
                         */
                        const v1 = {};

                        v1.Connection = (function() {

                            /**
                             * Properties of a Connection.
                             * @memberof clutch.config.service.db.postgres.v1
                             * @interface IConnection
                             * @property {string|null} [host] Connection host
                             * @property {number|null} [port] Connection port
                             * @property {string|null} [user] Connection user
                             * @property {string|null} [dbname] Connection dbname
                             * @property {clutch.config.service.db.postgres.v1.Connection.SSLMode|null} [sslMode] Connection sslMode
                             * @property {string|null} [password] Connection password
                             */

                            /**
                             * Constructs a new Connection.
                             * @memberof clutch.config.service.db.postgres.v1
                             * @classdesc Represents a Connection.
                             * @implements IConnection
                             * @constructor
                             * @param {clutch.config.service.db.postgres.v1.IConnection=} [properties] Properties to set
                             */
                            function Connection(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Connection host.
                             * @member {string} host
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             */
                            Connection.prototype.host = "";

                            /**
                             * Connection port.
                             * @member {number} port
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             */
                            Connection.prototype.port = 0;

                            /**
                             * Connection user.
                             * @member {string} user
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             */
                            Connection.prototype.user = "";

                            /**
                             * Connection dbname.
                             * @member {string} dbname
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             */
                            Connection.prototype.dbname = "";

                            /**
                             * Connection sslMode.
                             * @member {clutch.config.service.db.postgres.v1.Connection.SSLMode} sslMode
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             */
                            Connection.prototype.sslMode = 0;

                            /**
                             * Connection password.
                             * @member {string|null|undefined} password
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             */
                            Connection.prototype.password = null;

                            // OneOf field names bound to virtual getters and setters
                            let $oneOfFields;

                            /**
                             * Connection authn.
                             * @member {"password"|undefined} authn
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             */
                            Object.defineProperty(Connection.prototype, "authn", {
                                get: $util.oneOfGetter($oneOfFields = ["password"]),
                                set: $util.oneOfSetter($oneOfFields)
                            });

                            /**
                             * Verifies a Connection message.
                             * @function verify
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Connection.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                let properties = {};
                                if (message.host != null && message.hasOwnProperty("host"))
                                    if (!$util.isString(message.host))
                                        return "host: string expected";
                                if (message.port != null && message.hasOwnProperty("port"))
                                    if (!$util.isInteger(message.port))
                                        return "port: integer expected";
                                if (message.user != null && message.hasOwnProperty("user"))
                                    if (!$util.isString(message.user))
                                        return "user: string expected";
                                if (message.dbname != null && message.hasOwnProperty("dbname"))
                                    if (!$util.isString(message.dbname))
                                        return "dbname: string expected";
                                if (message.sslMode != null && message.hasOwnProperty("sslMode"))
                                    switch (message.sslMode) {
                                    default:
                                        return "sslMode: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                    case 4:
                                    case 5:
                                    case 6:
                                        break;
                                    }
                                if (message.password != null && message.hasOwnProperty("password")) {
                                    properties.authn = 1;
                                    if (!$util.isString(message.password))
                                        return "password: string expected";
                                }
                                return null;
                            };

                            /**
                             * Creates a Connection message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {clutch.config.service.db.postgres.v1.Connection} Connection
                             */
                            Connection.fromObject = function fromObject(object) {
                                if (object instanceof $root.clutch.config.service.db.postgres.v1.Connection)
                                    return object;
                                let message = new $root.clutch.config.service.db.postgres.v1.Connection();
                                if (object.host != null)
                                    message.host = String(object.host);
                                if (object.port != null)
                                    message.port = object.port >>> 0;
                                if (object.user != null)
                                    message.user = String(object.user);
                                if (object.dbname != null)
                                    message.dbname = String(object.dbname);
                                switch (object.sslMode) {
                                case "UNSPECIFIED":
                                case 0:
                                    message.sslMode = 0;
                                    break;
                                case "DISABLE":
                                case 1:
                                    message.sslMode = 1;
                                    break;
                                case "ALLOW":
                                case 2:
                                    message.sslMode = 2;
                                    break;
                                case "PREFER":
                                case 3:
                                    message.sslMode = 3;
                                    break;
                                case "REQUIRE":
                                case 4:
                                    message.sslMode = 4;
                                    break;
                                case "VERIFY_CA":
                                case 5:
                                    message.sslMode = 5;
                                    break;
                                case "VERIFY_FULL":
                                case 6:
                                    message.sslMode = 6;
                                    break;
                                }
                                if (object.password != null)
                                    message.password = String(object.password);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Connection message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @static
                             * @param {clutch.config.service.db.postgres.v1.Connection} message Connection
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Connection.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.host = "";
                                    object.port = 0;
                                    object.user = "";
                                    object.dbname = "";
                                    object.sslMode = options.enums === String ? "UNSPECIFIED" : 0;
                                }
                                if (message.host != null && message.hasOwnProperty("host"))
                                    object.host = message.host;
                                if (message.port != null && message.hasOwnProperty("port"))
                                    object.port = message.port;
                                if (message.user != null && message.hasOwnProperty("user"))
                                    object.user = message.user;
                                if (message.dbname != null && message.hasOwnProperty("dbname"))
                                    object.dbname = message.dbname;
                                if (message.sslMode != null && message.hasOwnProperty("sslMode"))
                                    object.sslMode = options.enums === String ? $root.clutch.config.service.db.postgres.v1.Connection.SSLMode[message.sslMode] : message.sslMode;
                                if (message.password != null && message.hasOwnProperty("password")) {
                                    object.password = message.password;
                                    if (options.oneofs)
                                        object.authn = "password";
                                }
                                return object;
                            };

                            /**
                             * Converts this Connection to JSON.
                             * @function toJSON
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Connection.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * SSLMode enum.
                             * @name clutch.config.service.db.postgres.v1.Connection.SSLMode
                             * @enum {number}
                             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                             * @property {number} DISABLE=1 DISABLE value
                             * @property {number} ALLOW=2 ALLOW value
                             * @property {number} PREFER=3 PREFER value
                             * @property {number} REQUIRE=4 REQUIRE value
                             * @property {number} VERIFY_CA=5 VERIFY_CA value
                             * @property {number} VERIFY_FULL=6 VERIFY_FULL value
                             */
                            Connection.SSLMode = (function() {
                                const valuesById = {}, values = Object.create(valuesById);
                                values[valuesById[0] = "UNSPECIFIED"] = 0;
                                values[valuesById[1] = "DISABLE"] = 1;
                                values[valuesById[2] = "ALLOW"] = 2;
                                values[valuesById[3] = "PREFER"] = 3;
                                values[valuesById[4] = "REQUIRE"] = 4;
                                values[valuesById[5] = "VERIFY_CA"] = 5;
                                values[valuesById[6] = "VERIFY_FULL"] = 6;
                                return values;
                            })();

                            return Connection;
                        })();

                        v1.Config = (function() {

                            /**
                             * Properties of a Config.
                             * @memberof clutch.config.service.db.postgres.v1
                             * @interface IConfig
                             * @property {clutch.config.service.db.postgres.v1.IConnection|null} [connection] Config connection
                             * @property {number|null} [maxIdleConnections] Config maxIdleConnections
                             */

                            /**
                             * Constructs a new Config.
                             * @memberof clutch.config.service.db.postgres.v1
                             * @classdesc Represents a Config.
                             * @implements IConfig
                             * @constructor
                             * @param {clutch.config.service.db.postgres.v1.IConfig=} [properties] Properties to set
                             */
                            function Config(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Config connection.
                             * @member {clutch.config.service.db.postgres.v1.IConnection|null|undefined} connection
                             * @memberof clutch.config.service.db.postgres.v1.Config
                             * @instance
                             */
                            Config.prototype.connection = null;

                            /**
                             * Config maxIdleConnections.
                             * @member {number} maxIdleConnections
                             * @memberof clutch.config.service.db.postgres.v1.Config
                             * @instance
                             */
                            Config.prototype.maxIdleConnections = 0;

                            /**
                             * Verifies a Config message.
                             * @function verify
                             * @memberof clutch.config.service.db.postgres.v1.Config
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Config.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.connection != null && message.hasOwnProperty("connection")) {
                                    let error = $root.clutch.config.service.db.postgres.v1.Connection.verify(message.connection);
                                    if (error)
                                        return "connection." + error;
                                }
                                if (message.maxIdleConnections != null && message.hasOwnProperty("maxIdleConnections"))
                                    if (!$util.isInteger(message.maxIdleConnections))
                                        return "maxIdleConnections: integer expected";
                                return null;
                            };

                            /**
                             * Creates a Config message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof clutch.config.service.db.postgres.v1.Config
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {clutch.config.service.db.postgres.v1.Config} Config
                             */
                            Config.fromObject = function fromObject(object) {
                                if (object instanceof $root.clutch.config.service.db.postgres.v1.Config)
                                    return object;
                                let message = new $root.clutch.config.service.db.postgres.v1.Config();
                                if (object.connection != null) {
                                    if (typeof object.connection !== "object")
                                        throw TypeError(".clutch.config.service.db.postgres.v1.Config.connection: object expected");
                                    message.connection = $root.clutch.config.service.db.postgres.v1.Connection.fromObject(object.connection);
                                }
                                if (object.maxIdleConnections != null)
                                    message.maxIdleConnections = object.maxIdleConnections | 0;
                                return message;
                            };

                            /**
                             * Creates a plain object from a Config message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof clutch.config.service.db.postgres.v1.Config
                             * @static
                             * @param {clutch.config.service.db.postgres.v1.Config} message Config
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Config.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.connection = null;
                                    object.maxIdleConnections = 0;
                                }
                                if (message.connection != null && message.hasOwnProperty("connection"))
                                    object.connection = $root.clutch.config.service.db.postgres.v1.Connection.toObject(message.connection, options);
                                if (message.maxIdleConnections != null && message.hasOwnProperty("maxIdleConnections"))
                                    object.maxIdleConnections = message.maxIdleConnections;
                                return object;
                            };

                            /**
                             * Converts this Config to JSON.
                             * @function toJSON
                             * @memberof clutch.config.service.db.postgres.v1.Config
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Config.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Config;
                        })();

                        return v1;
                    })();

                    return postgres;
                })();

                return db;
            })();

            service.envoyadmin = (function() {

                /**
                 * Namespace envoyadmin.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const envoyadmin = {};

                envoyadmin.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.envoyadmin
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.envoyadmin.v1
                         * @interface IConfig
                         * @property {boolean|null} [secure] Config secure
                         * @property {number|null} [defaultRemotePort] Config defaultRemotePort
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.envoyadmin.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.envoyadmin.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config secure.
                         * @member {boolean} secure
                         * @memberof clutch.config.service.envoyadmin.v1.Config
                         * @instance
                         */
                        Config.prototype.secure = false;

                        /**
                         * Config defaultRemotePort.
                         * @member {number} defaultRemotePort
                         * @memberof clutch.config.service.envoyadmin.v1.Config
                         * @instance
                         */
                        Config.prototype.defaultRemotePort = 0;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.envoyadmin.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.secure != null && message.hasOwnProperty("secure"))
                                if (typeof message.secure !== "boolean")
                                    return "secure: boolean expected";
                            if (message.defaultRemotePort != null && message.hasOwnProperty("defaultRemotePort"))
                                if (!$util.isInteger(message.defaultRemotePort))
                                    return "defaultRemotePort: integer expected";
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.envoyadmin.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.envoyadmin.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.envoyadmin.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.envoyadmin.v1.Config();
                            if (object.secure != null)
                                message.secure = Boolean(object.secure);
                            if (object.defaultRemotePort != null)
                                message.defaultRemotePort = object.defaultRemotePort >>> 0;
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.envoyadmin.v1.Config
                         * @static
                         * @param {clutch.config.service.envoyadmin.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.secure = false;
                                object.defaultRemotePort = 0;
                            }
                            if (message.secure != null && message.hasOwnProperty("secure"))
                                object.secure = message.secure;
                            if (message.defaultRemotePort != null && message.hasOwnProperty("defaultRemotePort"))
                                object.defaultRemotePort = message.defaultRemotePort;
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.envoyadmin.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return envoyadmin;
            })();

            service.github = (function() {

                /**
                 * Namespace github.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const github = {};

                github.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.github
                     * @namespace
                     */
                    const v1 = {};

                    v1.AppConfig = (function() {

                        /**
                         * Properties of an AppConfig.
                         * @memberof clutch.config.service.github.v1
                         * @interface IAppConfig
                         * @property {number|Long|null} [appId] AppConfig appId
                         * @property {number|Long|null} [installationId] AppConfig installationId
                         * @property {string|null} [keyPem] AppConfig keyPem
                         * @property {string|null} [base64Pem] AppConfig base64Pem
                         */

                        /**
                         * Constructs a new AppConfig.
                         * @memberof clutch.config.service.github.v1
                         * @classdesc Represents an AppConfig.
                         * @implements IAppConfig
                         * @constructor
                         * @param {clutch.config.service.github.v1.IAppConfig=} [properties] Properties to set
                         */
                        function AppConfig(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * AppConfig appId.
                         * @member {number|Long} appId
                         * @memberof clutch.config.service.github.v1.AppConfig
                         * @instance
                         */
                        AppConfig.prototype.appId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                        /**
                         * AppConfig installationId.
                         * @member {number|Long} installationId
                         * @memberof clutch.config.service.github.v1.AppConfig
                         * @instance
                         */
                        AppConfig.prototype.installationId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                        /**
                         * AppConfig keyPem.
                         * @member {string|null|undefined} keyPem
                         * @memberof clutch.config.service.github.v1.AppConfig
                         * @instance
                         */
                        AppConfig.prototype.keyPem = null;

                        /**
                         * AppConfig base64Pem.
                         * @member {string|null|undefined} base64Pem
                         * @memberof clutch.config.service.github.v1.AppConfig
                         * @instance
                         */
                        AppConfig.prototype.base64Pem = null;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * AppConfig pem.
                         * @member {"keyPem"|"base64Pem"|undefined} pem
                         * @memberof clutch.config.service.github.v1.AppConfig
                         * @instance
                         */
                        Object.defineProperty(AppConfig.prototype, "pem", {
                            get: $util.oneOfGetter($oneOfFields = ["keyPem", "base64Pem"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Verifies an AppConfig message.
                         * @function verify
                         * @memberof clutch.config.service.github.v1.AppConfig
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        AppConfig.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.appId != null && message.hasOwnProperty("appId"))
                                if (!$util.isInteger(message.appId) && !(message.appId && $util.isInteger(message.appId.low) && $util.isInteger(message.appId.high)))
                                    return "appId: integer|Long expected";
                            if (message.installationId != null && message.hasOwnProperty("installationId"))
                                if (!$util.isInteger(message.installationId) && !(message.installationId && $util.isInteger(message.installationId.low) && $util.isInteger(message.installationId.high)))
                                    return "installationId: integer|Long expected";
                            if (message.keyPem != null && message.hasOwnProperty("keyPem")) {
                                properties.pem = 1;
                                if (!$util.isString(message.keyPem))
                                    return "keyPem: string expected";
                            }
                            if (message.base64Pem != null && message.hasOwnProperty("base64Pem")) {
                                if (properties.pem === 1)
                                    return "pem: multiple values";
                                properties.pem = 1;
                                if (!$util.isString(message.base64Pem))
                                    return "base64Pem: string expected";
                            }
                            return null;
                        };

                        /**
                         * Creates an AppConfig message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.github.v1.AppConfig
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.github.v1.AppConfig} AppConfig
                         */
                        AppConfig.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.github.v1.AppConfig)
                                return object;
                            let message = new $root.clutch.config.service.github.v1.AppConfig();
                            if (object.appId != null)
                                if ($util.Long)
                                    (message.appId = $util.Long.fromValue(object.appId)).unsigned = false;
                                else if (typeof object.appId === "string")
                                    message.appId = parseInt(object.appId, 10);
                                else if (typeof object.appId === "number")
                                    message.appId = object.appId;
                                else if (typeof object.appId === "object")
                                    message.appId = new $util.LongBits(object.appId.low >>> 0, object.appId.high >>> 0).toNumber();
                            if (object.installationId != null)
                                if ($util.Long)
                                    (message.installationId = $util.Long.fromValue(object.installationId)).unsigned = false;
                                else if (typeof object.installationId === "string")
                                    message.installationId = parseInt(object.installationId, 10);
                                else if (typeof object.installationId === "number")
                                    message.installationId = object.installationId;
                                else if (typeof object.installationId === "object")
                                    message.installationId = new $util.LongBits(object.installationId.low >>> 0, object.installationId.high >>> 0).toNumber();
                            if (object.keyPem != null)
                                message.keyPem = String(object.keyPem);
                            if (object.base64Pem != null)
                                message.base64Pem = String(object.base64Pem);
                            return message;
                        };

                        /**
                         * Creates a plain object from an AppConfig message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.github.v1.AppConfig
                         * @static
                         * @param {clutch.config.service.github.v1.AppConfig} message AppConfig
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        AppConfig.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                if ($util.Long) {
                                    let long = new $util.Long(0, 0, false);
                                    object.appId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.appId = options.longs === String ? "0" : 0;
                                if ($util.Long) {
                                    let long = new $util.Long(0, 0, false);
                                    object.installationId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.installationId = options.longs === String ? "0" : 0;
                            }
                            if (message.appId != null && message.hasOwnProperty("appId"))
                                if (typeof message.appId === "number")
                                    object.appId = options.longs === String ? String(message.appId) : message.appId;
                                else
                                    object.appId = options.longs === String ? $util.Long.prototype.toString.call(message.appId) : options.longs === Number ? new $util.LongBits(message.appId.low >>> 0, message.appId.high >>> 0).toNumber() : message.appId;
                            if (message.installationId != null && message.hasOwnProperty("installationId"))
                                if (typeof message.installationId === "number")
                                    object.installationId = options.longs === String ? String(message.installationId) : message.installationId;
                                else
                                    object.installationId = options.longs === String ? $util.Long.prototype.toString.call(message.installationId) : options.longs === Number ? new $util.LongBits(message.installationId.low >>> 0, message.installationId.high >>> 0).toNumber() : message.installationId;
                            if (message.keyPem != null && message.hasOwnProperty("keyPem")) {
                                object.keyPem = message.keyPem;
                                if (options.oneofs)
                                    object.pem = "keyPem";
                            }
                            if (message.base64Pem != null && message.hasOwnProperty("base64Pem")) {
                                object.base64Pem = message.base64Pem;
                                if (options.oneofs)
                                    object.pem = "base64Pem";
                            }
                            return object;
                        };

                        /**
                         * Converts this AppConfig to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.github.v1.AppConfig
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        AppConfig.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return AppConfig;
                    })();

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.github.v1
                         * @interface IConfig
                         * @property {string|null} [accessToken] Config accessToken
                         * @property {clutch.config.service.github.v1.IAppConfig|null} [appConfig] Config appConfig
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.github.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.github.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config accessToken.
                         * @member {string|null|undefined} accessToken
                         * @memberof clutch.config.service.github.v1.Config
                         * @instance
                         */
                        Config.prototype.accessToken = null;

                        /**
                         * Config appConfig.
                         * @member {clutch.config.service.github.v1.IAppConfig|null|undefined} appConfig
                         * @memberof clutch.config.service.github.v1.Config
                         * @instance
                         */
                        Config.prototype.appConfig = null;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * Config auth.
                         * @member {"accessToken"|"appConfig"|undefined} auth
                         * @memberof clutch.config.service.github.v1.Config
                         * @instance
                         */
                        Object.defineProperty(Config.prototype, "auth", {
                            get: $util.oneOfGetter($oneOfFields = ["accessToken", "appConfig"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.github.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.accessToken != null && message.hasOwnProperty("accessToken")) {
                                properties.auth = 1;
                                if (!$util.isString(message.accessToken))
                                    return "accessToken: string expected";
                            }
                            if (message.appConfig != null && message.hasOwnProperty("appConfig")) {
                                if (properties.auth === 1)
                                    return "auth: multiple values";
                                properties.auth = 1;
                                {
                                    let error = $root.clutch.config.service.github.v1.AppConfig.verify(message.appConfig);
                                    if (error)
                                        return "appConfig." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.github.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.github.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.github.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.github.v1.Config();
                            if (object.accessToken != null)
                                message.accessToken = String(object.accessToken);
                            if (object.appConfig != null) {
                                if (typeof object.appConfig !== "object")
                                    throw TypeError(".clutch.config.service.github.v1.Config.appConfig: object expected");
                                message.appConfig = $root.clutch.config.service.github.v1.AppConfig.fromObject(object.appConfig);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.github.v1.Config
                         * @static
                         * @param {clutch.config.service.github.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (message.accessToken != null && message.hasOwnProperty("accessToken")) {
                                object.accessToken = message.accessToken;
                                if (options.oneofs)
                                    object.auth = "accessToken";
                            }
                            if (message.appConfig != null && message.hasOwnProperty("appConfig")) {
                                object.appConfig = $root.clutch.config.service.github.v1.AppConfig.toObject(message.appConfig, options);
                                if (options.oneofs)
                                    object.auth = "appConfig";
                            }
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.github.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return github;
            })();

            service.k8s = (function() {

                /**
                 * Namespace k8s.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const k8s = {};

                k8s.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.k8s
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.k8s.v1
                         * @interface IConfig
                         * @property {Array.<string>|null} [kubeconfigs] Config kubeconfigs
                         * @property {clutch.config.service.k8s.v1.IRestClientConfig|null} [restClientConfig] Config restClientConfig
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.k8s.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.k8s.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            this.kubeconfigs = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config kubeconfigs.
                         * @member {Array.<string>} kubeconfigs
                         * @memberof clutch.config.service.k8s.v1.Config
                         * @instance
                         */
                        Config.prototype.kubeconfigs = $util.emptyArray;

                        /**
                         * Config restClientConfig.
                         * @member {clutch.config.service.k8s.v1.IRestClientConfig|null|undefined} restClientConfig
                         * @memberof clutch.config.service.k8s.v1.Config
                         * @instance
                         */
                        Config.prototype.restClientConfig = null;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.k8s.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.kubeconfigs != null && message.hasOwnProperty("kubeconfigs")) {
                                if (!Array.isArray(message.kubeconfigs))
                                    return "kubeconfigs: array expected";
                                for (let i = 0; i < message.kubeconfigs.length; ++i)
                                    if (!$util.isString(message.kubeconfigs[i]))
                                        return "kubeconfigs: string[] expected";
                            }
                            if (message.restClientConfig != null && message.hasOwnProperty("restClientConfig")) {
                                let error = $root.clutch.config.service.k8s.v1.RestClientConfig.verify(message.restClientConfig);
                                if (error)
                                    return "restClientConfig." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.k8s.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.k8s.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.k8s.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.k8s.v1.Config();
                            if (object.kubeconfigs) {
                                if (!Array.isArray(object.kubeconfigs))
                                    throw TypeError(".clutch.config.service.k8s.v1.Config.kubeconfigs: array expected");
                                message.kubeconfigs = [];
                                for (let i = 0; i < object.kubeconfigs.length; ++i)
                                    message.kubeconfigs[i] = String(object.kubeconfigs[i]);
                            }
                            if (object.restClientConfig != null) {
                                if (typeof object.restClientConfig !== "object")
                                    throw TypeError(".clutch.config.service.k8s.v1.Config.restClientConfig: object expected");
                                message.restClientConfig = $root.clutch.config.service.k8s.v1.RestClientConfig.fromObject(object.restClientConfig);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.k8s.v1.Config
                         * @static
                         * @param {clutch.config.service.k8s.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.kubeconfigs = [];
                            if (options.defaults)
                                object.restClientConfig = null;
                            if (message.kubeconfigs && message.kubeconfigs.length) {
                                object.kubeconfigs = [];
                                for (let j = 0; j < message.kubeconfigs.length; ++j)
                                    object.kubeconfigs[j] = message.kubeconfigs[j];
                            }
                            if (message.restClientConfig != null && message.hasOwnProperty("restClientConfig"))
                                object.restClientConfig = $root.clutch.config.service.k8s.v1.RestClientConfig.toObject(message.restClientConfig, options);
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.k8s.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    v1.RestClientConfig = (function() {

                        /**
                         * Properties of a RestClientConfig.
                         * @memberof clutch.config.service.k8s.v1
                         * @interface IRestClientConfig
                         * @property {google.protobuf.IDuration|null} [timeout] RestClientConfig timeout
                         * @property {number|null} [qps] RestClientConfig qps
                         * @property {number|null} [burst] RestClientConfig burst
                         */

                        /**
                         * Constructs a new RestClientConfig.
                         * @memberof clutch.config.service.k8s.v1
                         * @classdesc Represents a RestClientConfig.
                         * @implements IRestClientConfig
                         * @constructor
                         * @param {clutch.config.service.k8s.v1.IRestClientConfig=} [properties] Properties to set
                         */
                        function RestClientConfig(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * RestClientConfig timeout.
                         * @member {google.protobuf.IDuration|null|undefined} timeout
                         * @memberof clutch.config.service.k8s.v1.RestClientConfig
                         * @instance
                         */
                        RestClientConfig.prototype.timeout = null;

                        /**
                         * RestClientConfig qps.
                         * @member {number} qps
                         * @memberof clutch.config.service.k8s.v1.RestClientConfig
                         * @instance
                         */
                        RestClientConfig.prototype.qps = 0;

                        /**
                         * RestClientConfig burst.
                         * @member {number} burst
                         * @memberof clutch.config.service.k8s.v1.RestClientConfig
                         * @instance
                         */
                        RestClientConfig.prototype.burst = 0;

                        /**
                         * Verifies a RestClientConfig message.
                         * @function verify
                         * @memberof clutch.config.service.k8s.v1.RestClientConfig
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        RestClientConfig.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.timeout != null && message.hasOwnProperty("timeout")) {
                                let error = $root.google.protobuf.Duration.verify(message.timeout);
                                if (error)
                                    return "timeout." + error;
                            }
                            if (message.qps != null && message.hasOwnProperty("qps"))
                                if (typeof message.qps !== "number")
                                    return "qps: number expected";
                            if (message.burst != null && message.hasOwnProperty("burst"))
                                if (!$util.isInteger(message.burst))
                                    return "burst: integer expected";
                            return null;
                        };

                        /**
                         * Creates a RestClientConfig message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.k8s.v1.RestClientConfig
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.k8s.v1.RestClientConfig} RestClientConfig
                         */
                        RestClientConfig.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.k8s.v1.RestClientConfig)
                                return object;
                            let message = new $root.clutch.config.service.k8s.v1.RestClientConfig();
                            if (object.timeout != null) {
                                if (typeof object.timeout !== "object")
                                    throw TypeError(".clutch.config.service.k8s.v1.RestClientConfig.timeout: object expected");
                                message.timeout = $root.google.protobuf.Duration.fromObject(object.timeout);
                            }
                            if (object.qps != null)
                                message.qps = Number(object.qps);
                            if (object.burst != null)
                                message.burst = object.burst >>> 0;
                            return message;
                        };

                        /**
                         * Creates a plain object from a RestClientConfig message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.k8s.v1.RestClientConfig
                         * @static
                         * @param {clutch.config.service.k8s.v1.RestClientConfig} message RestClientConfig
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        RestClientConfig.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.timeout = null;
                                object.qps = 0;
                                object.burst = 0;
                            }
                            if (message.timeout != null && message.hasOwnProperty("timeout"))
                                object.timeout = $root.google.protobuf.Duration.toObject(message.timeout, options);
                            if (message.qps != null && message.hasOwnProperty("qps"))
                                object.qps = options.json && !isFinite(message.qps) ? String(message.qps) : message.qps;
                            if (message.burst != null && message.hasOwnProperty("burst"))
                                object.burst = message.burst;
                            return object;
                        };

                        /**
                         * Converts this RestClientConfig to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.k8s.v1.RestClientConfig
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        RestClientConfig.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return RestClientConfig;
                    })();

                    return v1;
                })();

                return k8s;
            })();

            service.shortlink = (function() {

                /**
                 * Namespace shortlink.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const shortlink = {};

                shortlink.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.shortlink
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.shortlink.v1
                         * @interface IConfig
                         * @property {string|null} [shortlinkChars] Config shortlinkChars
                         * @property {number|Long|null} [shortlinkLength] Config shortlinkLength
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.shortlink.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.shortlink.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config shortlinkChars.
                         * @member {string} shortlinkChars
                         * @memberof clutch.config.service.shortlink.v1.Config
                         * @instance
                         */
                        Config.prototype.shortlinkChars = "";

                        /**
                         * Config shortlinkLength.
                         * @member {number|Long} shortlinkLength
                         * @memberof clutch.config.service.shortlink.v1.Config
                         * @instance
                         */
                        Config.prototype.shortlinkLength = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.shortlink.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.shortlinkChars != null && message.hasOwnProperty("shortlinkChars"))
                                if (!$util.isString(message.shortlinkChars))
                                    return "shortlinkChars: string expected";
                            if (message.shortlinkLength != null && message.hasOwnProperty("shortlinkLength"))
                                if (!$util.isInteger(message.shortlinkLength) && !(message.shortlinkLength && $util.isInteger(message.shortlinkLength.low) && $util.isInteger(message.shortlinkLength.high)))
                                    return "shortlinkLength: integer|Long expected";
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.shortlink.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.shortlink.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.shortlink.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.shortlink.v1.Config();
                            if (object.shortlinkChars != null)
                                message.shortlinkChars = String(object.shortlinkChars);
                            if (object.shortlinkLength != null)
                                if ($util.Long)
                                    (message.shortlinkLength = $util.Long.fromValue(object.shortlinkLength)).unsigned = false;
                                else if (typeof object.shortlinkLength === "string")
                                    message.shortlinkLength = parseInt(object.shortlinkLength, 10);
                                else if (typeof object.shortlinkLength === "number")
                                    message.shortlinkLength = object.shortlinkLength;
                                else if (typeof object.shortlinkLength === "object")
                                    message.shortlinkLength = new $util.LongBits(object.shortlinkLength.low >>> 0, object.shortlinkLength.high >>> 0).toNumber();
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.shortlink.v1.Config
                         * @static
                         * @param {clutch.config.service.shortlink.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.shortlinkChars = "";
                                if ($util.Long) {
                                    let long = new $util.Long(0, 0, false);
                                    object.shortlinkLength = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                                } else
                                    object.shortlinkLength = options.longs === String ? "0" : 0;
                            }
                            if (message.shortlinkChars != null && message.hasOwnProperty("shortlinkChars"))
                                object.shortlinkChars = message.shortlinkChars;
                            if (message.shortlinkLength != null && message.hasOwnProperty("shortlinkLength"))
                                if (typeof message.shortlinkLength === "number")
                                    object.shortlinkLength = options.longs === String ? String(message.shortlinkLength) : message.shortlinkLength;
                                else
                                    object.shortlinkLength = options.longs === String ? $util.Long.prototype.toString.call(message.shortlinkLength) : options.longs === Number ? new $util.LongBits(message.shortlinkLength.low >>> 0, message.shortlinkLength.high >>> 0).toNumber() : message.shortlinkLength;
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.shortlink.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return shortlink;
            })();

            service.sourcegraph = (function() {

                /**
                 * Namespace sourcegraph.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const sourcegraph = {};

                sourcegraph.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.sourcegraph
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.sourcegraph.v1
                         * @interface IConfig
                         * @property {string|null} [host] Config host
                         * @property {string|null} [token] Config token
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.sourcegraph.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.sourcegraph.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config host.
                         * @member {string} host
                         * @memberof clutch.config.service.sourcegraph.v1.Config
                         * @instance
                         */
                        Config.prototype.host = "";

                        /**
                         * Config token.
                         * @member {string} token
                         * @memberof clutch.config.service.sourcegraph.v1.Config
                         * @instance
                         */
                        Config.prototype.token = "";

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.sourcegraph.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.host != null && message.hasOwnProperty("host"))
                                if (!$util.isString(message.host))
                                    return "host: string expected";
                            if (message.token != null && message.hasOwnProperty("token"))
                                if (!$util.isString(message.token))
                                    return "token: string expected";
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.sourcegraph.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.sourcegraph.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.sourcegraph.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.sourcegraph.v1.Config();
                            if (object.host != null)
                                message.host = String(object.host);
                            if (object.token != null)
                                message.token = String(object.token);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.sourcegraph.v1.Config
                         * @static
                         * @param {clutch.config.service.sourcegraph.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.host = "";
                                object.token = "";
                            }
                            if (message.host != null && message.hasOwnProperty("host"))
                                object.host = message.host;
                            if (message.token != null && message.hasOwnProperty("token"))
                                object.token = message.token;
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.sourcegraph.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return sourcegraph;
            })();

            service.temporal = (function() {

                /**
                 * Namespace temporal.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const temporal = {};

                temporal.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.temporal
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.temporal.v1
                         * @interface IConfig
                         * @property {string|null} [host] Config host
                         * @property {number|null} [port] Config port
                         * @property {clutch.config.service.temporal.v1.IConnectionOptions|null} [connectionOptions] Config connectionOptions
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.temporal.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.temporal.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config host.
                         * @member {string} host
                         * @memberof clutch.config.service.temporal.v1.Config
                         * @instance
                         */
                        Config.prototype.host = "";

                        /**
                         * Config port.
                         * @member {number} port
                         * @memberof clutch.config.service.temporal.v1.Config
                         * @instance
                         */
                        Config.prototype.port = 0;

                        /**
                         * Config connectionOptions.
                         * @member {clutch.config.service.temporal.v1.IConnectionOptions|null|undefined} connectionOptions
                         * @memberof clutch.config.service.temporal.v1.Config
                         * @instance
                         */
                        Config.prototype.connectionOptions = null;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.temporal.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.host != null && message.hasOwnProperty("host"))
                                if (!$util.isString(message.host))
                                    return "host: string expected";
                            if (message.port != null && message.hasOwnProperty("port"))
                                if (!$util.isInteger(message.port))
                                    return "port: integer expected";
                            if (message.connectionOptions != null && message.hasOwnProperty("connectionOptions")) {
                                let error = $root.clutch.config.service.temporal.v1.ConnectionOptions.verify(message.connectionOptions);
                                if (error)
                                    return "connectionOptions." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.temporal.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.temporal.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.temporal.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.temporal.v1.Config();
                            if (object.host != null)
                                message.host = String(object.host);
                            if (object.port != null)
                                message.port = object.port >>> 0;
                            if (object.connectionOptions != null) {
                                if (typeof object.connectionOptions !== "object")
                                    throw TypeError(".clutch.config.service.temporal.v1.Config.connectionOptions: object expected");
                                message.connectionOptions = $root.clutch.config.service.temporal.v1.ConnectionOptions.fromObject(object.connectionOptions);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.temporal.v1.Config
                         * @static
                         * @param {clutch.config.service.temporal.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.host = "";
                                object.port = 0;
                                object.connectionOptions = null;
                            }
                            if (message.host != null && message.hasOwnProperty("host"))
                                object.host = message.host;
                            if (message.port != null && message.hasOwnProperty("port"))
                                object.port = message.port;
                            if (message.connectionOptions != null && message.hasOwnProperty("connectionOptions"))
                                object.connectionOptions = $root.clutch.config.service.temporal.v1.ConnectionOptions.toObject(message.connectionOptions, options);
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.temporal.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    v1.ConnectionOptions = (function() {

                        /**
                         * Properties of a ConnectionOptions.
                         * @memberof clutch.config.service.temporal.v1
                         * @interface IConnectionOptions
                         * @property {boolean|null} [useSystemCaBundle] ConnectionOptions useSystemCaBundle
                         */

                        /**
                         * Constructs a new ConnectionOptions.
                         * @memberof clutch.config.service.temporal.v1
                         * @classdesc Represents a ConnectionOptions.
                         * @implements IConnectionOptions
                         * @constructor
                         * @param {clutch.config.service.temporal.v1.IConnectionOptions=} [properties] Properties to set
                         */
                        function ConnectionOptions(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * ConnectionOptions useSystemCaBundle.
                         * @member {boolean} useSystemCaBundle
                         * @memberof clutch.config.service.temporal.v1.ConnectionOptions
                         * @instance
                         */
                        ConnectionOptions.prototype.useSystemCaBundle = false;

                        /**
                         * Verifies a ConnectionOptions message.
                         * @function verify
                         * @memberof clutch.config.service.temporal.v1.ConnectionOptions
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        ConnectionOptions.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.useSystemCaBundle != null && message.hasOwnProperty("useSystemCaBundle"))
                                if (typeof message.useSystemCaBundle !== "boolean")
                                    return "useSystemCaBundle: boolean expected";
                            return null;
                        };

                        /**
                         * Creates a ConnectionOptions message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.temporal.v1.ConnectionOptions
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.temporal.v1.ConnectionOptions} ConnectionOptions
                         */
                        ConnectionOptions.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.temporal.v1.ConnectionOptions)
                                return object;
                            let message = new $root.clutch.config.service.temporal.v1.ConnectionOptions();
                            if (object.useSystemCaBundle != null)
                                message.useSystemCaBundle = Boolean(object.useSystemCaBundle);
                            return message;
                        };

                        /**
                         * Creates a plain object from a ConnectionOptions message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.temporal.v1.ConnectionOptions
                         * @static
                         * @param {clutch.config.service.temporal.v1.ConnectionOptions} message ConnectionOptions
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        ConnectionOptions.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.useSystemCaBundle = false;
                            if (message.useSystemCaBundle != null && message.hasOwnProperty("useSystemCaBundle"))
                                object.useSystemCaBundle = message.useSystemCaBundle;
                            return object;
                        };

                        /**
                         * Converts this ConnectionOptions to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.temporal.v1.ConnectionOptions
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        ConnectionOptions.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return ConnectionOptions;
                    })();

                    return v1;
                })();

                return temporal;
            })();

            service.topology = (function() {

                /**
                 * Namespace topology.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const topology = {};

                topology.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.topology
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.topology.v1
                         * @interface IConfig
                         * @property {clutch.config.service.topology.v1.ICache|null} [cache] Config cache
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.topology.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.topology.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config cache.
                         * @member {clutch.config.service.topology.v1.ICache|null|undefined} cache
                         * @memberof clutch.config.service.topology.v1.Config
                         * @instance
                         */
                        Config.prototype.cache = null;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.topology.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.cache != null && message.hasOwnProperty("cache")) {
                                let error = $root.clutch.config.service.topology.v1.Cache.verify(message.cache);
                                if (error)
                                    return "cache." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.topology.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.topology.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.topology.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.topology.v1.Config();
                            if (object.cache != null) {
                                if (typeof object.cache !== "object")
                                    throw TypeError(".clutch.config.service.topology.v1.Config.cache: object expected");
                                message.cache = $root.clutch.config.service.topology.v1.Cache.fromObject(object.cache);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.topology.v1.Config
                         * @static
                         * @param {clutch.config.service.topology.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.cache = null;
                            if (message.cache != null && message.hasOwnProperty("cache"))
                                object.cache = $root.clutch.config.service.topology.v1.Cache.toObject(message.cache, options);
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.topology.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    v1.Cache = (function() {

                        /**
                         * Properties of a Cache.
                         * @memberof clutch.config.service.topology.v1
                         * @interface ICache
                         * @property {google.protobuf.IDuration|null} [ttl] Cache ttl
                         * @property {number|null} [batchInsertSize] Cache batchInsertSize
                         * @property {google.protobuf.IDuration|null} [batchInsertFlush] Cache batchInsertFlush
                         */

                        /**
                         * Constructs a new Cache.
                         * @memberof clutch.config.service.topology.v1
                         * @classdesc Represents a Cache.
                         * @implements ICache
                         * @constructor
                         * @param {clutch.config.service.topology.v1.ICache=} [properties] Properties to set
                         */
                        function Cache(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Cache ttl.
                         * @member {google.protobuf.IDuration|null|undefined} ttl
                         * @memberof clutch.config.service.topology.v1.Cache
                         * @instance
                         */
                        Cache.prototype.ttl = null;

                        /**
                         * Cache batchInsertSize.
                         * @member {number} batchInsertSize
                         * @memberof clutch.config.service.topology.v1.Cache
                         * @instance
                         */
                        Cache.prototype.batchInsertSize = 0;

                        /**
                         * Cache batchInsertFlush.
                         * @member {google.protobuf.IDuration|null|undefined} batchInsertFlush
                         * @memberof clutch.config.service.topology.v1.Cache
                         * @instance
                         */
                        Cache.prototype.batchInsertFlush = null;

                        /**
                         * Verifies a Cache message.
                         * @function verify
                         * @memberof clutch.config.service.topology.v1.Cache
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Cache.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.ttl != null && message.hasOwnProperty("ttl")) {
                                let error = $root.google.protobuf.Duration.verify(message.ttl);
                                if (error)
                                    return "ttl." + error;
                            }
                            if (message.batchInsertSize != null && message.hasOwnProperty("batchInsertSize"))
                                if (!$util.isInteger(message.batchInsertSize))
                                    return "batchInsertSize: integer expected";
                            if (message.batchInsertFlush != null && message.hasOwnProperty("batchInsertFlush")) {
                                let error = $root.google.protobuf.Duration.verify(message.batchInsertFlush);
                                if (error)
                                    return "batchInsertFlush." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Cache message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.topology.v1.Cache
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.topology.v1.Cache} Cache
                         */
                        Cache.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.topology.v1.Cache)
                                return object;
                            let message = new $root.clutch.config.service.topology.v1.Cache();
                            if (object.ttl != null) {
                                if (typeof object.ttl !== "object")
                                    throw TypeError(".clutch.config.service.topology.v1.Cache.ttl: object expected");
                                message.ttl = $root.google.protobuf.Duration.fromObject(object.ttl);
                            }
                            if (object.batchInsertSize != null)
                                message.batchInsertSize = object.batchInsertSize | 0;
                            if (object.batchInsertFlush != null) {
                                if (typeof object.batchInsertFlush !== "object")
                                    throw TypeError(".clutch.config.service.topology.v1.Cache.batchInsertFlush: object expected");
                                message.batchInsertFlush = $root.google.protobuf.Duration.fromObject(object.batchInsertFlush);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Cache message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.topology.v1.Cache
                         * @static
                         * @param {clutch.config.service.topology.v1.Cache} message Cache
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Cache.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.ttl = null;
                                object.batchInsertSize = 0;
                                object.batchInsertFlush = null;
                            }
                            if (message.ttl != null && message.hasOwnProperty("ttl"))
                                object.ttl = $root.google.protobuf.Duration.toObject(message.ttl, options);
                            if (message.batchInsertSize != null && message.hasOwnProperty("batchInsertSize"))
                                object.batchInsertSize = message.batchInsertSize;
                            if (message.batchInsertFlush != null && message.hasOwnProperty("batchInsertFlush"))
                                object.batchInsertFlush = $root.google.protobuf.Duration.toObject(message.batchInsertFlush, options);
                            return object;
                        };

                        /**
                         * Converts this Cache to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.topology.v1.Cache
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Cache.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Cache;
                    })();

                    return v1;
                })();

                return topology;
            })();

            return service;
        })();

        return config;
    })();

    clutch.feedback = (function() {

        /**
         * Namespace feedback.
         * @memberof clutch
         * @namespace
         */
        const feedback = {};

        feedback.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.feedback
             * @namespace
             */
            const v1 = {};

            v1.FeedbackAPI = (function() {

                /**
                 * Constructs a new FeedbackAPI service.
                 * @memberof clutch.feedback.v1
                 * @classdesc Represents a FeedbackAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function FeedbackAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (FeedbackAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FeedbackAPI;

                /**
                 * Callback as used by {@link clutch.feedback.v1.FeedbackAPI#getSurveys}.
                 * @memberof clutch.feedback.v1.FeedbackAPI
                 * @typedef GetSurveysCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.feedback.v1.GetSurveysResponse} [response] GetSurveysResponse
                 */

                /**
                 * Calls GetSurveys.
                 * @function getSurveys
                 * @memberof clutch.feedback.v1.FeedbackAPI
                 * @instance
                 * @param {clutch.feedback.v1.IGetSurveysRequest} request GetSurveysRequest message or plain object
                 * @param {clutch.feedback.v1.FeedbackAPI.GetSurveysCallback} callback Node-style callback called with the error, if any, and GetSurveysResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(FeedbackAPI.prototype.getSurveys = function getSurveys(request, callback) {
                    return this.rpcCall(getSurveys, $root.clutch.feedback.v1.GetSurveysRequest, $root.clutch.feedback.v1.GetSurveysResponse, request, callback);
                }, "name", { value: "GetSurveys" });

                /**
                 * Calls GetSurveys.
                 * @function getSurveys
                 * @memberof clutch.feedback.v1.FeedbackAPI
                 * @instance
                 * @param {clutch.feedback.v1.IGetSurveysRequest} request GetSurveysRequest message or plain object
                 * @returns {Promise<clutch.feedback.v1.GetSurveysResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.feedback.v1.FeedbackAPI#submitFeedback}.
                 * @memberof clutch.feedback.v1.FeedbackAPI
                 * @typedef SubmitFeedbackCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.feedback.v1.SubmitFeedbackResponse} [response] SubmitFeedbackResponse
                 */

                /**
                 * Calls SubmitFeedback.
                 * @function submitFeedback
                 * @memberof clutch.feedback.v1.FeedbackAPI
                 * @instance
                 * @param {clutch.feedback.v1.ISubmitFeedbackRequest} request SubmitFeedbackRequest message or plain object
                 * @param {clutch.feedback.v1.FeedbackAPI.SubmitFeedbackCallback} callback Node-style callback called with the error, if any, and SubmitFeedbackResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(FeedbackAPI.prototype.submitFeedback = function submitFeedback(request, callback) {
                    return this.rpcCall(submitFeedback, $root.clutch.feedback.v1.SubmitFeedbackRequest, $root.clutch.feedback.v1.SubmitFeedbackResponse, request, callback);
                }, "name", { value: "SubmitFeedback" });

                /**
                 * Calls SubmitFeedback.
                 * @function submitFeedback
                 * @memberof clutch.feedback.v1.FeedbackAPI
                 * @instance
                 * @param {clutch.feedback.v1.ISubmitFeedbackRequest} request SubmitFeedbackRequest message or plain object
                 * @returns {Promise<clutch.feedback.v1.SubmitFeedbackResponse>} Promise
                 * @variation 2
                 */

                return FeedbackAPI;
            })();

            /**
             * Origin enum.
             * @name clutch.feedback.v1.Origin
             * @enum {number}
             * @property {number} ORIGIN_UNSPECIFIED=0 ORIGIN_UNSPECIFIED value
             * @property {number} HEADER=1 HEADER value
             * @property {number} WIZARD=2 WIZARD value
             */
            v1.Origin = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "ORIGIN_UNSPECIFIED"] = 0;
                values[valuesById[1] = "HEADER"] = 1;
                values[valuesById[2] = "WIZARD"] = 2;
                return values;
            })();

            /**
             * EmojiRating enum.
             * @name clutch.feedback.v1.EmojiRating
             * @enum {number}
             * @property {number} EMOJI_UNSPECIFIED=0 EMOJI_UNSPECIFIED value
             * @property {number} SAD=1 SAD value
             * @property {number} NEUTRAL=2 NEUTRAL value
             * @property {number} HAPPY=3 HAPPY value
             */
            v1.EmojiRating = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "EMOJI_UNSPECIFIED"] = 0;
                values[valuesById[1] = "SAD"] = 1;
                values[valuesById[2] = "NEUTRAL"] = 2;
                values[valuesById[3] = "HAPPY"] = 3;
                return values;
            })();

            v1.RatingLabel = (function() {

                /**
                 * Properties of a RatingLabel.
                 * @memberof clutch.feedback.v1
                 * @interface IRatingLabel
                 * @property {clutch.feedback.v1.EmojiRating|null} [emoji] RatingLabel emoji
                 * @property {string|null} [label] RatingLabel label
                 */

                /**
                 * Constructs a new RatingLabel.
                 * @memberof clutch.feedback.v1
                 * @classdesc Represents a RatingLabel.
                 * @implements IRatingLabel
                 * @constructor
                 * @param {clutch.feedback.v1.IRatingLabel=} [properties] Properties to set
                 */
                function RatingLabel(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RatingLabel emoji.
                 * @member {clutch.feedback.v1.EmojiRating|null|undefined} emoji
                 * @memberof clutch.feedback.v1.RatingLabel
                 * @instance
                 */
                RatingLabel.prototype.emoji = null;

                /**
                 * RatingLabel label.
                 * @member {string} label
                 * @memberof clutch.feedback.v1.RatingLabel
                 * @instance
                 */
                RatingLabel.prototype.label = "";

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * RatingLabel type.
                 * @member {"emoji"|undefined} type
                 * @memberof clutch.feedback.v1.RatingLabel
                 * @instance
                 */
                Object.defineProperty(RatingLabel.prototype, "type", {
                    get: $util.oneOfGetter($oneOfFields = ["emoji"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies a RatingLabel message.
                 * @function verify
                 * @memberof clutch.feedback.v1.RatingLabel
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RatingLabel.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.emoji != null && message.hasOwnProperty("emoji")) {
                        properties.type = 1;
                        switch (message.emoji) {
                        default:
                            return "emoji: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    }
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    return null;
                };

                /**
                 * Creates a RatingLabel message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.feedback.v1.RatingLabel
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.feedback.v1.RatingLabel} RatingLabel
                 */
                RatingLabel.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.feedback.v1.RatingLabel)
                        return object;
                    let message = new $root.clutch.feedback.v1.RatingLabel();
                    switch (object.emoji) {
                    case "EMOJI_UNSPECIFIED":
                    case 0:
                        message.emoji = 0;
                        break;
                    case "SAD":
                    case 1:
                        message.emoji = 1;
                        break;
                    case "NEUTRAL":
                    case 2:
                        message.emoji = 2;
                        break;
                    case "HAPPY":
                    case 3:
                        message.emoji = 3;
                        break;
                    }
                    if (object.label != null)
                        message.label = String(object.label);
                    return message;
                };

                /**
                 * Creates a plain object from a RatingLabel message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.feedback.v1.RatingLabel
                 * @static
                 * @param {clutch.feedback.v1.RatingLabel} message RatingLabel
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RatingLabel.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.label = "";
                    if (message.emoji != null && message.hasOwnProperty("emoji")) {
                        object.emoji = options.enums === String ? $root.clutch.feedback.v1.EmojiRating[message.emoji] : message.emoji;
                        if (options.oneofs)
                            object.type = "emoji";
                    }
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    return object;
                };

                /**
                 * Converts this RatingLabel to JSON.
                 * @function toJSON
                 * @memberof clutch.feedback.v1.RatingLabel
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RatingLabel.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RatingLabel;
            })();

            v1.RatingScale = (function() {

                /**
                 * Properties of a RatingScale.
                 * @memberof clutch.feedback.v1
                 * @interface IRatingScale
                 * @property {clutch.feedback.v1.EmojiRating|null} [emoji] RatingScale emoji
                 */

                /**
                 * Constructs a new RatingScale.
                 * @memberof clutch.feedback.v1
                 * @classdesc Represents a RatingScale.
                 * @implements IRatingScale
                 * @constructor
                 * @param {clutch.feedback.v1.IRatingScale=} [properties] Properties to set
                 */
                function RatingScale(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RatingScale emoji.
                 * @member {clutch.feedback.v1.EmojiRating|null|undefined} emoji
                 * @memberof clutch.feedback.v1.RatingScale
                 * @instance
                 */
                RatingScale.prototype.emoji = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * RatingScale type.
                 * @member {"emoji"|undefined} type
                 * @memberof clutch.feedback.v1.RatingScale
                 * @instance
                 */
                Object.defineProperty(RatingScale.prototype, "type", {
                    get: $util.oneOfGetter($oneOfFields = ["emoji"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies a RatingScale message.
                 * @function verify
                 * @memberof clutch.feedback.v1.RatingScale
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RatingScale.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.emoji != null && message.hasOwnProperty("emoji")) {
                        properties.type = 1;
                        switch (message.emoji) {
                        default:
                            return "emoji: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a RatingScale message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.feedback.v1.RatingScale
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.feedback.v1.RatingScale} RatingScale
                 */
                RatingScale.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.feedback.v1.RatingScale)
                        return object;
                    let message = new $root.clutch.feedback.v1.RatingScale();
                    switch (object.emoji) {
                    case "EMOJI_UNSPECIFIED":
                    case 0:
                        message.emoji = 0;
                        break;
                    case "SAD":
                    case 1:
                        message.emoji = 1;
                        break;
                    case "NEUTRAL":
                    case 2:
                        message.emoji = 2;
                        break;
                    case "HAPPY":
                    case 3:
                        message.emoji = 3;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RatingScale message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.feedback.v1.RatingScale
                 * @static
                 * @param {clutch.feedback.v1.RatingScale} message RatingScale
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RatingScale.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.emoji != null && message.hasOwnProperty("emoji")) {
                        object.emoji = options.enums === String ? $root.clutch.feedback.v1.EmojiRating[message.emoji] : message.emoji;
                        if (options.oneofs)
                            object.type = "emoji";
                    }
                    return object;
                };

                /**
                 * Converts this RatingScale to JSON.
                 * @function toJSON
                 * @memberof clutch.feedback.v1.RatingScale
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RatingScale.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RatingScale;
            })();

            v1.GetSurveysRequest = (function() {

                /**
                 * Properties of a GetSurveysRequest.
                 * @memberof clutch.feedback.v1
                 * @interface IGetSurveysRequest
                 * @property {Array.<clutch.feedback.v1.Origin>|null} [origins] GetSurveysRequest origins
                 */

                /**
                 * Constructs a new GetSurveysRequest.
                 * @memberof clutch.feedback.v1
                 * @classdesc Represents a GetSurveysRequest.
                 * @implements IGetSurveysRequest
                 * @constructor
                 * @param {clutch.feedback.v1.IGetSurveysRequest=} [properties] Properties to set
                 */
                function GetSurveysRequest(properties) {
                    this.origins = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetSurveysRequest origins.
                 * @member {Array.<clutch.feedback.v1.Origin>} origins
                 * @memberof clutch.feedback.v1.GetSurveysRequest
                 * @instance
                 */
                GetSurveysRequest.prototype.origins = $util.emptyArray;

                /**
                 * Verifies a GetSurveysRequest message.
                 * @function verify
                 * @memberof clutch.feedback.v1.GetSurveysRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetSurveysRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.origins != null && message.hasOwnProperty("origins")) {
                        if (!Array.isArray(message.origins))
                            return "origins: array expected";
                        for (let i = 0; i < message.origins.length; ++i)
                            switch (message.origins[i]) {
                            default:
                                return "origins: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                    }
                    return null;
                };

                /**
                 * Creates a GetSurveysRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.feedback.v1.GetSurveysRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.feedback.v1.GetSurveysRequest} GetSurveysRequest
                 */
                GetSurveysRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.feedback.v1.GetSurveysRequest)
                        return object;
                    let message = new $root.clutch.feedback.v1.GetSurveysRequest();
                    if (object.origins) {
                        if (!Array.isArray(object.origins))
                            throw TypeError(".clutch.feedback.v1.GetSurveysRequest.origins: array expected");
                        message.origins = [];
                        for (let i = 0; i < object.origins.length; ++i)
                            switch (object.origins[i]) {
                            default:
                            case "ORIGIN_UNSPECIFIED":
                            case 0:
                                message.origins[i] = 0;
                                break;
                            case "HEADER":
                            case 1:
                                message.origins[i] = 1;
                                break;
                            case "WIZARD":
                            case 2:
                                message.origins[i] = 2;
                                break;
                            }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetSurveysRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.feedback.v1.GetSurveysRequest
                 * @static
                 * @param {clutch.feedback.v1.GetSurveysRequest} message GetSurveysRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetSurveysRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.origins = [];
                    if (message.origins && message.origins.length) {
                        object.origins = [];
                        for (let j = 0; j < message.origins.length; ++j)
                            object.origins[j] = options.enums === String ? $root.clutch.feedback.v1.Origin[message.origins[j]] : message.origins[j];
                    }
                    return object;
                };

                /**
                 * Converts this GetSurveysRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.feedback.v1.GetSurveysRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetSurveysRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetSurveysRequest;
            })();

            v1.Survey = (function() {

                /**
                 * Properties of a Survey.
                 * @memberof clutch.feedback.v1
                 * @interface ISurvey
                 * @property {string|null} [prompt] Survey prompt
                 * @property {string|null} [freeformPrompt] Survey freeformPrompt
                 * @property {Array.<clutch.feedback.v1.IRatingLabel>|null} [ratingLabels] Survey ratingLabels
                 */

                /**
                 * Constructs a new Survey.
                 * @memberof clutch.feedback.v1
                 * @classdesc Represents a Survey.
                 * @implements ISurvey
                 * @constructor
                 * @param {clutch.feedback.v1.ISurvey=} [properties] Properties to set
                 */
                function Survey(properties) {
                    this.ratingLabels = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Survey prompt.
                 * @member {string} prompt
                 * @memberof clutch.feedback.v1.Survey
                 * @instance
                 */
                Survey.prototype.prompt = "";

                /**
                 * Survey freeformPrompt.
                 * @member {string} freeformPrompt
                 * @memberof clutch.feedback.v1.Survey
                 * @instance
                 */
                Survey.prototype.freeformPrompt = "";

                /**
                 * Survey ratingLabels.
                 * @member {Array.<clutch.feedback.v1.IRatingLabel>} ratingLabels
                 * @memberof clutch.feedback.v1.Survey
                 * @instance
                 */
                Survey.prototype.ratingLabels = $util.emptyArray;

                /**
                 * Verifies a Survey message.
                 * @function verify
                 * @memberof clutch.feedback.v1.Survey
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Survey.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.prompt != null && message.hasOwnProperty("prompt"))
                        if (!$util.isString(message.prompt))
                            return "prompt: string expected";
                    if (message.freeformPrompt != null && message.hasOwnProperty("freeformPrompt"))
                        if (!$util.isString(message.freeformPrompt))
                            return "freeformPrompt: string expected";
                    if (message.ratingLabels != null && message.hasOwnProperty("ratingLabels")) {
                        if (!Array.isArray(message.ratingLabels))
                            return "ratingLabels: array expected";
                        for (let i = 0; i < message.ratingLabels.length; ++i) {
                            let error = $root.clutch.feedback.v1.RatingLabel.verify(message.ratingLabels[i]);
                            if (error)
                                return "ratingLabels." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Survey message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.feedback.v1.Survey
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.feedback.v1.Survey} Survey
                 */
                Survey.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.feedback.v1.Survey)
                        return object;
                    let message = new $root.clutch.feedback.v1.Survey();
                    if (object.prompt != null)
                        message.prompt = String(object.prompt);
                    if (object.freeformPrompt != null)
                        message.freeformPrompt = String(object.freeformPrompt);
                    if (object.ratingLabels) {
                        if (!Array.isArray(object.ratingLabels))
                            throw TypeError(".clutch.feedback.v1.Survey.ratingLabels: array expected");
                        message.ratingLabels = [];
                        for (let i = 0; i < object.ratingLabels.length; ++i) {
                            if (typeof object.ratingLabels[i] !== "object")
                                throw TypeError(".clutch.feedback.v1.Survey.ratingLabels: object expected");
                            message.ratingLabels[i] = $root.clutch.feedback.v1.RatingLabel.fromObject(object.ratingLabels[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Survey message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.feedback.v1.Survey
                 * @static
                 * @param {clutch.feedback.v1.Survey} message Survey
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Survey.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.ratingLabels = [];
                    if (options.defaults) {
                        object.prompt = "";
                        object.freeformPrompt = "";
                    }
                    if (message.prompt != null && message.hasOwnProperty("prompt"))
                        object.prompt = message.prompt;
                    if (message.freeformPrompt != null && message.hasOwnProperty("freeformPrompt"))
                        object.freeformPrompt = message.freeformPrompt;
                    if (message.ratingLabels && message.ratingLabels.length) {
                        object.ratingLabels = [];
                        for (let j = 0; j < message.ratingLabels.length; ++j)
                            object.ratingLabels[j] = $root.clutch.feedback.v1.RatingLabel.toObject(message.ratingLabels[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Survey to JSON.
                 * @function toJSON
                 * @memberof clutch.feedback.v1.Survey
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Survey.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Survey;
            })();

            v1.GetSurveysResponse = (function() {

                /**
                 * Properties of a GetSurveysResponse.
                 * @memberof clutch.feedback.v1
                 * @interface IGetSurveysResponse
                 * @property {Object.<string,clutch.feedback.v1.ISurvey>|null} [originSurvey] GetSurveysResponse originSurvey
                 */

                /**
                 * Constructs a new GetSurveysResponse.
                 * @memberof clutch.feedback.v1
                 * @classdesc Represents a GetSurveysResponse.
                 * @implements IGetSurveysResponse
                 * @constructor
                 * @param {clutch.feedback.v1.IGetSurveysResponse=} [properties] Properties to set
                 */
                function GetSurveysResponse(properties) {
                    this.originSurvey = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetSurveysResponse originSurvey.
                 * @member {Object.<string,clutch.feedback.v1.ISurvey>} originSurvey
                 * @memberof clutch.feedback.v1.GetSurveysResponse
                 * @instance
                 */
                GetSurveysResponse.prototype.originSurvey = $util.emptyObject;

                /**
                 * Verifies a GetSurveysResponse message.
                 * @function verify
                 * @memberof clutch.feedback.v1.GetSurveysResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetSurveysResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.originSurvey != null && message.hasOwnProperty("originSurvey")) {
                        if (!$util.isObject(message.originSurvey))
                            return "originSurvey: object expected";
                        let key = Object.keys(message.originSurvey);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.clutch.feedback.v1.Survey.verify(message.originSurvey[key[i]]);
                            if (error)
                                return "originSurvey." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetSurveysResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.feedback.v1.GetSurveysResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.feedback.v1.GetSurveysResponse} GetSurveysResponse
                 */
                GetSurveysResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.feedback.v1.GetSurveysResponse)
                        return object;
                    let message = new $root.clutch.feedback.v1.GetSurveysResponse();
                    if (object.originSurvey) {
                        if (typeof object.originSurvey !== "object")
                            throw TypeError(".clutch.feedback.v1.GetSurveysResponse.originSurvey: object expected");
                        message.originSurvey = {};
                        for (let keys = Object.keys(object.originSurvey), i = 0; i < keys.length; ++i) {
                            if (typeof object.originSurvey[keys[i]] !== "object")
                                throw TypeError(".clutch.feedback.v1.GetSurveysResponse.originSurvey: object expected");
                            message.originSurvey[keys[i]] = $root.clutch.feedback.v1.Survey.fromObject(object.originSurvey[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetSurveysResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.feedback.v1.GetSurveysResponse
                 * @static
                 * @param {clutch.feedback.v1.GetSurveysResponse} message GetSurveysResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetSurveysResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.originSurvey = {};
                    let keys2;
                    if (message.originSurvey && (keys2 = Object.keys(message.originSurvey)).length) {
                        object.originSurvey = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.originSurvey[keys2[j]] = $root.clutch.feedback.v1.Survey.toObject(message.originSurvey[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetSurveysResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.feedback.v1.GetSurveysResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetSurveysResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetSurveysResponse;
            })();

            v1.FeedbackMetadata = (function() {

                /**
                 * Properties of a FeedbackMetadata.
                 * @memberof clutch.feedback.v1
                 * @interface IFeedbackMetadata
                 * @property {clutch.feedback.v1.Origin|null} [origin] FeedbackMetadata origin
                 * @property {clutch.feedback.v1.ISurvey|null} [survey] FeedbackMetadata survey
                 * @property {boolean|null} [userSubmitted] FeedbackMetadata userSubmitted
                 * @property {string|null} [urlSearchParams] FeedbackMetadata urlSearchParams
                 */

                /**
                 * Constructs a new FeedbackMetadata.
                 * @memberof clutch.feedback.v1
                 * @classdesc Represents a FeedbackMetadata.
                 * @implements IFeedbackMetadata
                 * @constructor
                 * @param {clutch.feedback.v1.IFeedbackMetadata=} [properties] Properties to set
                 */
                function FeedbackMetadata(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FeedbackMetadata origin.
                 * @member {clutch.feedback.v1.Origin} origin
                 * @memberof clutch.feedback.v1.FeedbackMetadata
                 * @instance
                 */
                FeedbackMetadata.prototype.origin = 0;

                /**
                 * FeedbackMetadata survey.
                 * @member {clutch.feedback.v1.ISurvey|null|undefined} survey
                 * @memberof clutch.feedback.v1.FeedbackMetadata
                 * @instance
                 */
                FeedbackMetadata.prototype.survey = null;

                /**
                 * FeedbackMetadata userSubmitted.
                 * @member {boolean} userSubmitted
                 * @memberof clutch.feedback.v1.FeedbackMetadata
                 * @instance
                 */
                FeedbackMetadata.prototype.userSubmitted = false;

                /**
                 * FeedbackMetadata urlSearchParams.
                 * @member {string} urlSearchParams
                 * @memberof clutch.feedback.v1.FeedbackMetadata
                 * @instance
                 */
                FeedbackMetadata.prototype.urlSearchParams = "";

                /**
                 * Verifies a FeedbackMetadata message.
                 * @function verify
                 * @memberof clutch.feedback.v1.FeedbackMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FeedbackMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.origin != null && message.hasOwnProperty("origin"))
                        switch (message.origin) {
                        default:
                            return "origin: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.survey != null && message.hasOwnProperty("survey")) {
                        let error = $root.clutch.feedback.v1.Survey.verify(message.survey);
                        if (error)
                            return "survey." + error;
                    }
                    if (message.userSubmitted != null && message.hasOwnProperty("userSubmitted"))
                        if (typeof message.userSubmitted !== "boolean")
                            return "userSubmitted: boolean expected";
                    if (message.urlSearchParams != null && message.hasOwnProperty("urlSearchParams"))
                        if (!$util.isString(message.urlSearchParams))
                            return "urlSearchParams: string expected";
                    return null;
                };

                /**
                 * Creates a FeedbackMetadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.feedback.v1.FeedbackMetadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.feedback.v1.FeedbackMetadata} FeedbackMetadata
                 */
                FeedbackMetadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.feedback.v1.FeedbackMetadata)
                        return object;
                    let message = new $root.clutch.feedback.v1.FeedbackMetadata();
                    switch (object.origin) {
                    case "ORIGIN_UNSPECIFIED":
                    case 0:
                        message.origin = 0;
                        break;
                    case "HEADER":
                    case 1:
                        message.origin = 1;
                        break;
                    case "WIZARD":
                    case 2:
                        message.origin = 2;
                        break;
                    }
                    if (object.survey != null) {
                        if (typeof object.survey !== "object")
                            throw TypeError(".clutch.feedback.v1.FeedbackMetadata.survey: object expected");
                        message.survey = $root.clutch.feedback.v1.Survey.fromObject(object.survey);
                    }
                    if (object.userSubmitted != null)
                        message.userSubmitted = Boolean(object.userSubmitted);
                    if (object.urlSearchParams != null)
                        message.urlSearchParams = String(object.urlSearchParams);
                    return message;
                };

                /**
                 * Creates a plain object from a FeedbackMetadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.feedback.v1.FeedbackMetadata
                 * @static
                 * @param {clutch.feedback.v1.FeedbackMetadata} message FeedbackMetadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FeedbackMetadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.origin = options.enums === String ? "ORIGIN_UNSPECIFIED" : 0;
                        object.survey = null;
                        object.userSubmitted = false;
                        object.urlSearchParams = "";
                    }
                    if (message.origin != null && message.hasOwnProperty("origin"))
                        object.origin = options.enums === String ? $root.clutch.feedback.v1.Origin[message.origin] : message.origin;
                    if (message.survey != null && message.hasOwnProperty("survey"))
                        object.survey = $root.clutch.feedback.v1.Survey.toObject(message.survey, options);
                    if (message.userSubmitted != null && message.hasOwnProperty("userSubmitted"))
                        object.userSubmitted = message.userSubmitted;
                    if (message.urlSearchParams != null && message.hasOwnProperty("urlSearchParams"))
                        object.urlSearchParams = message.urlSearchParams;
                    return object;
                };

                /**
                 * Converts this FeedbackMetadata to JSON.
                 * @function toJSON
                 * @memberof clutch.feedback.v1.FeedbackMetadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FeedbackMetadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FeedbackMetadata;
            })();

            v1.Feedback = (function() {

                /**
                 * Properties of a Feedback.
                 * @memberof clutch.feedback.v1
                 * @interface IFeedback
                 * @property {string|null} [feedbackType] Feedback feedbackType
                 * @property {string|null} [ratingLabel] Feedback ratingLabel
                 * @property {clutch.feedback.v1.IRatingScale|null} [ratingScale] Feedback ratingScale
                 * @property {string|null} [freeformResponse] Feedback freeformResponse
                 */

                /**
                 * Constructs a new Feedback.
                 * @memberof clutch.feedback.v1
                 * @classdesc Represents a Feedback.
                 * @implements IFeedback
                 * @constructor
                 * @param {clutch.feedback.v1.IFeedback=} [properties] Properties to set
                 */
                function Feedback(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Feedback feedbackType.
                 * @member {string} feedbackType
                 * @memberof clutch.feedback.v1.Feedback
                 * @instance
                 */
                Feedback.prototype.feedbackType = "";

                /**
                 * Feedback ratingLabel.
                 * @member {string} ratingLabel
                 * @memberof clutch.feedback.v1.Feedback
                 * @instance
                 */
                Feedback.prototype.ratingLabel = "";

                /**
                 * Feedback ratingScale.
                 * @member {clutch.feedback.v1.IRatingScale|null|undefined} ratingScale
                 * @memberof clutch.feedback.v1.Feedback
                 * @instance
                 */
                Feedback.prototype.ratingScale = null;

                /**
                 * Feedback freeformResponse.
                 * @member {string} freeformResponse
                 * @memberof clutch.feedback.v1.Feedback
                 * @instance
                 */
                Feedback.prototype.freeformResponse = "";

                /**
                 * Verifies a Feedback message.
                 * @function verify
                 * @memberof clutch.feedback.v1.Feedback
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Feedback.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.feedbackType != null && message.hasOwnProperty("feedbackType"))
                        if (!$util.isString(message.feedbackType))
                            return "feedbackType: string expected";
                    if (message.ratingLabel != null && message.hasOwnProperty("ratingLabel"))
                        if (!$util.isString(message.ratingLabel))
                            return "ratingLabel: string expected";
                    if (message.ratingScale != null && message.hasOwnProperty("ratingScale")) {
                        let error = $root.clutch.feedback.v1.RatingScale.verify(message.ratingScale);
                        if (error)
                            return "ratingScale." + error;
                    }
                    if (message.freeformResponse != null && message.hasOwnProperty("freeformResponse"))
                        if (!$util.isString(message.freeformResponse))
                            return "freeformResponse: string expected";
                    return null;
                };

                /**
                 * Creates a Feedback message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.feedback.v1.Feedback
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.feedback.v1.Feedback} Feedback
                 */
                Feedback.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.feedback.v1.Feedback)
                        return object;
                    let message = new $root.clutch.feedback.v1.Feedback();
                    if (object.feedbackType != null)
                        message.feedbackType = String(object.feedbackType);
                    if (object.ratingLabel != null)
                        message.ratingLabel = String(object.ratingLabel);
                    if (object.ratingScale != null) {
                        if (typeof object.ratingScale !== "object")
                            throw TypeError(".clutch.feedback.v1.Feedback.ratingScale: object expected");
                        message.ratingScale = $root.clutch.feedback.v1.RatingScale.fromObject(object.ratingScale);
                    }
                    if (object.freeformResponse != null)
                        message.freeformResponse = String(object.freeformResponse);
                    return message;
                };

                /**
                 * Creates a plain object from a Feedback message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.feedback.v1.Feedback
                 * @static
                 * @param {clutch.feedback.v1.Feedback} message Feedback
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Feedback.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.feedbackType = "";
                        object.ratingLabel = "";
                        object.ratingScale = null;
                        object.freeformResponse = "";
                    }
                    if (message.feedbackType != null && message.hasOwnProperty("feedbackType"))
                        object.feedbackType = message.feedbackType;
                    if (message.ratingLabel != null && message.hasOwnProperty("ratingLabel"))
                        object.ratingLabel = message.ratingLabel;
                    if (message.ratingScale != null && message.hasOwnProperty("ratingScale"))
                        object.ratingScale = $root.clutch.feedback.v1.RatingScale.toObject(message.ratingScale, options);
                    if (message.freeformResponse != null && message.hasOwnProperty("freeformResponse"))
                        object.freeformResponse = message.freeformResponse;
                    return object;
                };

                /**
                 * Converts this Feedback to JSON.
                 * @function toJSON
                 * @memberof clutch.feedback.v1.Feedback
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Feedback.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Feedback;
            })();

            v1.SubmitFeedbackRequest = (function() {

                /**
                 * Properties of a SubmitFeedbackRequest.
                 * @memberof clutch.feedback.v1
                 * @interface ISubmitFeedbackRequest
                 * @property {string|null} [id] SubmitFeedbackRequest id
                 * @property {string|null} [userId] SubmitFeedbackRequest userId
                 * @property {clutch.feedback.v1.IFeedback|null} [feedback] SubmitFeedbackRequest feedback
                 * @property {clutch.feedback.v1.IFeedbackMetadata|null} [metadata] SubmitFeedbackRequest metadata
                 */

                /**
                 * Constructs a new SubmitFeedbackRequest.
                 * @memberof clutch.feedback.v1
                 * @classdesc Represents a SubmitFeedbackRequest.
                 * @implements ISubmitFeedbackRequest
                 * @constructor
                 * @param {clutch.feedback.v1.ISubmitFeedbackRequest=} [properties] Properties to set
                 */
                function SubmitFeedbackRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SubmitFeedbackRequest id.
                 * @member {string} id
                 * @memberof clutch.feedback.v1.SubmitFeedbackRequest
                 * @instance
                 */
                SubmitFeedbackRequest.prototype.id = "";

                /**
                 * SubmitFeedbackRequest userId.
                 * @member {string} userId
                 * @memberof clutch.feedback.v1.SubmitFeedbackRequest
                 * @instance
                 */
                SubmitFeedbackRequest.prototype.userId = "";

                /**
                 * SubmitFeedbackRequest feedback.
                 * @member {clutch.feedback.v1.IFeedback|null|undefined} feedback
                 * @memberof clutch.feedback.v1.SubmitFeedbackRequest
                 * @instance
                 */
                SubmitFeedbackRequest.prototype.feedback = null;

                /**
                 * SubmitFeedbackRequest metadata.
                 * @member {clutch.feedback.v1.IFeedbackMetadata|null|undefined} metadata
                 * @memberof clutch.feedback.v1.SubmitFeedbackRequest
                 * @instance
                 */
                SubmitFeedbackRequest.prototype.metadata = null;

                /**
                 * Verifies a SubmitFeedbackRequest message.
                 * @function verify
                 * @memberof clutch.feedback.v1.SubmitFeedbackRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SubmitFeedbackRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.userId != null && message.hasOwnProperty("userId"))
                        if (!$util.isString(message.userId))
                            return "userId: string expected";
                    if (message.feedback != null && message.hasOwnProperty("feedback")) {
                        let error = $root.clutch.feedback.v1.Feedback.verify(message.feedback);
                        if (error)
                            return "feedback." + error;
                    }
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        let error = $root.clutch.feedback.v1.FeedbackMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    return null;
                };

                /**
                 * Creates a SubmitFeedbackRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.feedback.v1.SubmitFeedbackRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.feedback.v1.SubmitFeedbackRequest} SubmitFeedbackRequest
                 */
                SubmitFeedbackRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.feedback.v1.SubmitFeedbackRequest)
                        return object;
                    let message = new $root.clutch.feedback.v1.SubmitFeedbackRequest();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.userId != null)
                        message.userId = String(object.userId);
                    if (object.feedback != null) {
                        if (typeof object.feedback !== "object")
                            throw TypeError(".clutch.feedback.v1.SubmitFeedbackRequest.feedback: object expected");
                        message.feedback = $root.clutch.feedback.v1.Feedback.fromObject(object.feedback);
                    }
                    if (object.metadata != null) {
                        if (typeof object.metadata !== "object")
                            throw TypeError(".clutch.feedback.v1.SubmitFeedbackRequest.metadata: object expected");
                        message.metadata = $root.clutch.feedback.v1.FeedbackMetadata.fromObject(object.metadata);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SubmitFeedbackRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.feedback.v1.SubmitFeedbackRequest
                 * @static
                 * @param {clutch.feedback.v1.SubmitFeedbackRequest} message SubmitFeedbackRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SubmitFeedbackRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.userId = "";
                        object.feedback = null;
                        object.metadata = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.userId != null && message.hasOwnProperty("userId"))
                        object.userId = message.userId;
                    if (message.feedback != null && message.hasOwnProperty("feedback"))
                        object.feedback = $root.clutch.feedback.v1.Feedback.toObject(message.feedback, options);
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        object.metadata = $root.clutch.feedback.v1.FeedbackMetadata.toObject(message.metadata, options);
                    return object;
                };

                /**
                 * Converts this SubmitFeedbackRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.feedback.v1.SubmitFeedbackRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SubmitFeedbackRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SubmitFeedbackRequest;
            })();

            v1.SubmitFeedbackResponse = (function() {

                /**
                 * Properties of a SubmitFeedbackResponse.
                 * @memberof clutch.feedback.v1
                 * @interface ISubmitFeedbackResponse
                 */

                /**
                 * Constructs a new SubmitFeedbackResponse.
                 * @memberof clutch.feedback.v1
                 * @classdesc Represents a SubmitFeedbackResponse.
                 * @implements ISubmitFeedbackResponse
                 * @constructor
                 * @param {clutch.feedback.v1.ISubmitFeedbackResponse=} [properties] Properties to set
                 */
                function SubmitFeedbackResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a SubmitFeedbackResponse message.
                 * @function verify
                 * @memberof clutch.feedback.v1.SubmitFeedbackResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SubmitFeedbackResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a SubmitFeedbackResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.feedback.v1.SubmitFeedbackResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.feedback.v1.SubmitFeedbackResponse} SubmitFeedbackResponse
                 */
                SubmitFeedbackResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.feedback.v1.SubmitFeedbackResponse)
                        return object;
                    return new $root.clutch.feedback.v1.SubmitFeedbackResponse();
                };

                /**
                 * Creates a plain object from a SubmitFeedbackResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.feedback.v1.SubmitFeedbackResponse
                 * @static
                 * @param {clutch.feedback.v1.SubmitFeedbackResponse} message SubmitFeedbackResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SubmitFeedbackResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this SubmitFeedbackResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.feedback.v1.SubmitFeedbackResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SubmitFeedbackResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SubmitFeedbackResponse;
            })();

            return v1;
        })();

        return feedback;
    })();

    clutch.sourcecontrol = (function() {

        /**
         * Namespace sourcecontrol.
         * @memberof clutch
         * @namespace
         */
        const sourcecontrol = {};

        sourcecontrol.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.sourcecontrol
             * @namespace
             */
            const v1 = {};

            /**
             * Visibility enum.
             * @name clutch.sourcecontrol.v1.Visibility
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} PUBLIC=1 PUBLIC value
             * @property {number} PRIVATE=2 PRIVATE value
             */
            v1.Visibility = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "PUBLIC"] = 1;
                values[valuesById[2] = "PRIVATE"] = 2;
                return values;
            })();

            v1.SourceControlAPI = (function() {

                /**
                 * Constructs a new SourceControlAPI service.
                 * @memberof clutch.sourcecontrol.v1
                 * @classdesc Represents a SourceControlAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function SourceControlAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (SourceControlAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = SourceControlAPI;

                /**
                 * Callback as used by {@link clutch.sourcecontrol.v1.SourceControlAPI#getRepositoryOptions}.
                 * @memberof clutch.sourcecontrol.v1.SourceControlAPI
                 * @typedef GetRepositoryOptionsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.sourcecontrol.v1.GetRepositoryOptionsResponse} [response] GetRepositoryOptionsResponse
                 */

                /**
                 * Calls GetRepositoryOptions.
                 * @function getRepositoryOptions
                 * @memberof clutch.sourcecontrol.v1.SourceControlAPI
                 * @instance
                 * @param {clutch.sourcecontrol.v1.IGetRepositoryOptionsRequest} request GetRepositoryOptionsRequest message or plain object
                 * @param {clutch.sourcecontrol.v1.SourceControlAPI.GetRepositoryOptionsCallback} callback Node-style callback called with the error, if any, and GetRepositoryOptionsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(SourceControlAPI.prototype.getRepositoryOptions = function getRepositoryOptions(request, callback) {
                    return this.rpcCall(getRepositoryOptions, $root.clutch.sourcecontrol.v1.GetRepositoryOptionsRequest, $root.clutch.sourcecontrol.v1.GetRepositoryOptionsResponse, request, callback);
                }, "name", { value: "GetRepositoryOptions" });

                /**
                 * Calls GetRepositoryOptions.
                 * @function getRepositoryOptions
                 * @memberof clutch.sourcecontrol.v1.SourceControlAPI
                 * @instance
                 * @param {clutch.sourcecontrol.v1.IGetRepositoryOptionsRequest} request GetRepositoryOptionsRequest message or plain object
                 * @returns {Promise<clutch.sourcecontrol.v1.GetRepositoryOptionsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.sourcecontrol.v1.SourceControlAPI#createRepository}.
                 * @memberof clutch.sourcecontrol.v1.SourceControlAPI
                 * @typedef CreateRepositoryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.sourcecontrol.v1.CreateRepositoryResponse} [response] CreateRepositoryResponse
                 */

                /**
                 * Calls CreateRepository.
                 * @function createRepository
                 * @memberof clutch.sourcecontrol.v1.SourceControlAPI
                 * @instance
                 * @param {clutch.sourcecontrol.v1.ICreateRepositoryRequest} request CreateRepositoryRequest message or plain object
                 * @param {clutch.sourcecontrol.v1.SourceControlAPI.CreateRepositoryCallback} callback Node-style callback called with the error, if any, and CreateRepositoryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(SourceControlAPI.prototype.createRepository = function createRepository(request, callback) {
                    return this.rpcCall(createRepository, $root.clutch.sourcecontrol.v1.CreateRepositoryRequest, $root.clutch.sourcecontrol.v1.CreateRepositoryResponse, request, callback);
                }, "name", { value: "CreateRepository" });

                /**
                 * Calls CreateRepository.
                 * @function createRepository
                 * @memberof clutch.sourcecontrol.v1.SourceControlAPI
                 * @instance
                 * @param {clutch.sourcecontrol.v1.ICreateRepositoryRequest} request CreateRepositoryRequest message or plain object
                 * @returns {Promise<clutch.sourcecontrol.v1.CreateRepositoryResponse>} Promise
                 * @variation 2
                 */

                return SourceControlAPI;
            })();

            v1.GetRepositoryOptionsRequest = (function() {

                /**
                 * Properties of a GetRepositoryOptionsRequest.
                 * @memberof clutch.sourcecontrol.v1
                 * @interface IGetRepositoryOptionsRequest
                 */

                /**
                 * Constructs a new GetRepositoryOptionsRequest.
                 * @memberof clutch.sourcecontrol.v1
                 * @classdesc Represents a GetRepositoryOptionsRequest.
                 * @implements IGetRepositoryOptionsRequest
                 * @constructor
                 * @param {clutch.sourcecontrol.v1.IGetRepositoryOptionsRequest=} [properties] Properties to set
                 */
                function GetRepositoryOptionsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a GetRepositoryOptionsRequest message.
                 * @function verify
                 * @memberof clutch.sourcecontrol.v1.GetRepositoryOptionsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetRepositoryOptionsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a GetRepositoryOptionsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.sourcecontrol.v1.GetRepositoryOptionsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.sourcecontrol.v1.GetRepositoryOptionsRequest} GetRepositoryOptionsRequest
                 */
                GetRepositoryOptionsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.sourcecontrol.v1.GetRepositoryOptionsRequest)
                        return object;
                    return new $root.clutch.sourcecontrol.v1.GetRepositoryOptionsRequest();
                };

                /**
                 * Creates a plain object from a GetRepositoryOptionsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.sourcecontrol.v1.GetRepositoryOptionsRequest
                 * @static
                 * @param {clutch.sourcecontrol.v1.GetRepositoryOptionsRequest} message GetRepositoryOptionsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetRepositoryOptionsRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this GetRepositoryOptionsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.sourcecontrol.v1.GetRepositoryOptionsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetRepositoryOptionsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetRepositoryOptionsRequest;
            })();

            v1.Entity = (function() {

                /**
                 * Properties of an Entity.
                 * @memberof clutch.sourcecontrol.v1
                 * @interface IEntity
                 * @property {string|null} [name] Entity name
                 * @property {string|null} [photoUrl] Entity photoUrl
                 */

                /**
                 * Constructs a new Entity.
                 * @memberof clutch.sourcecontrol.v1
                 * @classdesc Represents an Entity.
                 * @implements IEntity
                 * @constructor
                 * @param {clutch.sourcecontrol.v1.IEntity=} [properties] Properties to set
                 */
                function Entity(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Entity name.
                 * @member {string} name
                 * @memberof clutch.sourcecontrol.v1.Entity
                 * @instance
                 */
                Entity.prototype.name = "";

                /**
                 * Entity photoUrl.
                 * @member {string} photoUrl
                 * @memberof clutch.sourcecontrol.v1.Entity
                 * @instance
                 */
                Entity.prototype.photoUrl = "";

                /**
                 * Verifies an Entity message.
                 * @function verify
                 * @memberof clutch.sourcecontrol.v1.Entity
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Entity.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.photoUrl != null && message.hasOwnProperty("photoUrl"))
                        if (!$util.isString(message.photoUrl))
                            return "photoUrl: string expected";
                    return null;
                };

                /**
                 * Creates an Entity message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.sourcecontrol.v1.Entity
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.sourcecontrol.v1.Entity} Entity
                 */
                Entity.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.sourcecontrol.v1.Entity)
                        return object;
                    let message = new $root.clutch.sourcecontrol.v1.Entity();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.photoUrl != null)
                        message.photoUrl = String(object.photoUrl);
                    return message;
                };

                /**
                 * Creates a plain object from an Entity message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.sourcecontrol.v1.Entity
                 * @static
                 * @param {clutch.sourcecontrol.v1.Entity} message Entity
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Entity.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.photoUrl = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.photoUrl != null && message.hasOwnProperty("photoUrl"))
                        object.photoUrl = message.photoUrl;
                    return object;
                };

                /**
                 * Converts this Entity to JSON.
                 * @function toJSON
                 * @memberof clutch.sourcecontrol.v1.Entity
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Entity.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Entity;
            })();

            v1.GetRepositoryOptionsResponse = (function() {

                /**
                 * Properties of a GetRepositoryOptionsResponse.
                 * @memberof clutch.sourcecontrol.v1
                 * @interface IGetRepositoryOptionsResponse
                 * @property {Array.<clutch.sourcecontrol.v1.IEntity>|null} [availableOwners] GetRepositoryOptionsResponse availableOwners
                 * @property {Array.<clutch.sourcecontrol.v1.Visibility>|null} [visibilityOptions] GetRepositoryOptionsResponse visibilityOptions
                 */

                /**
                 * Constructs a new GetRepositoryOptionsResponse.
                 * @memberof clutch.sourcecontrol.v1
                 * @classdesc Represents a GetRepositoryOptionsResponse.
                 * @implements IGetRepositoryOptionsResponse
                 * @constructor
                 * @param {clutch.sourcecontrol.v1.IGetRepositoryOptionsResponse=} [properties] Properties to set
                 */
                function GetRepositoryOptionsResponse(properties) {
                    this.availableOwners = [];
                    this.visibilityOptions = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetRepositoryOptionsResponse availableOwners.
                 * @member {Array.<clutch.sourcecontrol.v1.IEntity>} availableOwners
                 * @memberof clutch.sourcecontrol.v1.GetRepositoryOptionsResponse
                 * @instance
                 */
                GetRepositoryOptionsResponse.prototype.availableOwners = $util.emptyArray;

                /**
                 * GetRepositoryOptionsResponse visibilityOptions.
                 * @member {Array.<clutch.sourcecontrol.v1.Visibility>} visibilityOptions
                 * @memberof clutch.sourcecontrol.v1.GetRepositoryOptionsResponse
                 * @instance
                 */
                GetRepositoryOptionsResponse.prototype.visibilityOptions = $util.emptyArray;

                /**
                 * Verifies a GetRepositoryOptionsResponse message.
                 * @function verify
                 * @memberof clutch.sourcecontrol.v1.GetRepositoryOptionsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetRepositoryOptionsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.availableOwners != null && message.hasOwnProperty("availableOwners")) {
                        if (!Array.isArray(message.availableOwners))
                            return "availableOwners: array expected";
                        for (let i = 0; i < message.availableOwners.length; ++i) {
                            let error = $root.clutch.sourcecontrol.v1.Entity.verify(message.availableOwners[i]);
                            if (error)
                                return "availableOwners." + error;
                        }
                    }
                    if (message.visibilityOptions != null && message.hasOwnProperty("visibilityOptions")) {
                        if (!Array.isArray(message.visibilityOptions))
                            return "visibilityOptions: array expected";
                        for (let i = 0; i < message.visibilityOptions.length; ++i)
                            switch (message.visibilityOptions[i]) {
                            default:
                                return "visibilityOptions: enum value[] expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                    }
                    return null;
                };

                /**
                 * Creates a GetRepositoryOptionsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.sourcecontrol.v1.GetRepositoryOptionsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.sourcecontrol.v1.GetRepositoryOptionsResponse} GetRepositoryOptionsResponse
                 */
                GetRepositoryOptionsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.sourcecontrol.v1.GetRepositoryOptionsResponse)
                        return object;
                    let message = new $root.clutch.sourcecontrol.v1.GetRepositoryOptionsResponse();
                    if (object.availableOwners) {
                        if (!Array.isArray(object.availableOwners))
                            throw TypeError(".clutch.sourcecontrol.v1.GetRepositoryOptionsResponse.availableOwners: array expected");
                        message.availableOwners = [];
                        for (let i = 0; i < object.availableOwners.length; ++i) {
                            if (typeof object.availableOwners[i] !== "object")
                                throw TypeError(".clutch.sourcecontrol.v1.GetRepositoryOptionsResponse.availableOwners: object expected");
                            message.availableOwners[i] = $root.clutch.sourcecontrol.v1.Entity.fromObject(object.availableOwners[i]);
                        }
                    }
                    if (object.visibilityOptions) {
                        if (!Array.isArray(object.visibilityOptions))
                            throw TypeError(".clutch.sourcecontrol.v1.GetRepositoryOptionsResponse.visibilityOptions: array expected");
                        message.visibilityOptions = [];
                        for (let i = 0; i < object.visibilityOptions.length; ++i)
                            switch (object.visibilityOptions[i]) {
                            default:
                            case "UNSPECIFIED":
                            case 0:
                                message.visibilityOptions[i] = 0;
                                break;
                            case "PUBLIC":
                            case 1:
                                message.visibilityOptions[i] = 1;
                                break;
                            case "PRIVATE":
                            case 2:
                                message.visibilityOptions[i] = 2;
                                break;
                            }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetRepositoryOptionsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.sourcecontrol.v1.GetRepositoryOptionsResponse
                 * @static
                 * @param {clutch.sourcecontrol.v1.GetRepositoryOptionsResponse} message GetRepositoryOptionsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetRepositoryOptionsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.availableOwners = [];
                        object.visibilityOptions = [];
                    }
                    if (message.availableOwners && message.availableOwners.length) {
                        object.availableOwners = [];
                        for (let j = 0; j < message.availableOwners.length; ++j)
                            object.availableOwners[j] = $root.clutch.sourcecontrol.v1.Entity.toObject(message.availableOwners[j], options);
                    }
                    if (message.visibilityOptions && message.visibilityOptions.length) {
                        object.visibilityOptions = [];
                        for (let j = 0; j < message.visibilityOptions.length; ++j)
                            object.visibilityOptions[j] = options.enums === String ? $root.clutch.sourcecontrol.v1.Visibility[message.visibilityOptions[j]] : message.visibilityOptions[j];
                    }
                    return object;
                };

                /**
                 * Converts this GetRepositoryOptionsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.sourcecontrol.v1.GetRepositoryOptionsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetRepositoryOptionsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetRepositoryOptionsResponse;
            })();

            v1.CreateRepositoryRequest = (function() {

                /**
                 * Properties of a CreateRepositoryRequest.
                 * @memberof clutch.sourcecontrol.v1
                 * @interface ICreateRepositoryRequest
                 * @property {string|null} [owner] CreateRepositoryRequest owner
                 * @property {string|null} [name] CreateRepositoryRequest name
                 * @property {string|null} [description] CreateRepositoryRequest description
                 * @property {google.protobuf.IAny|null} [customOptions] CreateRepositoryRequest customOptions
                 * @property {clutch.sourcecontrol.github.v1.ICreateRepositoryOptions|null} [githubOptions] CreateRepositoryRequest githubOptions
                 */

                /**
                 * Constructs a new CreateRepositoryRequest.
                 * @memberof clutch.sourcecontrol.v1
                 * @classdesc Represents a CreateRepositoryRequest.
                 * @implements ICreateRepositoryRequest
                 * @constructor
                 * @param {clutch.sourcecontrol.v1.ICreateRepositoryRequest=} [properties] Properties to set
                 */
                function CreateRepositoryRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateRepositoryRequest owner.
                 * @member {string} owner
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @instance
                 */
                CreateRepositoryRequest.prototype.owner = "";

                /**
                 * CreateRepositoryRequest name.
                 * @member {string} name
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @instance
                 */
                CreateRepositoryRequest.prototype.name = "";

                /**
                 * CreateRepositoryRequest description.
                 * @member {string} description
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @instance
                 */
                CreateRepositoryRequest.prototype.description = "";

                /**
                 * CreateRepositoryRequest customOptions.
                 * @member {google.protobuf.IAny|null|undefined} customOptions
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @instance
                 */
                CreateRepositoryRequest.prototype.customOptions = null;

                /**
                 * CreateRepositoryRequest githubOptions.
                 * @member {clutch.sourcecontrol.github.v1.ICreateRepositoryOptions|null|undefined} githubOptions
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @instance
                 */
                CreateRepositoryRequest.prototype.githubOptions = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * CreateRepositoryRequest options.
                 * @member {"customOptions"|"githubOptions"|undefined} options
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @instance
                 */
                Object.defineProperty(CreateRepositoryRequest.prototype, "options", {
                    get: $util.oneOfGetter($oneOfFields = ["customOptions", "githubOptions"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies a CreateRepositoryRequest message.
                 * @function verify
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateRepositoryRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!$util.isString(message.owner))
                            return "owner: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.customOptions != null && message.hasOwnProperty("customOptions")) {
                        properties.options = 1;
                        {
                            let error = $root.google.protobuf.Any.verify(message.customOptions);
                            if (error)
                                return "customOptions." + error;
                        }
                    }
                    if (message.githubOptions != null && message.hasOwnProperty("githubOptions")) {
                        if (properties.options === 1)
                            return "options: multiple values";
                        properties.options = 1;
                        {
                            let error = $root.clutch.sourcecontrol.github.v1.CreateRepositoryOptions.verify(message.githubOptions);
                            if (error)
                                return "githubOptions." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a CreateRepositoryRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.sourcecontrol.v1.CreateRepositoryRequest} CreateRepositoryRequest
                 */
                CreateRepositoryRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.sourcecontrol.v1.CreateRepositoryRequest)
                        return object;
                    let message = new $root.clutch.sourcecontrol.v1.CreateRepositoryRequest();
                    if (object.owner != null)
                        message.owner = String(object.owner);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.customOptions != null) {
                        if (typeof object.customOptions !== "object")
                            throw TypeError(".clutch.sourcecontrol.v1.CreateRepositoryRequest.customOptions: object expected");
                        message.customOptions = $root.google.protobuf.Any.fromObject(object.customOptions);
                    }
                    if (object.githubOptions != null) {
                        if (typeof object.githubOptions !== "object")
                            throw TypeError(".clutch.sourcecontrol.v1.CreateRepositoryRequest.githubOptions: object expected");
                        message.githubOptions = $root.clutch.sourcecontrol.github.v1.CreateRepositoryOptions.fromObject(object.githubOptions);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateRepositoryRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @static
                 * @param {clutch.sourcecontrol.v1.CreateRepositoryRequest} message CreateRepositoryRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateRepositoryRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.owner = "";
                        object.name = "";
                        object.description = "";
                    }
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = message.owner;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.customOptions != null && message.hasOwnProperty("customOptions")) {
                        object.customOptions = $root.google.protobuf.Any.toObject(message.customOptions, options);
                        if (options.oneofs)
                            object.options = "customOptions";
                    }
                    if (message.githubOptions != null && message.hasOwnProperty("githubOptions")) {
                        object.githubOptions = $root.clutch.sourcecontrol.github.v1.CreateRepositoryOptions.toObject(message.githubOptions, options);
                        if (options.oneofs)
                            object.options = "githubOptions";
                    }
                    return object;
                };

                /**
                 * Converts this CreateRepositoryRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateRepositoryRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateRepositoryRequest;
            })();

            v1.CreateRepositoryResponse = (function() {

                /**
                 * Properties of a CreateRepositoryResponse.
                 * @memberof clutch.sourcecontrol.v1
                 * @interface ICreateRepositoryResponse
                 * @property {string|null} [url] CreateRepositoryResponse url
                 */

                /**
                 * Constructs a new CreateRepositoryResponse.
                 * @memberof clutch.sourcecontrol.v1
                 * @classdesc Represents a CreateRepositoryResponse.
                 * @implements ICreateRepositoryResponse
                 * @constructor
                 * @param {clutch.sourcecontrol.v1.ICreateRepositoryResponse=} [properties] Properties to set
                 */
                function CreateRepositoryResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateRepositoryResponse url.
                 * @member {string} url
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryResponse
                 * @instance
                 */
                CreateRepositoryResponse.prototype.url = "";

                /**
                 * Verifies a CreateRepositoryResponse message.
                 * @function verify
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateRepositoryResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.url != null && message.hasOwnProperty("url"))
                        if (!$util.isString(message.url))
                            return "url: string expected";
                    return null;
                };

                /**
                 * Creates a CreateRepositoryResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.sourcecontrol.v1.CreateRepositoryResponse} CreateRepositoryResponse
                 */
                CreateRepositoryResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.sourcecontrol.v1.CreateRepositoryResponse)
                        return object;
                    let message = new $root.clutch.sourcecontrol.v1.CreateRepositoryResponse();
                    if (object.url != null)
                        message.url = String(object.url);
                    return message;
                };

                /**
                 * Creates a plain object from a CreateRepositoryResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryResponse
                 * @static
                 * @param {clutch.sourcecontrol.v1.CreateRepositoryResponse} message CreateRepositoryResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateRepositoryResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.url = "";
                    if (message.url != null && message.hasOwnProperty("url"))
                        object.url = message.url;
                    return object;
                };

                /**
                 * Converts this CreateRepositoryResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateRepositoryResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateRepositoryResponse;
            })();

            return v1;
        })();

        sourcecontrol.github = (function() {

            /**
             * Namespace github.
             * @memberof clutch.sourcecontrol
             * @namespace
             */
            const github = {};

            github.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.sourcecontrol.github
                 * @namespace
                 */
                const v1 = {};

                v1.RepositoryParameters = (function() {

                    /**
                     * Properties of a RepositoryParameters.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @interface IRepositoryParameters
                     * @property {clutch.sourcecontrol.github.v1.RepositoryParameters.Visibility|null} [visibility] RepositoryParameters visibility
                     * @property {google.protobuf.IBoolValue|null} [allowMergeCommit] RepositoryParameters allowMergeCommit
                     * @property {google.protobuf.IBoolValue|null} [allowRebaseMerge] RepositoryParameters allowRebaseMerge
                     * @property {google.protobuf.IBoolValue|null} [allowSquashMerge] RepositoryParameters allowSquashMerge
                     */

                    /**
                     * Constructs a new RepositoryParameters.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @classdesc Represents a RepositoryParameters.
                     * @implements IRepositoryParameters
                     * @constructor
                     * @param {clutch.sourcecontrol.github.v1.IRepositoryParameters=} [properties] Properties to set
                     */
                    function RepositoryParameters(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * RepositoryParameters visibility.
                     * @member {clutch.sourcecontrol.github.v1.RepositoryParameters.Visibility} visibility
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @instance
                     */
                    RepositoryParameters.prototype.visibility = 0;

                    /**
                     * RepositoryParameters allowMergeCommit.
                     * @member {google.protobuf.IBoolValue|null|undefined} allowMergeCommit
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @instance
                     */
                    RepositoryParameters.prototype.allowMergeCommit = null;

                    /**
                     * RepositoryParameters allowRebaseMerge.
                     * @member {google.protobuf.IBoolValue|null|undefined} allowRebaseMerge
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @instance
                     */
                    RepositoryParameters.prototype.allowRebaseMerge = null;

                    /**
                     * RepositoryParameters allowSquashMerge.
                     * @member {google.protobuf.IBoolValue|null|undefined} allowSquashMerge
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @instance
                     */
                    RepositoryParameters.prototype.allowSquashMerge = null;

                    /**
                     * Verifies a RepositoryParameters message.
                     * @function verify
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RepositoryParameters.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.visibility != null && message.hasOwnProperty("visibility"))
                            switch (message.visibility) {
                            default:
                                return "visibility: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        if (message.allowMergeCommit != null && message.hasOwnProperty("allowMergeCommit")) {
                            let error = $root.google.protobuf.BoolValue.verify(message.allowMergeCommit);
                            if (error)
                                return "allowMergeCommit." + error;
                        }
                        if (message.allowRebaseMerge != null && message.hasOwnProperty("allowRebaseMerge")) {
                            let error = $root.google.protobuf.BoolValue.verify(message.allowRebaseMerge);
                            if (error)
                                return "allowRebaseMerge." + error;
                        }
                        if (message.allowSquashMerge != null && message.hasOwnProperty("allowSquashMerge")) {
                            let error = $root.google.protobuf.BoolValue.verify(message.allowSquashMerge);
                            if (error)
                                return "allowSquashMerge." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a RepositoryParameters message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.sourcecontrol.github.v1.RepositoryParameters} RepositoryParameters
                     */
                    RepositoryParameters.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.sourcecontrol.github.v1.RepositoryParameters)
                            return object;
                        let message = new $root.clutch.sourcecontrol.github.v1.RepositoryParameters();
                        switch (object.visibility) {
                        case "UNSPECIFIED":
                        case 0:
                            message.visibility = 0;
                            break;
                        case "PUBLIC":
                        case 1:
                            message.visibility = 1;
                            break;
                        case "PRIVATE":
                        case 2:
                            message.visibility = 2;
                            break;
                        }
                        if (object.allowMergeCommit != null) {
                            if (typeof object.allowMergeCommit !== "object")
                                throw TypeError(".clutch.sourcecontrol.github.v1.RepositoryParameters.allowMergeCommit: object expected");
                            message.allowMergeCommit = $root.google.protobuf.BoolValue.fromObject(object.allowMergeCommit);
                        }
                        if (object.allowRebaseMerge != null) {
                            if (typeof object.allowRebaseMerge !== "object")
                                throw TypeError(".clutch.sourcecontrol.github.v1.RepositoryParameters.allowRebaseMerge: object expected");
                            message.allowRebaseMerge = $root.google.protobuf.BoolValue.fromObject(object.allowRebaseMerge);
                        }
                        if (object.allowSquashMerge != null) {
                            if (typeof object.allowSquashMerge !== "object")
                                throw TypeError(".clutch.sourcecontrol.github.v1.RepositoryParameters.allowSquashMerge: object expected");
                            message.allowSquashMerge = $root.google.protobuf.BoolValue.fromObject(object.allowSquashMerge);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a RepositoryParameters message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @static
                     * @param {clutch.sourcecontrol.github.v1.RepositoryParameters} message RepositoryParameters
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RepositoryParameters.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.visibility = options.enums === String ? "UNSPECIFIED" : 0;
                            object.allowMergeCommit = null;
                            object.allowRebaseMerge = null;
                            object.allowSquashMerge = null;
                        }
                        if (message.visibility != null && message.hasOwnProperty("visibility"))
                            object.visibility = options.enums === String ? $root.clutch.sourcecontrol.github.v1.RepositoryParameters.Visibility[message.visibility] : message.visibility;
                        if (message.allowMergeCommit != null && message.hasOwnProperty("allowMergeCommit"))
                            object.allowMergeCommit = $root.google.protobuf.BoolValue.toObject(message.allowMergeCommit, options);
                        if (message.allowRebaseMerge != null && message.hasOwnProperty("allowRebaseMerge"))
                            object.allowRebaseMerge = $root.google.protobuf.BoolValue.toObject(message.allowRebaseMerge, options);
                        if (message.allowSquashMerge != null && message.hasOwnProperty("allowSquashMerge"))
                            object.allowSquashMerge = $root.google.protobuf.BoolValue.toObject(message.allowSquashMerge, options);
                        return object;
                    };

                    /**
                     * Converts this RepositoryParameters to JSON.
                     * @function toJSON
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RepositoryParameters.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Visibility enum.
                     * @name clutch.sourcecontrol.github.v1.RepositoryParameters.Visibility
                     * @enum {number}
                     * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                     * @property {number} PUBLIC=1 PUBLIC value
                     * @property {number} PRIVATE=2 PRIVATE value
                     */
                    RepositoryParameters.Visibility = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNSPECIFIED"] = 0;
                        values[valuesById[1] = "PUBLIC"] = 1;
                        values[valuesById[2] = "PRIVATE"] = 2;
                        return values;
                    })();

                    return RepositoryParameters;
                })();

                v1.CreateRepositoryOptions = (function() {

                    /**
                     * Properties of a CreateRepositoryOptions.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @interface ICreateRepositoryOptions
                     * @property {clutch.sourcecontrol.github.v1.IRepositoryParameters|null} [parameters] CreateRepositoryOptions parameters
                     * @property {boolean|null} [autoInit] CreateRepositoryOptions autoInit
                     */

                    /**
                     * Constructs a new CreateRepositoryOptions.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @classdesc Represents a CreateRepositoryOptions.
                     * @implements ICreateRepositoryOptions
                     * @constructor
                     * @param {clutch.sourcecontrol.github.v1.ICreateRepositoryOptions=} [properties] Properties to set
                     */
                    function CreateRepositoryOptions(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CreateRepositoryOptions parameters.
                     * @member {clutch.sourcecontrol.github.v1.IRepositoryParameters|null|undefined} parameters
                     * @memberof clutch.sourcecontrol.github.v1.CreateRepositoryOptions
                     * @instance
                     */
                    CreateRepositoryOptions.prototype.parameters = null;

                    /**
                     * CreateRepositoryOptions autoInit.
                     * @member {boolean} autoInit
                     * @memberof clutch.sourcecontrol.github.v1.CreateRepositoryOptions
                     * @instance
                     */
                    CreateRepositoryOptions.prototype.autoInit = false;

                    /**
                     * Verifies a CreateRepositoryOptions message.
                     * @function verify
                     * @memberof clutch.sourcecontrol.github.v1.CreateRepositoryOptions
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateRepositoryOptions.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.parameters != null && message.hasOwnProperty("parameters")) {
                            let error = $root.clutch.sourcecontrol.github.v1.RepositoryParameters.verify(message.parameters);
                            if (error)
                                return "parameters." + error;
                        }
                        if (message.autoInit != null && message.hasOwnProperty("autoInit"))
                            if (typeof message.autoInit !== "boolean")
                                return "autoInit: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a CreateRepositoryOptions message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.sourcecontrol.github.v1.CreateRepositoryOptions
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.sourcecontrol.github.v1.CreateRepositoryOptions} CreateRepositoryOptions
                     */
                    CreateRepositoryOptions.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.sourcecontrol.github.v1.CreateRepositoryOptions)
                            return object;
                        let message = new $root.clutch.sourcecontrol.github.v1.CreateRepositoryOptions();
                        if (object.parameters != null) {
                            if (typeof object.parameters !== "object")
                                throw TypeError(".clutch.sourcecontrol.github.v1.CreateRepositoryOptions.parameters: object expected");
                            message.parameters = $root.clutch.sourcecontrol.github.v1.RepositoryParameters.fromObject(object.parameters);
                        }
                        if (object.autoInit != null)
                            message.autoInit = Boolean(object.autoInit);
                        return message;
                    };

                    /**
                     * Creates a plain object from a CreateRepositoryOptions message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.sourcecontrol.github.v1.CreateRepositoryOptions
                     * @static
                     * @param {clutch.sourcecontrol.github.v1.CreateRepositoryOptions} message CreateRepositoryOptions
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateRepositoryOptions.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.parameters = null;
                            object.autoInit = false;
                        }
                        if (message.parameters != null && message.hasOwnProperty("parameters"))
                            object.parameters = $root.clutch.sourcecontrol.github.v1.RepositoryParameters.toObject(message.parameters, options);
                        if (message.autoInit != null && message.hasOwnProperty("autoInit"))
                            object.autoInit = message.autoInit;
                        return object;
                    };

                    /**
                     * Converts this CreateRepositoryOptions to JSON.
                     * @function toJSON
                     * @memberof clutch.sourcecontrol.github.v1.CreateRepositoryOptions
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateRepositoryOptions.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CreateRepositoryOptions;
                })();

                v1.UpdateRepositoryOptions = (function() {

                    /**
                     * Properties of an UpdateRepositoryOptions.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @interface IUpdateRepositoryOptions
                     * @property {clutch.sourcecontrol.github.v1.IRepositoryParameters|null} [parameters] UpdateRepositoryOptions parameters
                     * @property {boolean|null} [archived] UpdateRepositoryOptions archived
                     */

                    /**
                     * Constructs a new UpdateRepositoryOptions.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @classdesc Represents an UpdateRepositoryOptions.
                     * @implements IUpdateRepositoryOptions
                     * @constructor
                     * @param {clutch.sourcecontrol.github.v1.IUpdateRepositoryOptions=} [properties] Properties to set
                     */
                    function UpdateRepositoryOptions(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UpdateRepositoryOptions parameters.
                     * @member {clutch.sourcecontrol.github.v1.IRepositoryParameters|null|undefined} parameters
                     * @memberof clutch.sourcecontrol.github.v1.UpdateRepositoryOptions
                     * @instance
                     */
                    UpdateRepositoryOptions.prototype.parameters = null;

                    /**
                     * UpdateRepositoryOptions archived.
                     * @member {boolean} archived
                     * @memberof clutch.sourcecontrol.github.v1.UpdateRepositoryOptions
                     * @instance
                     */
                    UpdateRepositoryOptions.prototype.archived = false;

                    /**
                     * Verifies an UpdateRepositoryOptions message.
                     * @function verify
                     * @memberof clutch.sourcecontrol.github.v1.UpdateRepositoryOptions
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UpdateRepositoryOptions.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.parameters != null && message.hasOwnProperty("parameters")) {
                            let error = $root.clutch.sourcecontrol.github.v1.RepositoryParameters.verify(message.parameters);
                            if (error)
                                return "parameters." + error;
                        }
                        if (message.archived != null && message.hasOwnProperty("archived"))
                            if (typeof message.archived !== "boolean")
                                return "archived: boolean expected";
                        return null;
                    };

                    /**
                     * Creates an UpdateRepositoryOptions message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.sourcecontrol.github.v1.UpdateRepositoryOptions
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.sourcecontrol.github.v1.UpdateRepositoryOptions} UpdateRepositoryOptions
                     */
                    UpdateRepositoryOptions.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.sourcecontrol.github.v1.UpdateRepositoryOptions)
                            return object;
                        let message = new $root.clutch.sourcecontrol.github.v1.UpdateRepositoryOptions();
                        if (object.parameters != null) {
                            if (typeof object.parameters !== "object")
                                throw TypeError(".clutch.sourcecontrol.github.v1.UpdateRepositoryOptions.parameters: object expected");
                            message.parameters = $root.clutch.sourcecontrol.github.v1.RepositoryParameters.fromObject(object.parameters);
                        }
                        if (object.archived != null)
                            message.archived = Boolean(object.archived);
                        return message;
                    };

                    /**
                     * Creates a plain object from an UpdateRepositoryOptions message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.sourcecontrol.github.v1.UpdateRepositoryOptions
                     * @static
                     * @param {clutch.sourcecontrol.github.v1.UpdateRepositoryOptions} message UpdateRepositoryOptions
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UpdateRepositoryOptions.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.parameters = null;
                            object.archived = false;
                        }
                        if (message.parameters != null && message.hasOwnProperty("parameters"))
                            object.parameters = $root.clutch.sourcecontrol.github.v1.RepositoryParameters.toObject(message.parameters, options);
                        if (message.archived != null && message.hasOwnProperty("archived"))
                            object.archived = message.archived;
                        return object;
                    };

                    /**
                     * Converts this UpdateRepositoryOptions to JSON.
                     * @function toJSON
                     * @memberof clutch.sourcecontrol.github.v1.UpdateRepositoryOptions
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UpdateRepositoryOptions.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UpdateRepositoryOptions;
                })();

                /**
                 * CommitCompareStatus enum.
                 * @name clutch.sourcecontrol.github.v1.CommitCompareStatus
                 * @enum {number}
                 * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                 * @property {number} UNKNOWN=1 UNKNOWN value
                 * @property {number} BEHIND=2 BEHIND value
                 * @property {number} AHEAD=3 AHEAD value
                 * @property {number} IDENTICAL=4 IDENTICAL value
                 */
                v1.CommitCompareStatus = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNSPECIFIED"] = 0;
                    values[valuesById[1] = "UNKNOWN"] = 1;
                    values[valuesById[2] = "BEHIND"] = 2;
                    values[valuesById[3] = "AHEAD"] = 3;
                    values[valuesById[4] = "IDENTICAL"] = 4;
                    return values;
                })();

                v1.CommitComparison = (function() {

                    /**
                     * Properties of a CommitComparison.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @interface ICommitComparison
                     * @property {clutch.sourcecontrol.github.v1.CommitCompareStatus|null} [status] CommitComparison status
                     */

                    /**
                     * Constructs a new CommitComparison.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @classdesc Represents a CommitComparison.
                     * @implements ICommitComparison
                     * @constructor
                     * @param {clutch.sourcecontrol.github.v1.ICommitComparison=} [properties] Properties to set
                     */
                    function CommitComparison(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CommitComparison status.
                     * @member {clutch.sourcecontrol.github.v1.CommitCompareStatus} status
                     * @memberof clutch.sourcecontrol.github.v1.CommitComparison
                     * @instance
                     */
                    CommitComparison.prototype.status = 0;

                    /**
                     * Verifies a CommitComparison message.
                     * @function verify
                     * @memberof clutch.sourcecontrol.github.v1.CommitComparison
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CommitComparison.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a CommitComparison message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.sourcecontrol.github.v1.CommitComparison
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.sourcecontrol.github.v1.CommitComparison} CommitComparison
                     */
                    CommitComparison.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.sourcecontrol.github.v1.CommitComparison)
                            return object;
                        let message = new $root.clutch.sourcecontrol.github.v1.CommitComparison();
                        switch (object.status) {
                        case "UNSPECIFIED":
                        case 0:
                            message.status = 0;
                            break;
                        case "UNKNOWN":
                        case 1:
                            message.status = 1;
                            break;
                        case "BEHIND":
                        case 2:
                            message.status = 2;
                            break;
                        case "AHEAD":
                        case 3:
                            message.status = 3;
                            break;
                        case "IDENTICAL":
                        case 4:
                            message.status = 4;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a CommitComparison message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.sourcecontrol.github.v1.CommitComparison
                     * @static
                     * @param {clutch.sourcecontrol.github.v1.CommitComparison} message CommitComparison
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CommitComparison.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.status = options.enums === String ? "UNSPECIFIED" : 0;
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.clutch.sourcecontrol.github.v1.CommitCompareStatus[message.status] : message.status;
                        return object;
                    };

                    /**
                     * Converts this CommitComparison to JSON.
                     * @function toJSON
                     * @memberof clutch.sourcecontrol.github.v1.CommitComparison
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CommitComparison.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CommitComparison;
                })();

                return v1;
            })();

            return github;
        })();

        return sourcecontrol;
    })();

    clutch.core = (function() {

        /**
         * Namespace core.
         * @memberof clutch
         * @namespace
         */
        const core = {};

        core.envoy = (function() {

            /**
             * Namespace envoy.
             * @memberof clutch.core
             * @namespace
             */
            const envoy = {};

            envoy.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.core.envoy
                 * @namespace
                 */
                const v1 = {};

                v1.Cluster = (function() {

                    /**
                     * Properties of a Cluster.
                     * @memberof clutch.core.envoy.v1
                     * @interface ICluster
                     * @property {string|null} [name] Cluster name
                     */

                    /**
                     * Constructs a new Cluster.
                     * @memberof clutch.core.envoy.v1
                     * @classdesc Represents a Cluster.
                     * @implements ICluster
                     * @constructor
                     * @param {clutch.core.envoy.v1.ICluster=} [properties] Properties to set
                     */
                    function Cluster(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Cluster name.
                     * @member {string} name
                     * @memberof clutch.core.envoy.v1.Cluster
                     * @instance
                     */
                    Cluster.prototype.name = "";

                    /**
                     * Verifies a Cluster message.
                     * @function verify
                     * @memberof clutch.core.envoy.v1.Cluster
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Cluster.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        return null;
                    };

                    /**
                     * Creates a Cluster message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.core.envoy.v1.Cluster
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.core.envoy.v1.Cluster} Cluster
                     */
                    Cluster.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.core.envoy.v1.Cluster)
                            return object;
                        let message = new $root.clutch.core.envoy.v1.Cluster();
                        if (object.name != null)
                            message.name = String(object.name);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Cluster message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.core.envoy.v1.Cluster
                     * @static
                     * @param {clutch.core.envoy.v1.Cluster} message Cluster
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Cluster.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.name = "";
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        return object;
                    };

                    /**
                     * Converts this Cluster to JSON.
                     * @function toJSON
                     * @memberof clutch.core.envoy.v1.Cluster
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Cluster.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Cluster;
                })();

                return v1;
            })();

            return envoy;
        })();

        core.project = (function() {

            /**
             * Namespace project.
             * @memberof clutch.core
             * @namespace
             */
            const project = {};

            project.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.core.project
                 * @namespace
                 */
                const v1 = {};

                v1.Project = (function() {

                    /**
                     * Properties of a Project.
                     * @memberof clutch.core.project.v1
                     * @interface IProject
                     * @property {string|null} [name] Project name
                     * @property {string|null} [tier] Project tier
                     * @property {Array.<string>|null} [owners] Project owners
                     * @property {Array.<string>|null} [languages] Project languages
                     * @property {Object.<string,google.protobuf.IValue>|null} [data] Project data
                     * @property {clutch.core.project.v1.IProjectDependencies|null} [dependencies] Project dependencies
                     * @property {clutch.core.project.v1.IOnCall|null} [oncall] Project oncall
                     * @property {Array.<clutch.core.project.v1.ILinkGroup>|null} [linkGroups] Project linkGroups
                     */

                    /**
                     * Constructs a new Project.
                     * @memberof clutch.core.project.v1
                     * @classdesc Represents a Project.
                     * @implements IProject
                     * @constructor
                     * @param {clutch.core.project.v1.IProject=} [properties] Properties to set
                     */
                    function Project(properties) {
                        this.owners = [];
                        this.languages = [];
                        this.data = {};
                        this.linkGroups = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Project name.
                     * @member {string} name
                     * @memberof clutch.core.project.v1.Project
                     * @instance
                     */
                    Project.prototype.name = "";

                    /**
                     * Project tier.
                     * @member {string} tier
                     * @memberof clutch.core.project.v1.Project
                     * @instance
                     */
                    Project.prototype.tier = "";

                    /**
                     * Project owners.
                     * @member {Array.<string>} owners
                     * @memberof clutch.core.project.v1.Project
                     * @instance
                     */
                    Project.prototype.owners = $util.emptyArray;

                    /**
                     * Project languages.
                     * @member {Array.<string>} languages
                     * @memberof clutch.core.project.v1.Project
                     * @instance
                     */
                    Project.prototype.languages = $util.emptyArray;

                    /**
                     * Project data.
                     * @member {Object.<string,google.protobuf.IValue>} data
                     * @memberof clutch.core.project.v1.Project
                     * @instance
                     */
                    Project.prototype.data = $util.emptyObject;

                    /**
                     * Project dependencies.
                     * @member {clutch.core.project.v1.IProjectDependencies|null|undefined} dependencies
                     * @memberof clutch.core.project.v1.Project
                     * @instance
                     */
                    Project.prototype.dependencies = null;

                    /**
                     * Project oncall.
                     * @member {clutch.core.project.v1.IOnCall|null|undefined} oncall
                     * @memberof clutch.core.project.v1.Project
                     * @instance
                     */
                    Project.prototype.oncall = null;

                    /**
                     * Project linkGroups.
                     * @member {Array.<clutch.core.project.v1.ILinkGroup>} linkGroups
                     * @memberof clutch.core.project.v1.Project
                     * @instance
                     */
                    Project.prototype.linkGroups = $util.emptyArray;

                    /**
                     * Verifies a Project message.
                     * @function verify
                     * @memberof clutch.core.project.v1.Project
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Project.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.tier != null && message.hasOwnProperty("tier"))
                            if (!$util.isString(message.tier))
                                return "tier: string expected";
                        if (message.owners != null && message.hasOwnProperty("owners")) {
                            if (!Array.isArray(message.owners))
                                return "owners: array expected";
                            for (let i = 0; i < message.owners.length; ++i)
                                if (!$util.isString(message.owners[i]))
                                    return "owners: string[] expected";
                        }
                        if (message.languages != null && message.hasOwnProperty("languages")) {
                            if (!Array.isArray(message.languages))
                                return "languages: array expected";
                            for (let i = 0; i < message.languages.length; ++i)
                                if (!$util.isString(message.languages[i]))
                                    return "languages: string[] expected";
                        }
                        if (message.data != null && message.hasOwnProperty("data")) {
                            if (!$util.isObject(message.data))
                                return "data: object expected";
                            let key = Object.keys(message.data);
                            for (let i = 0; i < key.length; ++i) {
                                let error = $root.google.protobuf.Value.verify(message.data[key[i]]);
                                if (error)
                                    return "data." + error;
                            }
                        }
                        if (message.dependencies != null && message.hasOwnProperty("dependencies")) {
                            let error = $root.clutch.core.project.v1.ProjectDependencies.verify(message.dependencies);
                            if (error)
                                return "dependencies." + error;
                        }
                        if (message.oncall != null && message.hasOwnProperty("oncall")) {
                            let error = $root.clutch.core.project.v1.OnCall.verify(message.oncall);
                            if (error)
                                return "oncall." + error;
                        }
                        if (message.linkGroups != null && message.hasOwnProperty("linkGroups")) {
                            if (!Array.isArray(message.linkGroups))
                                return "linkGroups: array expected";
                            for (let i = 0; i < message.linkGroups.length; ++i) {
                                let error = $root.clutch.core.project.v1.LinkGroup.verify(message.linkGroups[i]);
                                if (error)
                                    return "linkGroups." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Project message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.core.project.v1.Project
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.core.project.v1.Project} Project
                     */
                    Project.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.core.project.v1.Project)
                            return object;
                        let message = new $root.clutch.core.project.v1.Project();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.tier != null)
                            message.tier = String(object.tier);
                        if (object.owners) {
                            if (!Array.isArray(object.owners))
                                throw TypeError(".clutch.core.project.v1.Project.owners: array expected");
                            message.owners = [];
                            for (let i = 0; i < object.owners.length; ++i)
                                message.owners[i] = String(object.owners[i]);
                        }
                        if (object.languages) {
                            if (!Array.isArray(object.languages))
                                throw TypeError(".clutch.core.project.v1.Project.languages: array expected");
                            message.languages = [];
                            for (let i = 0; i < object.languages.length; ++i)
                                message.languages[i] = String(object.languages[i]);
                        }
                        if (object.data) {
                            if (typeof object.data !== "object")
                                throw TypeError(".clutch.core.project.v1.Project.data: object expected");
                            message.data = {};
                            for (let keys = Object.keys(object.data), i = 0; i < keys.length; ++i) {
                                if (typeof object.data[keys[i]] !== "object")
                                    throw TypeError(".clutch.core.project.v1.Project.data: object expected");
                                message.data[keys[i]] = $root.google.protobuf.Value.fromObject(object.data[keys[i]]);
                            }
                        }
                        if (object.dependencies != null) {
                            if (typeof object.dependencies !== "object")
                                throw TypeError(".clutch.core.project.v1.Project.dependencies: object expected");
                            message.dependencies = $root.clutch.core.project.v1.ProjectDependencies.fromObject(object.dependencies);
                        }
                        if (object.oncall != null) {
                            if (typeof object.oncall !== "object")
                                throw TypeError(".clutch.core.project.v1.Project.oncall: object expected");
                            message.oncall = $root.clutch.core.project.v1.OnCall.fromObject(object.oncall);
                        }
                        if (object.linkGroups) {
                            if (!Array.isArray(object.linkGroups))
                                throw TypeError(".clutch.core.project.v1.Project.linkGroups: array expected");
                            message.linkGroups = [];
                            for (let i = 0; i < object.linkGroups.length; ++i) {
                                if (typeof object.linkGroups[i] !== "object")
                                    throw TypeError(".clutch.core.project.v1.Project.linkGroups: object expected");
                                message.linkGroups[i] = $root.clutch.core.project.v1.LinkGroup.fromObject(object.linkGroups[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Project message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.core.project.v1.Project
                     * @static
                     * @param {clutch.core.project.v1.Project} message Project
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Project.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults) {
                            object.owners = [];
                            object.languages = [];
                            object.linkGroups = [];
                        }
                        if (options.objects || options.defaults)
                            object.data = {};
                        if (options.defaults) {
                            object.name = "";
                            object.tier = "";
                            object.dependencies = null;
                            object.oncall = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.tier != null && message.hasOwnProperty("tier"))
                            object.tier = message.tier;
                        if (message.owners && message.owners.length) {
                            object.owners = [];
                            for (let j = 0; j < message.owners.length; ++j)
                                object.owners[j] = message.owners[j];
                        }
                        if (message.languages && message.languages.length) {
                            object.languages = [];
                            for (let j = 0; j < message.languages.length; ++j)
                                object.languages[j] = message.languages[j];
                        }
                        let keys2;
                        if (message.data && (keys2 = Object.keys(message.data)).length) {
                            object.data = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.data[keys2[j]] = $root.google.protobuf.Value.toObject(message.data[keys2[j]], options);
                        }
                        if (message.dependencies != null && message.hasOwnProperty("dependencies"))
                            object.dependencies = $root.clutch.core.project.v1.ProjectDependencies.toObject(message.dependencies, options);
                        if (message.oncall != null && message.hasOwnProperty("oncall"))
                            object.oncall = $root.clutch.core.project.v1.OnCall.toObject(message.oncall, options);
                        if (message.linkGroups && message.linkGroups.length) {
                            object.linkGroups = [];
                            for (let j = 0; j < message.linkGroups.length; ++j)
                                object.linkGroups[j] = $root.clutch.core.project.v1.LinkGroup.toObject(message.linkGroups[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Project to JSON.
                     * @function toJSON
                     * @memberof clutch.core.project.v1.Project
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Project.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Project;
                })();

                v1.ProjectDependencies = (function() {

                    /**
                     * Properties of a ProjectDependencies.
                     * @memberof clutch.core.project.v1
                     * @interface IProjectDependencies
                     * @property {Object.<string,clutch.core.project.v1.IDependency>|null} [upstreams] ProjectDependencies upstreams
                     * @property {Object.<string,clutch.core.project.v1.IDependency>|null} [downstreams] ProjectDependencies downstreams
                     */

                    /**
                     * Constructs a new ProjectDependencies.
                     * @memberof clutch.core.project.v1
                     * @classdesc Represents a ProjectDependencies.
                     * @implements IProjectDependencies
                     * @constructor
                     * @param {clutch.core.project.v1.IProjectDependencies=} [properties] Properties to set
                     */
                    function ProjectDependencies(properties) {
                        this.upstreams = {};
                        this.downstreams = {};
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ProjectDependencies upstreams.
                     * @member {Object.<string,clutch.core.project.v1.IDependency>} upstreams
                     * @memberof clutch.core.project.v1.ProjectDependencies
                     * @instance
                     */
                    ProjectDependencies.prototype.upstreams = $util.emptyObject;

                    /**
                     * ProjectDependencies downstreams.
                     * @member {Object.<string,clutch.core.project.v1.IDependency>} downstreams
                     * @memberof clutch.core.project.v1.ProjectDependencies
                     * @instance
                     */
                    ProjectDependencies.prototype.downstreams = $util.emptyObject;

                    /**
                     * Verifies a ProjectDependencies message.
                     * @function verify
                     * @memberof clutch.core.project.v1.ProjectDependencies
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ProjectDependencies.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.upstreams != null && message.hasOwnProperty("upstreams")) {
                            if (!$util.isObject(message.upstreams))
                                return "upstreams: object expected";
                            let key = Object.keys(message.upstreams);
                            for (let i = 0; i < key.length; ++i) {
                                let error = $root.clutch.core.project.v1.Dependency.verify(message.upstreams[key[i]]);
                                if (error)
                                    return "upstreams." + error;
                            }
                        }
                        if (message.downstreams != null && message.hasOwnProperty("downstreams")) {
                            if (!$util.isObject(message.downstreams))
                                return "downstreams: object expected";
                            let key = Object.keys(message.downstreams);
                            for (let i = 0; i < key.length; ++i) {
                                let error = $root.clutch.core.project.v1.Dependency.verify(message.downstreams[key[i]]);
                                if (error)
                                    return "downstreams." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a ProjectDependencies message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.core.project.v1.ProjectDependencies
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.core.project.v1.ProjectDependencies} ProjectDependencies
                     */
                    ProjectDependencies.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.core.project.v1.ProjectDependencies)
                            return object;
                        let message = new $root.clutch.core.project.v1.ProjectDependencies();
                        if (object.upstreams) {
                            if (typeof object.upstreams !== "object")
                                throw TypeError(".clutch.core.project.v1.ProjectDependencies.upstreams: object expected");
                            message.upstreams = {};
                            for (let keys = Object.keys(object.upstreams), i = 0; i < keys.length; ++i) {
                                if (typeof object.upstreams[keys[i]] !== "object")
                                    throw TypeError(".clutch.core.project.v1.ProjectDependencies.upstreams: object expected");
                                message.upstreams[keys[i]] = $root.clutch.core.project.v1.Dependency.fromObject(object.upstreams[keys[i]]);
                            }
                        }
                        if (object.downstreams) {
                            if (typeof object.downstreams !== "object")
                                throw TypeError(".clutch.core.project.v1.ProjectDependencies.downstreams: object expected");
                            message.downstreams = {};
                            for (let keys = Object.keys(object.downstreams), i = 0; i < keys.length; ++i) {
                                if (typeof object.downstreams[keys[i]] !== "object")
                                    throw TypeError(".clutch.core.project.v1.ProjectDependencies.downstreams: object expected");
                                message.downstreams[keys[i]] = $root.clutch.core.project.v1.Dependency.fromObject(object.downstreams[keys[i]]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ProjectDependencies message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.core.project.v1.ProjectDependencies
                     * @static
                     * @param {clutch.core.project.v1.ProjectDependencies} message ProjectDependencies
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ProjectDependencies.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.objects || options.defaults) {
                            object.upstreams = {};
                            object.downstreams = {};
                        }
                        let keys2;
                        if (message.upstreams && (keys2 = Object.keys(message.upstreams)).length) {
                            object.upstreams = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.upstreams[keys2[j]] = $root.clutch.core.project.v1.Dependency.toObject(message.upstreams[keys2[j]], options);
                        }
                        if (message.downstreams && (keys2 = Object.keys(message.downstreams)).length) {
                            object.downstreams = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.downstreams[keys2[j]] = $root.clutch.core.project.v1.Dependency.toObject(message.downstreams[keys2[j]], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this ProjectDependencies to JSON.
                     * @function toJSON
                     * @memberof clutch.core.project.v1.ProjectDependencies
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ProjectDependencies.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ProjectDependencies;
                })();

                v1.Dependency = (function() {

                    /**
                     * Properties of a Dependency.
                     * @memberof clutch.core.project.v1
                     * @interface IDependency
                     * @property {Array.<string>|null} [ids] Dependency ids
                     */

                    /**
                     * Constructs a new Dependency.
                     * @memberof clutch.core.project.v1
                     * @classdesc Represents a Dependency.
                     * @implements IDependency
                     * @constructor
                     * @param {clutch.core.project.v1.IDependency=} [properties] Properties to set
                     */
                    function Dependency(properties) {
                        this.ids = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Dependency ids.
                     * @member {Array.<string>} ids
                     * @memberof clutch.core.project.v1.Dependency
                     * @instance
                     */
                    Dependency.prototype.ids = $util.emptyArray;

                    /**
                     * Verifies a Dependency message.
                     * @function verify
                     * @memberof clutch.core.project.v1.Dependency
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Dependency.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ids != null && message.hasOwnProperty("ids")) {
                            if (!Array.isArray(message.ids))
                                return "ids: array expected";
                            for (let i = 0; i < message.ids.length; ++i)
                                if (!$util.isString(message.ids[i]))
                                    return "ids: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Dependency message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.core.project.v1.Dependency
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.core.project.v1.Dependency} Dependency
                     */
                    Dependency.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.core.project.v1.Dependency)
                            return object;
                        let message = new $root.clutch.core.project.v1.Dependency();
                        if (object.ids) {
                            if (!Array.isArray(object.ids))
                                throw TypeError(".clutch.core.project.v1.Dependency.ids: array expected");
                            message.ids = [];
                            for (let i = 0; i < object.ids.length; ++i)
                                message.ids[i] = String(object.ids[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Dependency message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.core.project.v1.Dependency
                     * @static
                     * @param {clutch.core.project.v1.Dependency} message Dependency
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Dependency.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.ids = [];
                        if (message.ids && message.ids.length) {
                            object.ids = [];
                            for (let j = 0; j < message.ids.length; ++j)
                                object.ids[j] = message.ids[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this Dependency to JSON.
                     * @function toJSON
                     * @memberof clutch.core.project.v1.Dependency
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Dependency.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Dependency;
                })();

                v1.OnCall = (function() {

                    /**
                     * Properties of an OnCall.
                     * @memberof clutch.core.project.v1
                     * @interface IOnCall
                     * @property {clutch.core.project.v1.IPagerDuty|null} [pagerduty] OnCall pagerduty
                     */

                    /**
                     * Constructs a new OnCall.
                     * @memberof clutch.core.project.v1
                     * @classdesc Represents an OnCall.
                     * @implements IOnCall
                     * @constructor
                     * @param {clutch.core.project.v1.IOnCall=} [properties] Properties to set
                     */
                    function OnCall(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * OnCall pagerduty.
                     * @member {clutch.core.project.v1.IPagerDuty|null|undefined} pagerduty
                     * @memberof clutch.core.project.v1.OnCall
                     * @instance
                     */
                    OnCall.prototype.pagerduty = null;

                    /**
                     * Verifies an OnCall message.
                     * @function verify
                     * @memberof clutch.core.project.v1.OnCall
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    OnCall.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.pagerduty != null && message.hasOwnProperty("pagerduty")) {
                            let error = $root.clutch.core.project.v1.PagerDuty.verify(message.pagerduty);
                            if (error)
                                return "pagerduty." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an OnCall message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.core.project.v1.OnCall
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.core.project.v1.OnCall} OnCall
                     */
                    OnCall.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.core.project.v1.OnCall)
                            return object;
                        let message = new $root.clutch.core.project.v1.OnCall();
                        if (object.pagerduty != null) {
                            if (typeof object.pagerduty !== "object")
                                throw TypeError(".clutch.core.project.v1.OnCall.pagerduty: object expected");
                            message.pagerduty = $root.clutch.core.project.v1.PagerDuty.fromObject(object.pagerduty);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an OnCall message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.core.project.v1.OnCall
                     * @static
                     * @param {clutch.core.project.v1.OnCall} message OnCall
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    OnCall.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.pagerduty = null;
                        if (message.pagerduty != null && message.hasOwnProperty("pagerduty"))
                            object.pagerduty = $root.clutch.core.project.v1.PagerDuty.toObject(message.pagerduty, options);
                        return object;
                    };

                    /**
                     * Converts this OnCall to JSON.
                     * @function toJSON
                     * @memberof clutch.core.project.v1.OnCall
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    OnCall.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return OnCall;
                })();

                v1.PagerDuty = (function() {

                    /**
                     * Properties of a PagerDuty.
                     * @memberof clutch.core.project.v1
                     * @interface IPagerDuty
                     * @property {Array.<string>|null} [serviceIds] PagerDuty serviceIds
                     */

                    /**
                     * Constructs a new PagerDuty.
                     * @memberof clutch.core.project.v1
                     * @classdesc Represents a PagerDuty.
                     * @implements IPagerDuty
                     * @constructor
                     * @param {clutch.core.project.v1.IPagerDuty=} [properties] Properties to set
                     */
                    function PagerDuty(properties) {
                        this.serviceIds = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PagerDuty serviceIds.
                     * @member {Array.<string>} serviceIds
                     * @memberof clutch.core.project.v1.PagerDuty
                     * @instance
                     */
                    PagerDuty.prototype.serviceIds = $util.emptyArray;

                    /**
                     * Verifies a PagerDuty message.
                     * @function verify
                     * @memberof clutch.core.project.v1.PagerDuty
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PagerDuty.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.serviceIds != null && message.hasOwnProperty("serviceIds")) {
                            if (!Array.isArray(message.serviceIds))
                                return "serviceIds: array expected";
                            for (let i = 0; i < message.serviceIds.length; ++i)
                                if (!$util.isString(message.serviceIds[i]))
                                    return "serviceIds: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a PagerDuty message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.core.project.v1.PagerDuty
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.core.project.v1.PagerDuty} PagerDuty
                     */
                    PagerDuty.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.core.project.v1.PagerDuty)
                            return object;
                        let message = new $root.clutch.core.project.v1.PagerDuty();
                        if (object.serviceIds) {
                            if (!Array.isArray(object.serviceIds))
                                throw TypeError(".clutch.core.project.v1.PagerDuty.serviceIds: array expected");
                            message.serviceIds = [];
                            for (let i = 0; i < object.serviceIds.length; ++i)
                                message.serviceIds[i] = String(object.serviceIds[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a PagerDuty message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.core.project.v1.PagerDuty
                     * @static
                     * @param {clutch.core.project.v1.PagerDuty} message PagerDuty
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PagerDuty.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.serviceIds = [];
                        if (message.serviceIds && message.serviceIds.length) {
                            object.serviceIds = [];
                            for (let j = 0; j < message.serviceIds.length; ++j)
                                object.serviceIds[j] = message.serviceIds[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this PagerDuty to JSON.
                     * @function toJSON
                     * @memberof clutch.core.project.v1.PagerDuty
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PagerDuty.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return PagerDuty;
                })();

                v1.Link = (function() {

                    /**
                     * Properties of a Link.
                     * @memberof clutch.core.project.v1
                     * @interface ILink
                     * @property {string|null} [name] Link name
                     * @property {string|null} [url] Link url
                     */

                    /**
                     * Constructs a new Link.
                     * @memberof clutch.core.project.v1
                     * @classdesc Represents a Link.
                     * @implements ILink
                     * @constructor
                     * @param {clutch.core.project.v1.ILink=} [properties] Properties to set
                     */
                    function Link(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Link name.
                     * @member {string} name
                     * @memberof clutch.core.project.v1.Link
                     * @instance
                     */
                    Link.prototype.name = "";

                    /**
                     * Link url.
                     * @member {string} url
                     * @memberof clutch.core.project.v1.Link
                     * @instance
                     */
                    Link.prototype.url = "";

                    /**
                     * Verifies a Link message.
                     * @function verify
                     * @memberof clutch.core.project.v1.Link
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Link.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.url != null && message.hasOwnProperty("url"))
                            if (!$util.isString(message.url))
                                return "url: string expected";
                        return null;
                    };

                    /**
                     * Creates a Link message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.core.project.v1.Link
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.core.project.v1.Link} Link
                     */
                    Link.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.core.project.v1.Link)
                            return object;
                        let message = new $root.clutch.core.project.v1.Link();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.url != null)
                            message.url = String(object.url);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Link message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.core.project.v1.Link
                     * @static
                     * @param {clutch.core.project.v1.Link} message Link
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Link.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.url = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.url != null && message.hasOwnProperty("url"))
                            object.url = message.url;
                        return object;
                    };

                    /**
                     * Converts this Link to JSON.
                     * @function toJSON
                     * @memberof clutch.core.project.v1.Link
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Link.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Link;
                })();

                v1.LinkGroup = (function() {

                    /**
                     * Properties of a LinkGroup.
                     * @memberof clutch.core.project.v1
                     * @interface ILinkGroup
                     * @property {string|null} [name] LinkGroup name
                     * @property {Array.<clutch.core.project.v1.ILink>|null} [links] LinkGroup links
                     * @property {string|null} [imagePath] LinkGroup imagePath
                     */

                    /**
                     * Constructs a new LinkGroup.
                     * @memberof clutch.core.project.v1
                     * @classdesc Represents a LinkGroup.
                     * @implements ILinkGroup
                     * @constructor
                     * @param {clutch.core.project.v1.ILinkGroup=} [properties] Properties to set
                     */
                    function LinkGroup(properties) {
                        this.links = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * LinkGroup name.
                     * @member {string} name
                     * @memberof clutch.core.project.v1.LinkGroup
                     * @instance
                     */
                    LinkGroup.prototype.name = "";

                    /**
                     * LinkGroup links.
                     * @member {Array.<clutch.core.project.v1.ILink>} links
                     * @memberof clutch.core.project.v1.LinkGroup
                     * @instance
                     */
                    LinkGroup.prototype.links = $util.emptyArray;

                    /**
                     * LinkGroup imagePath.
                     * @member {string} imagePath
                     * @memberof clutch.core.project.v1.LinkGroup
                     * @instance
                     */
                    LinkGroup.prototype.imagePath = "";

                    /**
                     * Verifies a LinkGroup message.
                     * @function verify
                     * @memberof clutch.core.project.v1.LinkGroup
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    LinkGroup.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.links != null && message.hasOwnProperty("links")) {
                            if (!Array.isArray(message.links))
                                return "links: array expected";
                            for (let i = 0; i < message.links.length; ++i) {
                                let error = $root.clutch.core.project.v1.Link.verify(message.links[i]);
                                if (error)
                                    return "links." + error;
                            }
                        }
                        if (message.imagePath != null && message.hasOwnProperty("imagePath"))
                            if (!$util.isString(message.imagePath))
                                return "imagePath: string expected";
                        return null;
                    };

                    /**
                     * Creates a LinkGroup message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.core.project.v1.LinkGroup
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.core.project.v1.LinkGroup} LinkGroup
                     */
                    LinkGroup.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.core.project.v1.LinkGroup)
                            return object;
                        let message = new $root.clutch.core.project.v1.LinkGroup();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.links) {
                            if (!Array.isArray(object.links))
                                throw TypeError(".clutch.core.project.v1.LinkGroup.links: array expected");
                            message.links = [];
                            for (let i = 0; i < object.links.length; ++i) {
                                if (typeof object.links[i] !== "object")
                                    throw TypeError(".clutch.core.project.v1.LinkGroup.links: object expected");
                                message.links[i] = $root.clutch.core.project.v1.Link.fromObject(object.links[i]);
                            }
                        }
                        if (object.imagePath != null)
                            message.imagePath = String(object.imagePath);
                        return message;
                    };

                    /**
                     * Creates a plain object from a LinkGroup message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.core.project.v1.LinkGroup
                     * @static
                     * @param {clutch.core.project.v1.LinkGroup} message LinkGroup
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    LinkGroup.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.links = [];
                        if (options.defaults) {
                            object.name = "";
                            object.imagePath = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.links && message.links.length) {
                            object.links = [];
                            for (let j = 0; j < message.links.length; ++j)
                                object.links[j] = $root.clutch.core.project.v1.Link.toObject(message.links[j], options);
                        }
                        if (message.imagePath != null && message.hasOwnProperty("imagePath"))
                            object.imagePath = message.imagePath;
                        return object;
                    };

                    /**
                     * Converts this LinkGroup to JSON.
                     * @function toJSON
                     * @memberof clutch.core.project.v1.LinkGroup
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    LinkGroup.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return LinkGroup;
                })();

                return v1;
            })();

            return project;
        })();

        return core;
    })();

    clutch.envoytriage = (function() {

        /**
         * Namespace envoytriage.
         * @memberof clutch
         * @namespace
         */
        const envoytriage = {};

        envoytriage.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.envoytriage
             * @namespace
             */
            const v1 = {};

            v1.EnvoyTriageAPI = (function() {

                /**
                 * Constructs a new EnvoyTriageAPI service.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents an EnvoyTriageAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function EnvoyTriageAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (EnvoyTriageAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = EnvoyTriageAPI;

                /**
                 * Callback as used by {@link clutch.envoytriage.v1.EnvoyTriageAPI#read}.
                 * @memberof clutch.envoytriage.v1.EnvoyTriageAPI
                 * @typedef ReadCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.envoytriage.v1.ReadResponse} [response] ReadResponse
                 */

                /**
                 * Calls Read.
                 * @function read
                 * @memberof clutch.envoytriage.v1.EnvoyTriageAPI
                 * @instance
                 * @param {clutch.envoytriage.v1.IReadRequest} request ReadRequest message or plain object
                 * @param {clutch.envoytriage.v1.EnvoyTriageAPI.ReadCallback} callback Node-style callback called with the error, if any, and ReadResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(EnvoyTriageAPI.prototype.read = function read(request, callback) {
                    return this.rpcCall(read, $root.clutch.envoytriage.v1.ReadRequest, $root.clutch.envoytriage.v1.ReadResponse, request, callback);
                }, "name", { value: "Read" });

                /**
                 * Calls Read.
                 * @function read
                 * @memberof clutch.envoytriage.v1.EnvoyTriageAPI
                 * @instance
                 * @param {clutch.envoytriage.v1.IReadRequest} request ReadRequest message or plain object
                 * @returns {Promise<clutch.envoytriage.v1.ReadResponse>} Promise
                 * @variation 2
                 */

                return EnvoyTriageAPI;
            })();

            v1.ReadRequest = (function() {

                /**
                 * Properties of a ReadRequest.
                 * @memberof clutch.envoytriage.v1
                 * @interface IReadRequest
                 * @property {Array.<clutch.envoytriage.v1.IReadOperation>|null} [operations] ReadRequest operations
                 */

                /**
                 * Constructs a new ReadRequest.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a ReadRequest.
                 * @implements IReadRequest
                 * @constructor
                 * @param {clutch.envoytriage.v1.IReadRequest=} [properties] Properties to set
                 */
                function ReadRequest(properties) {
                    this.operations = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReadRequest operations.
                 * @member {Array.<clutch.envoytriage.v1.IReadOperation>} operations
                 * @memberof clutch.envoytriage.v1.ReadRequest
                 * @instance
                 */
                ReadRequest.prototype.operations = $util.emptyArray;

                /**
                 * Verifies a ReadRequest message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.ReadRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReadRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.operations != null && message.hasOwnProperty("operations")) {
                        if (!Array.isArray(message.operations))
                            return "operations: array expected";
                        for (let i = 0; i < message.operations.length; ++i) {
                            let error = $root.clutch.envoytriage.v1.ReadOperation.verify(message.operations[i]);
                            if (error)
                                return "operations." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ReadRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.ReadRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.ReadRequest} ReadRequest
                 */
                ReadRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.ReadRequest)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.ReadRequest();
                    if (object.operations) {
                        if (!Array.isArray(object.operations))
                            throw TypeError(".clutch.envoytriage.v1.ReadRequest.operations: array expected");
                        message.operations = [];
                        for (let i = 0; i < object.operations.length; ++i) {
                            if (typeof object.operations[i] !== "object")
                                throw TypeError(".clutch.envoytriage.v1.ReadRequest.operations: object expected");
                            message.operations[i] = $root.clutch.envoytriage.v1.ReadOperation.fromObject(object.operations[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ReadRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.ReadRequest
                 * @static
                 * @param {clutch.envoytriage.v1.ReadRequest} message ReadRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReadRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.operations = [];
                    if (message.operations && message.operations.length) {
                        object.operations = [];
                        for (let j = 0; j < message.operations.length; ++j)
                            object.operations[j] = $root.clutch.envoytriage.v1.ReadOperation.toObject(message.operations[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ReadRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.ReadRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReadRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReadRequest;
            })();

            v1.ReadOperation = (function() {

                /**
                 * Properties of a ReadOperation.
                 * @memberof clutch.envoytriage.v1
                 * @interface IReadOperation
                 * @property {clutch.envoytriage.v1.IAddress|null} [address] ReadOperation address
                 * @property {clutch.envoytriage.v1.ReadOperation.IInclude|null} [include] ReadOperation include
                 */

                /**
                 * Constructs a new ReadOperation.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a ReadOperation.
                 * @implements IReadOperation
                 * @constructor
                 * @param {clutch.envoytriage.v1.IReadOperation=} [properties] Properties to set
                 */
                function ReadOperation(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReadOperation address.
                 * @member {clutch.envoytriage.v1.IAddress|null|undefined} address
                 * @memberof clutch.envoytriage.v1.ReadOperation
                 * @instance
                 */
                ReadOperation.prototype.address = null;

                /**
                 * ReadOperation include.
                 * @member {clutch.envoytriage.v1.ReadOperation.IInclude|null|undefined} include
                 * @memberof clutch.envoytriage.v1.ReadOperation
                 * @instance
                 */
                ReadOperation.prototype.include = null;

                /**
                 * Verifies a ReadOperation message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.ReadOperation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReadOperation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.address != null && message.hasOwnProperty("address")) {
                        let error = $root.clutch.envoytriage.v1.Address.verify(message.address);
                        if (error)
                            return "address." + error;
                    }
                    if (message.include != null && message.hasOwnProperty("include")) {
                        let error = $root.clutch.envoytriage.v1.ReadOperation.Include.verify(message.include);
                        if (error)
                            return "include." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ReadOperation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.ReadOperation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.ReadOperation} ReadOperation
                 */
                ReadOperation.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.ReadOperation)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.ReadOperation();
                    if (object.address != null) {
                        if (typeof object.address !== "object")
                            throw TypeError(".clutch.envoytriage.v1.ReadOperation.address: object expected");
                        message.address = $root.clutch.envoytriage.v1.Address.fromObject(object.address);
                    }
                    if (object.include != null) {
                        if (typeof object.include !== "object")
                            throw TypeError(".clutch.envoytriage.v1.ReadOperation.include: object expected");
                        message.include = $root.clutch.envoytriage.v1.ReadOperation.Include.fromObject(object.include);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ReadOperation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.ReadOperation
                 * @static
                 * @param {clutch.envoytriage.v1.ReadOperation} message ReadOperation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReadOperation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.address = null;
                        object.include = null;
                    }
                    if (message.address != null && message.hasOwnProperty("address"))
                        object.address = $root.clutch.envoytriage.v1.Address.toObject(message.address, options);
                    if (message.include != null && message.hasOwnProperty("include"))
                        object.include = $root.clutch.envoytriage.v1.ReadOperation.Include.toObject(message.include, options);
                    return object;
                };

                /**
                 * Converts this ReadOperation to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.ReadOperation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReadOperation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                ReadOperation.Include = (function() {

                    /**
                     * Properties of an Include.
                     * @memberof clutch.envoytriage.v1.ReadOperation
                     * @interface IInclude
                     * @property {boolean|null} [clusters] Include clusters
                     * @property {boolean|null} [configDump] Include configDump
                     * @property {boolean|null} [listeners] Include listeners
                     * @property {boolean|null} [runtime] Include runtime
                     * @property {boolean|null} [stats] Include stats
                     * @property {boolean|null} [serverInfo] Include serverInfo
                     */

                    /**
                     * Constructs a new Include.
                     * @memberof clutch.envoytriage.v1.ReadOperation
                     * @classdesc Represents an Include.
                     * @implements IInclude
                     * @constructor
                     * @param {clutch.envoytriage.v1.ReadOperation.IInclude=} [properties] Properties to set
                     */
                    function Include(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Include clusters.
                     * @member {boolean} clusters
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @instance
                     */
                    Include.prototype.clusters = false;

                    /**
                     * Include configDump.
                     * @member {boolean} configDump
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @instance
                     */
                    Include.prototype.configDump = false;

                    /**
                     * Include listeners.
                     * @member {boolean} listeners
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @instance
                     */
                    Include.prototype.listeners = false;

                    /**
                     * Include runtime.
                     * @member {boolean} runtime
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @instance
                     */
                    Include.prototype.runtime = false;

                    /**
                     * Include stats.
                     * @member {boolean} stats
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @instance
                     */
                    Include.prototype.stats = false;

                    /**
                     * Include serverInfo.
                     * @member {boolean} serverInfo
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @instance
                     */
                    Include.prototype.serverInfo = false;

                    /**
                     * Verifies an Include message.
                     * @function verify
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Include.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.clusters != null && message.hasOwnProperty("clusters"))
                            if (typeof message.clusters !== "boolean")
                                return "clusters: boolean expected";
                        if (message.configDump != null && message.hasOwnProperty("configDump"))
                            if (typeof message.configDump !== "boolean")
                                return "configDump: boolean expected";
                        if (message.listeners != null && message.hasOwnProperty("listeners"))
                            if (typeof message.listeners !== "boolean")
                                return "listeners: boolean expected";
                        if (message.runtime != null && message.hasOwnProperty("runtime"))
                            if (typeof message.runtime !== "boolean")
                                return "runtime: boolean expected";
                        if (message.stats != null && message.hasOwnProperty("stats"))
                            if (typeof message.stats !== "boolean")
                                return "stats: boolean expected";
                        if (message.serverInfo != null && message.hasOwnProperty("serverInfo"))
                            if (typeof message.serverInfo !== "boolean")
                                return "serverInfo: boolean expected";
                        return null;
                    };

                    /**
                     * Creates an Include message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.envoytriage.v1.ReadOperation.Include} Include
                     */
                    Include.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.envoytriage.v1.ReadOperation.Include)
                            return object;
                        let message = new $root.clutch.envoytriage.v1.ReadOperation.Include();
                        if (object.clusters != null)
                            message.clusters = Boolean(object.clusters);
                        if (object.configDump != null)
                            message.configDump = Boolean(object.configDump);
                        if (object.listeners != null)
                            message.listeners = Boolean(object.listeners);
                        if (object.runtime != null)
                            message.runtime = Boolean(object.runtime);
                        if (object.stats != null)
                            message.stats = Boolean(object.stats);
                        if (object.serverInfo != null)
                            message.serverInfo = Boolean(object.serverInfo);
                        return message;
                    };

                    /**
                     * Creates a plain object from an Include message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @static
                     * @param {clutch.envoytriage.v1.ReadOperation.Include} message Include
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Include.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.clusters = false;
                            object.configDump = false;
                            object.listeners = false;
                            object.runtime = false;
                            object.stats = false;
                            object.serverInfo = false;
                        }
                        if (message.clusters != null && message.hasOwnProperty("clusters"))
                            object.clusters = message.clusters;
                        if (message.configDump != null && message.hasOwnProperty("configDump"))
                            object.configDump = message.configDump;
                        if (message.listeners != null && message.hasOwnProperty("listeners"))
                            object.listeners = message.listeners;
                        if (message.runtime != null && message.hasOwnProperty("runtime"))
                            object.runtime = message.runtime;
                        if (message.stats != null && message.hasOwnProperty("stats"))
                            object.stats = message.stats;
                        if (message.serverInfo != null && message.hasOwnProperty("serverInfo"))
                            object.serverInfo = message.serverInfo;
                        return object;
                    };

                    /**
                     * Converts this Include to JSON.
                     * @function toJSON
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Include.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Include;
                })();

                return ReadOperation;
            })();

            v1.ReadResponse = (function() {

                /**
                 * Properties of a ReadResponse.
                 * @memberof clutch.envoytriage.v1
                 * @interface IReadResponse
                 * @property {Array.<clutch.envoytriage.v1.IResult>|null} [results] ReadResponse results
                 */

                /**
                 * Constructs a new ReadResponse.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a ReadResponse.
                 * @implements IReadResponse
                 * @constructor
                 * @param {clutch.envoytriage.v1.IReadResponse=} [properties] Properties to set
                 */
                function ReadResponse(properties) {
                    this.results = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReadResponse results.
                 * @member {Array.<clutch.envoytriage.v1.IResult>} results
                 * @memberof clutch.envoytriage.v1.ReadResponse
                 * @instance
                 */
                ReadResponse.prototype.results = $util.emptyArray;

                /**
                 * Verifies a ReadResponse message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.ReadResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReadResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.results != null && message.hasOwnProperty("results")) {
                        if (!Array.isArray(message.results))
                            return "results: array expected";
                        for (let i = 0; i < message.results.length; ++i) {
                            let error = $root.clutch.envoytriage.v1.Result.verify(message.results[i]);
                            if (error)
                                return "results." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ReadResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.ReadResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.ReadResponse} ReadResponse
                 */
                ReadResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.ReadResponse)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.ReadResponse();
                    if (object.results) {
                        if (!Array.isArray(object.results))
                            throw TypeError(".clutch.envoytriage.v1.ReadResponse.results: array expected");
                        message.results = [];
                        for (let i = 0; i < object.results.length; ++i) {
                            if (typeof object.results[i] !== "object")
                                throw TypeError(".clutch.envoytriage.v1.ReadResponse.results: object expected");
                            message.results[i] = $root.clutch.envoytriage.v1.Result.fromObject(object.results[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ReadResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.ReadResponse
                 * @static
                 * @param {clutch.envoytriage.v1.ReadResponse} message ReadResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReadResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.results = [];
                    if (message.results && message.results.length) {
                        object.results = [];
                        for (let j = 0; j < message.results.length; ++j)
                            object.results[j] = $root.clutch.envoytriage.v1.Result.toObject(message.results[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ReadResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.ReadResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReadResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReadResponse;
            })();

            v1.Address = (function() {

                /**
                 * Properties of an Address.
                 * @memberof clutch.envoytriage.v1
                 * @interface IAddress
                 * @property {string|null} [host] Address host
                 * @property {number|null} [port] Address port
                 */

                /**
                 * Constructs a new Address.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents an Address.
                 * @implements IAddress
                 * @constructor
                 * @param {clutch.envoytriage.v1.IAddress=} [properties] Properties to set
                 */
                function Address(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Address host.
                 * @member {string} host
                 * @memberof clutch.envoytriage.v1.Address
                 * @instance
                 */
                Address.prototype.host = "";

                /**
                 * Address port.
                 * @member {number} port
                 * @memberof clutch.envoytriage.v1.Address
                 * @instance
                 */
                Address.prototype.port = 0;

                /**
                 * Verifies an Address message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.Address
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Address.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.host != null && message.hasOwnProperty("host"))
                        if (!$util.isString(message.host))
                            return "host: string expected";
                    if (message.port != null && message.hasOwnProperty("port"))
                        if (!$util.isInteger(message.port))
                            return "port: integer expected";
                    return null;
                };

                /**
                 * Creates an Address message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.Address
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.Address} Address
                 */
                Address.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.Address)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.Address();
                    if (object.host != null)
                        message.host = String(object.host);
                    if (object.port != null)
                        message.port = object.port >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from an Address message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.Address
                 * @static
                 * @param {clutch.envoytriage.v1.Address} message Address
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Address.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.host = "";
                        object.port = 0;
                    }
                    if (message.host != null && message.hasOwnProperty("host"))
                        object.host = message.host;
                    if (message.port != null && message.hasOwnProperty("port"))
                        object.port = message.port;
                    return object;
                };

                /**
                 * Converts this Address to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.Address
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Address.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Address;
            })();

            v1.Result = (function() {

                /**
                 * Properties of a Result.
                 * @memberof clutch.envoytriage.v1
                 * @interface IResult
                 * @property {clutch.envoytriage.v1.IAddress|null} [address] Result address
                 * @property {clutch.envoytriage.v1.INodeMetadata|null} [nodeMetadata] Result nodeMetadata
                 * @property {clutch.envoytriage.v1.Result.IOutput|null} [output] Result output
                 */

                /**
                 * Constructs a new Result.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a Result.
                 * @implements IResult
                 * @constructor
                 * @param {clutch.envoytriage.v1.IResult=} [properties] Properties to set
                 */
                function Result(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Result address.
                 * @member {clutch.envoytriage.v1.IAddress|null|undefined} address
                 * @memberof clutch.envoytriage.v1.Result
                 * @instance
                 */
                Result.prototype.address = null;

                /**
                 * Result nodeMetadata.
                 * @member {clutch.envoytriage.v1.INodeMetadata|null|undefined} nodeMetadata
                 * @memberof clutch.envoytriage.v1.Result
                 * @instance
                 */
                Result.prototype.nodeMetadata = null;

                /**
                 * Result output.
                 * @member {clutch.envoytriage.v1.Result.IOutput|null|undefined} output
                 * @memberof clutch.envoytriage.v1.Result
                 * @instance
                 */
                Result.prototype.output = null;

                /**
                 * Verifies a Result message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.Result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.address != null && message.hasOwnProperty("address")) {
                        let error = $root.clutch.envoytriage.v1.Address.verify(message.address);
                        if (error)
                            return "address." + error;
                    }
                    if (message.nodeMetadata != null && message.hasOwnProperty("nodeMetadata")) {
                        let error = $root.clutch.envoytriage.v1.NodeMetadata.verify(message.nodeMetadata);
                        if (error)
                            return "nodeMetadata." + error;
                    }
                    if (message.output != null && message.hasOwnProperty("output")) {
                        let error = $root.clutch.envoytriage.v1.Result.Output.verify(message.output);
                        if (error)
                            return "output." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.Result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.Result} Result
                 */
                Result.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.Result)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.Result();
                    if (object.address != null) {
                        if (typeof object.address !== "object")
                            throw TypeError(".clutch.envoytriage.v1.Result.address: object expected");
                        message.address = $root.clutch.envoytriage.v1.Address.fromObject(object.address);
                    }
                    if (object.nodeMetadata != null) {
                        if (typeof object.nodeMetadata !== "object")
                            throw TypeError(".clutch.envoytriage.v1.Result.nodeMetadata: object expected");
                        message.nodeMetadata = $root.clutch.envoytriage.v1.NodeMetadata.fromObject(object.nodeMetadata);
                    }
                    if (object.output != null) {
                        if (typeof object.output !== "object")
                            throw TypeError(".clutch.envoytriage.v1.Result.output: object expected");
                        message.output = $root.clutch.envoytriage.v1.Result.Output.fromObject(object.output);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.Result
                 * @static
                 * @param {clutch.envoytriage.v1.Result} message Result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.address = null;
                        object.nodeMetadata = null;
                        object.output = null;
                    }
                    if (message.address != null && message.hasOwnProperty("address"))
                        object.address = $root.clutch.envoytriage.v1.Address.toObject(message.address, options);
                    if (message.nodeMetadata != null && message.hasOwnProperty("nodeMetadata"))
                        object.nodeMetadata = $root.clutch.envoytriage.v1.NodeMetadata.toObject(message.nodeMetadata, options);
                    if (message.output != null && message.hasOwnProperty("output"))
                        object.output = $root.clutch.envoytriage.v1.Result.Output.toObject(message.output, options);
                    return object;
                };

                /**
                 * Converts this Result to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.Result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Result.Output = (function() {

                    /**
                     * Properties of an Output.
                     * @memberof clutch.envoytriage.v1.Result
                     * @interface IOutput
                     * @property {clutch.envoytriage.v1.IClusters|null} [clusters] Output clusters
                     * @property {clutch.envoytriage.v1.IConfigDump|null} [configDump] Output configDump
                     * @property {clutch.envoytriage.v1.IListeners|null} [listeners] Output listeners
                     * @property {clutch.envoytriage.v1.IRuntime|null} [runtime] Output runtime
                     * @property {clutch.envoytriage.v1.IStats|null} [stats] Output stats
                     * @property {clutch.envoytriage.v1.IServerInfo|null} [serverInfo] Output serverInfo
                     */

                    /**
                     * Constructs a new Output.
                     * @memberof clutch.envoytriage.v1.Result
                     * @classdesc Represents an Output.
                     * @implements IOutput
                     * @constructor
                     * @param {clutch.envoytriage.v1.Result.IOutput=} [properties] Properties to set
                     */
                    function Output(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Output clusters.
                     * @member {clutch.envoytriage.v1.IClusters|null|undefined} clusters
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @instance
                     */
                    Output.prototype.clusters = null;

                    /**
                     * Output configDump.
                     * @member {clutch.envoytriage.v1.IConfigDump|null|undefined} configDump
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @instance
                     */
                    Output.prototype.configDump = null;

                    /**
                     * Output listeners.
                     * @member {clutch.envoytriage.v1.IListeners|null|undefined} listeners
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @instance
                     */
                    Output.prototype.listeners = null;

                    /**
                     * Output runtime.
                     * @member {clutch.envoytriage.v1.IRuntime|null|undefined} runtime
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @instance
                     */
                    Output.prototype.runtime = null;

                    /**
                     * Output stats.
                     * @member {clutch.envoytriage.v1.IStats|null|undefined} stats
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @instance
                     */
                    Output.prototype.stats = null;

                    /**
                     * Output serverInfo.
                     * @member {clutch.envoytriage.v1.IServerInfo|null|undefined} serverInfo
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @instance
                     */
                    Output.prototype.serverInfo = null;

                    /**
                     * Verifies an Output message.
                     * @function verify
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Output.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.clusters != null && message.hasOwnProperty("clusters")) {
                            let error = $root.clutch.envoytriage.v1.Clusters.verify(message.clusters);
                            if (error)
                                return "clusters." + error;
                        }
                        if (message.configDump != null && message.hasOwnProperty("configDump")) {
                            let error = $root.clutch.envoytriage.v1.ConfigDump.verify(message.configDump);
                            if (error)
                                return "configDump." + error;
                        }
                        if (message.listeners != null && message.hasOwnProperty("listeners")) {
                            let error = $root.clutch.envoytriage.v1.Listeners.verify(message.listeners);
                            if (error)
                                return "listeners." + error;
                        }
                        if (message.runtime != null && message.hasOwnProperty("runtime")) {
                            let error = $root.clutch.envoytriage.v1.Runtime.verify(message.runtime);
                            if (error)
                                return "runtime." + error;
                        }
                        if (message.stats != null && message.hasOwnProperty("stats")) {
                            let error = $root.clutch.envoytriage.v1.Stats.verify(message.stats);
                            if (error)
                                return "stats." + error;
                        }
                        if (message.serverInfo != null && message.hasOwnProperty("serverInfo")) {
                            let error = $root.clutch.envoytriage.v1.ServerInfo.verify(message.serverInfo);
                            if (error)
                                return "serverInfo." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an Output message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.envoytriage.v1.Result.Output} Output
                     */
                    Output.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.envoytriage.v1.Result.Output)
                            return object;
                        let message = new $root.clutch.envoytriage.v1.Result.Output();
                        if (object.clusters != null) {
                            if (typeof object.clusters !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Result.Output.clusters: object expected");
                            message.clusters = $root.clutch.envoytriage.v1.Clusters.fromObject(object.clusters);
                        }
                        if (object.configDump != null) {
                            if (typeof object.configDump !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Result.Output.configDump: object expected");
                            message.configDump = $root.clutch.envoytriage.v1.ConfigDump.fromObject(object.configDump);
                        }
                        if (object.listeners != null) {
                            if (typeof object.listeners !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Result.Output.listeners: object expected");
                            message.listeners = $root.clutch.envoytriage.v1.Listeners.fromObject(object.listeners);
                        }
                        if (object.runtime != null) {
                            if (typeof object.runtime !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Result.Output.runtime: object expected");
                            message.runtime = $root.clutch.envoytriage.v1.Runtime.fromObject(object.runtime);
                        }
                        if (object.stats != null) {
                            if (typeof object.stats !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Result.Output.stats: object expected");
                            message.stats = $root.clutch.envoytriage.v1.Stats.fromObject(object.stats);
                        }
                        if (object.serverInfo != null) {
                            if (typeof object.serverInfo !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Result.Output.serverInfo: object expected");
                            message.serverInfo = $root.clutch.envoytriage.v1.ServerInfo.fromObject(object.serverInfo);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an Output message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @static
                     * @param {clutch.envoytriage.v1.Result.Output} message Output
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Output.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.clusters = null;
                            object.configDump = null;
                            object.listeners = null;
                            object.runtime = null;
                            object.stats = null;
                            object.serverInfo = null;
                        }
                        if (message.clusters != null && message.hasOwnProperty("clusters"))
                            object.clusters = $root.clutch.envoytriage.v1.Clusters.toObject(message.clusters, options);
                        if (message.configDump != null && message.hasOwnProperty("configDump"))
                            object.configDump = $root.clutch.envoytriage.v1.ConfigDump.toObject(message.configDump, options);
                        if (message.listeners != null && message.hasOwnProperty("listeners"))
                            object.listeners = $root.clutch.envoytriage.v1.Listeners.toObject(message.listeners, options);
                        if (message.runtime != null && message.hasOwnProperty("runtime"))
                            object.runtime = $root.clutch.envoytriage.v1.Runtime.toObject(message.runtime, options);
                        if (message.stats != null && message.hasOwnProperty("stats"))
                            object.stats = $root.clutch.envoytriage.v1.Stats.toObject(message.stats, options);
                        if (message.serverInfo != null && message.hasOwnProperty("serverInfo"))
                            object.serverInfo = $root.clutch.envoytriage.v1.ServerInfo.toObject(message.serverInfo, options);
                        return object;
                    };

                    /**
                     * Converts this Output to JSON.
                     * @function toJSON
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Output.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Output;
                })();

                return Result;
            })();

            v1.NodeMetadata = (function() {

                /**
                 * Properties of a NodeMetadata.
                 * @memberof clutch.envoytriage.v1
                 * @interface INodeMetadata
                 * @property {string|null} [serviceNode] NodeMetadata serviceNode
                 * @property {string|null} [serviceCluster] NodeMetadata serviceCluster
                 * @property {string|null} [serviceZone] NodeMetadata serviceZone
                 * @property {string|null} [version] NodeMetadata version
                 */

                /**
                 * Constructs a new NodeMetadata.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a NodeMetadata.
                 * @implements INodeMetadata
                 * @constructor
                 * @param {clutch.envoytriage.v1.INodeMetadata=} [properties] Properties to set
                 */
                function NodeMetadata(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NodeMetadata serviceNode.
                 * @member {string} serviceNode
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @instance
                 */
                NodeMetadata.prototype.serviceNode = "";

                /**
                 * NodeMetadata serviceCluster.
                 * @member {string} serviceCluster
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @instance
                 */
                NodeMetadata.prototype.serviceCluster = "";

                /**
                 * NodeMetadata serviceZone.
                 * @member {string} serviceZone
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @instance
                 */
                NodeMetadata.prototype.serviceZone = "";

                /**
                 * NodeMetadata version.
                 * @member {string} version
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @instance
                 */
                NodeMetadata.prototype.version = "";

                /**
                 * Verifies a NodeMetadata message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.serviceNode != null && message.hasOwnProperty("serviceNode"))
                        if (!$util.isString(message.serviceNode))
                            return "serviceNode: string expected";
                    if (message.serviceCluster != null && message.hasOwnProperty("serviceCluster"))
                        if (!$util.isString(message.serviceCluster))
                            return "serviceCluster: string expected";
                    if (message.serviceZone != null && message.hasOwnProperty("serviceZone"))
                        if (!$util.isString(message.serviceZone))
                            return "serviceZone: string expected";
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isString(message.version))
                            return "version: string expected";
                    return null;
                };

                /**
                 * Creates a NodeMetadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.NodeMetadata} NodeMetadata
                 */
                NodeMetadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.NodeMetadata)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.NodeMetadata();
                    if (object.serviceNode != null)
                        message.serviceNode = String(object.serviceNode);
                    if (object.serviceCluster != null)
                        message.serviceCluster = String(object.serviceCluster);
                    if (object.serviceZone != null)
                        message.serviceZone = String(object.serviceZone);
                    if (object.version != null)
                        message.version = String(object.version);
                    return message;
                };

                /**
                 * Creates a plain object from a NodeMetadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @static
                 * @param {clutch.envoytriage.v1.NodeMetadata} message NodeMetadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NodeMetadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.serviceNode = "";
                        object.serviceCluster = "";
                        object.serviceZone = "";
                        object.version = "";
                    }
                    if (message.serviceNode != null && message.hasOwnProperty("serviceNode"))
                        object.serviceNode = message.serviceNode;
                    if (message.serviceCluster != null && message.hasOwnProperty("serviceCluster"))
                        object.serviceCluster = message.serviceCluster;
                    if (message.serviceZone != null && message.hasOwnProperty("serviceZone"))
                        object.serviceZone = message.serviceZone;
                    if (message.version != null && message.hasOwnProperty("version"))
                        object.version = message.version;
                    return object;
                };

                /**
                 * Converts this NodeMetadata to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NodeMetadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NodeMetadata;
            })();

            v1.HostStatus = (function() {

                /**
                 * Properties of a HostStatus.
                 * @memberof clutch.envoytriage.v1
                 * @interface IHostStatus
                 * @property {string|null} [address] HostStatus address
                 * @property {boolean|null} [healthy] HostStatus healthy
                 */

                /**
                 * Constructs a new HostStatus.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a HostStatus.
                 * @implements IHostStatus
                 * @constructor
                 * @param {clutch.envoytriage.v1.IHostStatus=} [properties] Properties to set
                 */
                function HostStatus(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * HostStatus address.
                 * @member {string} address
                 * @memberof clutch.envoytriage.v1.HostStatus
                 * @instance
                 */
                HostStatus.prototype.address = "";

                /**
                 * HostStatus healthy.
                 * @member {boolean} healthy
                 * @memberof clutch.envoytriage.v1.HostStatus
                 * @instance
                 */
                HostStatus.prototype.healthy = false;

                /**
                 * Verifies a HostStatus message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.HostStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HostStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.address != null && message.hasOwnProperty("address"))
                        if (!$util.isString(message.address))
                            return "address: string expected";
                    if (message.healthy != null && message.hasOwnProperty("healthy"))
                        if (typeof message.healthy !== "boolean")
                            return "healthy: boolean expected";
                    return null;
                };

                /**
                 * Creates a HostStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.HostStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.HostStatus} HostStatus
                 */
                HostStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.HostStatus)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.HostStatus();
                    if (object.address != null)
                        message.address = String(object.address);
                    if (object.healthy != null)
                        message.healthy = Boolean(object.healthy);
                    return message;
                };

                /**
                 * Creates a plain object from a HostStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.HostStatus
                 * @static
                 * @param {clutch.envoytriage.v1.HostStatus} message HostStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HostStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.address = "";
                        object.healthy = false;
                    }
                    if (message.address != null && message.hasOwnProperty("address"))
                        object.address = message.address;
                    if (message.healthy != null && message.hasOwnProperty("healthy"))
                        object.healthy = message.healthy;
                    return object;
                };

                /**
                 * Converts this HostStatus to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.HostStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HostStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return HostStatus;
            })();

            v1.ClusterStatus = (function() {

                /**
                 * Properties of a ClusterStatus.
                 * @memberof clutch.envoytriage.v1
                 * @interface IClusterStatus
                 * @property {string|null} [name] ClusterStatus name
                 * @property {Array.<clutch.envoytriage.v1.IHostStatus>|null} [hostStatuses] ClusterStatus hostStatuses
                 */

                /**
                 * Constructs a new ClusterStatus.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a ClusterStatus.
                 * @implements IClusterStatus
                 * @constructor
                 * @param {clutch.envoytriage.v1.IClusterStatus=} [properties] Properties to set
                 */
                function ClusterStatus(properties) {
                    this.hostStatuses = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ClusterStatus name.
                 * @member {string} name
                 * @memberof clutch.envoytriage.v1.ClusterStatus
                 * @instance
                 */
                ClusterStatus.prototype.name = "";

                /**
                 * ClusterStatus hostStatuses.
                 * @member {Array.<clutch.envoytriage.v1.IHostStatus>} hostStatuses
                 * @memberof clutch.envoytriage.v1.ClusterStatus
                 * @instance
                 */
                ClusterStatus.prototype.hostStatuses = $util.emptyArray;

                /**
                 * Verifies a ClusterStatus message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.ClusterStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ClusterStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.hostStatuses != null && message.hasOwnProperty("hostStatuses")) {
                        if (!Array.isArray(message.hostStatuses))
                            return "hostStatuses: array expected";
                        for (let i = 0; i < message.hostStatuses.length; ++i) {
                            let error = $root.clutch.envoytriage.v1.HostStatus.verify(message.hostStatuses[i]);
                            if (error)
                                return "hostStatuses." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ClusterStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.ClusterStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.ClusterStatus} ClusterStatus
                 */
                ClusterStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.ClusterStatus)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.ClusterStatus();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.hostStatuses) {
                        if (!Array.isArray(object.hostStatuses))
                            throw TypeError(".clutch.envoytriage.v1.ClusterStatus.hostStatuses: array expected");
                        message.hostStatuses = [];
                        for (let i = 0; i < object.hostStatuses.length; ++i) {
                            if (typeof object.hostStatuses[i] !== "object")
                                throw TypeError(".clutch.envoytriage.v1.ClusterStatus.hostStatuses: object expected");
                            message.hostStatuses[i] = $root.clutch.envoytriage.v1.HostStatus.fromObject(object.hostStatuses[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ClusterStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.ClusterStatus
                 * @static
                 * @param {clutch.envoytriage.v1.ClusterStatus} message ClusterStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClusterStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.hostStatuses = [];
                    if (options.defaults)
                        object.name = "";
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.hostStatuses && message.hostStatuses.length) {
                        object.hostStatuses = [];
                        for (let j = 0; j < message.hostStatuses.length; ++j)
                            object.hostStatuses[j] = $root.clutch.envoytriage.v1.HostStatus.toObject(message.hostStatuses[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ClusterStatus to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.ClusterStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ClusterStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ClusterStatus;
            })();

            v1.Clusters = (function() {

                /**
                 * Properties of a Clusters.
                 * @memberof clutch.envoytriage.v1
                 * @interface IClusters
                 * @property {Array.<clutch.envoytriage.v1.IClusterStatus>|null} [clusterStatuses] Clusters clusterStatuses
                 */

                /**
                 * Constructs a new Clusters.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a Clusters.
                 * @implements IClusters
                 * @constructor
                 * @param {clutch.envoytriage.v1.IClusters=} [properties] Properties to set
                 */
                function Clusters(properties) {
                    this.clusterStatuses = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Clusters clusterStatuses.
                 * @member {Array.<clutch.envoytriage.v1.IClusterStatus>} clusterStatuses
                 * @memberof clutch.envoytriage.v1.Clusters
                 * @instance
                 */
                Clusters.prototype.clusterStatuses = $util.emptyArray;

                /**
                 * Verifies a Clusters message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.Clusters
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Clusters.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clusterStatuses != null && message.hasOwnProperty("clusterStatuses")) {
                        if (!Array.isArray(message.clusterStatuses))
                            return "clusterStatuses: array expected";
                        for (let i = 0; i < message.clusterStatuses.length; ++i) {
                            let error = $root.clutch.envoytriage.v1.ClusterStatus.verify(message.clusterStatuses[i]);
                            if (error)
                                return "clusterStatuses." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Clusters message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.Clusters
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.Clusters} Clusters
                 */
                Clusters.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.Clusters)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.Clusters();
                    if (object.clusterStatuses) {
                        if (!Array.isArray(object.clusterStatuses))
                            throw TypeError(".clutch.envoytriage.v1.Clusters.clusterStatuses: array expected");
                        message.clusterStatuses = [];
                        for (let i = 0; i < object.clusterStatuses.length; ++i) {
                            if (typeof object.clusterStatuses[i] !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Clusters.clusterStatuses: object expected");
                            message.clusterStatuses[i] = $root.clutch.envoytriage.v1.ClusterStatus.fromObject(object.clusterStatuses[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Clusters message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.Clusters
                 * @static
                 * @param {clutch.envoytriage.v1.Clusters} message Clusters
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Clusters.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.clusterStatuses = [];
                    if (message.clusterStatuses && message.clusterStatuses.length) {
                        object.clusterStatuses = [];
                        for (let j = 0; j < message.clusterStatuses.length; ++j)
                            object.clusterStatuses[j] = $root.clutch.envoytriage.v1.ClusterStatus.toObject(message.clusterStatuses[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Clusters to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.Clusters
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Clusters.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Clusters;
            })();

            v1.ConfigDump = (function() {

                /**
                 * Properties of a ConfigDump.
                 * @memberof clutch.envoytriage.v1
                 * @interface IConfigDump
                 * @property {google.protobuf.IValue|null} [value] ConfigDump value
                 */

                /**
                 * Constructs a new ConfigDump.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a ConfigDump.
                 * @implements IConfigDump
                 * @constructor
                 * @param {clutch.envoytriage.v1.IConfigDump=} [properties] Properties to set
                 */
                function ConfigDump(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ConfigDump value.
                 * @member {google.protobuf.IValue|null|undefined} value
                 * @memberof clutch.envoytriage.v1.ConfigDump
                 * @instance
                 */
                ConfigDump.prototype.value = null;

                /**
                 * Verifies a ConfigDump message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.ConfigDump
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConfigDump.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        let error = $root.google.protobuf.Value.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ConfigDump message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.ConfigDump
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.ConfigDump} ConfigDump
                 */
                ConfigDump.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.ConfigDump)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.ConfigDump();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".clutch.envoytriage.v1.ConfigDump.value: object expected");
                        message.value = $root.google.protobuf.Value.fromObject(object.value);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ConfigDump message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.ConfigDump
                 * @static
                 * @param {clutch.envoytriage.v1.ConfigDump} message ConfigDump
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConfigDump.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.google.protobuf.Value.toObject(message.value, options);
                    return object;
                };

                /**
                 * Converts this ConfigDump to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.ConfigDump
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConfigDump.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ConfigDump;
            })();

            v1.ListenerStatus = (function() {

                /**
                 * Properties of a ListenerStatus.
                 * @memberof clutch.envoytriage.v1
                 * @interface IListenerStatus
                 * @property {string|null} [name] ListenerStatus name
                 * @property {string|null} [localAddress] ListenerStatus localAddress
                 */

                /**
                 * Constructs a new ListenerStatus.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a ListenerStatus.
                 * @implements IListenerStatus
                 * @constructor
                 * @param {clutch.envoytriage.v1.IListenerStatus=} [properties] Properties to set
                 */
                function ListenerStatus(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListenerStatus name.
                 * @member {string} name
                 * @memberof clutch.envoytriage.v1.ListenerStatus
                 * @instance
                 */
                ListenerStatus.prototype.name = "";

                /**
                 * ListenerStatus localAddress.
                 * @member {string} localAddress
                 * @memberof clutch.envoytriage.v1.ListenerStatus
                 * @instance
                 */
                ListenerStatus.prototype.localAddress = "";

                /**
                 * Verifies a ListenerStatus message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.ListenerStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListenerStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.localAddress != null && message.hasOwnProperty("localAddress"))
                        if (!$util.isString(message.localAddress))
                            return "localAddress: string expected";
                    return null;
                };

                /**
                 * Creates a ListenerStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.ListenerStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.ListenerStatus} ListenerStatus
                 */
                ListenerStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.ListenerStatus)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.ListenerStatus();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.localAddress != null)
                        message.localAddress = String(object.localAddress);
                    return message;
                };

                /**
                 * Creates a plain object from a ListenerStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.ListenerStatus
                 * @static
                 * @param {clutch.envoytriage.v1.ListenerStatus} message ListenerStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListenerStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.localAddress = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.localAddress != null && message.hasOwnProperty("localAddress"))
                        object.localAddress = message.localAddress;
                    return object;
                };

                /**
                 * Converts this ListenerStatus to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.ListenerStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListenerStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListenerStatus;
            })();

            v1.Listeners = (function() {

                /**
                 * Properties of a Listeners.
                 * @memberof clutch.envoytriage.v1
                 * @interface IListeners
                 * @property {Array.<clutch.envoytriage.v1.IListenerStatus>|null} [listenerStatuses] Listeners listenerStatuses
                 */

                /**
                 * Constructs a new Listeners.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a Listeners.
                 * @implements IListeners
                 * @constructor
                 * @param {clutch.envoytriage.v1.IListeners=} [properties] Properties to set
                 */
                function Listeners(properties) {
                    this.listenerStatuses = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Listeners listenerStatuses.
                 * @member {Array.<clutch.envoytriage.v1.IListenerStatus>} listenerStatuses
                 * @memberof clutch.envoytriage.v1.Listeners
                 * @instance
                 */
                Listeners.prototype.listenerStatuses = $util.emptyArray;

                /**
                 * Verifies a Listeners message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.Listeners
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Listeners.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.listenerStatuses != null && message.hasOwnProperty("listenerStatuses")) {
                        if (!Array.isArray(message.listenerStatuses))
                            return "listenerStatuses: array expected";
                        for (let i = 0; i < message.listenerStatuses.length; ++i) {
                            let error = $root.clutch.envoytriage.v1.ListenerStatus.verify(message.listenerStatuses[i]);
                            if (error)
                                return "listenerStatuses." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Listeners message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.Listeners
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.Listeners} Listeners
                 */
                Listeners.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.Listeners)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.Listeners();
                    if (object.listenerStatuses) {
                        if (!Array.isArray(object.listenerStatuses))
                            throw TypeError(".clutch.envoytriage.v1.Listeners.listenerStatuses: array expected");
                        message.listenerStatuses = [];
                        for (let i = 0; i < object.listenerStatuses.length; ++i) {
                            if (typeof object.listenerStatuses[i] !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Listeners.listenerStatuses: object expected");
                            message.listenerStatuses[i] = $root.clutch.envoytriage.v1.ListenerStatus.fromObject(object.listenerStatuses[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Listeners message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.Listeners
                 * @static
                 * @param {clutch.envoytriage.v1.Listeners} message Listeners
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Listeners.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.listenerStatuses = [];
                    if (message.listenerStatuses && message.listenerStatuses.length) {
                        object.listenerStatuses = [];
                        for (let j = 0; j < message.listenerStatuses.length; ++j)
                            object.listenerStatuses[j] = $root.clutch.envoytriage.v1.ListenerStatus.toObject(message.listenerStatuses[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Listeners to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.Listeners
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Listeners.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Listeners;
            })();

            v1.Runtime = (function() {

                /**
                 * Properties of a Runtime.
                 * @memberof clutch.envoytriage.v1
                 * @interface IRuntime
                 * @property {Array.<clutch.envoytriage.v1.Runtime.IEntry>|null} [entries] Runtime entries
                 */

                /**
                 * Constructs a new Runtime.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a Runtime.
                 * @implements IRuntime
                 * @constructor
                 * @param {clutch.envoytriage.v1.IRuntime=} [properties] Properties to set
                 */
                function Runtime(properties) {
                    this.entries = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Runtime entries.
                 * @member {Array.<clutch.envoytriage.v1.Runtime.IEntry>} entries
                 * @memberof clutch.envoytriage.v1.Runtime
                 * @instance
                 */
                Runtime.prototype.entries = $util.emptyArray;

                /**
                 * Verifies a Runtime message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.Runtime
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Runtime.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entries != null && message.hasOwnProperty("entries")) {
                        if (!Array.isArray(message.entries))
                            return "entries: array expected";
                        for (let i = 0; i < message.entries.length; ++i) {
                            let error = $root.clutch.envoytriage.v1.Runtime.Entry.verify(message.entries[i]);
                            if (error)
                                return "entries." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Runtime message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.Runtime
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.Runtime} Runtime
                 */
                Runtime.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.Runtime)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.Runtime();
                    if (object.entries) {
                        if (!Array.isArray(object.entries))
                            throw TypeError(".clutch.envoytriage.v1.Runtime.entries: array expected");
                        message.entries = [];
                        for (let i = 0; i < object.entries.length; ++i) {
                            if (typeof object.entries[i] !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Runtime.entries: object expected");
                            message.entries[i] = $root.clutch.envoytriage.v1.Runtime.Entry.fromObject(object.entries[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Runtime message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.Runtime
                 * @static
                 * @param {clutch.envoytriage.v1.Runtime} message Runtime
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Runtime.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.entries = [];
                    if (message.entries && message.entries.length) {
                        object.entries = [];
                        for (let j = 0; j < message.entries.length; ++j)
                            object.entries[j] = $root.clutch.envoytriage.v1.Runtime.Entry.toObject(message.entries[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Runtime to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.Runtime
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Runtime.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Runtime.Entry = (function() {

                    /**
                     * Properties of an Entry.
                     * @memberof clutch.envoytriage.v1.Runtime
                     * @interface IEntry
                     * @property {string|null} [key] Entry key
                     * @property {string|null} [value] Entry value
                     */

                    /**
                     * Constructs a new Entry.
                     * @memberof clutch.envoytriage.v1.Runtime
                     * @classdesc Represents an Entry.
                     * @implements IEntry
                     * @constructor
                     * @param {clutch.envoytriage.v1.Runtime.IEntry=} [properties] Properties to set
                     */
                    function Entry(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Entry key.
                     * @member {string} key
                     * @memberof clutch.envoytriage.v1.Runtime.Entry
                     * @instance
                     */
                    Entry.prototype.key = "";

                    /**
                     * Entry value.
                     * @member {string|null|undefined} value
                     * @memberof clutch.envoytriage.v1.Runtime.Entry
                     * @instance
                     */
                    Entry.prototype.value = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Entry type.
                     * @member {"value"|undefined} type
                     * @memberof clutch.envoytriage.v1.Runtime.Entry
                     * @instance
                     */
                    Object.defineProperty(Entry.prototype, "type", {
                        get: $util.oneOfGetter($oneOfFields = ["value"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies an Entry message.
                     * @function verify
                     * @memberof clutch.envoytriage.v1.Runtime.Entry
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Entry.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.key != null && message.hasOwnProperty("key"))
                            if (!$util.isString(message.key))
                                return "key: string expected";
                        if (message.value != null && message.hasOwnProperty("value")) {
                            properties.type = 1;
                            if (!$util.isString(message.value))
                                return "value: string expected";
                        }
                        return null;
                    };

                    /**
                     * Creates an Entry message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.envoytriage.v1.Runtime.Entry
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.envoytriage.v1.Runtime.Entry} Entry
                     */
                    Entry.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.envoytriage.v1.Runtime.Entry)
                            return object;
                        let message = new $root.clutch.envoytriage.v1.Runtime.Entry();
                        if (object.key != null)
                            message.key = String(object.key);
                        if (object.value != null)
                            message.value = String(object.value);
                        return message;
                    };

                    /**
                     * Creates a plain object from an Entry message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.envoytriage.v1.Runtime.Entry
                     * @static
                     * @param {clutch.envoytriage.v1.Runtime.Entry} message Entry
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Entry.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.key = "";
                        if (message.key != null && message.hasOwnProperty("key"))
                            object.key = message.key;
                        if (message.value != null && message.hasOwnProperty("value")) {
                            object.value = message.value;
                            if (options.oneofs)
                                object.type = "value";
                        }
                        return object;
                    };

                    /**
                     * Converts this Entry to JSON.
                     * @function toJSON
                     * @memberof clutch.envoytriage.v1.Runtime.Entry
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Entry.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Entry;
                })();

                return Runtime;
            })();

            v1.ServerInfo = (function() {

                /**
                 * Properties of a ServerInfo.
                 * @memberof clutch.envoytriage.v1
                 * @interface IServerInfo
                 * @property {google.protobuf.IValue|null} [value] ServerInfo value
                 */

                /**
                 * Constructs a new ServerInfo.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a ServerInfo.
                 * @implements IServerInfo
                 * @constructor
                 * @param {clutch.envoytriage.v1.IServerInfo=} [properties] Properties to set
                 */
                function ServerInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ServerInfo value.
                 * @member {google.protobuf.IValue|null|undefined} value
                 * @memberof clutch.envoytriage.v1.ServerInfo
                 * @instance
                 */
                ServerInfo.prototype.value = null;

                /**
                 * Verifies a ServerInfo message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.ServerInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServerInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        let error = $root.google.protobuf.Value.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ServerInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.ServerInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.ServerInfo} ServerInfo
                 */
                ServerInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.ServerInfo)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.ServerInfo();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".clutch.envoytriage.v1.ServerInfo.value: object expected");
                        message.value = $root.google.protobuf.Value.fromObject(object.value);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ServerInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.ServerInfo
                 * @static
                 * @param {clutch.envoytriage.v1.ServerInfo} message ServerInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServerInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.google.protobuf.Value.toObject(message.value, options);
                    return object;
                };

                /**
                 * Converts this ServerInfo to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.ServerInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServerInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ServerInfo;
            })();

            v1.Stats = (function() {

                /**
                 * Properties of a Stats.
                 * @memberof clutch.envoytriage.v1
                 * @interface IStats
                 * @property {Array.<clutch.envoytriage.v1.Stats.IStat>|null} [stats] Stats stats
                 */

                /**
                 * Constructs a new Stats.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a Stats.
                 * @implements IStats
                 * @constructor
                 * @param {clutch.envoytriage.v1.IStats=} [properties] Properties to set
                 */
                function Stats(properties) {
                    this.stats = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Stats stats.
                 * @member {Array.<clutch.envoytriage.v1.Stats.IStat>} stats
                 * @memberof clutch.envoytriage.v1.Stats
                 * @instance
                 */
                Stats.prototype.stats = $util.emptyArray;

                /**
                 * Verifies a Stats message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.Stats
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Stats.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.stats != null && message.hasOwnProperty("stats")) {
                        if (!Array.isArray(message.stats))
                            return "stats: array expected";
                        for (let i = 0; i < message.stats.length; ++i) {
                            let error = $root.clutch.envoytriage.v1.Stats.Stat.verify(message.stats[i]);
                            if (error)
                                return "stats." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Stats message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.Stats
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.Stats} Stats
                 */
                Stats.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.Stats)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.Stats();
                    if (object.stats) {
                        if (!Array.isArray(object.stats))
                            throw TypeError(".clutch.envoytriage.v1.Stats.stats: array expected");
                        message.stats = [];
                        for (let i = 0; i < object.stats.length; ++i) {
                            if (typeof object.stats[i] !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Stats.stats: object expected");
                            message.stats[i] = $root.clutch.envoytriage.v1.Stats.Stat.fromObject(object.stats[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Stats message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.Stats
                 * @static
                 * @param {clutch.envoytriage.v1.Stats} message Stats
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Stats.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.stats = [];
                    if (message.stats && message.stats.length) {
                        object.stats = [];
                        for (let j = 0; j < message.stats.length; ++j)
                            object.stats[j] = $root.clutch.envoytriage.v1.Stats.Stat.toObject(message.stats[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Stats to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.Stats
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Stats.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Stats.Stat = (function() {

                    /**
                     * Properties of a Stat.
                     * @memberof clutch.envoytriage.v1.Stats
                     * @interface IStat
                     * @property {string|null} [key] Stat key
                     * @property {number|Long|null} [value] Stat value
                     */

                    /**
                     * Constructs a new Stat.
                     * @memberof clutch.envoytriage.v1.Stats
                     * @classdesc Represents a Stat.
                     * @implements IStat
                     * @constructor
                     * @param {clutch.envoytriage.v1.Stats.IStat=} [properties] Properties to set
                     */
                    function Stat(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Stat key.
                     * @member {string} key
                     * @memberof clutch.envoytriage.v1.Stats.Stat
                     * @instance
                     */
                    Stat.prototype.key = "";

                    /**
                     * Stat value.
                     * @member {number|Long} value
                     * @memberof clutch.envoytriage.v1.Stats.Stat
                     * @instance
                     */
                    Stat.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Verifies a Stat message.
                     * @function verify
                     * @memberof clutch.envoytriage.v1.Stats.Stat
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Stat.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.key != null && message.hasOwnProperty("key"))
                            if (!$util.isString(message.key))
                                return "key: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a Stat message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.envoytriage.v1.Stats.Stat
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.envoytriage.v1.Stats.Stat} Stat
                     */
                    Stat.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.envoytriage.v1.Stats.Stat)
                            return object;
                        let message = new $root.clutch.envoytriage.v1.Stats.Stat();
                        if (object.key != null)
                            message.key = String(object.key);
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Stat message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.envoytriage.v1.Stats.Stat
                     * @static
                     * @param {clutch.envoytriage.v1.Stats.Stat} message Stat
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Stat.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.key = "";
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                        }
                        if (message.key != null && message.hasOwnProperty("key"))
                            object.key = message.key;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        return object;
                    };

                    /**
                     * Converts this Stat to JSON.
                     * @function toJSON
                     * @memberof clutch.envoytriage.v1.Stats.Stat
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Stat.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Stat;
                })();

                return Stats;
            })();

            return v1;
        })();

        return envoytriage;
    })();

    clutch.featureflag = (function() {

        /**
         * Namespace featureflag.
         * @memberof clutch
         * @namespace
         */
        const featureflag = {};

        featureflag.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.featureflag
             * @namespace
             */
            const v1 = {};

            v1.FeatureFlagAPI = (function() {

                /**
                 * Constructs a new FeatureFlagAPI service.
                 * @memberof clutch.featureflag.v1
                 * @classdesc Represents a FeatureFlagAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function FeatureFlagAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (FeatureFlagAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = FeatureFlagAPI;

                /**
                 * Callback as used by {@link clutch.featureflag.v1.FeatureFlagAPI#getFlags}.
                 * @memberof clutch.featureflag.v1.FeatureFlagAPI
                 * @typedef GetFlagsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.featureflag.v1.GetFlagsResponse} [response] GetFlagsResponse
                 */

                /**
                 * Calls GetFlags.
                 * @function getFlags
                 * @memberof clutch.featureflag.v1.FeatureFlagAPI
                 * @instance
                 * @param {clutch.featureflag.v1.IGetFlagsRequest} request GetFlagsRequest message or plain object
                 * @param {clutch.featureflag.v1.FeatureFlagAPI.GetFlagsCallback} callback Node-style callback called with the error, if any, and GetFlagsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(FeatureFlagAPI.prototype.getFlags = function getFlags(request, callback) {
                    return this.rpcCall(getFlags, $root.clutch.featureflag.v1.GetFlagsRequest, $root.clutch.featureflag.v1.GetFlagsResponse, request, callback);
                }, "name", { value: "GetFlags" });

                /**
                 * Calls GetFlags.
                 * @function getFlags
                 * @memberof clutch.featureflag.v1.FeatureFlagAPI
                 * @instance
                 * @param {clutch.featureflag.v1.IGetFlagsRequest} request GetFlagsRequest message or plain object
                 * @returns {Promise<clutch.featureflag.v1.GetFlagsResponse>} Promise
                 * @variation 2
                 */

                return FeatureFlagAPI;
            })();

            v1.GetFlagsRequest = (function() {

                /**
                 * Properties of a GetFlagsRequest.
                 * @memberof clutch.featureflag.v1
                 * @interface IGetFlagsRequest
                 */

                /**
                 * Constructs a new GetFlagsRequest.
                 * @memberof clutch.featureflag.v1
                 * @classdesc Represents a GetFlagsRequest.
                 * @implements IGetFlagsRequest
                 * @constructor
                 * @param {clutch.featureflag.v1.IGetFlagsRequest=} [properties] Properties to set
                 */
                function GetFlagsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a GetFlagsRequest message.
                 * @function verify
                 * @memberof clutch.featureflag.v1.GetFlagsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetFlagsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a GetFlagsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.featureflag.v1.GetFlagsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.featureflag.v1.GetFlagsRequest} GetFlagsRequest
                 */
                GetFlagsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.featureflag.v1.GetFlagsRequest)
                        return object;
                    return new $root.clutch.featureflag.v1.GetFlagsRequest();
                };

                /**
                 * Creates a plain object from a GetFlagsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.featureflag.v1.GetFlagsRequest
                 * @static
                 * @param {clutch.featureflag.v1.GetFlagsRequest} message GetFlagsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetFlagsRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this GetFlagsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.featureflag.v1.GetFlagsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetFlagsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetFlagsRequest;
            })();

            v1.Flag = (function() {

                /**
                 * Properties of a Flag.
                 * @memberof clutch.featureflag.v1
                 * @interface IFlag
                 * @property {boolean|null} [booleanValue] Flag booleanValue
                 */

                /**
                 * Constructs a new Flag.
                 * @memberof clutch.featureflag.v1
                 * @classdesc Represents a Flag.
                 * @implements IFlag
                 * @constructor
                 * @param {clutch.featureflag.v1.IFlag=} [properties] Properties to set
                 */
                function Flag(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Flag booleanValue.
                 * @member {boolean|null|undefined} booleanValue
                 * @memberof clutch.featureflag.v1.Flag
                 * @instance
                 */
                Flag.prototype.booleanValue = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Flag type.
                 * @member {"booleanValue"|undefined} type
                 * @memberof clutch.featureflag.v1.Flag
                 * @instance
                 */
                Object.defineProperty(Flag.prototype, "type", {
                    get: $util.oneOfGetter($oneOfFields = ["booleanValue"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies a Flag message.
                 * @function verify
                 * @memberof clutch.featureflag.v1.Flag
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Flag.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.booleanValue != null && message.hasOwnProperty("booleanValue")) {
                        properties.type = 1;
                        if (typeof message.booleanValue !== "boolean")
                            return "booleanValue: boolean expected";
                    }
                    return null;
                };

                /**
                 * Creates a Flag message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.featureflag.v1.Flag
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.featureflag.v1.Flag} Flag
                 */
                Flag.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.featureflag.v1.Flag)
                        return object;
                    let message = new $root.clutch.featureflag.v1.Flag();
                    if (object.booleanValue != null)
                        message.booleanValue = Boolean(object.booleanValue);
                    return message;
                };

                /**
                 * Creates a plain object from a Flag message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.featureflag.v1.Flag
                 * @static
                 * @param {clutch.featureflag.v1.Flag} message Flag
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Flag.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.booleanValue != null && message.hasOwnProperty("booleanValue")) {
                        object.booleanValue = message.booleanValue;
                        if (options.oneofs)
                            object.type = "booleanValue";
                    }
                    return object;
                };

                /**
                 * Converts this Flag to JSON.
                 * @function toJSON
                 * @memberof clutch.featureflag.v1.Flag
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Flag.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Flag;
            })();

            v1.GetFlagsResponse = (function() {

                /**
                 * Properties of a GetFlagsResponse.
                 * @memberof clutch.featureflag.v1
                 * @interface IGetFlagsResponse
                 * @property {Object.<string,clutch.featureflag.v1.IFlag>|null} [flags] GetFlagsResponse flags
                 */

                /**
                 * Constructs a new GetFlagsResponse.
                 * @memberof clutch.featureflag.v1
                 * @classdesc Represents a GetFlagsResponse.
                 * @implements IGetFlagsResponse
                 * @constructor
                 * @param {clutch.featureflag.v1.IGetFlagsResponse=} [properties] Properties to set
                 */
                function GetFlagsResponse(properties) {
                    this.flags = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetFlagsResponse flags.
                 * @member {Object.<string,clutch.featureflag.v1.IFlag>} flags
                 * @memberof clutch.featureflag.v1.GetFlagsResponse
                 * @instance
                 */
                GetFlagsResponse.prototype.flags = $util.emptyObject;

                /**
                 * Verifies a GetFlagsResponse message.
                 * @function verify
                 * @memberof clutch.featureflag.v1.GetFlagsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetFlagsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.flags != null && message.hasOwnProperty("flags")) {
                        if (!$util.isObject(message.flags))
                            return "flags: object expected";
                        let key = Object.keys(message.flags);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.clutch.featureflag.v1.Flag.verify(message.flags[key[i]]);
                            if (error)
                                return "flags." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetFlagsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.featureflag.v1.GetFlagsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.featureflag.v1.GetFlagsResponse} GetFlagsResponse
                 */
                GetFlagsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.featureflag.v1.GetFlagsResponse)
                        return object;
                    let message = new $root.clutch.featureflag.v1.GetFlagsResponse();
                    if (object.flags) {
                        if (typeof object.flags !== "object")
                            throw TypeError(".clutch.featureflag.v1.GetFlagsResponse.flags: object expected");
                        message.flags = {};
                        for (let keys = Object.keys(object.flags), i = 0; i < keys.length; ++i) {
                            if (typeof object.flags[keys[i]] !== "object")
                                throw TypeError(".clutch.featureflag.v1.GetFlagsResponse.flags: object expected");
                            message.flags[keys[i]] = $root.clutch.featureflag.v1.Flag.fromObject(object.flags[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetFlagsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.featureflag.v1.GetFlagsResponse
                 * @static
                 * @param {clutch.featureflag.v1.GetFlagsResponse} message GetFlagsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetFlagsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.flags = {};
                    let keys2;
                    if (message.flags && (keys2 = Object.keys(message.flags)).length) {
                        object.flags = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.flags[keys2[j]] = $root.clutch.featureflag.v1.Flag.toObject(message.flags[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetFlagsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.featureflag.v1.GetFlagsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetFlagsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetFlagsResponse;
            })();

            return v1;
        })();

        return featureflag;
    })();

    clutch.healthcheck = (function() {

        /**
         * Namespace healthcheck.
         * @memberof clutch
         * @namespace
         */
        const healthcheck = {};

        healthcheck.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.healthcheck
             * @namespace
             */
            const v1 = {};

            v1.HealthcheckAPI = (function() {

                /**
                 * Constructs a new HealthcheckAPI service.
                 * @memberof clutch.healthcheck.v1
                 * @classdesc Represents a HealthcheckAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function HealthcheckAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (HealthcheckAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = HealthcheckAPI;

                /**
                 * Callback as used by {@link clutch.healthcheck.v1.HealthcheckAPI#healthcheck}.
                 * @memberof clutch.healthcheck.v1.HealthcheckAPI
                 * @typedef HealthcheckCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.healthcheck.v1.HealthcheckResponse} [response] HealthcheckResponse
                 */

                /**
                 * Calls Healthcheck.
                 * @function healthcheck
                 * @memberof clutch.healthcheck.v1.HealthcheckAPI
                 * @instance
                 * @param {clutch.healthcheck.v1.IHealthcheckRequest} request HealthcheckRequest message or plain object
                 * @param {clutch.healthcheck.v1.HealthcheckAPI.HealthcheckCallback} callback Node-style callback called with the error, if any, and HealthcheckResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(HealthcheckAPI.prototype.healthcheck = function healthcheck(request, callback) {
                    return this.rpcCall(healthcheck, $root.clutch.healthcheck.v1.HealthcheckRequest, $root.clutch.healthcheck.v1.HealthcheckResponse, request, callback);
                }, "name", { value: "Healthcheck" });

                /**
                 * Calls Healthcheck.
                 * @function healthcheck
                 * @memberof clutch.healthcheck.v1.HealthcheckAPI
                 * @instance
                 * @param {clutch.healthcheck.v1.IHealthcheckRequest} request HealthcheckRequest message or plain object
                 * @returns {Promise<clutch.healthcheck.v1.HealthcheckResponse>} Promise
                 * @variation 2
                 */

                return HealthcheckAPI;
            })();

            v1.HealthcheckRequest = (function() {

                /**
                 * Properties of a HealthcheckRequest.
                 * @memberof clutch.healthcheck.v1
                 * @interface IHealthcheckRequest
                 */

                /**
                 * Constructs a new HealthcheckRequest.
                 * @memberof clutch.healthcheck.v1
                 * @classdesc Represents a HealthcheckRequest.
                 * @implements IHealthcheckRequest
                 * @constructor
                 * @param {clutch.healthcheck.v1.IHealthcheckRequest=} [properties] Properties to set
                 */
                function HealthcheckRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a HealthcheckRequest message.
                 * @function verify
                 * @memberof clutch.healthcheck.v1.HealthcheckRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HealthcheckRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a HealthcheckRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.healthcheck.v1.HealthcheckRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.healthcheck.v1.HealthcheckRequest} HealthcheckRequest
                 */
                HealthcheckRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.healthcheck.v1.HealthcheckRequest)
                        return object;
                    return new $root.clutch.healthcheck.v1.HealthcheckRequest();
                };

                /**
                 * Creates a plain object from a HealthcheckRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.healthcheck.v1.HealthcheckRequest
                 * @static
                 * @param {clutch.healthcheck.v1.HealthcheckRequest} message HealthcheckRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HealthcheckRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this HealthcheckRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.healthcheck.v1.HealthcheckRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HealthcheckRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return HealthcheckRequest;
            })();

            v1.HealthcheckResponse = (function() {

                /**
                 * Properties of a HealthcheckResponse.
                 * @memberof clutch.healthcheck.v1
                 * @interface IHealthcheckResponse
                 */

                /**
                 * Constructs a new HealthcheckResponse.
                 * @memberof clutch.healthcheck.v1
                 * @classdesc Represents a HealthcheckResponse.
                 * @implements IHealthcheckResponse
                 * @constructor
                 * @param {clutch.healthcheck.v1.IHealthcheckResponse=} [properties] Properties to set
                 */
                function HealthcheckResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a HealthcheckResponse message.
                 * @function verify
                 * @memberof clutch.healthcheck.v1.HealthcheckResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HealthcheckResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a HealthcheckResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.healthcheck.v1.HealthcheckResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.healthcheck.v1.HealthcheckResponse} HealthcheckResponse
                 */
                HealthcheckResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.healthcheck.v1.HealthcheckResponse)
                        return object;
                    return new $root.clutch.healthcheck.v1.HealthcheckResponse();
                };

                /**
                 * Creates a plain object from a HealthcheckResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.healthcheck.v1.HealthcheckResponse
                 * @static
                 * @param {clutch.healthcheck.v1.HealthcheckResponse} message HealthcheckResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HealthcheckResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this HealthcheckResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.healthcheck.v1.HealthcheckResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HealthcheckResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return HealthcheckResponse;
            })();

            return v1;
        })();

        return healthcheck;
    })();

    clutch.k8s = (function() {

        /**
         * Namespace k8s.
         * @memberof clutch
         * @namespace
         */
        const k8s = {};

        k8s.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.k8s
             * @namespace
             */
            const v1 = {};

            v1.K8sAPI = (function() {

                /**
                 * Constructs a new K8sAPI service.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a K8sAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function K8sAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (K8sAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = K8sAPI;

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#describePod}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DescribePodCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DescribePodResponse} [response] DescribePodResponse
                 */

                /**
                 * Calls DescribePod.
                 * @function describePod
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribePodRequest} request DescribePodRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DescribePodCallback} callback Node-style callback called with the error, if any, and DescribePodResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.describePod = function describePod(request, callback) {
                    return this.rpcCall(describePod, $root.clutch.k8s.v1.DescribePodRequest, $root.clutch.k8s.v1.DescribePodResponse, request, callback);
                }, "name", { value: "DescribePod" });

                /**
                 * Calls DescribePod.
                 * @function describePod
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribePodRequest} request DescribePodRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DescribePodResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#listPods}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef ListPodsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.ListPodsResponse} [response] ListPodsResponse
                 */

                /**
                 * Calls ListPods.
                 * @function listPods
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListPodsRequest} request ListPodsRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.ListPodsCallback} callback Node-style callback called with the error, if any, and ListPodsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.listPods = function listPods(request, callback) {
                    return this.rpcCall(listPods, $root.clutch.k8s.v1.ListPodsRequest, $root.clutch.k8s.v1.ListPodsResponse, request, callback);
                }, "name", { value: "ListPods" });

                /**
                 * Calls ListPods.
                 * @function listPods
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListPodsRequest} request ListPodsRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.ListPodsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#deletePod}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DeletePodCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DeletePodResponse} [response] DeletePodResponse
                 */

                /**
                 * Calls DeletePod.
                 * @function deletePod
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeletePodRequest} request DeletePodRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DeletePodCallback} callback Node-style callback called with the error, if any, and DeletePodResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.deletePod = function deletePod(request, callback) {
                    return this.rpcCall(deletePod, $root.clutch.k8s.v1.DeletePodRequest, $root.clutch.k8s.v1.DeletePodResponse, request, callback);
                }, "name", { value: "DeletePod" });

                /**
                 * Calls DeletePod.
                 * @function deletePod
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeletePodRequest} request DeletePodRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DeletePodResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#updatePod}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef UpdatePodCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.UpdatePodResponse} [response] UpdatePodResponse
                 */

                /**
                 * Calls UpdatePod.
                 * @function updatePod
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IUpdatePodRequest} request UpdatePodRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.UpdatePodCallback} callback Node-style callback called with the error, if any, and UpdatePodResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.updatePod = function updatePod(request, callback) {
                    return this.rpcCall(updatePod, $root.clutch.k8s.v1.UpdatePodRequest, $root.clutch.k8s.v1.UpdatePodResponse, request, callback);
                }, "name", { value: "UpdatePod" });

                /**
                 * Calls UpdatePod.
                 * @function updatePod
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IUpdatePodRequest} request UpdatePodRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.UpdatePodResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#resizeHPA}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef ResizeHPACallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.ResizeHPAResponse} [response] ResizeHPAResponse
                 */

                /**
                 * Calls ResizeHPA.
                 * @function resizeHPA
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IResizeHPARequest} request ResizeHPARequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.ResizeHPACallback} callback Node-style callback called with the error, if any, and ResizeHPAResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.resizeHPA = function resizeHPA(request, callback) {
                    return this.rpcCall(resizeHPA, $root.clutch.k8s.v1.ResizeHPARequest, $root.clutch.k8s.v1.ResizeHPAResponse, request, callback);
                }, "name", { value: "ResizeHPA" });

                /**
                 * Calls ResizeHPA.
                 * @function resizeHPA
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IResizeHPARequest} request ResizeHPARequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.ResizeHPAResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#deleteHPA}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DeleteHPACallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DeleteHPAResponse} [response] DeleteHPAResponse
                 */

                /**
                 * Calls DeleteHPA.
                 * @function deleteHPA
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeleteHPARequest} request DeleteHPARequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DeleteHPACallback} callback Node-style callback called with the error, if any, and DeleteHPAResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.deleteHPA = function deleteHPA(request, callback) {
                    return this.rpcCall(deleteHPA, $root.clutch.k8s.v1.DeleteHPARequest, $root.clutch.k8s.v1.DeleteHPAResponse, request, callback);
                }, "name", { value: "DeleteHPA" });

                /**
                 * Calls DeleteHPA.
                 * @function deleteHPA
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeleteHPARequest} request DeleteHPARequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DeleteHPAResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#describeDeployment}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DescribeDeploymentCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DescribeDeploymentResponse} [response] DescribeDeploymentResponse
                 */

                /**
                 * Calls DescribeDeployment.
                 * @function describeDeployment
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribeDeploymentRequest} request DescribeDeploymentRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DescribeDeploymentCallback} callback Node-style callback called with the error, if any, and DescribeDeploymentResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.describeDeployment = function describeDeployment(request, callback) {
                    return this.rpcCall(describeDeployment, $root.clutch.k8s.v1.DescribeDeploymentRequest, $root.clutch.k8s.v1.DescribeDeploymentResponse, request, callback);
                }, "name", { value: "DescribeDeployment" });

                /**
                 * Calls DescribeDeployment.
                 * @function describeDeployment
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribeDeploymentRequest} request DescribeDeploymentRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DescribeDeploymentResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#listDeployments}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef ListDeploymentsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.ListDeploymentsResponse} [response] ListDeploymentsResponse
                 */

                /**
                 * Calls ListDeployments.
                 * @function listDeployments
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListDeploymentsRequest} request ListDeploymentsRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.ListDeploymentsCallback} callback Node-style callback called with the error, if any, and ListDeploymentsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.listDeployments = function listDeployments(request, callback) {
                    return this.rpcCall(listDeployments, $root.clutch.k8s.v1.ListDeploymentsRequest, $root.clutch.k8s.v1.ListDeploymentsResponse, request, callback);
                }, "name", { value: "ListDeployments" });

                /**
                 * Calls ListDeployments.
                 * @function listDeployments
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListDeploymentsRequest} request ListDeploymentsRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.ListDeploymentsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#updateDeployment}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef UpdateDeploymentCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.UpdateDeploymentResponse} [response] UpdateDeploymentResponse
                 */

                /**
                 * Calls UpdateDeployment.
                 * @function updateDeployment
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IUpdateDeploymentRequest} request UpdateDeploymentRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.UpdateDeploymentCallback} callback Node-style callback called with the error, if any, and UpdateDeploymentResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.updateDeployment = function updateDeployment(request, callback) {
                    return this.rpcCall(updateDeployment, $root.clutch.k8s.v1.UpdateDeploymentRequest, $root.clutch.k8s.v1.UpdateDeploymentResponse, request, callback);
                }, "name", { value: "UpdateDeployment" });

                /**
                 * Calls UpdateDeployment.
                 * @function updateDeployment
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IUpdateDeploymentRequest} request UpdateDeploymentRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.UpdateDeploymentResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#deleteDeployment}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DeleteDeploymentCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DeleteDeploymentResponse} [response] DeleteDeploymentResponse
                 */

                /**
                 * Calls DeleteDeployment.
                 * @function deleteDeployment
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeleteDeploymentRequest} request DeleteDeploymentRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DeleteDeploymentCallback} callback Node-style callback called with the error, if any, and DeleteDeploymentResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.deleteDeployment = function deleteDeployment(request, callback) {
                    return this.rpcCall(deleteDeployment, $root.clutch.k8s.v1.DeleteDeploymentRequest, $root.clutch.k8s.v1.DeleteDeploymentResponse, request, callback);
                }, "name", { value: "DeleteDeployment" });

                /**
                 * Calls DeleteDeployment.
                 * @function deleteDeployment
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeleteDeploymentRequest} request DeleteDeploymentRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DeleteDeploymentResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#describeService}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DescribeServiceCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DescribeServiceResponse} [response] DescribeServiceResponse
                 */

                /**
                 * Calls DescribeService.
                 * @function describeService
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribeServiceRequest} request DescribeServiceRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DescribeServiceCallback} callback Node-style callback called with the error, if any, and DescribeServiceResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.describeService = function describeService(request, callback) {
                    return this.rpcCall(describeService, $root.clutch.k8s.v1.DescribeServiceRequest, $root.clutch.k8s.v1.DescribeServiceResponse, request, callback);
                }, "name", { value: "DescribeService" });

                /**
                 * Calls DescribeService.
                 * @function describeService
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribeServiceRequest} request DescribeServiceRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DescribeServiceResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#listServices}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef ListServicesCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.ListServicesResponse} [response] ListServicesResponse
                 */

                /**
                 * Calls ListServices.
                 * @function listServices
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListServicesRequest} request ListServicesRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.ListServicesCallback} callback Node-style callback called with the error, if any, and ListServicesResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.listServices = function listServices(request, callback) {
                    return this.rpcCall(listServices, $root.clutch.k8s.v1.ListServicesRequest, $root.clutch.k8s.v1.ListServicesResponse, request, callback);
                }, "name", { value: "ListServices" });

                /**
                 * Calls ListServices.
                 * @function listServices
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListServicesRequest} request ListServicesRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.ListServicesResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#deleteService}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DeleteServiceCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DeleteServiceResponse} [response] DeleteServiceResponse
                 */

                /**
                 * Calls DeleteService.
                 * @function deleteService
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeleteServiceRequest} request DeleteServiceRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DeleteServiceCallback} callback Node-style callback called with the error, if any, and DeleteServiceResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.deleteService = function deleteService(request, callback) {
                    return this.rpcCall(deleteService, $root.clutch.k8s.v1.DeleteServiceRequest, $root.clutch.k8s.v1.DeleteServiceResponse, request, callback);
                }, "name", { value: "DeleteService" });

                /**
                 * Calls DeleteService.
                 * @function deleteService
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeleteServiceRequest} request DeleteServiceRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DeleteServiceResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#describeStatefulSet}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DescribeStatefulSetCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DescribeStatefulSetResponse} [response] DescribeStatefulSetResponse
                 */

                /**
                 * Calls DescribeStatefulSet.
                 * @function describeStatefulSet
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribeStatefulSetRequest} request DescribeStatefulSetRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DescribeStatefulSetCallback} callback Node-style callback called with the error, if any, and DescribeStatefulSetResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.describeStatefulSet = function describeStatefulSet(request, callback) {
                    return this.rpcCall(describeStatefulSet, $root.clutch.k8s.v1.DescribeStatefulSetRequest, $root.clutch.k8s.v1.DescribeStatefulSetResponse, request, callback);
                }, "name", { value: "DescribeStatefulSet" });

                /**
                 * Calls DescribeStatefulSet.
                 * @function describeStatefulSet
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribeStatefulSetRequest} request DescribeStatefulSetRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DescribeStatefulSetResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#listStatefulSets}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef ListStatefulSetsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.ListStatefulSetsResponse} [response] ListStatefulSetsResponse
                 */

                /**
                 * Calls ListStatefulSets.
                 * @function listStatefulSets
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListStatefulSetsRequest} request ListStatefulSetsRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.ListStatefulSetsCallback} callback Node-style callback called with the error, if any, and ListStatefulSetsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.listStatefulSets = function listStatefulSets(request, callback) {
                    return this.rpcCall(listStatefulSets, $root.clutch.k8s.v1.ListStatefulSetsRequest, $root.clutch.k8s.v1.ListStatefulSetsResponse, request, callback);
                }, "name", { value: "ListStatefulSets" });

                /**
                 * Calls ListStatefulSets.
                 * @function listStatefulSets
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListStatefulSetsRequest} request ListStatefulSetsRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.ListStatefulSetsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#updateStatefulSet}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef UpdateStatefulSetCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.UpdateStatefulSetResponse} [response] UpdateStatefulSetResponse
                 */

                /**
                 * Calls UpdateStatefulSet.
                 * @function updateStatefulSet
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IUpdateStatefulSetRequest} request UpdateStatefulSetRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.UpdateStatefulSetCallback} callback Node-style callback called with the error, if any, and UpdateStatefulSetResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.updateStatefulSet = function updateStatefulSet(request, callback) {
                    return this.rpcCall(updateStatefulSet, $root.clutch.k8s.v1.UpdateStatefulSetRequest, $root.clutch.k8s.v1.UpdateStatefulSetResponse, request, callback);
                }, "name", { value: "UpdateStatefulSet" });

                /**
                 * Calls UpdateStatefulSet.
                 * @function updateStatefulSet
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IUpdateStatefulSetRequest} request UpdateStatefulSetRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.UpdateStatefulSetResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#deleteStatefulSet}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DeleteStatefulSetCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DeleteStatefulSetResponse} [response] DeleteStatefulSetResponse
                 */

                /**
                 * Calls DeleteStatefulSet.
                 * @function deleteStatefulSet
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeleteStatefulSetRequest} request DeleteStatefulSetRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DeleteStatefulSetCallback} callback Node-style callback called with the error, if any, and DeleteStatefulSetResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.deleteStatefulSet = function deleteStatefulSet(request, callback) {
                    return this.rpcCall(deleteStatefulSet, $root.clutch.k8s.v1.DeleteStatefulSetRequest, $root.clutch.k8s.v1.DeleteStatefulSetResponse, request, callback);
                }, "name", { value: "DeleteStatefulSet" });

                /**
                 * Calls DeleteStatefulSet.
                 * @function deleteStatefulSet
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeleteStatefulSetRequest} request DeleteStatefulSetRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DeleteStatefulSetResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#describeCronJob}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DescribeCronJobCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DescribeCronJobResponse} [response] DescribeCronJobResponse
                 */

                /**
                 * Calls DescribeCronJob.
                 * @function describeCronJob
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribeCronJobRequest} request DescribeCronJobRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DescribeCronJobCallback} callback Node-style callback called with the error, if any, and DescribeCronJobResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.describeCronJob = function describeCronJob(request, callback) {
                    return this.rpcCall(describeCronJob, $root.clutch.k8s.v1.DescribeCronJobRequest, $root.clutch.k8s.v1.DescribeCronJobResponse, request, callback);
                }, "name", { value: "DescribeCronJob" });

                /**
                 * Calls DescribeCronJob.
                 * @function describeCronJob
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribeCronJobRequest} request DescribeCronJobRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DescribeCronJobResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#listCronJobs}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef ListCronJobsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.ListCronJobsResponse} [response] ListCronJobsResponse
                 */

                /**
                 * Calls ListCronJobs.
                 * @function listCronJobs
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListCronJobsRequest} request ListCronJobsRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.ListCronJobsCallback} callback Node-style callback called with the error, if any, and ListCronJobsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.listCronJobs = function listCronJobs(request, callback) {
                    return this.rpcCall(listCronJobs, $root.clutch.k8s.v1.ListCronJobsRequest, $root.clutch.k8s.v1.ListCronJobsResponse, request, callback);
                }, "name", { value: "ListCronJobs" });

                /**
                 * Calls ListCronJobs.
                 * @function listCronJobs
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListCronJobsRequest} request ListCronJobsRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.ListCronJobsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#deleteCronJob}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DeleteCronJobCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DeleteCronJobResponse} [response] DeleteCronJobResponse
                 */

                /**
                 * Calls DeleteCronJob.
                 * @function deleteCronJob
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeleteCronJobRequest} request DeleteCronJobRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DeleteCronJobCallback} callback Node-style callback called with the error, if any, and DeleteCronJobResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.deleteCronJob = function deleteCronJob(request, callback) {
                    return this.rpcCall(deleteCronJob, $root.clutch.k8s.v1.DeleteCronJobRequest, $root.clutch.k8s.v1.DeleteCronJobResponse, request, callback);
                }, "name", { value: "DeleteCronJob" });

                /**
                 * Calls DeleteCronJob.
                 * @function deleteCronJob
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeleteCronJobRequest} request DeleteCronJobRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DeleteCronJobResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#listConfigMaps}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef ListConfigMapsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.ListConfigMapsResponse} [response] ListConfigMapsResponse
                 */

                /**
                 * Calls ListConfigMaps.
                 * @function listConfigMaps
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListConfigMapsRequest} request ListConfigMapsRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.ListConfigMapsCallback} callback Node-style callback called with the error, if any, and ListConfigMapsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.listConfigMaps = function listConfigMaps(request, callback) {
                    return this.rpcCall(listConfigMaps, $root.clutch.k8s.v1.ListConfigMapsRequest, $root.clutch.k8s.v1.ListConfigMapsResponse, request, callback);
                }, "name", { value: "ListConfigMaps" });

                /**
                 * Calls ListConfigMaps.
                 * @function listConfigMaps
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListConfigMapsRequest} request ListConfigMapsRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.ListConfigMapsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#describeConfigMap}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DescribeConfigMapCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DescribeConfigMapResponse} [response] DescribeConfigMapResponse
                 */

                /**
                 * Calls DescribeConfigMap.
                 * @function describeConfigMap
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribeConfigMapRequest} request DescribeConfigMapRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DescribeConfigMapCallback} callback Node-style callback called with the error, if any, and DescribeConfigMapResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.describeConfigMap = function describeConfigMap(request, callback) {
                    return this.rpcCall(describeConfigMap, $root.clutch.k8s.v1.DescribeConfigMapRequest, $root.clutch.k8s.v1.DescribeConfigMapResponse, request, callback);
                }, "name", { value: "DescribeConfigMap" });

                /**
                 * Calls DescribeConfigMap.
                 * @function describeConfigMap
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribeConfigMapRequest} request DescribeConfigMapRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DescribeConfigMapResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#deleteConfigMap}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DeleteConfigMapCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DeleteConfigMapResponse} [response] DeleteConfigMapResponse
                 */

                /**
                 * Calls DeleteConfigMap.
                 * @function deleteConfigMap
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeleteConfigMapRequest} request DeleteConfigMapRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DeleteConfigMapCallback} callback Node-style callback called with the error, if any, and DeleteConfigMapResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.deleteConfigMap = function deleteConfigMap(request, callback) {
                    return this.rpcCall(deleteConfigMap, $root.clutch.k8s.v1.DeleteConfigMapRequest, $root.clutch.k8s.v1.DeleteConfigMapResponse, request, callback);
                }, "name", { value: "DeleteConfigMap" });

                /**
                 * Calls DeleteConfigMap.
                 * @function deleteConfigMap
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeleteConfigMapRequest} request DeleteConfigMapRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DeleteConfigMapResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#listJobs}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef ListJobsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.ListJobsResponse} [response] ListJobsResponse
                 */

                /**
                 * Calls ListJobs.
                 * @function listJobs
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListJobsRequest} request ListJobsRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.ListJobsCallback} callback Node-style callback called with the error, if any, and ListJobsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.listJobs = function listJobs(request, callback) {
                    return this.rpcCall(listJobs, $root.clutch.k8s.v1.ListJobsRequest, $root.clutch.k8s.v1.ListJobsResponse, request, callback);
                }, "name", { value: "ListJobs" });

                /**
                 * Calls ListJobs.
                 * @function listJobs
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListJobsRequest} request ListJobsRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.ListJobsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#deleteJob}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DeleteJobCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DeleteJobResponse} [response] DeleteJobResponse
                 */

                /**
                 * Calls DeleteJob.
                 * @function deleteJob
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeleteJobRequest} request DeleteJobRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DeleteJobCallback} callback Node-style callback called with the error, if any, and DeleteJobResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.deleteJob = function deleteJob(request, callback) {
                    return this.rpcCall(deleteJob, $root.clutch.k8s.v1.DeleteJobRequest, $root.clutch.k8s.v1.DeleteJobResponse, request, callback);
                }, "name", { value: "DeleteJob" });

                /**
                 * Calls DeleteJob.
                 * @function deleteJob
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeleteJobRequest} request DeleteJobRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DeleteJobResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#createJob}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef CreateJobCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.CreateJobResponse} [response] CreateJobResponse
                 */

                /**
                 * Calls CreateJob.
                 * @function createJob
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.ICreateJobRequest} request CreateJobRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.CreateJobCallback} callback Node-style callback called with the error, if any, and CreateJobResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.createJob = function createJob(request, callback) {
                    return this.rpcCall(createJob, $root.clutch.k8s.v1.CreateJobRequest, $root.clutch.k8s.v1.CreateJobResponse, request, callback);
                }, "name", { value: "CreateJob" });

                /**
                 * Calls CreateJob.
                 * @function createJob
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.ICreateJobRequest} request CreateJobRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.CreateJobResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#describeNamespace}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DescribeNamespaceCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DescribeNamespaceResponse} [response] DescribeNamespaceResponse
                 */

                /**
                 * Calls DescribeNamespace.
                 * @function describeNamespace
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribeNamespaceRequest} request DescribeNamespaceRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DescribeNamespaceCallback} callback Node-style callback called with the error, if any, and DescribeNamespaceResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.describeNamespace = function describeNamespace(request, callback) {
                    return this.rpcCall(describeNamespace, $root.clutch.k8s.v1.DescribeNamespaceRequest, $root.clutch.k8s.v1.DescribeNamespaceResponse, request, callback);
                }, "name", { value: "DescribeNamespace" });

                /**
                 * Calls DescribeNamespace.
                 * @function describeNamespace
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribeNamespaceRequest} request DescribeNamespaceRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DescribeNamespaceResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#listEvents}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef ListEventsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.ListEventsResponse} [response] ListEventsResponse
                 */

                /**
                 * Calls ListEvents.
                 * @function listEvents
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListEventsRequest} request ListEventsRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.ListEventsCallback} callback Node-style callback called with the error, if any, and ListEventsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.listEvents = function listEvents(request, callback) {
                    return this.rpcCall(listEvents, $root.clutch.k8s.v1.ListEventsRequest, $root.clutch.k8s.v1.ListEventsResponse, request, callback);
                }, "name", { value: "ListEvents" });

                /**
                 * Calls ListEvents.
                 * @function listEvents
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListEventsRequest} request ListEventsRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.ListEventsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#describeNode}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DescribeNodeCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DescribeNodeResponse} [response] DescribeNodeResponse
                 */

                /**
                 * Calls DescribeNode.
                 * @function describeNode
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribeNodeRequest} request DescribeNodeRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DescribeNodeCallback} callback Node-style callback called with the error, if any, and DescribeNodeResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.describeNode = function describeNode(request, callback) {
                    return this.rpcCall(describeNode, $root.clutch.k8s.v1.DescribeNodeRequest, $root.clutch.k8s.v1.DescribeNodeResponse, request, callback);
                }, "name", { value: "DescribeNode" });

                /**
                 * Calls DescribeNode.
                 * @function describeNode
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribeNodeRequest} request DescribeNodeRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DescribeNodeResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#updateNode}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef UpdateNodeCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.UpdateNodeResponse} [response] UpdateNodeResponse
                 */

                /**
                 * Calls UpdateNode.
                 * @function updateNode
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IUpdateNodeRequest} request UpdateNodeRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.UpdateNodeCallback} callback Node-style callback called with the error, if any, and UpdateNodeResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.updateNode = function updateNode(request, callback) {
                    return this.rpcCall(updateNode, $root.clutch.k8s.v1.UpdateNodeRequest, $root.clutch.k8s.v1.UpdateNodeResponse, request, callback);
                }, "name", { value: "UpdateNode" });

                /**
                 * Calls UpdateNode.
                 * @function updateNode
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IUpdateNodeRequest} request UpdateNodeRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.UpdateNodeResponse>} Promise
                 * @variation 2
                 */

                return K8sAPI;
            })();

            v1.DescribePodRequest = (function() {

                /**
                 * Properties of a DescribePodRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribePodRequest
                 * @property {string|null} [clientset] DescribePodRequest clientset
                 * @property {string|null} [cluster] DescribePodRequest cluster
                 * @property {string|null} [namespace] DescribePodRequest namespace
                 * @property {string|null} [name] DescribePodRequest name
                 */

                /**
                 * Constructs a new DescribePodRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribePodRequest.
                 * @implements IDescribePodRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribePodRequest=} [properties] Properties to set
                 */
                function DescribePodRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribePodRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @instance
                 */
                DescribePodRequest.prototype.clientset = "";

                /**
                 * DescribePodRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @instance
                 */
                DescribePodRequest.prototype.cluster = "";

                /**
                 * DescribePodRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @instance
                 */
                DescribePodRequest.prototype.namespace = "";

                /**
                 * DescribePodRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @instance
                 */
                DescribePodRequest.prototype.name = "";

                /**
                 * Verifies a DescribePodRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribePodRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DescribePodRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribePodRequest} DescribePodRequest
                 */
                DescribePodRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribePodRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribePodRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DescribePodRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @static
                 * @param {clutch.k8s.v1.DescribePodRequest} message DescribePodRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribePodRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DescribePodRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribePodRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribePodRequest;
            })();

            v1.DescribePodResponse = (function() {

                /**
                 * Properties of a DescribePodResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribePodResponse
                 * @property {clutch.k8s.v1.IPod|null} [pod] DescribePodResponse pod
                 */

                /**
                 * Constructs a new DescribePodResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribePodResponse.
                 * @implements IDescribePodResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribePodResponse=} [properties] Properties to set
                 */
                function DescribePodResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribePodResponse pod.
                 * @member {clutch.k8s.v1.IPod|null|undefined} pod
                 * @memberof clutch.k8s.v1.DescribePodResponse
                 * @instance
                 */
                DescribePodResponse.prototype.pod = null;

                /**
                 * Verifies a DescribePodResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribePodResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribePodResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pod != null && message.hasOwnProperty("pod")) {
                        let error = $root.clutch.k8s.v1.Pod.verify(message.pod);
                        if (error)
                            return "pod." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DescribePodResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribePodResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribePodResponse} DescribePodResponse
                 */
                DescribePodResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribePodResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribePodResponse();
                    if (object.pod != null) {
                        if (typeof object.pod !== "object")
                            throw TypeError(".clutch.k8s.v1.DescribePodResponse.pod: object expected");
                        message.pod = $root.clutch.k8s.v1.Pod.fromObject(object.pod);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DescribePodResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribePodResponse
                 * @static
                 * @param {clutch.k8s.v1.DescribePodResponse} message DescribePodResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribePodResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.pod = null;
                    if (message.pod != null && message.hasOwnProperty("pod"))
                        object.pod = $root.clutch.k8s.v1.Pod.toObject(message.pod, options);
                    return object;
                };

                /**
                 * Converts this DescribePodResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribePodResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribePodResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribePodResponse;
            })();

            v1.Container = (function() {

                /**
                 * Properties of a Container.
                 * @memberof clutch.k8s.v1
                 * @interface IContainer
                 * @property {string|null} [name] Container name
                 * @property {string|null} [image] Container image
                 * @property {clutch.k8s.v1.Container.State|null} [state] Container state
                 * @property {boolean|null} [ready] Container ready
                 * @property {number|null} [restartCount] Container restartCount
                 * @property {clutch.k8s.v1.IStateWaiting|null} [stateWaiting] Container stateWaiting
                 * @property {clutch.k8s.v1.IStateRunning|null} [stateRunning] Container stateRunning
                 * @property {clutch.k8s.v1.IStateTerminated|null} [stateTerminated] Container stateTerminated
                 */

                /**
                 * Constructs a new Container.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a Container.
                 * @implements IContainer
                 * @constructor
                 * @param {clutch.k8s.v1.IContainer=} [properties] Properties to set
                 */
                function Container(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Container name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 */
                Container.prototype.name = "";

                /**
                 * Container image.
                 * @member {string} image
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 */
                Container.prototype.image = "";

                /**
                 * Container state.
                 * @member {clutch.k8s.v1.Container.State} state
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 */
                Container.prototype.state = 0;

                /**
                 * Container ready.
                 * @member {boolean} ready
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 */
                Container.prototype.ready = false;

                /**
                 * Container restartCount.
                 * @member {number} restartCount
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 */
                Container.prototype.restartCount = 0;

                /**
                 * Container stateWaiting.
                 * @member {clutch.k8s.v1.IStateWaiting|null|undefined} stateWaiting
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 */
                Container.prototype.stateWaiting = null;

                /**
                 * Container stateRunning.
                 * @member {clutch.k8s.v1.IStateRunning|null|undefined} stateRunning
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 */
                Container.prototype.stateRunning = null;

                /**
                 * Container stateTerminated.
                 * @member {clutch.k8s.v1.IStateTerminated|null|undefined} stateTerminated
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 */
                Container.prototype.stateTerminated = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Container stateDetails.
                 * @member {"stateWaiting"|"stateRunning"|"stateTerminated"|undefined} stateDetails
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 */
                Object.defineProperty(Container.prototype, "stateDetails", {
                    get: $util.oneOfGetter($oneOfFields = ["stateWaiting", "stateRunning", "stateTerminated"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies a Container message.
                 * @function verify
                 * @memberof clutch.k8s.v1.Container
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Container.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.image != null && message.hasOwnProperty("image"))
                        if (!$util.isString(message.image))
                            return "image: string expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.ready != null && message.hasOwnProperty("ready"))
                        if (typeof message.ready !== "boolean")
                            return "ready: boolean expected";
                    if (message.restartCount != null && message.hasOwnProperty("restartCount"))
                        if (!$util.isInteger(message.restartCount))
                            return "restartCount: integer expected";
                    if (message.stateWaiting != null && message.hasOwnProperty("stateWaiting")) {
                        properties.stateDetails = 1;
                        {
                            let error = $root.clutch.k8s.v1.StateWaiting.verify(message.stateWaiting);
                            if (error)
                                return "stateWaiting." + error;
                        }
                    }
                    if (message.stateRunning != null && message.hasOwnProperty("stateRunning")) {
                        if (properties.stateDetails === 1)
                            return "stateDetails: multiple values";
                        properties.stateDetails = 1;
                        {
                            let error = $root.clutch.k8s.v1.StateRunning.verify(message.stateRunning);
                            if (error)
                                return "stateRunning." + error;
                        }
                    }
                    if (message.stateTerminated != null && message.hasOwnProperty("stateTerminated")) {
                        if (properties.stateDetails === 1)
                            return "stateDetails: multiple values";
                        properties.stateDetails = 1;
                        {
                            let error = $root.clutch.k8s.v1.StateTerminated.verify(message.stateTerminated);
                            if (error)
                                return "stateTerminated." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Container message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.Container
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.Container} Container
                 */
                Container.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.Container)
                        return object;
                    let message = new $root.clutch.k8s.v1.Container();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.image != null)
                        message.image = String(object.image);
                    switch (object.state) {
                    case "UNSPECIFIED":
                    case 0:
                        message.state = 0;
                        break;
                    case "UNKNOWN":
                    case 1:
                        message.state = 1;
                        break;
                    case "TERMINATED":
                    case 2:
                        message.state = 2;
                        break;
                    case "RUNNING":
                    case 3:
                        message.state = 3;
                        break;
                    case "WAITING":
                    case 4:
                        message.state = 4;
                        break;
                    }
                    if (object.ready != null)
                        message.ready = Boolean(object.ready);
                    if (object.restartCount != null)
                        message.restartCount = object.restartCount | 0;
                    if (object.stateWaiting != null) {
                        if (typeof object.stateWaiting !== "object")
                            throw TypeError(".clutch.k8s.v1.Container.stateWaiting: object expected");
                        message.stateWaiting = $root.clutch.k8s.v1.StateWaiting.fromObject(object.stateWaiting);
                    }
                    if (object.stateRunning != null) {
                        if (typeof object.stateRunning !== "object")
                            throw TypeError(".clutch.k8s.v1.Container.stateRunning: object expected");
                        message.stateRunning = $root.clutch.k8s.v1.StateRunning.fromObject(object.stateRunning);
                    }
                    if (object.stateTerminated != null) {
                        if (typeof object.stateTerminated !== "object")
                            throw TypeError(".clutch.k8s.v1.Container.stateTerminated: object expected");
                        message.stateTerminated = $root.clutch.k8s.v1.StateTerminated.fromObject(object.stateTerminated);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Container message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.Container
                 * @static
                 * @param {clutch.k8s.v1.Container} message Container
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Container.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.image = "";
                        object.state = options.enums === String ? "UNSPECIFIED" : 0;
                        object.ready = false;
                        object.restartCount = 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.image != null && message.hasOwnProperty("image"))
                        object.image = message.image;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = options.enums === String ? $root.clutch.k8s.v1.Container.State[message.state] : message.state;
                    if (message.ready != null && message.hasOwnProperty("ready"))
                        object.ready = message.ready;
                    if (message.restartCount != null && message.hasOwnProperty("restartCount"))
                        object.restartCount = message.restartCount;
                    if (message.stateWaiting != null && message.hasOwnProperty("stateWaiting")) {
                        object.stateWaiting = $root.clutch.k8s.v1.StateWaiting.toObject(message.stateWaiting, options);
                        if (options.oneofs)
                            object.stateDetails = "stateWaiting";
                    }
                    if (message.stateRunning != null && message.hasOwnProperty("stateRunning")) {
                        object.stateRunning = $root.clutch.k8s.v1.StateRunning.toObject(message.stateRunning, options);
                        if (options.oneofs)
                            object.stateDetails = "stateRunning";
                    }
                    if (message.stateTerminated != null && message.hasOwnProperty("stateTerminated")) {
                        object.stateTerminated = $root.clutch.k8s.v1.StateTerminated.toObject(message.stateTerminated, options);
                        if (options.oneofs)
                            object.stateDetails = "stateTerminated";
                    }
                    return object;
                };

                /**
                 * Converts this Container to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Container.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * State enum.
                 * @name clutch.k8s.v1.Container.State
                 * @enum {number}
                 * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                 * @property {number} UNKNOWN=1 UNKNOWN value
                 * @property {number} TERMINATED=2 TERMINATED value
                 * @property {number} RUNNING=3 RUNNING value
                 * @property {number} WAITING=4 WAITING value
                 */
                Container.State = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNSPECIFIED"] = 0;
                    values[valuesById[1] = "UNKNOWN"] = 1;
                    values[valuesById[2] = "TERMINATED"] = 2;
                    values[valuesById[3] = "RUNNING"] = 3;
                    values[valuesById[4] = "WAITING"] = 4;
                    return values;
                })();

                return Container;
            })();

            v1.StateWaiting = (function() {

                /**
                 * Properties of a StateWaiting.
                 * @memberof clutch.k8s.v1
                 * @interface IStateWaiting
                 * @property {string|null} [reason] StateWaiting reason
                 * @property {string|null} [message] StateWaiting message
                 */

                /**
                 * Constructs a new StateWaiting.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a StateWaiting.
                 * @implements IStateWaiting
                 * @constructor
                 * @param {clutch.k8s.v1.IStateWaiting=} [properties] Properties to set
                 */
                function StateWaiting(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StateWaiting reason.
                 * @member {string} reason
                 * @memberof clutch.k8s.v1.StateWaiting
                 * @instance
                 */
                StateWaiting.prototype.reason = "";

                /**
                 * StateWaiting message.
                 * @member {string} message
                 * @memberof clutch.k8s.v1.StateWaiting
                 * @instance
                 */
                StateWaiting.prototype.message = "";

                /**
                 * Verifies a StateWaiting message.
                 * @function verify
                 * @memberof clutch.k8s.v1.StateWaiting
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StateWaiting.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        if (!$util.isString(message.reason))
                            return "reason: string expected";
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    return null;
                };

                /**
                 * Creates a StateWaiting message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.StateWaiting
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.StateWaiting} StateWaiting
                 */
                StateWaiting.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.StateWaiting)
                        return object;
                    let message = new $root.clutch.k8s.v1.StateWaiting();
                    if (object.reason != null)
                        message.reason = String(object.reason);
                    if (object.message != null)
                        message.message = String(object.message);
                    return message;
                };

                /**
                 * Creates a plain object from a StateWaiting message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.StateWaiting
                 * @static
                 * @param {clutch.k8s.v1.StateWaiting} message StateWaiting
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StateWaiting.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.reason = "";
                        object.message = "";
                    }
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        object.reason = message.reason;
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    return object;
                };

                /**
                 * Converts this StateWaiting to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.StateWaiting
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StateWaiting.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return StateWaiting;
            })();

            v1.StateRunning = (function() {

                /**
                 * Properties of a StateRunning.
                 * @memberof clutch.k8s.v1
                 * @interface IStateRunning
                 * @property {google.protobuf.ITimestamp|null} [startTime] StateRunning startTime
                 */

                /**
                 * Constructs a new StateRunning.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a StateRunning.
                 * @implements IStateRunning
                 * @constructor
                 * @param {clutch.k8s.v1.IStateRunning=} [properties] Properties to set
                 */
                function StateRunning(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StateRunning startTime.
                 * @member {google.protobuf.ITimestamp|null|undefined} startTime
                 * @memberof clutch.k8s.v1.StateRunning
                 * @instance
                 */
                StateRunning.prototype.startTime = null;

                /**
                 * Verifies a StateRunning message.
                 * @function verify
                 * @memberof clutch.k8s.v1.StateRunning
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StateRunning.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.startTime != null && message.hasOwnProperty("startTime")) {
                        let error = $root.google.protobuf.Timestamp.verify(message.startTime);
                        if (error)
                            return "startTime." + error;
                    }
                    return null;
                };

                /**
                 * Creates a StateRunning message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.StateRunning
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.StateRunning} StateRunning
                 */
                StateRunning.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.StateRunning)
                        return object;
                    let message = new $root.clutch.k8s.v1.StateRunning();
                    if (object.startTime != null) {
                        if (typeof object.startTime !== "object")
                            throw TypeError(".clutch.k8s.v1.StateRunning.startTime: object expected");
                        message.startTime = $root.google.protobuf.Timestamp.fromObject(object.startTime);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a StateRunning message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.StateRunning
                 * @static
                 * @param {clutch.k8s.v1.StateRunning} message StateRunning
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StateRunning.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.startTime = null;
                    if (message.startTime != null && message.hasOwnProperty("startTime"))
                        object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
                    return object;
                };

                /**
                 * Converts this StateRunning to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.StateRunning
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StateRunning.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return StateRunning;
            })();

            v1.StateTerminated = (function() {

                /**
                 * Properties of a StateTerminated.
                 * @memberof clutch.k8s.v1
                 * @interface IStateTerminated
                 * @property {string|null} [reason] StateTerminated reason
                 * @property {string|null} [message] StateTerminated message
                 * @property {number|null} [exitCode] StateTerminated exitCode
                 * @property {number|null} [signal] StateTerminated signal
                 */

                /**
                 * Constructs a new StateTerminated.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a StateTerminated.
                 * @implements IStateTerminated
                 * @constructor
                 * @param {clutch.k8s.v1.IStateTerminated=} [properties] Properties to set
                 */
                function StateTerminated(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StateTerminated reason.
                 * @member {string} reason
                 * @memberof clutch.k8s.v1.StateTerminated
                 * @instance
                 */
                StateTerminated.prototype.reason = "";

                /**
                 * StateTerminated message.
                 * @member {string} message
                 * @memberof clutch.k8s.v1.StateTerminated
                 * @instance
                 */
                StateTerminated.prototype.message = "";

                /**
                 * StateTerminated exitCode.
                 * @member {number} exitCode
                 * @memberof clutch.k8s.v1.StateTerminated
                 * @instance
                 */
                StateTerminated.prototype.exitCode = 0;

                /**
                 * StateTerminated signal.
                 * @member {number} signal
                 * @memberof clutch.k8s.v1.StateTerminated
                 * @instance
                 */
                StateTerminated.prototype.signal = 0;

                /**
                 * Verifies a StateTerminated message.
                 * @function verify
                 * @memberof clutch.k8s.v1.StateTerminated
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StateTerminated.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        if (!$util.isString(message.reason))
                            return "reason: string expected";
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                        if (!$util.isInteger(message.exitCode))
                            return "exitCode: integer expected";
                    if (message.signal != null && message.hasOwnProperty("signal"))
                        if (!$util.isInteger(message.signal))
                            return "signal: integer expected";
                    return null;
                };

                /**
                 * Creates a StateTerminated message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.StateTerminated
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.StateTerminated} StateTerminated
                 */
                StateTerminated.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.StateTerminated)
                        return object;
                    let message = new $root.clutch.k8s.v1.StateTerminated();
                    if (object.reason != null)
                        message.reason = String(object.reason);
                    if (object.message != null)
                        message.message = String(object.message);
                    if (object.exitCode != null)
                        message.exitCode = object.exitCode | 0;
                    if (object.signal != null)
                        message.signal = object.signal | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a StateTerminated message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.StateTerminated
                 * @static
                 * @param {clutch.k8s.v1.StateTerminated} message StateTerminated
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StateTerminated.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.reason = "";
                        object.message = "";
                        object.exitCode = 0;
                        object.signal = 0;
                    }
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        object.reason = message.reason;
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    if (message.exitCode != null && message.hasOwnProperty("exitCode"))
                        object.exitCode = message.exitCode;
                    if (message.signal != null && message.hasOwnProperty("signal"))
                        object.signal = message.signal;
                    return object;
                };

                /**
                 * Converts this StateTerminated to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.StateTerminated
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StateTerminated.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return StateTerminated;
            })();

            v1.PodCondition = (function() {

                /**
                 * Properties of a PodCondition.
                 * @memberof clutch.k8s.v1
                 * @interface IPodCondition
                 * @property {clutch.k8s.v1.PodCondition.Type|null} [type] PodCondition type
                 * @property {clutch.k8s.v1.PodCondition.Status|null} [status] PodCondition status
                 */

                /**
                 * Constructs a new PodCondition.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a PodCondition.
                 * @implements IPodCondition
                 * @constructor
                 * @param {clutch.k8s.v1.IPodCondition=} [properties] Properties to set
                 */
                function PodCondition(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * PodCondition type.
                 * @member {clutch.k8s.v1.PodCondition.Type} type
                 * @memberof clutch.k8s.v1.PodCondition
                 * @instance
                 */
                PodCondition.prototype.type = 0;

                /**
                 * PodCondition status.
                 * @member {clutch.k8s.v1.PodCondition.Status} status
                 * @memberof clutch.k8s.v1.PodCondition
                 * @instance
                 */
                PodCondition.prototype.status = 0;

                /**
                 * Verifies a PodCondition message.
                 * @function verify
                 * @memberof clutch.k8s.v1.PodCondition
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                PodCondition.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.status != null && message.hasOwnProperty("status"))
                        switch (message.status) {
                        default:
                            return "status: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a PodCondition message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.PodCondition
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.PodCondition} PodCondition
                 */
                PodCondition.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.PodCondition)
                        return object;
                    let message = new $root.clutch.k8s.v1.PodCondition();
                    switch (object.type) {
                    case "TYPE_UNSPECIFIED":
                    case 0:
                        message.type = 0;
                        break;
                    case "CONTAINERS_READY":
                    case 1:
                        message.type = 1;
                        break;
                    case "INITIALIZED":
                    case 2:
                        message.type = 2;
                        break;
                    case "READY":
                    case 3:
                        message.type = 3;
                        break;
                    case "POD_SCHEDULED":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    switch (object.status) {
                    case "STATUS_UNSPECIFIED":
                    case 0:
                        message.status = 0;
                        break;
                    case "TRUE":
                    case 1:
                        message.status = 1;
                        break;
                    case "FALSE":
                    case 2:
                        message.status = 2;
                        break;
                    case "UNKNOWN":
                    case 3:
                        message.status = 3;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a PodCondition message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.PodCondition
                 * @static
                 * @param {clutch.k8s.v1.PodCondition} message PodCondition
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                PodCondition.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.type = options.enums === String ? "TYPE_UNSPECIFIED" : 0;
                        object.status = options.enums === String ? "STATUS_UNSPECIFIED" : 0;
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.clutch.k8s.v1.PodCondition.Type[message.type] : message.type;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = options.enums === String ? $root.clutch.k8s.v1.PodCondition.Status[message.status] : message.status;
                    return object;
                };

                /**
                 * Converts this PodCondition to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.PodCondition
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                PodCondition.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Type enum.
                 * @name clutch.k8s.v1.PodCondition.Type
                 * @enum {number}
                 * @property {number} TYPE_UNSPECIFIED=0 TYPE_UNSPECIFIED value
                 * @property {number} CONTAINERS_READY=1 CONTAINERS_READY value
                 * @property {number} INITIALIZED=2 INITIALIZED value
                 * @property {number} READY=3 READY value
                 * @property {number} POD_SCHEDULED=4 POD_SCHEDULED value
                 */
                PodCondition.Type = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "TYPE_UNSPECIFIED"] = 0;
                    values[valuesById[1] = "CONTAINERS_READY"] = 1;
                    values[valuesById[2] = "INITIALIZED"] = 2;
                    values[valuesById[3] = "READY"] = 3;
                    values[valuesById[4] = "POD_SCHEDULED"] = 4;
                    return values;
                })();

                /**
                 * Status enum.
                 * @name clutch.k8s.v1.PodCondition.Status
                 * @enum {number}
                 * @property {number} STATUS_UNSPECIFIED=0 STATUS_UNSPECIFIED value
                 * @property {number} TRUE=1 TRUE value
                 * @property {number} FALSE=2 FALSE value
                 * @property {number} UNKNOWN=3 UNKNOWN value
                 */
                PodCondition.Status = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "STATUS_UNSPECIFIED"] = 0;
                    values[valuesById[1] = "TRUE"] = 1;
                    values[valuesById[2] = "FALSE"] = 2;
                    values[valuesById[3] = "UNKNOWN"] = 3;
                    return values;
                })();

                return PodCondition;
            })();

            v1.Pod = (function() {

                /**
                 * Properties of a Pod.
                 * @memberof clutch.k8s.v1
                 * @interface IPod
                 * @property {string|null} [cluster] Pod cluster
                 * @property {string|null} [namespace] Pod namespace
                 * @property {string|null} [name] Pod name
                 * @property {Array.<clutch.k8s.v1.IContainer>|null} [containers] Pod containers
                 * @property {string|null} [nodeIp] Pod nodeIp
                 * @property {string|null} [podIp] Pod podIp
                 * @property {clutch.k8s.v1.Pod.State|null} [state] Pod state
                 * @property {google.protobuf.ITimestamp|null} [startTime] Pod startTime
                 * @property {Object.<string,string>|null} [labels] Pod labels
                 * @property {Object.<string,string>|null} [annotations] Pod annotations
                 * @property {string|null} [stateReason] Pod stateReason
                 * @property {Array.<clutch.k8s.v1.IPodCondition>|null} [podConditions] Pod podConditions
                 * @property {Array.<clutch.k8s.v1.IContainer>|null} [initContainers] Pod initContainers
                 * @property {string|null} [status] Pod status
                 * @property {number|Long|null} [startTimeMillis] Pod startTimeMillis
                 */

                /**
                 * Constructs a new Pod.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a Pod.
                 * @implements IPod
                 * @constructor
                 * @param {clutch.k8s.v1.IPod=} [properties] Properties to set
                 */
                function Pod(properties) {
                    this.containers = [];
                    this.labels = {};
                    this.annotations = {};
                    this.podConditions = [];
                    this.initContainers = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Pod cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.cluster = "";

                /**
                 * Pod namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.namespace = "";

                /**
                 * Pod name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.name = "";

                /**
                 * Pod containers.
                 * @member {Array.<clutch.k8s.v1.IContainer>} containers
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.containers = $util.emptyArray;

                /**
                 * Pod nodeIp.
                 * @member {string} nodeIp
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.nodeIp = "";

                /**
                 * Pod podIp.
                 * @member {string} podIp
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.podIp = "";

                /**
                 * Pod state.
                 * @member {clutch.k8s.v1.Pod.State} state
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.state = 0;

                /**
                 * Pod startTime.
                 * @member {google.protobuf.ITimestamp|null|undefined} startTime
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.startTime = null;

                /**
                 * Pod labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.labels = $util.emptyObject;

                /**
                 * Pod annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.annotations = $util.emptyObject;

                /**
                 * Pod stateReason.
                 * @member {string} stateReason
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.stateReason = "";

                /**
                 * Pod podConditions.
                 * @member {Array.<clutch.k8s.v1.IPodCondition>} podConditions
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.podConditions = $util.emptyArray;

                /**
                 * Pod initContainers.
                 * @member {Array.<clutch.k8s.v1.IContainer>} initContainers
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.initContainers = $util.emptyArray;

                /**
                 * Pod status.
                 * @member {string} status
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.status = "";

                /**
                 * Pod startTimeMillis.
                 * @member {number|Long} startTimeMillis
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.startTimeMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Verifies a Pod message.
                 * @function verify
                 * @memberof clutch.k8s.v1.Pod
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Pod.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.containers != null && message.hasOwnProperty("containers")) {
                        if (!Array.isArray(message.containers))
                            return "containers: array expected";
                        for (let i = 0; i < message.containers.length; ++i) {
                            let error = $root.clutch.k8s.v1.Container.verify(message.containers[i]);
                            if (error)
                                return "containers." + error;
                        }
                    }
                    if (message.nodeIp != null && message.hasOwnProperty("nodeIp"))
                        if (!$util.isString(message.nodeIp))
                            return "nodeIp: string expected";
                    if (message.podIp != null && message.hasOwnProperty("podIp"))
                        if (!$util.isString(message.podIp))
                            return "podIp: string expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.startTime != null && message.hasOwnProperty("startTime")) {
                        let error = $root.google.protobuf.Timestamp.verify(message.startTime);
                        if (error)
                            return "startTime." + error;
                    }
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    if (message.stateReason != null && message.hasOwnProperty("stateReason"))
                        if (!$util.isString(message.stateReason))
                            return "stateReason: string expected";
                    if (message.podConditions != null && message.hasOwnProperty("podConditions")) {
                        if (!Array.isArray(message.podConditions))
                            return "podConditions: array expected";
                        for (let i = 0; i < message.podConditions.length; ++i) {
                            let error = $root.clutch.k8s.v1.PodCondition.verify(message.podConditions[i]);
                            if (error)
                                return "podConditions." + error;
                        }
                    }
                    if (message.initContainers != null && message.hasOwnProperty("initContainers")) {
                        if (!Array.isArray(message.initContainers))
                            return "initContainers: array expected";
                        for (let i = 0; i < message.initContainers.length; ++i) {
                            let error = $root.clutch.k8s.v1.Container.verify(message.initContainers[i]);
                            if (error)
                                return "initContainers." + error;
                        }
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        if (!$util.isString(message.status))
                            return "status: string expected";
                    if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                        if (!$util.isInteger(message.startTimeMillis) && !(message.startTimeMillis && $util.isInteger(message.startTimeMillis.low) && $util.isInteger(message.startTimeMillis.high)))
                            return "startTimeMillis: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a Pod message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.Pod
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.Pod} Pod
                 */
                Pod.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.Pod)
                        return object;
                    let message = new $root.clutch.k8s.v1.Pod();
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.containers) {
                        if (!Array.isArray(object.containers))
                            throw TypeError(".clutch.k8s.v1.Pod.containers: array expected");
                        message.containers = [];
                        for (let i = 0; i < object.containers.length; ++i) {
                            if (typeof object.containers[i] !== "object")
                                throw TypeError(".clutch.k8s.v1.Pod.containers: object expected");
                            message.containers[i] = $root.clutch.k8s.v1.Container.fromObject(object.containers[i]);
                        }
                    }
                    if (object.nodeIp != null)
                        message.nodeIp = String(object.nodeIp);
                    if (object.podIp != null)
                        message.podIp = String(object.podIp);
                    switch (object.state) {
                    case "UNSPECIFIED":
                    case 0:
                        message.state = 0;
                        break;
                    case "UNKNOWN":
                    case 1:
                        message.state = 1;
                        break;
                    case "PENDING":
                    case 2:
                        message.state = 2;
                        break;
                    case "RUNNING":
                    case 3:
                        message.state = 3;
                        break;
                    case "SUCCEEDED":
                    case 4:
                        message.state = 4;
                        break;
                    case "FAILED":
                    case 5:
                        message.state = 5;
                        break;
                    }
                    if (object.startTime != null) {
                        if (typeof object.startTime !== "object")
                            throw TypeError(".clutch.k8s.v1.Pod.startTime: object expected");
                        message.startTime = $root.google.protobuf.Timestamp.fromObject(object.startTime);
                    }
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.Pod.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.Pod.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                            message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                    }
                    if (object.stateReason != null)
                        message.stateReason = String(object.stateReason);
                    if (object.podConditions) {
                        if (!Array.isArray(object.podConditions))
                            throw TypeError(".clutch.k8s.v1.Pod.podConditions: array expected");
                        message.podConditions = [];
                        for (let i = 0; i < object.podConditions.length; ++i) {
                            if (typeof object.podConditions[i] !== "object")
                                throw TypeError(".clutch.k8s.v1.Pod.podConditions: object expected");
                            message.podConditions[i] = $root.clutch.k8s.v1.PodCondition.fromObject(object.podConditions[i]);
                        }
                    }
                    if (object.initContainers) {
                        if (!Array.isArray(object.initContainers))
                            throw TypeError(".clutch.k8s.v1.Pod.initContainers: array expected");
                        message.initContainers = [];
                        for (let i = 0; i < object.initContainers.length; ++i) {
                            if (typeof object.initContainers[i] !== "object")
                                throw TypeError(".clutch.k8s.v1.Pod.initContainers: object expected");
                            message.initContainers[i] = $root.clutch.k8s.v1.Container.fromObject(object.initContainers[i]);
                        }
                    }
                    if (object.status != null)
                        message.status = String(object.status);
                    if (object.startTimeMillis != null)
                        if ($util.Long)
                            (message.startTimeMillis = $util.Long.fromValue(object.startTimeMillis)).unsigned = false;
                        else if (typeof object.startTimeMillis === "string")
                            message.startTimeMillis = parseInt(object.startTimeMillis, 10);
                        else if (typeof object.startTimeMillis === "number")
                            message.startTimeMillis = object.startTimeMillis;
                        else if (typeof object.startTimeMillis === "object")
                            message.startTimeMillis = new $util.LongBits(object.startTimeMillis.low >>> 0, object.startTimeMillis.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a Pod message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.Pod
                 * @static
                 * @param {clutch.k8s.v1.Pod} message Pod
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Pod.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.containers = [];
                        object.podConditions = [];
                        object.initContainers = [];
                    }
                    if (options.objects || options.defaults) {
                        object.labels = {};
                        object.annotations = {};
                    }
                    if (options.defaults) {
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.nodeIp = "";
                        object.podIp = "";
                        object.state = options.enums === String ? "UNSPECIFIED" : 0;
                        object.startTime = null;
                        object.stateReason = "";
                        object.status = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.startTimeMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.startTimeMillis = options.longs === String ? "0" : 0;
                    }
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.containers && message.containers.length) {
                        object.containers = [];
                        for (let j = 0; j < message.containers.length; ++j)
                            object.containers[j] = $root.clutch.k8s.v1.Container.toObject(message.containers[j], options);
                    }
                    if (message.nodeIp != null && message.hasOwnProperty("nodeIp"))
                        object.nodeIp = message.nodeIp;
                    if (message.podIp != null && message.hasOwnProperty("podIp"))
                        object.podIp = message.podIp;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = options.enums === String ? $root.clutch.k8s.v1.Pod.State[message.state] : message.state;
                    if (message.startTime != null && message.hasOwnProperty("startTime"))
                        object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = message.annotations[keys2[j]];
                    }
                    if (message.stateReason != null && message.hasOwnProperty("stateReason"))
                        object.stateReason = message.stateReason;
                    if (message.podConditions && message.podConditions.length) {
                        object.podConditions = [];
                        for (let j = 0; j < message.podConditions.length; ++j)
                            object.podConditions[j] = $root.clutch.k8s.v1.PodCondition.toObject(message.podConditions[j], options);
                    }
                    if (message.initContainers && message.initContainers.length) {
                        object.initContainers = [];
                        for (let j = 0; j < message.initContainers.length; ++j)
                            object.initContainers[j] = $root.clutch.k8s.v1.Container.toObject(message.initContainers[j], options);
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = message.status;
                    if (message.startTimeMillis != null && message.hasOwnProperty("startTimeMillis"))
                        if (typeof message.startTimeMillis === "number")
                            object.startTimeMillis = options.longs === String ? String(message.startTimeMillis) : message.startTimeMillis;
                        else
                            object.startTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeMillis) : options.longs === Number ? new $util.LongBits(message.startTimeMillis.low >>> 0, message.startTimeMillis.high >>> 0).toNumber() : message.startTimeMillis;
                    return object;
                };

                /**
                 * Converts this Pod to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Pod.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * State enum.
                 * @name clutch.k8s.v1.Pod.State
                 * @enum {number}
                 * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                 * @property {number} UNKNOWN=1 UNKNOWN value
                 * @property {number} PENDING=2 PENDING value
                 * @property {number} RUNNING=3 RUNNING value
                 * @property {number} SUCCEEDED=4 SUCCEEDED value
                 * @property {number} FAILED=5 FAILED value
                 */
                Pod.State = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNSPECIFIED"] = 0;
                    values[valuesById[1] = "UNKNOWN"] = 1;
                    values[valuesById[2] = "PENDING"] = 2;
                    values[valuesById[3] = "RUNNING"] = 3;
                    values[valuesById[4] = "SUCCEEDED"] = 4;
                    values[valuesById[5] = "FAILED"] = 5;
                    return values;
                })();

                return Pod;
            })();

            v1.ListOptions = (function() {

                /**
                 * Properties of a ListOptions.
                 * @memberof clutch.k8s.v1
                 * @interface IListOptions
                 * @property {Object.<string,string>|null} [labels] ListOptions labels
                 * @property {string|null} [supplementalSelectorString] ListOptions supplementalSelectorString
                 */

                /**
                 * Constructs a new ListOptions.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListOptions.
                 * @implements IListOptions
                 * @constructor
                 * @param {clutch.k8s.v1.IListOptions=} [properties] Properties to set
                 */
                function ListOptions(properties) {
                    this.labels = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListOptions labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.ListOptions
                 * @instance
                 */
                ListOptions.prototype.labels = $util.emptyObject;

                /**
                 * ListOptions supplementalSelectorString.
                 * @member {string} supplementalSelectorString
                 * @memberof clutch.k8s.v1.ListOptions
                 * @instance
                 */
                ListOptions.prototype.supplementalSelectorString = "";

                /**
                 * Verifies a ListOptions message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.supplementalSelectorString != null && message.hasOwnProperty("supplementalSelectorString"))
                        if (!$util.isString(message.supplementalSelectorString))
                            return "supplementalSelectorString: string expected";
                    return null;
                };

                /**
                 * Creates a ListOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListOptions} ListOptions
                 */
                ListOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListOptions)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListOptions();
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.ListOptions.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    if (object.supplementalSelectorString != null)
                        message.supplementalSelectorString = String(object.supplementalSelectorString);
                    return message;
                };

                /**
                 * Creates a plain object from a ListOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListOptions
                 * @static
                 * @param {clutch.k8s.v1.ListOptions} message ListOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.labels = {};
                    if (options.defaults)
                        object.supplementalSelectorString = "";
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    if (message.supplementalSelectorString != null && message.hasOwnProperty("supplementalSelectorString"))
                        object.supplementalSelectorString = message.supplementalSelectorString;
                    return object;
                };

                /**
                 * Converts this ListOptions to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListOptions;
            })();

            v1.ListPodsRequest = (function() {

                /**
                 * Properties of a ListPodsRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IListPodsRequest
                 * @property {string|null} [clientset] ListPodsRequest clientset
                 * @property {string|null} [cluster] ListPodsRequest cluster
                 * @property {string|null} [namespace] ListPodsRequest namespace
                 * @property {clutch.k8s.v1.IListOptions|null} [options] ListPodsRequest options
                 */

                /**
                 * Constructs a new ListPodsRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListPodsRequest.
                 * @implements IListPodsRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IListPodsRequest=} [properties] Properties to set
                 */
                function ListPodsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListPodsRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @instance
                 */
                ListPodsRequest.prototype.clientset = "";

                /**
                 * ListPodsRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @instance
                 */
                ListPodsRequest.prototype.cluster = "";

                /**
                 * ListPodsRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @instance
                 */
                ListPodsRequest.prototype.namespace = "";

                /**
                 * ListPodsRequest options.
                 * @member {clutch.k8s.v1.IListOptions|null|undefined} options
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @instance
                 */
                ListPodsRequest.prototype.options = null;

                /**
                 * Verifies a ListPodsRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListPodsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        let error = $root.clutch.k8s.v1.ListOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ListPodsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListPodsRequest} ListPodsRequest
                 */
                ListPodsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListPodsRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListPodsRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".clutch.k8s.v1.ListPodsRequest.options: object expected");
                        message.options = $root.clutch.k8s.v1.ListOptions.fromObject(object.options);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListPodsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @static
                 * @param {clutch.k8s.v1.ListPodsRequest} message ListPodsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListPodsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.options = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.clutch.k8s.v1.ListOptions.toObject(message.options, options);
                    return object;
                };

                /**
                 * Converts this ListPodsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListPodsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListPodsRequest;
            })();

            v1.ListPodsResponse = (function() {

                /**
                 * Properties of a ListPodsResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IListPodsResponse
                 * @property {Array.<clutch.k8s.v1.IPod>|null} [pods] ListPodsResponse pods
                 */

                /**
                 * Constructs a new ListPodsResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListPodsResponse.
                 * @implements IListPodsResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IListPodsResponse=} [properties] Properties to set
                 */
                function ListPodsResponse(properties) {
                    this.pods = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListPodsResponse pods.
                 * @member {Array.<clutch.k8s.v1.IPod>} pods
                 * @memberof clutch.k8s.v1.ListPodsResponse
                 * @instance
                 */
                ListPodsResponse.prototype.pods = $util.emptyArray;

                /**
                 * Verifies a ListPodsResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListPodsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListPodsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pods != null && message.hasOwnProperty("pods")) {
                        if (!Array.isArray(message.pods))
                            return "pods: array expected";
                        for (let i = 0; i < message.pods.length; ++i) {
                            let error = $root.clutch.k8s.v1.Pod.verify(message.pods[i]);
                            if (error)
                                return "pods." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ListPodsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListPodsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListPodsResponse} ListPodsResponse
                 */
                ListPodsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListPodsResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListPodsResponse();
                    if (object.pods) {
                        if (!Array.isArray(object.pods))
                            throw TypeError(".clutch.k8s.v1.ListPodsResponse.pods: array expected");
                        message.pods = [];
                        for (let i = 0; i < object.pods.length; ++i) {
                            if (typeof object.pods[i] !== "object")
                                throw TypeError(".clutch.k8s.v1.ListPodsResponse.pods: object expected");
                            message.pods[i] = $root.clutch.k8s.v1.Pod.fromObject(object.pods[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListPodsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListPodsResponse
                 * @static
                 * @param {clutch.k8s.v1.ListPodsResponse} message ListPodsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListPodsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.pods = [];
                    if (message.pods && message.pods.length) {
                        object.pods = [];
                        for (let j = 0; j < message.pods.length; ++j)
                            object.pods[j] = $root.clutch.k8s.v1.Pod.toObject(message.pods[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ListPodsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListPodsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListPodsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListPodsResponse;
            })();

            v1.DeletePodRequest = (function() {

                /**
                 * Properties of a DeletePodRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDeletePodRequest
                 * @property {string|null} [clientset] DeletePodRequest clientset
                 * @property {string|null} [cluster] DeletePodRequest cluster
                 * @property {string|null} [namespace] DeletePodRequest namespace
                 * @property {string|null} [name] DeletePodRequest name
                 */

                /**
                 * Constructs a new DeletePodRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeletePodRequest.
                 * @implements IDeletePodRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDeletePodRequest=} [properties] Properties to set
                 */
                function DeletePodRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeletePodRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @instance
                 */
                DeletePodRequest.prototype.clientset = "";

                /**
                 * DeletePodRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @instance
                 */
                DeletePodRequest.prototype.cluster = "";

                /**
                 * DeletePodRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @instance
                 */
                DeletePodRequest.prototype.namespace = "";

                /**
                 * DeletePodRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @instance
                 */
                DeletePodRequest.prototype.name = "";

                /**
                 * Verifies a DeletePodRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeletePodRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DeletePodRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeletePodRequest} DeletePodRequest
                 */
                DeletePodRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeletePodRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DeletePodRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DeletePodRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @static
                 * @param {clutch.k8s.v1.DeletePodRequest} message DeletePodRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeletePodRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DeletePodRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeletePodRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeletePodRequest;
            })();

            v1.DeletePodResponse = (function() {

                /**
                 * Properties of a DeletePodResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDeletePodResponse
                 */

                /**
                 * Constructs a new DeletePodResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeletePodResponse.
                 * @implements IDeletePodResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDeletePodResponse=} [properties] Properties to set
                 */
                function DeletePodResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a DeletePodResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeletePodResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeletePodResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a DeletePodResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeletePodResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeletePodResponse} DeletePodResponse
                 */
                DeletePodResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeletePodResponse)
                        return object;
                    return new $root.clutch.k8s.v1.DeletePodResponse();
                };

                /**
                 * Creates a plain object from a DeletePodResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeletePodResponse
                 * @static
                 * @param {clutch.k8s.v1.DeletePodResponse} message DeletePodResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeletePodResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this DeletePodResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeletePodResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeletePodResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeletePodResponse;
            })();

            v1.UpdatePodRequest = (function() {

                /**
                 * Properties of an UpdatePodRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IUpdatePodRequest
                 * @property {string|null} [clientset] UpdatePodRequest clientset
                 * @property {string|null} [cluster] UpdatePodRequest cluster
                 * @property {string|null} [namespace] UpdatePodRequest namespace
                 * @property {string|null} [name] UpdatePodRequest name
                 * @property {clutch.k8s.v1.IExpectedObjectMetaFields|null} [expectedObjectMetaFields] UpdatePodRequest expectedObjectMetaFields
                 * @property {clutch.k8s.v1.IObjectMetaFields|null} [objectMetaFields] UpdatePodRequest objectMetaFields
                 * @property {clutch.k8s.v1.IRemoveObjectMetaFields|null} [removeObjectMetaFields] UpdatePodRequest removeObjectMetaFields
                 */

                /**
                 * Constructs a new UpdatePodRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an UpdatePodRequest.
                 * @implements IUpdatePodRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IUpdatePodRequest=} [properties] Properties to set
                 */
                function UpdatePodRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdatePodRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 */
                UpdatePodRequest.prototype.clientset = "";

                /**
                 * UpdatePodRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 */
                UpdatePodRequest.prototype.cluster = "";

                /**
                 * UpdatePodRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 */
                UpdatePodRequest.prototype.namespace = "";

                /**
                 * UpdatePodRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 */
                UpdatePodRequest.prototype.name = "";

                /**
                 * UpdatePodRequest expectedObjectMetaFields.
                 * @member {clutch.k8s.v1.IExpectedObjectMetaFields|null|undefined} expectedObjectMetaFields
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 */
                UpdatePodRequest.prototype.expectedObjectMetaFields = null;

                /**
                 * UpdatePodRequest objectMetaFields.
                 * @member {clutch.k8s.v1.IObjectMetaFields|null|undefined} objectMetaFields
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 */
                UpdatePodRequest.prototype.objectMetaFields = null;

                /**
                 * UpdatePodRequest removeObjectMetaFields.
                 * @member {clutch.k8s.v1.IRemoveObjectMetaFields|null|undefined} removeObjectMetaFields
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 */
                UpdatePodRequest.prototype.removeObjectMetaFields = null;

                /**
                 * Verifies an UpdatePodRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdatePodRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.expectedObjectMetaFields != null && message.hasOwnProperty("expectedObjectMetaFields")) {
                        let error = $root.clutch.k8s.v1.ExpectedObjectMetaFields.verify(message.expectedObjectMetaFields);
                        if (error)
                            return "expectedObjectMetaFields." + error;
                    }
                    if (message.objectMetaFields != null && message.hasOwnProperty("objectMetaFields")) {
                        let error = $root.clutch.k8s.v1.ObjectMetaFields.verify(message.objectMetaFields);
                        if (error)
                            return "objectMetaFields." + error;
                    }
                    if (message.removeObjectMetaFields != null && message.hasOwnProperty("removeObjectMetaFields")) {
                        let error = $root.clutch.k8s.v1.RemoveObjectMetaFields.verify(message.removeObjectMetaFields);
                        if (error)
                            return "removeObjectMetaFields." + error;
                    }
                    return null;
                };

                /**
                 * Creates an UpdatePodRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.UpdatePodRequest} UpdatePodRequest
                 */
                UpdatePodRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.UpdatePodRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.UpdatePodRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.expectedObjectMetaFields != null) {
                        if (typeof object.expectedObjectMetaFields !== "object")
                            throw TypeError(".clutch.k8s.v1.UpdatePodRequest.expectedObjectMetaFields: object expected");
                        message.expectedObjectMetaFields = $root.clutch.k8s.v1.ExpectedObjectMetaFields.fromObject(object.expectedObjectMetaFields);
                    }
                    if (object.objectMetaFields != null) {
                        if (typeof object.objectMetaFields !== "object")
                            throw TypeError(".clutch.k8s.v1.UpdatePodRequest.objectMetaFields: object expected");
                        message.objectMetaFields = $root.clutch.k8s.v1.ObjectMetaFields.fromObject(object.objectMetaFields);
                    }
                    if (object.removeObjectMetaFields != null) {
                        if (typeof object.removeObjectMetaFields !== "object")
                            throw TypeError(".clutch.k8s.v1.UpdatePodRequest.removeObjectMetaFields: object expected");
                        message.removeObjectMetaFields = $root.clutch.k8s.v1.RemoveObjectMetaFields.fromObject(object.removeObjectMetaFields);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an UpdatePodRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @static
                 * @param {clutch.k8s.v1.UpdatePodRequest} message UpdatePodRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdatePodRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.expectedObjectMetaFields = null;
                        object.objectMetaFields = null;
                        object.removeObjectMetaFields = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.expectedObjectMetaFields != null && message.hasOwnProperty("expectedObjectMetaFields"))
                        object.expectedObjectMetaFields = $root.clutch.k8s.v1.ExpectedObjectMetaFields.toObject(message.expectedObjectMetaFields, options);
                    if (message.objectMetaFields != null && message.hasOwnProperty("objectMetaFields"))
                        object.objectMetaFields = $root.clutch.k8s.v1.ObjectMetaFields.toObject(message.objectMetaFields, options);
                    if (message.removeObjectMetaFields != null && message.hasOwnProperty("removeObjectMetaFields"))
                        object.removeObjectMetaFields = $root.clutch.k8s.v1.RemoveObjectMetaFields.toObject(message.removeObjectMetaFields, options);
                    return object;
                };

                /**
                 * Converts this UpdatePodRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdatePodRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdatePodRequest;
            })();

            v1.UpdatePodResponse = (function() {

                /**
                 * Properties of an UpdatePodResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IUpdatePodResponse
                 */

                /**
                 * Constructs a new UpdatePodResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an UpdatePodResponse.
                 * @implements IUpdatePodResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IUpdatePodResponse=} [properties] Properties to set
                 */
                function UpdatePodResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies an UpdatePodResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.UpdatePodResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdatePodResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an UpdatePodResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.UpdatePodResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.UpdatePodResponse} UpdatePodResponse
                 */
                UpdatePodResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.UpdatePodResponse)
                        return object;
                    return new $root.clutch.k8s.v1.UpdatePodResponse();
                };

                /**
                 * Creates a plain object from an UpdatePodResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.UpdatePodResponse
                 * @static
                 * @param {clutch.k8s.v1.UpdatePodResponse} message UpdatePodResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdatePodResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this UpdatePodResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.UpdatePodResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdatePodResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdatePodResponse;
            })();

            v1.HPA = (function() {

                /**
                 * Properties of a HPA.
                 * @memberof clutch.k8s.v1
                 * @interface IHPA
                 * @property {string|null} [cluster] HPA cluster
                 * @property {string|null} [namespace] HPA namespace
                 * @property {string|null} [name] HPA name
                 * @property {clutch.k8s.v1.HPA.ISizing|null} [sizing] HPA sizing
                 * @property {Object.<string,string>|null} [labels] HPA labels
                 * @property {Object.<string,string>|null} [annotations] HPA annotations
                 */

                /**
                 * Constructs a new HPA.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a HPA.
                 * @implements IHPA
                 * @constructor
                 * @param {clutch.k8s.v1.IHPA=} [properties] Properties to set
                 */
                function HPA(properties) {
                    this.labels = {};
                    this.annotations = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * HPA cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.HPA
                 * @instance
                 */
                HPA.prototype.cluster = "";

                /**
                 * HPA namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.HPA
                 * @instance
                 */
                HPA.prototype.namespace = "";

                /**
                 * HPA name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.HPA
                 * @instance
                 */
                HPA.prototype.name = "";

                /**
                 * HPA sizing.
                 * @member {clutch.k8s.v1.HPA.ISizing|null|undefined} sizing
                 * @memberof clutch.k8s.v1.HPA
                 * @instance
                 */
                HPA.prototype.sizing = null;

                /**
                 * HPA labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.HPA
                 * @instance
                 */
                HPA.prototype.labels = $util.emptyObject;

                /**
                 * HPA annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof clutch.k8s.v1.HPA
                 * @instance
                 */
                HPA.prototype.annotations = $util.emptyObject;

                /**
                 * Verifies a HPA message.
                 * @function verify
                 * @memberof clutch.k8s.v1.HPA
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HPA.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.sizing != null && message.hasOwnProperty("sizing")) {
                        let error = $root.clutch.k8s.v1.HPA.Sizing.verify(message.sizing);
                        if (error)
                            return "sizing." + error;
                    }
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates a HPA message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.HPA
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.HPA} HPA
                 */
                HPA.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.HPA)
                        return object;
                    let message = new $root.clutch.k8s.v1.HPA();
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.sizing != null) {
                        if (typeof object.sizing !== "object")
                            throw TypeError(".clutch.k8s.v1.HPA.sizing: object expected");
                        message.sizing = $root.clutch.k8s.v1.HPA.Sizing.fromObject(object.sizing);
                    }
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.HPA.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.HPA.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                            message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a HPA message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.HPA
                 * @static
                 * @param {clutch.k8s.v1.HPA} message HPA
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HPA.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.labels = {};
                        object.annotations = {};
                    }
                    if (options.defaults) {
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.sizing = null;
                    }
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.sizing != null && message.hasOwnProperty("sizing"))
                        object.sizing = $root.clutch.k8s.v1.HPA.Sizing.toObject(message.sizing, options);
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = message.annotations[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Converts this HPA to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.HPA
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HPA.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                HPA.Sizing = (function() {

                    /**
                     * Properties of a Sizing.
                     * @memberof clutch.k8s.v1.HPA
                     * @interface ISizing
                     * @property {number|null} [minReplicas] Sizing minReplicas
                     * @property {number|null} [maxReplicas] Sizing maxReplicas
                     * @property {number|null} [currentReplicas] Sizing currentReplicas
                     * @property {number|null} [desiredReplicas] Sizing desiredReplicas
                     */

                    /**
                     * Constructs a new Sizing.
                     * @memberof clutch.k8s.v1.HPA
                     * @classdesc Represents a Sizing.
                     * @implements ISizing
                     * @constructor
                     * @param {clutch.k8s.v1.HPA.ISizing=} [properties] Properties to set
                     */
                    function Sizing(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Sizing minReplicas.
                     * @member {number} minReplicas
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @instance
                     */
                    Sizing.prototype.minReplicas = 0;

                    /**
                     * Sizing maxReplicas.
                     * @member {number} maxReplicas
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @instance
                     */
                    Sizing.prototype.maxReplicas = 0;

                    /**
                     * Sizing currentReplicas.
                     * @member {number} currentReplicas
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @instance
                     */
                    Sizing.prototype.currentReplicas = 0;

                    /**
                     * Sizing desiredReplicas.
                     * @member {number} desiredReplicas
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @instance
                     */
                    Sizing.prototype.desiredReplicas = 0;

                    /**
                     * Verifies a Sizing message.
                     * @function verify
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Sizing.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.minReplicas != null && message.hasOwnProperty("minReplicas"))
                            if (!$util.isInteger(message.minReplicas))
                                return "minReplicas: integer expected";
                        if (message.maxReplicas != null && message.hasOwnProperty("maxReplicas"))
                            if (!$util.isInteger(message.maxReplicas))
                                return "maxReplicas: integer expected";
                        if (message.currentReplicas != null && message.hasOwnProperty("currentReplicas"))
                            if (!$util.isInteger(message.currentReplicas))
                                return "currentReplicas: integer expected";
                        if (message.desiredReplicas != null && message.hasOwnProperty("desiredReplicas"))
                            if (!$util.isInteger(message.desiredReplicas))
                                return "desiredReplicas: integer expected";
                        return null;
                    };

                    /**
                     * Creates a Sizing message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.k8s.v1.HPA.Sizing} Sizing
                     */
                    Sizing.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.k8s.v1.HPA.Sizing)
                            return object;
                        let message = new $root.clutch.k8s.v1.HPA.Sizing();
                        if (object.minReplicas != null)
                            message.minReplicas = object.minReplicas >>> 0;
                        if (object.maxReplicas != null)
                            message.maxReplicas = object.maxReplicas >>> 0;
                        if (object.currentReplicas != null)
                            message.currentReplicas = object.currentReplicas >>> 0;
                        if (object.desiredReplicas != null)
                            message.desiredReplicas = object.desiredReplicas >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a Sizing message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @static
                     * @param {clutch.k8s.v1.HPA.Sizing} message Sizing
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Sizing.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.minReplicas = 0;
                            object.maxReplicas = 0;
                            object.currentReplicas = 0;
                            object.desiredReplicas = 0;
                        }
                        if (message.minReplicas != null && message.hasOwnProperty("minReplicas"))
                            object.minReplicas = message.minReplicas;
                        if (message.maxReplicas != null && message.hasOwnProperty("maxReplicas"))
                            object.maxReplicas = message.maxReplicas;
                        if (message.currentReplicas != null && message.hasOwnProperty("currentReplicas"))
                            object.currentReplicas = message.currentReplicas;
                        if (message.desiredReplicas != null && message.hasOwnProperty("desiredReplicas"))
                            object.desiredReplicas = message.desiredReplicas;
                        return object;
                    };

                    /**
                     * Converts this Sizing to JSON.
                     * @function toJSON
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Sizing.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Sizing;
                })();

                return HPA;
            })();

            v1.ResizeHPARequest = (function() {

                /**
                 * Properties of a ResizeHPARequest.
                 * @memberof clutch.k8s.v1
                 * @interface IResizeHPARequest
                 * @property {string|null} [clientset] ResizeHPARequest clientset
                 * @property {string|null} [cluster] ResizeHPARequest cluster
                 * @property {string|null} [namespace] ResizeHPARequest namespace
                 * @property {string|null} [name] ResizeHPARequest name
                 * @property {clutch.k8s.v1.ResizeHPARequest.ISizing|null} [sizing] ResizeHPARequest sizing
                 */

                /**
                 * Constructs a new ResizeHPARequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ResizeHPARequest.
                 * @implements IResizeHPARequest
                 * @constructor
                 * @param {clutch.k8s.v1.IResizeHPARequest=} [properties] Properties to set
                 */
                function ResizeHPARequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ResizeHPARequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @instance
                 */
                ResizeHPARequest.prototype.clientset = "";

                /**
                 * ResizeHPARequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @instance
                 */
                ResizeHPARequest.prototype.cluster = "";

                /**
                 * ResizeHPARequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @instance
                 */
                ResizeHPARequest.prototype.namespace = "";

                /**
                 * ResizeHPARequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @instance
                 */
                ResizeHPARequest.prototype.name = "";

                /**
                 * ResizeHPARequest sizing.
                 * @member {clutch.k8s.v1.ResizeHPARequest.ISizing|null|undefined} sizing
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @instance
                 */
                ResizeHPARequest.prototype.sizing = null;

                /**
                 * Verifies a ResizeHPARequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ResizeHPARequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.sizing != null && message.hasOwnProperty("sizing")) {
                        let error = $root.clutch.k8s.v1.ResizeHPARequest.Sizing.verify(message.sizing);
                        if (error)
                            return "sizing." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ResizeHPARequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ResizeHPARequest} ResizeHPARequest
                 */
                ResizeHPARequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ResizeHPARequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.ResizeHPARequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.sizing != null) {
                        if (typeof object.sizing !== "object")
                            throw TypeError(".clutch.k8s.v1.ResizeHPARequest.sizing: object expected");
                        message.sizing = $root.clutch.k8s.v1.ResizeHPARequest.Sizing.fromObject(object.sizing);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ResizeHPARequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @static
                 * @param {clutch.k8s.v1.ResizeHPARequest} message ResizeHPARequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ResizeHPARequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.sizing = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.sizing != null && message.hasOwnProperty("sizing"))
                        object.sizing = $root.clutch.k8s.v1.ResizeHPARequest.Sizing.toObject(message.sizing, options);
                    return object;
                };

                /**
                 * Converts this ResizeHPARequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ResizeHPARequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                ResizeHPARequest.Sizing = (function() {

                    /**
                     * Properties of a Sizing.
                     * @memberof clutch.k8s.v1.ResizeHPARequest
                     * @interface ISizing
                     * @property {number|null} [min] Sizing min
                     * @property {number|null} [max] Sizing max
                     */

                    /**
                     * Constructs a new Sizing.
                     * @memberof clutch.k8s.v1.ResizeHPARequest
                     * @classdesc Represents a Sizing.
                     * @implements ISizing
                     * @constructor
                     * @param {clutch.k8s.v1.ResizeHPARequest.ISizing=} [properties] Properties to set
                     */
                    function Sizing(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Sizing min.
                     * @member {number} min
                     * @memberof clutch.k8s.v1.ResizeHPARequest.Sizing
                     * @instance
                     */
                    Sizing.prototype.min = 0;

                    /**
                     * Sizing max.
                     * @member {number} max
                     * @memberof clutch.k8s.v1.ResizeHPARequest.Sizing
                     * @instance
                     */
                    Sizing.prototype.max = 0;

                    /**
                     * Verifies a Sizing message.
                     * @function verify
                     * @memberof clutch.k8s.v1.ResizeHPARequest.Sizing
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Sizing.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.min != null && message.hasOwnProperty("min"))
                            if (!$util.isInteger(message.min))
                                return "min: integer expected";
                        if (message.max != null && message.hasOwnProperty("max"))
                            if (!$util.isInteger(message.max))
                                return "max: integer expected";
                        return null;
                    };

                    /**
                     * Creates a Sizing message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.k8s.v1.ResizeHPARequest.Sizing
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.k8s.v1.ResizeHPARequest.Sizing} Sizing
                     */
                    Sizing.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.k8s.v1.ResizeHPARequest.Sizing)
                            return object;
                        let message = new $root.clutch.k8s.v1.ResizeHPARequest.Sizing();
                        if (object.min != null)
                            message.min = object.min >>> 0;
                        if (object.max != null)
                            message.max = object.max >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a Sizing message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.k8s.v1.ResizeHPARequest.Sizing
                     * @static
                     * @param {clutch.k8s.v1.ResizeHPARequest.Sizing} message Sizing
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Sizing.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.min = 0;
                            object.max = 0;
                        }
                        if (message.min != null && message.hasOwnProperty("min"))
                            object.min = message.min;
                        if (message.max != null && message.hasOwnProperty("max"))
                            object.max = message.max;
                        return object;
                    };

                    /**
                     * Converts this Sizing to JSON.
                     * @function toJSON
                     * @memberof clutch.k8s.v1.ResizeHPARequest.Sizing
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Sizing.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Sizing;
                })();

                return ResizeHPARequest;
            })();

            v1.ResizeHPAResponse = (function() {

                /**
                 * Properties of a ResizeHPAResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IResizeHPAResponse
                 */

                /**
                 * Constructs a new ResizeHPAResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ResizeHPAResponse.
                 * @implements IResizeHPAResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IResizeHPAResponse=} [properties] Properties to set
                 */
                function ResizeHPAResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a ResizeHPAResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ResizeHPAResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ResizeHPAResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a ResizeHPAResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ResizeHPAResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ResizeHPAResponse} ResizeHPAResponse
                 */
                ResizeHPAResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ResizeHPAResponse)
                        return object;
                    return new $root.clutch.k8s.v1.ResizeHPAResponse();
                };

                /**
                 * Creates a plain object from a ResizeHPAResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ResizeHPAResponse
                 * @static
                 * @param {clutch.k8s.v1.ResizeHPAResponse} message ResizeHPAResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ResizeHPAResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this ResizeHPAResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ResizeHPAResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ResizeHPAResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ResizeHPAResponse;
            })();

            v1.DeleteHPARequest = (function() {

                /**
                 * Properties of a DeleteHPARequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDeleteHPARequest
                 * @property {string|null} [clientset] DeleteHPARequest clientset
                 * @property {string|null} [cluster] DeleteHPARequest cluster
                 * @property {string|null} [namespace] DeleteHPARequest namespace
                 * @property {string|null} [name] DeleteHPARequest name
                 */

                /**
                 * Constructs a new DeleteHPARequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeleteHPARequest.
                 * @implements IDeleteHPARequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDeleteHPARequest=} [properties] Properties to set
                 */
                function DeleteHPARequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeleteHPARequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DeleteHPARequest
                 * @instance
                 */
                DeleteHPARequest.prototype.clientset = "";

                /**
                 * DeleteHPARequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DeleteHPARequest
                 * @instance
                 */
                DeleteHPARequest.prototype.cluster = "";

                /**
                 * DeleteHPARequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DeleteHPARequest
                 * @instance
                 */
                DeleteHPARequest.prototype.namespace = "";

                /**
                 * DeleteHPARequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DeleteHPARequest
                 * @instance
                 */
                DeleteHPARequest.prototype.name = "";

                /**
                 * Verifies a DeleteHPARequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeleteHPARequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteHPARequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DeleteHPARequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeleteHPARequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeleteHPARequest} DeleteHPARequest
                 */
                DeleteHPARequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeleteHPARequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DeleteHPARequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DeleteHPARequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeleteHPARequest
                 * @static
                 * @param {clutch.k8s.v1.DeleteHPARequest} message DeleteHPARequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteHPARequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DeleteHPARequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeleteHPARequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteHPARequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteHPARequest;
            })();

            v1.DeleteHPAResponse = (function() {

                /**
                 * Properties of a DeleteHPAResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDeleteHPAResponse
                 */

                /**
                 * Constructs a new DeleteHPAResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeleteHPAResponse.
                 * @implements IDeleteHPAResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDeleteHPAResponse=} [properties] Properties to set
                 */
                function DeleteHPAResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a DeleteHPAResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeleteHPAResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteHPAResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a DeleteHPAResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeleteHPAResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeleteHPAResponse} DeleteHPAResponse
                 */
                DeleteHPAResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeleteHPAResponse)
                        return object;
                    return new $root.clutch.k8s.v1.DeleteHPAResponse();
                };

                /**
                 * Creates a plain object from a DeleteHPAResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeleteHPAResponse
                 * @static
                 * @param {clutch.k8s.v1.DeleteHPAResponse} message DeleteHPAResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteHPAResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this DeleteHPAResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeleteHPAResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteHPAResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteHPAResponse;
            })();

            v1.Deployment = (function() {

                /**
                 * Properties of a Deployment.
                 * @memberof clutch.k8s.v1
                 * @interface IDeployment
                 * @property {string|null} [cluster] Deployment cluster
                 * @property {string|null} [namespace] Deployment namespace
                 * @property {string|null} [name] Deployment name
                 * @property {Object.<string,string>|null} [labels] Deployment labels
                 * @property {Object.<string,string>|null} [annotations] Deployment annotations
                 * @property {clutch.k8s.v1.Deployment.IDeploymentStatus|null} [deploymentStatus] Deployment deploymentStatus
                 * @property {number|Long|null} [creationTimeMillis] Deployment creationTimeMillis
                 */

                /**
                 * Constructs a new Deployment.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a Deployment.
                 * @implements IDeployment
                 * @constructor
                 * @param {clutch.k8s.v1.IDeployment=} [properties] Properties to set
                 */
                function Deployment(properties) {
                    this.labels = {};
                    this.annotations = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Deployment cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.Deployment
                 * @instance
                 */
                Deployment.prototype.cluster = "";

                /**
                 * Deployment namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.Deployment
                 * @instance
                 */
                Deployment.prototype.namespace = "";

                /**
                 * Deployment name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.Deployment
                 * @instance
                 */
                Deployment.prototype.name = "";

                /**
                 * Deployment labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.Deployment
                 * @instance
                 */
                Deployment.prototype.labels = $util.emptyObject;

                /**
                 * Deployment annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof clutch.k8s.v1.Deployment
                 * @instance
                 */
                Deployment.prototype.annotations = $util.emptyObject;

                /**
                 * Deployment deploymentStatus.
                 * @member {clutch.k8s.v1.Deployment.IDeploymentStatus|null|undefined} deploymentStatus
                 * @memberof clutch.k8s.v1.Deployment
                 * @instance
                 */
                Deployment.prototype.deploymentStatus = null;

                /**
                 * Deployment creationTimeMillis.
                 * @member {number|Long} creationTimeMillis
                 * @memberof clutch.k8s.v1.Deployment
                 * @instance
                 */
                Deployment.prototype.creationTimeMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Verifies a Deployment message.
                 * @function verify
                 * @memberof clutch.k8s.v1.Deployment
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Deployment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    if (message.deploymentStatus != null && message.hasOwnProperty("deploymentStatus")) {
                        let error = $root.clutch.k8s.v1.Deployment.DeploymentStatus.verify(message.deploymentStatus);
                        if (error)
                            return "deploymentStatus." + error;
                    }
                    if (message.creationTimeMillis != null && message.hasOwnProperty("creationTimeMillis"))
                        if (!$util.isInteger(message.creationTimeMillis) && !(message.creationTimeMillis && $util.isInteger(message.creationTimeMillis.low) && $util.isInteger(message.creationTimeMillis.high)))
                            return "creationTimeMillis: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a Deployment message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.Deployment
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.Deployment} Deployment
                 */
                Deployment.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.Deployment)
                        return object;
                    let message = new $root.clutch.k8s.v1.Deployment();
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.Deployment.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.Deployment.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                            message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                    }
                    if (object.deploymentStatus != null) {
                        if (typeof object.deploymentStatus !== "object")
                            throw TypeError(".clutch.k8s.v1.Deployment.deploymentStatus: object expected");
                        message.deploymentStatus = $root.clutch.k8s.v1.Deployment.DeploymentStatus.fromObject(object.deploymentStatus);
                    }
                    if (object.creationTimeMillis != null)
                        if ($util.Long)
                            (message.creationTimeMillis = $util.Long.fromValue(object.creationTimeMillis)).unsigned = false;
                        else if (typeof object.creationTimeMillis === "string")
                            message.creationTimeMillis = parseInt(object.creationTimeMillis, 10);
                        else if (typeof object.creationTimeMillis === "number")
                            message.creationTimeMillis = object.creationTimeMillis;
                        else if (typeof object.creationTimeMillis === "object")
                            message.creationTimeMillis = new $util.LongBits(object.creationTimeMillis.low >>> 0, object.creationTimeMillis.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a Deployment message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.Deployment
                 * @static
                 * @param {clutch.k8s.v1.Deployment} message Deployment
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Deployment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.labels = {};
                        object.annotations = {};
                    }
                    if (options.defaults) {
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.deploymentStatus = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.creationTimeMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.creationTimeMillis = options.longs === String ? "0" : 0;
                    }
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = message.annotations[keys2[j]];
                    }
                    if (message.deploymentStatus != null && message.hasOwnProperty("deploymentStatus"))
                        object.deploymentStatus = $root.clutch.k8s.v1.Deployment.DeploymentStatus.toObject(message.deploymentStatus, options);
                    if (message.creationTimeMillis != null && message.hasOwnProperty("creationTimeMillis"))
                        if (typeof message.creationTimeMillis === "number")
                            object.creationTimeMillis = options.longs === String ? String(message.creationTimeMillis) : message.creationTimeMillis;
                        else
                            object.creationTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.creationTimeMillis) : options.longs === Number ? new $util.LongBits(message.creationTimeMillis.low >>> 0, message.creationTimeMillis.high >>> 0).toNumber() : message.creationTimeMillis;
                    return object;
                };

                /**
                 * Converts this Deployment to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.Deployment
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Deployment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Deployment.DeploymentStatus = (function() {

                    /**
                     * Properties of a DeploymentStatus.
                     * @memberof clutch.k8s.v1.Deployment
                     * @interface IDeploymentStatus
                     * @property {number|null} [replicas] DeploymentStatus replicas
                     * @property {number|null} [updatedReplicas] DeploymentStatus updatedReplicas
                     * @property {number|null} [readyReplicas] DeploymentStatus readyReplicas
                     * @property {number|null} [availableReplicas] DeploymentStatus availableReplicas
                     * @property {number|null} [unavailableReplicas] DeploymentStatus unavailableReplicas
                     * @property {Array.<clutch.k8s.v1.Deployment.DeploymentStatus.ICondition>|null} [deploymentConditions] DeploymentStatus deploymentConditions
                     */

                    /**
                     * Constructs a new DeploymentStatus.
                     * @memberof clutch.k8s.v1.Deployment
                     * @classdesc Represents a DeploymentStatus.
                     * @implements IDeploymentStatus
                     * @constructor
                     * @param {clutch.k8s.v1.Deployment.IDeploymentStatus=} [properties] Properties to set
                     */
                    function DeploymentStatus(properties) {
                        this.deploymentConditions = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * DeploymentStatus replicas.
                     * @member {number} replicas
                     * @memberof clutch.k8s.v1.Deployment.DeploymentStatus
                     * @instance
                     */
                    DeploymentStatus.prototype.replicas = 0;

                    /**
                     * DeploymentStatus updatedReplicas.
                     * @member {number} updatedReplicas
                     * @memberof clutch.k8s.v1.Deployment.DeploymentStatus
                     * @instance
                     */
                    DeploymentStatus.prototype.updatedReplicas = 0;

                    /**
                     * DeploymentStatus readyReplicas.
                     * @member {number} readyReplicas
                     * @memberof clutch.k8s.v1.Deployment.DeploymentStatus
                     * @instance
                     */
                    DeploymentStatus.prototype.readyReplicas = 0;

                    /**
                     * DeploymentStatus availableReplicas.
                     * @member {number} availableReplicas
                     * @memberof clutch.k8s.v1.Deployment.DeploymentStatus
                     * @instance
                     */
                    DeploymentStatus.prototype.availableReplicas = 0;

                    /**
                     * DeploymentStatus unavailableReplicas.
                     * @member {number} unavailableReplicas
                     * @memberof clutch.k8s.v1.Deployment.DeploymentStatus
                     * @instance
                     */
                    DeploymentStatus.prototype.unavailableReplicas = 0;

                    /**
                     * DeploymentStatus deploymentConditions.
                     * @member {Array.<clutch.k8s.v1.Deployment.DeploymentStatus.ICondition>} deploymentConditions
                     * @memberof clutch.k8s.v1.Deployment.DeploymentStatus
                     * @instance
                     */
                    DeploymentStatus.prototype.deploymentConditions = $util.emptyArray;

                    /**
                     * Verifies a DeploymentStatus message.
                     * @function verify
                     * @memberof clutch.k8s.v1.Deployment.DeploymentStatus
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DeploymentStatus.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.replicas != null && message.hasOwnProperty("replicas"))
                            if (!$util.isInteger(message.replicas))
                                return "replicas: integer expected";
                        if (message.updatedReplicas != null && message.hasOwnProperty("updatedReplicas"))
                            if (!$util.isInteger(message.updatedReplicas))
                                return "updatedReplicas: integer expected";
                        if (message.readyReplicas != null && message.hasOwnProperty("readyReplicas"))
                            if (!$util.isInteger(message.readyReplicas))
                                return "readyReplicas: integer expected";
                        if (message.availableReplicas != null && message.hasOwnProperty("availableReplicas"))
                            if (!$util.isInteger(message.availableReplicas))
                                return "availableReplicas: integer expected";
                        if (message.unavailableReplicas != null && message.hasOwnProperty("unavailableReplicas"))
                            if (!$util.isInteger(message.unavailableReplicas))
                                return "unavailableReplicas: integer expected";
                        if (message.deploymentConditions != null && message.hasOwnProperty("deploymentConditions")) {
                            if (!Array.isArray(message.deploymentConditions))
                                return "deploymentConditions: array expected";
                            for (let i = 0; i < message.deploymentConditions.length; ++i) {
                                let error = $root.clutch.k8s.v1.Deployment.DeploymentStatus.Condition.verify(message.deploymentConditions[i]);
                                if (error)
                                    return "deploymentConditions." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a DeploymentStatus message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.k8s.v1.Deployment.DeploymentStatus
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.k8s.v1.Deployment.DeploymentStatus} DeploymentStatus
                     */
                    DeploymentStatus.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.k8s.v1.Deployment.DeploymentStatus)
                            return object;
                        let message = new $root.clutch.k8s.v1.Deployment.DeploymentStatus();
                        if (object.replicas != null)
                            message.replicas = object.replicas >>> 0;
                        if (object.updatedReplicas != null)
                            message.updatedReplicas = object.updatedReplicas >>> 0;
                        if (object.readyReplicas != null)
                            message.readyReplicas = object.readyReplicas >>> 0;
                        if (object.availableReplicas != null)
                            message.availableReplicas = object.availableReplicas >>> 0;
                        if (object.unavailableReplicas != null)
                            message.unavailableReplicas = object.unavailableReplicas >>> 0;
                        if (object.deploymentConditions) {
                            if (!Array.isArray(object.deploymentConditions))
                                throw TypeError(".clutch.k8s.v1.Deployment.DeploymentStatus.deploymentConditions: array expected");
                            message.deploymentConditions = [];
                            for (let i = 0; i < object.deploymentConditions.length; ++i) {
                                if (typeof object.deploymentConditions[i] !== "object")
                                    throw TypeError(".clutch.k8s.v1.Deployment.DeploymentStatus.deploymentConditions: object expected");
                                message.deploymentConditions[i] = $root.clutch.k8s.v1.Deployment.DeploymentStatus.Condition.fromObject(object.deploymentConditions[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a DeploymentStatus message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.k8s.v1.Deployment.DeploymentStatus
                     * @static
                     * @param {clutch.k8s.v1.Deployment.DeploymentStatus} message DeploymentStatus
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DeploymentStatus.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.deploymentConditions = [];
                        if (options.defaults) {
                            object.replicas = 0;
                            object.updatedReplicas = 0;
                            object.readyReplicas = 0;
                            object.availableReplicas = 0;
                            object.unavailableReplicas = 0;
                        }
                        if (message.replicas != null && message.hasOwnProperty("replicas"))
                            object.replicas = message.replicas;
                        if (message.updatedReplicas != null && message.hasOwnProperty("updatedReplicas"))
                            object.updatedReplicas = message.updatedReplicas;
                        if (message.readyReplicas != null && message.hasOwnProperty("readyReplicas"))
                            object.readyReplicas = message.readyReplicas;
                        if (message.availableReplicas != null && message.hasOwnProperty("availableReplicas"))
                            object.availableReplicas = message.availableReplicas;
                        if (message.unavailableReplicas != null && message.hasOwnProperty("unavailableReplicas"))
                            object.unavailableReplicas = message.unavailableReplicas;
                        if (message.deploymentConditions && message.deploymentConditions.length) {
                            object.deploymentConditions = [];
                            for (let j = 0; j < message.deploymentConditions.length; ++j)
                                object.deploymentConditions[j] = $root.clutch.k8s.v1.Deployment.DeploymentStatus.Condition.toObject(message.deploymentConditions[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this DeploymentStatus to JSON.
                     * @function toJSON
                     * @memberof clutch.k8s.v1.Deployment.DeploymentStatus
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DeploymentStatus.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    DeploymentStatus.Condition = (function() {

                        /**
                         * Properties of a Condition.
                         * @memberof clutch.k8s.v1.Deployment.DeploymentStatus
                         * @interface ICondition
                         * @property {clutch.k8s.v1.Deployment.DeploymentStatus.Condition.Type|null} [type] Condition type
                         * @property {clutch.k8s.v1.Deployment.DeploymentStatus.Condition.ConditionStatus|null} [conditionStatus] Condition conditionStatus
                         * @property {string|null} [reason] Condition reason
                         * @property {string|null} [message] Condition message
                         */

                        /**
                         * Constructs a new Condition.
                         * @memberof clutch.k8s.v1.Deployment.DeploymentStatus
                         * @classdesc Represents a Condition.
                         * @implements ICondition
                         * @constructor
                         * @param {clutch.k8s.v1.Deployment.DeploymentStatus.ICondition=} [properties] Properties to set
                         */
                        function Condition(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Condition type.
                         * @member {clutch.k8s.v1.Deployment.DeploymentStatus.Condition.Type} type
                         * @memberof clutch.k8s.v1.Deployment.DeploymentStatus.Condition
                         * @instance
                         */
                        Condition.prototype.type = 0;

                        /**
                         * Condition conditionStatus.
                         * @member {clutch.k8s.v1.Deployment.DeploymentStatus.Condition.ConditionStatus} conditionStatus
                         * @memberof clutch.k8s.v1.Deployment.DeploymentStatus.Condition
                         * @instance
                         */
                        Condition.prototype.conditionStatus = 0;

                        /**
                         * Condition reason.
                         * @member {string} reason
                         * @memberof clutch.k8s.v1.Deployment.DeploymentStatus.Condition
                         * @instance
                         */
                        Condition.prototype.reason = "";

                        /**
                         * Condition message.
                         * @member {string} message
                         * @memberof clutch.k8s.v1.Deployment.DeploymentStatus.Condition
                         * @instance
                         */
                        Condition.prototype.message = "";

                        /**
                         * Verifies a Condition message.
                         * @function verify
                         * @memberof clutch.k8s.v1.Deployment.DeploymentStatus.Condition
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Condition.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.type != null && message.hasOwnProperty("type"))
                                switch (message.type) {
                                default:
                                    return "type: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                    break;
                                }
                            if (message.conditionStatus != null && message.hasOwnProperty("conditionStatus"))
                                switch (message.conditionStatus) {
                                default:
                                    return "conditionStatus: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                    break;
                                }
                            if (message.reason != null && message.hasOwnProperty("reason"))
                                if (!$util.isString(message.reason))
                                    return "reason: string expected";
                            if (message.message != null && message.hasOwnProperty("message"))
                                if (!$util.isString(message.message))
                                    return "message: string expected";
                            return null;
                        };

                        /**
                         * Creates a Condition message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.k8s.v1.Deployment.DeploymentStatus.Condition
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.k8s.v1.Deployment.DeploymentStatus.Condition} Condition
                         */
                        Condition.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.k8s.v1.Deployment.DeploymentStatus.Condition)
                                return object;
                            let message = new $root.clutch.k8s.v1.Deployment.DeploymentStatus.Condition();
                            switch (object.type) {
                            case "UNSPECIFIED":
                            case 0:
                                message.type = 0;
                                break;
                            case "UNKNOWN":
                            case 1:
                                message.type = 1;
                                break;
                            case "AVAILABLE":
                            case 2:
                                message.type = 2;
                                break;
                            case "PROGRESSING":
                            case 3:
                                message.type = 3;
                                break;
                            case "REPLICA_FAILURE":
                            case 4:
                                message.type = 4;
                                break;
                            }
                            switch (object.conditionStatus) {
                            case "CONDITION_UNSPECIFIED":
                            case 0:
                                message.conditionStatus = 0;
                                break;
                            case "CONDITION_TRUE":
                            case 1:
                                message.conditionStatus = 1;
                                break;
                            case "CONDITION_FALSE":
                            case 2:
                                message.conditionStatus = 2;
                                break;
                            case "CONDITION_UNKNOWN":
                            case 3:
                                message.conditionStatus = 3;
                                break;
                            }
                            if (object.reason != null)
                                message.reason = String(object.reason);
                            if (object.message != null)
                                message.message = String(object.message);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Condition message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.k8s.v1.Deployment.DeploymentStatus.Condition
                         * @static
                         * @param {clutch.k8s.v1.Deployment.DeploymentStatus.Condition} message Condition
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Condition.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.type = options.enums === String ? "UNSPECIFIED" : 0;
                                object.conditionStatus = options.enums === String ? "CONDITION_UNSPECIFIED" : 0;
                                object.reason = "";
                                object.message = "";
                            }
                            if (message.type != null && message.hasOwnProperty("type"))
                                object.type = options.enums === String ? $root.clutch.k8s.v1.Deployment.DeploymentStatus.Condition.Type[message.type] : message.type;
                            if (message.conditionStatus != null && message.hasOwnProperty("conditionStatus"))
                                object.conditionStatus = options.enums === String ? $root.clutch.k8s.v1.Deployment.DeploymentStatus.Condition.ConditionStatus[message.conditionStatus] : message.conditionStatus;
                            if (message.reason != null && message.hasOwnProperty("reason"))
                                object.reason = message.reason;
                            if (message.message != null && message.hasOwnProperty("message"))
                                object.message = message.message;
                            return object;
                        };

                        /**
                         * Converts this Condition to JSON.
                         * @function toJSON
                         * @memberof clutch.k8s.v1.Deployment.DeploymentStatus.Condition
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Condition.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * Type enum.
                         * @name clutch.k8s.v1.Deployment.DeploymentStatus.Condition.Type
                         * @enum {number}
                         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                         * @property {number} UNKNOWN=1 UNKNOWN value
                         * @property {number} AVAILABLE=2 AVAILABLE value
                         * @property {number} PROGRESSING=3 PROGRESSING value
                         * @property {number} REPLICA_FAILURE=4 REPLICA_FAILURE value
                         */
                        Condition.Type = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "UNSPECIFIED"] = 0;
                            values[valuesById[1] = "UNKNOWN"] = 1;
                            values[valuesById[2] = "AVAILABLE"] = 2;
                            values[valuesById[3] = "PROGRESSING"] = 3;
                            values[valuesById[4] = "REPLICA_FAILURE"] = 4;
                            return values;
                        })();

                        /**
                         * ConditionStatus enum.
                         * @name clutch.k8s.v1.Deployment.DeploymentStatus.Condition.ConditionStatus
                         * @enum {number}
                         * @property {number} CONDITION_UNSPECIFIED=0 CONDITION_UNSPECIFIED value
                         * @property {number} CONDITION_TRUE=1 CONDITION_TRUE value
                         * @property {number} CONDITION_FALSE=2 CONDITION_FALSE value
                         * @property {number} CONDITION_UNKNOWN=3 CONDITION_UNKNOWN value
                         */
                        Condition.ConditionStatus = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "CONDITION_UNSPECIFIED"] = 0;
                            values[valuesById[1] = "CONDITION_TRUE"] = 1;
                            values[valuesById[2] = "CONDITION_FALSE"] = 2;
                            values[valuesById[3] = "CONDITION_UNKNOWN"] = 3;
                            return values;
                        })();

                        return Condition;
                    })();

                    return DeploymentStatus;
                })();

                return Deployment;
            })();

            v1.DescribeDeploymentRequest = (function() {

                /**
                 * Properties of a DescribeDeploymentRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribeDeploymentRequest
                 * @property {string|null} [clientset] DescribeDeploymentRequest clientset
                 * @property {string|null} [cluster] DescribeDeploymentRequest cluster
                 * @property {string|null} [namespace] DescribeDeploymentRequest namespace
                 * @property {string|null} [name] DescribeDeploymentRequest name
                 */

                /**
                 * Constructs a new DescribeDeploymentRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribeDeploymentRequest.
                 * @implements IDescribeDeploymentRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribeDeploymentRequest=} [properties] Properties to set
                 */
                function DescribeDeploymentRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeDeploymentRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DescribeDeploymentRequest
                 * @instance
                 */
                DescribeDeploymentRequest.prototype.clientset = "";

                /**
                 * DescribeDeploymentRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DescribeDeploymentRequest
                 * @instance
                 */
                DescribeDeploymentRequest.prototype.cluster = "";

                /**
                 * DescribeDeploymentRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DescribeDeploymentRequest
                 * @instance
                 */
                DescribeDeploymentRequest.prototype.namespace = "";

                /**
                 * DescribeDeploymentRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DescribeDeploymentRequest
                 * @instance
                 */
                DescribeDeploymentRequest.prototype.name = "";

                /**
                 * Verifies a DescribeDeploymentRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribeDeploymentRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeDeploymentRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DescribeDeploymentRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribeDeploymentRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribeDeploymentRequest} DescribeDeploymentRequest
                 */
                DescribeDeploymentRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribeDeploymentRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribeDeploymentRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeDeploymentRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribeDeploymentRequest
                 * @static
                 * @param {clutch.k8s.v1.DescribeDeploymentRequest} message DescribeDeploymentRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeDeploymentRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DescribeDeploymentRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribeDeploymentRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeDeploymentRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeDeploymentRequest;
            })();

            v1.DescribeDeploymentResponse = (function() {

                /**
                 * Properties of a DescribeDeploymentResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribeDeploymentResponse
                 * @property {clutch.k8s.v1.IDeployment|null} [deployment] DescribeDeploymentResponse deployment
                 */

                /**
                 * Constructs a new DescribeDeploymentResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribeDeploymentResponse.
                 * @implements IDescribeDeploymentResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribeDeploymentResponse=} [properties] Properties to set
                 */
                function DescribeDeploymentResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeDeploymentResponse deployment.
                 * @member {clutch.k8s.v1.IDeployment|null|undefined} deployment
                 * @memberof clutch.k8s.v1.DescribeDeploymentResponse
                 * @instance
                 */
                DescribeDeploymentResponse.prototype.deployment = null;

                /**
                 * Verifies a DescribeDeploymentResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribeDeploymentResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeDeploymentResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deployment != null && message.hasOwnProperty("deployment")) {
                        let error = $root.clutch.k8s.v1.Deployment.verify(message.deployment);
                        if (error)
                            return "deployment." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DescribeDeploymentResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribeDeploymentResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribeDeploymentResponse} DescribeDeploymentResponse
                 */
                DescribeDeploymentResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribeDeploymentResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribeDeploymentResponse();
                    if (object.deployment != null) {
                        if (typeof object.deployment !== "object")
                            throw TypeError(".clutch.k8s.v1.DescribeDeploymentResponse.deployment: object expected");
                        message.deployment = $root.clutch.k8s.v1.Deployment.fromObject(object.deployment);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeDeploymentResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribeDeploymentResponse
                 * @static
                 * @param {clutch.k8s.v1.DescribeDeploymentResponse} message DescribeDeploymentResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeDeploymentResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.deployment = null;
                    if (message.deployment != null && message.hasOwnProperty("deployment"))
                        object.deployment = $root.clutch.k8s.v1.Deployment.toObject(message.deployment, options);
                    return object;
                };

                /**
                 * Converts this DescribeDeploymentResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribeDeploymentResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeDeploymentResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeDeploymentResponse;
            })();

            v1.ListDeploymentsRequest = (function() {

                /**
                 * Properties of a ListDeploymentsRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IListDeploymentsRequest
                 * @property {string|null} [clientset] ListDeploymentsRequest clientset
                 * @property {string|null} [cluster] ListDeploymentsRequest cluster
                 * @property {string|null} [namespace] ListDeploymentsRequest namespace
                 * @property {clutch.k8s.v1.IListOptions|null} [options] ListDeploymentsRequest options
                 */

                /**
                 * Constructs a new ListDeploymentsRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListDeploymentsRequest.
                 * @implements IListDeploymentsRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IListDeploymentsRequest=} [properties] Properties to set
                 */
                function ListDeploymentsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListDeploymentsRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.ListDeploymentsRequest
                 * @instance
                 */
                ListDeploymentsRequest.prototype.clientset = "";

                /**
                 * ListDeploymentsRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.ListDeploymentsRequest
                 * @instance
                 */
                ListDeploymentsRequest.prototype.cluster = "";

                /**
                 * ListDeploymentsRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.ListDeploymentsRequest
                 * @instance
                 */
                ListDeploymentsRequest.prototype.namespace = "";

                /**
                 * ListDeploymentsRequest options.
                 * @member {clutch.k8s.v1.IListOptions|null|undefined} options
                 * @memberof clutch.k8s.v1.ListDeploymentsRequest
                 * @instance
                 */
                ListDeploymentsRequest.prototype.options = null;

                /**
                 * Verifies a ListDeploymentsRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListDeploymentsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListDeploymentsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        let error = $root.clutch.k8s.v1.ListOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ListDeploymentsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListDeploymentsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListDeploymentsRequest} ListDeploymentsRequest
                 */
                ListDeploymentsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListDeploymentsRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListDeploymentsRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".clutch.k8s.v1.ListDeploymentsRequest.options: object expected");
                        message.options = $root.clutch.k8s.v1.ListOptions.fromObject(object.options);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListDeploymentsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListDeploymentsRequest
                 * @static
                 * @param {clutch.k8s.v1.ListDeploymentsRequest} message ListDeploymentsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListDeploymentsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.options = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.clutch.k8s.v1.ListOptions.toObject(message.options, options);
                    return object;
                };

                /**
                 * Converts this ListDeploymentsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListDeploymentsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListDeploymentsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListDeploymentsRequest;
            })();

            v1.ListDeploymentsResponse = (function() {

                /**
                 * Properties of a ListDeploymentsResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IListDeploymentsResponse
                 * @property {Array.<clutch.k8s.v1.IDeployment>|null} [deployments] ListDeploymentsResponse deployments
                 */

                /**
                 * Constructs a new ListDeploymentsResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListDeploymentsResponse.
                 * @implements IListDeploymentsResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IListDeploymentsResponse=} [properties] Properties to set
                 */
                function ListDeploymentsResponse(properties) {
                    this.deployments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListDeploymentsResponse deployments.
                 * @member {Array.<clutch.k8s.v1.IDeployment>} deployments
                 * @memberof clutch.k8s.v1.ListDeploymentsResponse
                 * @instance
                 */
                ListDeploymentsResponse.prototype.deployments = $util.emptyArray;

                /**
                 * Verifies a ListDeploymentsResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListDeploymentsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListDeploymentsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.deployments != null && message.hasOwnProperty("deployments")) {
                        if (!Array.isArray(message.deployments))
                            return "deployments: array expected";
                        for (let i = 0; i < message.deployments.length; ++i) {
                            let error = $root.clutch.k8s.v1.Deployment.verify(message.deployments[i]);
                            if (error)
                                return "deployments." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ListDeploymentsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListDeploymentsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListDeploymentsResponse} ListDeploymentsResponse
                 */
                ListDeploymentsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListDeploymentsResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListDeploymentsResponse();
                    if (object.deployments) {
                        if (!Array.isArray(object.deployments))
                            throw TypeError(".clutch.k8s.v1.ListDeploymentsResponse.deployments: array expected");
                        message.deployments = [];
                        for (let i = 0; i < object.deployments.length; ++i) {
                            if (typeof object.deployments[i] !== "object")
                                throw TypeError(".clutch.k8s.v1.ListDeploymentsResponse.deployments: object expected");
                            message.deployments[i] = $root.clutch.k8s.v1.Deployment.fromObject(object.deployments[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListDeploymentsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListDeploymentsResponse
                 * @static
                 * @param {clutch.k8s.v1.ListDeploymentsResponse} message ListDeploymentsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListDeploymentsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.deployments = [];
                    if (message.deployments && message.deployments.length) {
                        object.deployments = [];
                        for (let j = 0; j < message.deployments.length; ++j)
                            object.deployments[j] = $root.clutch.k8s.v1.Deployment.toObject(message.deployments[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ListDeploymentsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListDeploymentsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListDeploymentsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListDeploymentsResponse;
            })();

            v1.UpdateDeploymentRequest = (function() {

                /**
                 * Properties of an UpdateDeploymentRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IUpdateDeploymentRequest
                 * @property {string|null} [clientset] UpdateDeploymentRequest clientset
                 * @property {string|null} [cluster] UpdateDeploymentRequest cluster
                 * @property {string|null} [namespace] UpdateDeploymentRequest namespace
                 * @property {string|null} [name] UpdateDeploymentRequest name
                 * @property {clutch.k8s.v1.UpdateDeploymentRequest.IFields|null} [fields] UpdateDeploymentRequest fields
                 */

                /**
                 * Constructs a new UpdateDeploymentRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an UpdateDeploymentRequest.
                 * @implements IUpdateDeploymentRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IUpdateDeploymentRequest=} [properties] Properties to set
                 */
                function UpdateDeploymentRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdateDeploymentRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @instance
                 */
                UpdateDeploymentRequest.prototype.clientset = "";

                /**
                 * UpdateDeploymentRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @instance
                 */
                UpdateDeploymentRequest.prototype.cluster = "";

                /**
                 * UpdateDeploymentRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @instance
                 */
                UpdateDeploymentRequest.prototype.namespace = "";

                /**
                 * UpdateDeploymentRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @instance
                 */
                UpdateDeploymentRequest.prototype.name = "";

                /**
                 * UpdateDeploymentRequest fields.
                 * @member {clutch.k8s.v1.UpdateDeploymentRequest.IFields|null|undefined} fields
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @instance
                 */
                UpdateDeploymentRequest.prototype.fields = null;

                /**
                 * Verifies an UpdateDeploymentRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateDeploymentRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.fields != null && message.hasOwnProperty("fields")) {
                        let error = $root.clutch.k8s.v1.UpdateDeploymentRequest.Fields.verify(message.fields);
                        if (error)
                            return "fields." + error;
                    }
                    return null;
                };

                /**
                 * Creates an UpdateDeploymentRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.UpdateDeploymentRequest} UpdateDeploymentRequest
                 */
                UpdateDeploymentRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.UpdateDeploymentRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.UpdateDeploymentRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.fields != null) {
                        if (typeof object.fields !== "object")
                            throw TypeError(".clutch.k8s.v1.UpdateDeploymentRequest.fields: object expected");
                        message.fields = $root.clutch.k8s.v1.UpdateDeploymentRequest.Fields.fromObject(object.fields);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an UpdateDeploymentRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @static
                 * @param {clutch.k8s.v1.UpdateDeploymentRequest} message UpdateDeploymentRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateDeploymentRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.fields = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.fields != null && message.hasOwnProperty("fields"))
                        object.fields = $root.clutch.k8s.v1.UpdateDeploymentRequest.Fields.toObject(message.fields, options);
                    return object;
                };

                /**
                 * Converts this UpdateDeploymentRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateDeploymentRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                UpdateDeploymentRequest.Fields = (function() {

                    /**
                     * Properties of a Fields.
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                     * @interface IFields
                     * @property {Object.<string,string>|null} [labels] Fields labels
                     * @property {Object.<string,string>|null} [annotations] Fields annotations
                     */

                    /**
                     * Constructs a new Fields.
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                     * @classdesc Represents a Fields.
                     * @implements IFields
                     * @constructor
                     * @param {clutch.k8s.v1.UpdateDeploymentRequest.IFields=} [properties] Properties to set
                     */
                    function Fields(properties) {
                        this.labels = {};
                        this.annotations = {};
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Fields labels.
                     * @member {Object.<string,string>} labels
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest.Fields
                     * @instance
                     */
                    Fields.prototype.labels = $util.emptyObject;

                    /**
                     * Fields annotations.
                     * @member {Object.<string,string>} annotations
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest.Fields
                     * @instance
                     */
                    Fields.prototype.annotations = $util.emptyObject;

                    /**
                     * Verifies a Fields message.
                     * @function verify
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest.Fields
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Fields.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.labels != null && message.hasOwnProperty("labels")) {
                            if (!$util.isObject(message.labels))
                                return "labels: object expected";
                            let key = Object.keys(message.labels);
                            for (let i = 0; i < key.length; ++i)
                                if (!$util.isString(message.labels[key[i]]))
                                    return "labels: string{k:string} expected";
                        }
                        if (message.annotations != null && message.hasOwnProperty("annotations")) {
                            if (!$util.isObject(message.annotations))
                                return "annotations: object expected";
                            let key = Object.keys(message.annotations);
                            for (let i = 0; i < key.length; ++i)
                                if (!$util.isString(message.annotations[key[i]]))
                                    return "annotations: string{k:string} expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Fields message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest.Fields
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.k8s.v1.UpdateDeploymentRequest.Fields} Fields
                     */
                    Fields.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.k8s.v1.UpdateDeploymentRequest.Fields)
                            return object;
                        let message = new $root.clutch.k8s.v1.UpdateDeploymentRequest.Fields();
                        if (object.labels) {
                            if (typeof object.labels !== "object")
                                throw TypeError(".clutch.k8s.v1.UpdateDeploymentRequest.Fields.labels: object expected");
                            message.labels = {};
                            for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                                message.labels[keys[i]] = String(object.labels[keys[i]]);
                        }
                        if (object.annotations) {
                            if (typeof object.annotations !== "object")
                                throw TypeError(".clutch.k8s.v1.UpdateDeploymentRequest.Fields.annotations: object expected");
                            message.annotations = {};
                            for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                                message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Fields message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest.Fields
                     * @static
                     * @param {clutch.k8s.v1.UpdateDeploymentRequest.Fields} message Fields
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Fields.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.objects || options.defaults) {
                            object.labels = {};
                            object.annotations = {};
                        }
                        let keys2;
                        if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                            object.labels = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.labels[keys2[j]] = message.labels[keys2[j]];
                        }
                        if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                            object.annotations = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.annotations[keys2[j]] = message.annotations[keys2[j]];
                        }
                        return object;
                    };

                    /**
                     * Converts this Fields to JSON.
                     * @function toJSON
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest.Fields
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Fields.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Fields;
                })();

                return UpdateDeploymentRequest;
            })();

            v1.UpdateDeploymentResponse = (function() {

                /**
                 * Properties of an UpdateDeploymentResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IUpdateDeploymentResponse
                 */

                /**
                 * Constructs a new UpdateDeploymentResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an UpdateDeploymentResponse.
                 * @implements IUpdateDeploymentResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IUpdateDeploymentResponse=} [properties] Properties to set
                 */
                function UpdateDeploymentResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies an UpdateDeploymentResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.UpdateDeploymentResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateDeploymentResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an UpdateDeploymentResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.UpdateDeploymentResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.UpdateDeploymentResponse} UpdateDeploymentResponse
                 */
                UpdateDeploymentResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.UpdateDeploymentResponse)
                        return object;
                    return new $root.clutch.k8s.v1.UpdateDeploymentResponse();
                };

                /**
                 * Creates a plain object from an UpdateDeploymentResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.UpdateDeploymentResponse
                 * @static
                 * @param {clutch.k8s.v1.UpdateDeploymentResponse} message UpdateDeploymentResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateDeploymentResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this UpdateDeploymentResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.UpdateDeploymentResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateDeploymentResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdateDeploymentResponse;
            })();

            v1.DeleteDeploymentRequest = (function() {

                /**
                 * Properties of a DeleteDeploymentRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDeleteDeploymentRequest
                 * @property {string|null} [clientset] DeleteDeploymentRequest clientset
                 * @property {string|null} [cluster] DeleteDeploymentRequest cluster
                 * @property {string|null} [namespace] DeleteDeploymentRequest namespace
                 * @property {string|null} [name] DeleteDeploymentRequest name
                 */

                /**
                 * Constructs a new DeleteDeploymentRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeleteDeploymentRequest.
                 * @implements IDeleteDeploymentRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDeleteDeploymentRequest=} [properties] Properties to set
                 */
                function DeleteDeploymentRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeleteDeploymentRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DeleteDeploymentRequest
                 * @instance
                 */
                DeleteDeploymentRequest.prototype.clientset = "";

                /**
                 * DeleteDeploymentRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DeleteDeploymentRequest
                 * @instance
                 */
                DeleteDeploymentRequest.prototype.cluster = "";

                /**
                 * DeleteDeploymentRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DeleteDeploymentRequest
                 * @instance
                 */
                DeleteDeploymentRequest.prototype.namespace = "";

                /**
                 * DeleteDeploymentRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DeleteDeploymentRequest
                 * @instance
                 */
                DeleteDeploymentRequest.prototype.name = "";

                /**
                 * Verifies a DeleteDeploymentRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeleteDeploymentRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteDeploymentRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DeleteDeploymentRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeleteDeploymentRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeleteDeploymentRequest} DeleteDeploymentRequest
                 */
                DeleteDeploymentRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeleteDeploymentRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DeleteDeploymentRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DeleteDeploymentRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeleteDeploymentRequest
                 * @static
                 * @param {clutch.k8s.v1.DeleteDeploymentRequest} message DeleteDeploymentRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteDeploymentRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DeleteDeploymentRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeleteDeploymentRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteDeploymentRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteDeploymentRequest;
            })();

            v1.DeleteDeploymentResponse = (function() {

                /**
                 * Properties of a DeleteDeploymentResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDeleteDeploymentResponse
                 */

                /**
                 * Constructs a new DeleteDeploymentResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeleteDeploymentResponse.
                 * @implements IDeleteDeploymentResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDeleteDeploymentResponse=} [properties] Properties to set
                 */
                function DeleteDeploymentResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a DeleteDeploymentResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeleteDeploymentResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteDeploymentResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a DeleteDeploymentResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeleteDeploymentResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeleteDeploymentResponse} DeleteDeploymentResponse
                 */
                DeleteDeploymentResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeleteDeploymentResponse)
                        return object;
                    return new $root.clutch.k8s.v1.DeleteDeploymentResponse();
                };

                /**
                 * Creates a plain object from a DeleteDeploymentResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeleteDeploymentResponse
                 * @static
                 * @param {clutch.k8s.v1.DeleteDeploymentResponse} message DeleteDeploymentResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteDeploymentResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this DeleteDeploymentResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeleteDeploymentResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteDeploymentResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteDeploymentResponse;
            })();

            v1.StatefulSet = (function() {

                /**
                 * Properties of a StatefulSet.
                 * @memberof clutch.k8s.v1
                 * @interface IStatefulSet
                 * @property {string|null} [cluster] StatefulSet cluster
                 * @property {string|null} [namespace] StatefulSet namespace
                 * @property {string|null} [name] StatefulSet name
                 * @property {Object.<string,string>|null} [labels] StatefulSet labels
                 * @property {Object.<string,string>|null} [annotations] StatefulSet annotations
                 * @property {clutch.k8s.v1.StatefulSet.IStatus|null} [status] StatefulSet status
                 * @property {number|Long|null} [creationTimeMillis] StatefulSet creationTimeMillis
                 */

                /**
                 * Constructs a new StatefulSet.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a StatefulSet.
                 * @implements IStatefulSet
                 * @constructor
                 * @param {clutch.k8s.v1.IStatefulSet=} [properties] Properties to set
                 */
                function StatefulSet(properties) {
                    this.labels = {};
                    this.annotations = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StatefulSet cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.StatefulSet
                 * @instance
                 */
                StatefulSet.prototype.cluster = "";

                /**
                 * StatefulSet namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.StatefulSet
                 * @instance
                 */
                StatefulSet.prototype.namespace = "";

                /**
                 * StatefulSet name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.StatefulSet
                 * @instance
                 */
                StatefulSet.prototype.name = "";

                /**
                 * StatefulSet labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.StatefulSet
                 * @instance
                 */
                StatefulSet.prototype.labels = $util.emptyObject;

                /**
                 * StatefulSet annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof clutch.k8s.v1.StatefulSet
                 * @instance
                 */
                StatefulSet.prototype.annotations = $util.emptyObject;

                /**
                 * StatefulSet status.
                 * @member {clutch.k8s.v1.StatefulSet.IStatus|null|undefined} status
                 * @memberof clutch.k8s.v1.StatefulSet
                 * @instance
                 */
                StatefulSet.prototype.status = null;

                /**
                 * StatefulSet creationTimeMillis.
                 * @member {number|Long} creationTimeMillis
                 * @memberof clutch.k8s.v1.StatefulSet
                 * @instance
                 */
                StatefulSet.prototype.creationTimeMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Verifies a StatefulSet message.
                 * @function verify
                 * @memberof clutch.k8s.v1.StatefulSet
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StatefulSet.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    if (message.status != null && message.hasOwnProperty("status")) {
                        let error = $root.clutch.k8s.v1.StatefulSet.Status.verify(message.status);
                        if (error)
                            return "status." + error;
                    }
                    if (message.creationTimeMillis != null && message.hasOwnProperty("creationTimeMillis"))
                        if (!$util.isInteger(message.creationTimeMillis) && !(message.creationTimeMillis && $util.isInteger(message.creationTimeMillis.low) && $util.isInteger(message.creationTimeMillis.high)))
                            return "creationTimeMillis: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a StatefulSet message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.StatefulSet
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.StatefulSet} StatefulSet
                 */
                StatefulSet.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.StatefulSet)
                        return object;
                    let message = new $root.clutch.k8s.v1.StatefulSet();
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.StatefulSet.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.StatefulSet.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                            message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                    }
                    if (object.status != null) {
                        if (typeof object.status !== "object")
                            throw TypeError(".clutch.k8s.v1.StatefulSet.status: object expected");
                        message.status = $root.clutch.k8s.v1.StatefulSet.Status.fromObject(object.status);
                    }
                    if (object.creationTimeMillis != null)
                        if ($util.Long)
                            (message.creationTimeMillis = $util.Long.fromValue(object.creationTimeMillis)).unsigned = false;
                        else if (typeof object.creationTimeMillis === "string")
                            message.creationTimeMillis = parseInt(object.creationTimeMillis, 10);
                        else if (typeof object.creationTimeMillis === "number")
                            message.creationTimeMillis = object.creationTimeMillis;
                        else if (typeof object.creationTimeMillis === "object")
                            message.creationTimeMillis = new $util.LongBits(object.creationTimeMillis.low >>> 0, object.creationTimeMillis.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a StatefulSet message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.StatefulSet
                 * @static
                 * @param {clutch.k8s.v1.StatefulSet} message StatefulSet
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StatefulSet.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.labels = {};
                        object.annotations = {};
                    }
                    if (options.defaults) {
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.status = null;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.creationTimeMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.creationTimeMillis = options.longs === String ? "0" : 0;
                    }
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = message.annotations[keys2[j]];
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = $root.clutch.k8s.v1.StatefulSet.Status.toObject(message.status, options);
                    if (message.creationTimeMillis != null && message.hasOwnProperty("creationTimeMillis"))
                        if (typeof message.creationTimeMillis === "number")
                            object.creationTimeMillis = options.longs === String ? String(message.creationTimeMillis) : message.creationTimeMillis;
                        else
                            object.creationTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.creationTimeMillis) : options.longs === Number ? new $util.LongBits(message.creationTimeMillis.low >>> 0, message.creationTimeMillis.high >>> 0).toNumber() : message.creationTimeMillis;
                    return object;
                };

                /**
                 * Converts this StatefulSet to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.StatefulSet
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StatefulSet.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                StatefulSet.Status = (function() {

                    /**
                     * Properties of a Status.
                     * @memberof clutch.k8s.v1.StatefulSet
                     * @interface IStatus
                     * @property {number|null} [replicas] Status replicas
                     * @property {number|null} [updatedReplicas] Status updatedReplicas
                     * @property {number|null} [readyReplicas] Status readyReplicas
                     */

                    /**
                     * Constructs a new Status.
                     * @memberof clutch.k8s.v1.StatefulSet
                     * @classdesc Represents a Status.
                     * @implements IStatus
                     * @constructor
                     * @param {clutch.k8s.v1.StatefulSet.IStatus=} [properties] Properties to set
                     */
                    function Status(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Status replicas.
                     * @member {number} replicas
                     * @memberof clutch.k8s.v1.StatefulSet.Status
                     * @instance
                     */
                    Status.prototype.replicas = 0;

                    /**
                     * Status updatedReplicas.
                     * @member {number} updatedReplicas
                     * @memberof clutch.k8s.v1.StatefulSet.Status
                     * @instance
                     */
                    Status.prototype.updatedReplicas = 0;

                    /**
                     * Status readyReplicas.
                     * @member {number} readyReplicas
                     * @memberof clutch.k8s.v1.StatefulSet.Status
                     * @instance
                     */
                    Status.prototype.readyReplicas = 0;

                    /**
                     * Verifies a Status message.
                     * @function verify
                     * @memberof clutch.k8s.v1.StatefulSet.Status
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Status.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.replicas != null && message.hasOwnProperty("replicas"))
                            if (!$util.isInteger(message.replicas))
                                return "replicas: integer expected";
                        if (message.updatedReplicas != null && message.hasOwnProperty("updatedReplicas"))
                            if (!$util.isInteger(message.updatedReplicas))
                                return "updatedReplicas: integer expected";
                        if (message.readyReplicas != null && message.hasOwnProperty("readyReplicas"))
                            if (!$util.isInteger(message.readyReplicas))
                                return "readyReplicas: integer expected";
                        return null;
                    };

                    /**
                     * Creates a Status message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.k8s.v1.StatefulSet.Status
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.k8s.v1.StatefulSet.Status} Status
                     */
                    Status.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.k8s.v1.StatefulSet.Status)
                            return object;
                        let message = new $root.clutch.k8s.v1.StatefulSet.Status();
                        if (object.replicas != null)
                            message.replicas = object.replicas >>> 0;
                        if (object.updatedReplicas != null)
                            message.updatedReplicas = object.updatedReplicas >>> 0;
                        if (object.readyReplicas != null)
                            message.readyReplicas = object.readyReplicas >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a Status message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.k8s.v1.StatefulSet.Status
                     * @static
                     * @param {clutch.k8s.v1.StatefulSet.Status} message Status
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Status.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.replicas = 0;
                            object.updatedReplicas = 0;
                            object.readyReplicas = 0;
                        }
                        if (message.replicas != null && message.hasOwnProperty("replicas"))
                            object.replicas = message.replicas;
                        if (message.updatedReplicas != null && message.hasOwnProperty("updatedReplicas"))
                            object.updatedReplicas = message.updatedReplicas;
                        if (message.readyReplicas != null && message.hasOwnProperty("readyReplicas"))
                            object.readyReplicas = message.readyReplicas;
                        return object;
                    };

                    /**
                     * Converts this Status to JSON.
                     * @function toJSON
                     * @memberof clutch.k8s.v1.StatefulSet.Status
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Status.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Status;
                })();

                return StatefulSet;
            })();

            v1.DescribeStatefulSetRequest = (function() {

                /**
                 * Properties of a DescribeStatefulSetRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribeStatefulSetRequest
                 * @property {string|null} [clientset] DescribeStatefulSetRequest clientset
                 * @property {string|null} [cluster] DescribeStatefulSetRequest cluster
                 * @property {string|null} [namespace] DescribeStatefulSetRequest namespace
                 * @property {string|null} [name] DescribeStatefulSetRequest name
                 */

                /**
                 * Constructs a new DescribeStatefulSetRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribeStatefulSetRequest.
                 * @implements IDescribeStatefulSetRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribeStatefulSetRequest=} [properties] Properties to set
                 */
                function DescribeStatefulSetRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeStatefulSetRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DescribeStatefulSetRequest
                 * @instance
                 */
                DescribeStatefulSetRequest.prototype.clientset = "";

                /**
                 * DescribeStatefulSetRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DescribeStatefulSetRequest
                 * @instance
                 */
                DescribeStatefulSetRequest.prototype.cluster = "";

                /**
                 * DescribeStatefulSetRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DescribeStatefulSetRequest
                 * @instance
                 */
                DescribeStatefulSetRequest.prototype.namespace = "";

                /**
                 * DescribeStatefulSetRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DescribeStatefulSetRequest
                 * @instance
                 */
                DescribeStatefulSetRequest.prototype.name = "";

                /**
                 * Verifies a DescribeStatefulSetRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribeStatefulSetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeStatefulSetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DescribeStatefulSetRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribeStatefulSetRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribeStatefulSetRequest} DescribeStatefulSetRequest
                 */
                DescribeStatefulSetRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribeStatefulSetRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribeStatefulSetRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeStatefulSetRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribeStatefulSetRequest
                 * @static
                 * @param {clutch.k8s.v1.DescribeStatefulSetRequest} message DescribeStatefulSetRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeStatefulSetRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DescribeStatefulSetRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribeStatefulSetRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeStatefulSetRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeStatefulSetRequest;
            })();

            v1.DescribeStatefulSetResponse = (function() {

                /**
                 * Properties of a DescribeStatefulSetResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribeStatefulSetResponse
                 * @property {clutch.k8s.v1.IStatefulSet|null} [statefulSet] DescribeStatefulSetResponse statefulSet
                 */

                /**
                 * Constructs a new DescribeStatefulSetResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribeStatefulSetResponse.
                 * @implements IDescribeStatefulSetResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribeStatefulSetResponse=} [properties] Properties to set
                 */
                function DescribeStatefulSetResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeStatefulSetResponse statefulSet.
                 * @member {clutch.k8s.v1.IStatefulSet|null|undefined} statefulSet
                 * @memberof clutch.k8s.v1.DescribeStatefulSetResponse
                 * @instance
                 */
                DescribeStatefulSetResponse.prototype.statefulSet = null;

                /**
                 * Verifies a DescribeStatefulSetResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribeStatefulSetResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeStatefulSetResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.statefulSet != null && message.hasOwnProperty("statefulSet")) {
                        let error = $root.clutch.k8s.v1.StatefulSet.verify(message.statefulSet);
                        if (error)
                            return "statefulSet." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DescribeStatefulSetResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribeStatefulSetResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribeStatefulSetResponse} DescribeStatefulSetResponse
                 */
                DescribeStatefulSetResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribeStatefulSetResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribeStatefulSetResponse();
                    if (object.statefulSet != null) {
                        if (typeof object.statefulSet !== "object")
                            throw TypeError(".clutch.k8s.v1.DescribeStatefulSetResponse.statefulSet: object expected");
                        message.statefulSet = $root.clutch.k8s.v1.StatefulSet.fromObject(object.statefulSet);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeStatefulSetResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribeStatefulSetResponse
                 * @static
                 * @param {clutch.k8s.v1.DescribeStatefulSetResponse} message DescribeStatefulSetResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeStatefulSetResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.statefulSet = null;
                    if (message.statefulSet != null && message.hasOwnProperty("statefulSet"))
                        object.statefulSet = $root.clutch.k8s.v1.StatefulSet.toObject(message.statefulSet, options);
                    return object;
                };

                /**
                 * Converts this DescribeStatefulSetResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribeStatefulSetResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeStatefulSetResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeStatefulSetResponse;
            })();

            v1.ListStatefulSetsRequest = (function() {

                /**
                 * Properties of a ListStatefulSetsRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IListStatefulSetsRequest
                 * @property {string|null} [clientset] ListStatefulSetsRequest clientset
                 * @property {string|null} [cluster] ListStatefulSetsRequest cluster
                 * @property {string|null} [namespace] ListStatefulSetsRequest namespace
                 * @property {clutch.k8s.v1.IListOptions|null} [options] ListStatefulSetsRequest options
                 */

                /**
                 * Constructs a new ListStatefulSetsRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListStatefulSetsRequest.
                 * @implements IListStatefulSetsRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IListStatefulSetsRequest=} [properties] Properties to set
                 */
                function ListStatefulSetsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListStatefulSetsRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.ListStatefulSetsRequest
                 * @instance
                 */
                ListStatefulSetsRequest.prototype.clientset = "";

                /**
                 * ListStatefulSetsRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.ListStatefulSetsRequest
                 * @instance
                 */
                ListStatefulSetsRequest.prototype.cluster = "";

                /**
                 * ListStatefulSetsRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.ListStatefulSetsRequest
                 * @instance
                 */
                ListStatefulSetsRequest.prototype.namespace = "";

                /**
                 * ListStatefulSetsRequest options.
                 * @member {clutch.k8s.v1.IListOptions|null|undefined} options
                 * @memberof clutch.k8s.v1.ListStatefulSetsRequest
                 * @instance
                 */
                ListStatefulSetsRequest.prototype.options = null;

                /**
                 * Verifies a ListStatefulSetsRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListStatefulSetsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListStatefulSetsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        let error = $root.clutch.k8s.v1.ListOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ListStatefulSetsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListStatefulSetsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListStatefulSetsRequest} ListStatefulSetsRequest
                 */
                ListStatefulSetsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListStatefulSetsRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListStatefulSetsRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".clutch.k8s.v1.ListStatefulSetsRequest.options: object expected");
                        message.options = $root.clutch.k8s.v1.ListOptions.fromObject(object.options);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListStatefulSetsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListStatefulSetsRequest
                 * @static
                 * @param {clutch.k8s.v1.ListStatefulSetsRequest} message ListStatefulSetsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListStatefulSetsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.options = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.clutch.k8s.v1.ListOptions.toObject(message.options, options);
                    return object;
                };

                /**
                 * Converts this ListStatefulSetsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListStatefulSetsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListStatefulSetsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListStatefulSetsRequest;
            })();

            v1.ListStatefulSetsResponse = (function() {

                /**
                 * Properties of a ListStatefulSetsResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IListStatefulSetsResponse
                 * @property {Array.<clutch.k8s.v1.IStatefulSet>|null} [statefulSets] ListStatefulSetsResponse statefulSets
                 */

                /**
                 * Constructs a new ListStatefulSetsResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListStatefulSetsResponse.
                 * @implements IListStatefulSetsResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IListStatefulSetsResponse=} [properties] Properties to set
                 */
                function ListStatefulSetsResponse(properties) {
                    this.statefulSets = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListStatefulSetsResponse statefulSets.
                 * @member {Array.<clutch.k8s.v1.IStatefulSet>} statefulSets
                 * @memberof clutch.k8s.v1.ListStatefulSetsResponse
                 * @instance
                 */
                ListStatefulSetsResponse.prototype.statefulSets = $util.emptyArray;

                /**
                 * Verifies a ListStatefulSetsResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListStatefulSetsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListStatefulSetsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.statefulSets != null && message.hasOwnProperty("statefulSets")) {
                        if (!Array.isArray(message.statefulSets))
                            return "statefulSets: array expected";
                        for (let i = 0; i < message.statefulSets.length; ++i) {
                            let error = $root.clutch.k8s.v1.StatefulSet.verify(message.statefulSets[i]);
                            if (error)
                                return "statefulSets." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ListStatefulSetsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListStatefulSetsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListStatefulSetsResponse} ListStatefulSetsResponse
                 */
                ListStatefulSetsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListStatefulSetsResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListStatefulSetsResponse();
                    if (object.statefulSets) {
                        if (!Array.isArray(object.statefulSets))
                            throw TypeError(".clutch.k8s.v1.ListStatefulSetsResponse.statefulSets: array expected");
                        message.statefulSets = [];
                        for (let i = 0; i < object.statefulSets.length; ++i) {
                            if (typeof object.statefulSets[i] !== "object")
                                throw TypeError(".clutch.k8s.v1.ListStatefulSetsResponse.statefulSets: object expected");
                            message.statefulSets[i] = $root.clutch.k8s.v1.StatefulSet.fromObject(object.statefulSets[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListStatefulSetsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListStatefulSetsResponse
                 * @static
                 * @param {clutch.k8s.v1.ListStatefulSetsResponse} message ListStatefulSetsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListStatefulSetsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.statefulSets = [];
                    if (message.statefulSets && message.statefulSets.length) {
                        object.statefulSets = [];
                        for (let j = 0; j < message.statefulSets.length; ++j)
                            object.statefulSets[j] = $root.clutch.k8s.v1.StatefulSet.toObject(message.statefulSets[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ListStatefulSetsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListStatefulSetsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListStatefulSetsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListStatefulSetsResponse;
            })();

            v1.DeleteStatefulSetRequest = (function() {

                /**
                 * Properties of a DeleteStatefulSetRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDeleteStatefulSetRequest
                 * @property {string|null} [clientset] DeleteStatefulSetRequest clientset
                 * @property {string|null} [cluster] DeleteStatefulSetRequest cluster
                 * @property {string|null} [namespace] DeleteStatefulSetRequest namespace
                 * @property {string|null} [name] DeleteStatefulSetRequest name
                 */

                /**
                 * Constructs a new DeleteStatefulSetRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeleteStatefulSetRequest.
                 * @implements IDeleteStatefulSetRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDeleteStatefulSetRequest=} [properties] Properties to set
                 */
                function DeleteStatefulSetRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeleteStatefulSetRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DeleteStatefulSetRequest
                 * @instance
                 */
                DeleteStatefulSetRequest.prototype.clientset = "";

                /**
                 * DeleteStatefulSetRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DeleteStatefulSetRequest
                 * @instance
                 */
                DeleteStatefulSetRequest.prototype.cluster = "";

                /**
                 * DeleteStatefulSetRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DeleteStatefulSetRequest
                 * @instance
                 */
                DeleteStatefulSetRequest.prototype.namespace = "";

                /**
                 * DeleteStatefulSetRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DeleteStatefulSetRequest
                 * @instance
                 */
                DeleteStatefulSetRequest.prototype.name = "";

                /**
                 * Verifies a DeleteStatefulSetRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeleteStatefulSetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteStatefulSetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DeleteStatefulSetRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeleteStatefulSetRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeleteStatefulSetRequest} DeleteStatefulSetRequest
                 */
                DeleteStatefulSetRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeleteStatefulSetRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DeleteStatefulSetRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DeleteStatefulSetRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeleteStatefulSetRequest
                 * @static
                 * @param {clutch.k8s.v1.DeleteStatefulSetRequest} message DeleteStatefulSetRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteStatefulSetRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DeleteStatefulSetRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeleteStatefulSetRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteStatefulSetRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteStatefulSetRequest;
            })();

            v1.DeleteStatefulSetResponse = (function() {

                /**
                 * Properties of a DeleteStatefulSetResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDeleteStatefulSetResponse
                 */

                /**
                 * Constructs a new DeleteStatefulSetResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeleteStatefulSetResponse.
                 * @implements IDeleteStatefulSetResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDeleteStatefulSetResponse=} [properties] Properties to set
                 */
                function DeleteStatefulSetResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a DeleteStatefulSetResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeleteStatefulSetResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteStatefulSetResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a DeleteStatefulSetResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeleteStatefulSetResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeleteStatefulSetResponse} DeleteStatefulSetResponse
                 */
                DeleteStatefulSetResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeleteStatefulSetResponse)
                        return object;
                    return new $root.clutch.k8s.v1.DeleteStatefulSetResponse();
                };

                /**
                 * Creates a plain object from a DeleteStatefulSetResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeleteStatefulSetResponse
                 * @static
                 * @param {clutch.k8s.v1.DeleteStatefulSetResponse} message DeleteStatefulSetResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteStatefulSetResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this DeleteStatefulSetResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeleteStatefulSetResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteStatefulSetResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteStatefulSetResponse;
            })();

            v1.UpdateStatefulSetRequest = (function() {

                /**
                 * Properties of an UpdateStatefulSetRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IUpdateStatefulSetRequest
                 * @property {string|null} [clientset] UpdateStatefulSetRequest clientset
                 * @property {string|null} [cluster] UpdateStatefulSetRequest cluster
                 * @property {string|null} [namespace] UpdateStatefulSetRequest namespace
                 * @property {string|null} [name] UpdateStatefulSetRequest name
                 * @property {clutch.k8s.v1.UpdateStatefulSetRequest.IFields|null} [fields] UpdateStatefulSetRequest fields
                 */

                /**
                 * Constructs a new UpdateStatefulSetRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an UpdateStatefulSetRequest.
                 * @implements IUpdateStatefulSetRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IUpdateStatefulSetRequest=} [properties] Properties to set
                 */
                function UpdateStatefulSetRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdateStatefulSetRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.UpdateStatefulSetRequest
                 * @instance
                 */
                UpdateStatefulSetRequest.prototype.clientset = "";

                /**
                 * UpdateStatefulSetRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.UpdateStatefulSetRequest
                 * @instance
                 */
                UpdateStatefulSetRequest.prototype.cluster = "";

                /**
                 * UpdateStatefulSetRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.UpdateStatefulSetRequest
                 * @instance
                 */
                UpdateStatefulSetRequest.prototype.namespace = "";

                /**
                 * UpdateStatefulSetRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.UpdateStatefulSetRequest
                 * @instance
                 */
                UpdateStatefulSetRequest.prototype.name = "";

                /**
                 * UpdateStatefulSetRequest fields.
                 * @member {clutch.k8s.v1.UpdateStatefulSetRequest.IFields|null|undefined} fields
                 * @memberof clutch.k8s.v1.UpdateStatefulSetRequest
                 * @instance
                 */
                UpdateStatefulSetRequest.prototype.fields = null;

                /**
                 * Verifies an UpdateStatefulSetRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.UpdateStatefulSetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateStatefulSetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.fields != null && message.hasOwnProperty("fields")) {
                        let error = $root.clutch.k8s.v1.UpdateStatefulSetRequest.Fields.verify(message.fields);
                        if (error)
                            return "fields." + error;
                    }
                    return null;
                };

                /**
                 * Creates an UpdateStatefulSetRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.UpdateStatefulSetRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.UpdateStatefulSetRequest} UpdateStatefulSetRequest
                 */
                UpdateStatefulSetRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.UpdateStatefulSetRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.UpdateStatefulSetRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.fields != null) {
                        if (typeof object.fields !== "object")
                            throw TypeError(".clutch.k8s.v1.UpdateStatefulSetRequest.fields: object expected");
                        message.fields = $root.clutch.k8s.v1.UpdateStatefulSetRequest.Fields.fromObject(object.fields);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an UpdateStatefulSetRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.UpdateStatefulSetRequest
                 * @static
                 * @param {clutch.k8s.v1.UpdateStatefulSetRequest} message UpdateStatefulSetRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateStatefulSetRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.fields = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.fields != null && message.hasOwnProperty("fields"))
                        object.fields = $root.clutch.k8s.v1.UpdateStatefulSetRequest.Fields.toObject(message.fields, options);
                    return object;
                };

                /**
                 * Converts this UpdateStatefulSetRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.UpdateStatefulSetRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateStatefulSetRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                UpdateStatefulSetRequest.Fields = (function() {

                    /**
                     * Properties of a Fields.
                     * @memberof clutch.k8s.v1.UpdateStatefulSetRequest
                     * @interface IFields
                     * @property {Object.<string,string>|null} [labels] Fields labels
                     * @property {Object.<string,string>|null} [annotations] Fields annotations
                     */

                    /**
                     * Constructs a new Fields.
                     * @memberof clutch.k8s.v1.UpdateStatefulSetRequest
                     * @classdesc Represents a Fields.
                     * @implements IFields
                     * @constructor
                     * @param {clutch.k8s.v1.UpdateStatefulSetRequest.IFields=} [properties] Properties to set
                     */
                    function Fields(properties) {
                        this.labels = {};
                        this.annotations = {};
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Fields labels.
                     * @member {Object.<string,string>} labels
                     * @memberof clutch.k8s.v1.UpdateStatefulSetRequest.Fields
                     * @instance
                     */
                    Fields.prototype.labels = $util.emptyObject;

                    /**
                     * Fields annotations.
                     * @member {Object.<string,string>} annotations
                     * @memberof clutch.k8s.v1.UpdateStatefulSetRequest.Fields
                     * @instance
                     */
                    Fields.prototype.annotations = $util.emptyObject;

                    /**
                     * Verifies a Fields message.
                     * @function verify
                     * @memberof clutch.k8s.v1.UpdateStatefulSetRequest.Fields
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Fields.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.labels != null && message.hasOwnProperty("labels")) {
                            if (!$util.isObject(message.labels))
                                return "labels: object expected";
                            let key = Object.keys(message.labels);
                            for (let i = 0; i < key.length; ++i)
                                if (!$util.isString(message.labels[key[i]]))
                                    return "labels: string{k:string} expected";
                        }
                        if (message.annotations != null && message.hasOwnProperty("annotations")) {
                            if (!$util.isObject(message.annotations))
                                return "annotations: object expected";
                            let key = Object.keys(message.annotations);
                            for (let i = 0; i < key.length; ++i)
                                if (!$util.isString(message.annotations[key[i]]))
                                    return "annotations: string{k:string} expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Fields message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.k8s.v1.UpdateStatefulSetRequest.Fields
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.k8s.v1.UpdateStatefulSetRequest.Fields} Fields
                     */
                    Fields.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.k8s.v1.UpdateStatefulSetRequest.Fields)
                            return object;
                        let message = new $root.clutch.k8s.v1.UpdateStatefulSetRequest.Fields();
                        if (object.labels) {
                            if (typeof object.labels !== "object")
                                throw TypeError(".clutch.k8s.v1.UpdateStatefulSetRequest.Fields.labels: object expected");
                            message.labels = {};
                            for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                                message.labels[keys[i]] = String(object.labels[keys[i]]);
                        }
                        if (object.annotations) {
                            if (typeof object.annotations !== "object")
                                throw TypeError(".clutch.k8s.v1.UpdateStatefulSetRequest.Fields.annotations: object expected");
                            message.annotations = {};
                            for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                                message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Fields message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.k8s.v1.UpdateStatefulSetRequest.Fields
                     * @static
                     * @param {clutch.k8s.v1.UpdateStatefulSetRequest.Fields} message Fields
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Fields.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.objects || options.defaults) {
                            object.labels = {};
                            object.annotations = {};
                        }
                        let keys2;
                        if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                            object.labels = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.labels[keys2[j]] = message.labels[keys2[j]];
                        }
                        if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                            object.annotations = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.annotations[keys2[j]] = message.annotations[keys2[j]];
                        }
                        return object;
                    };

                    /**
                     * Converts this Fields to JSON.
                     * @function toJSON
                     * @memberof clutch.k8s.v1.UpdateStatefulSetRequest.Fields
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Fields.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Fields;
                })();

                return UpdateStatefulSetRequest;
            })();

            v1.UpdateStatefulSetResponse = (function() {

                /**
                 * Properties of an UpdateStatefulSetResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IUpdateStatefulSetResponse
                 */

                /**
                 * Constructs a new UpdateStatefulSetResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an UpdateStatefulSetResponse.
                 * @implements IUpdateStatefulSetResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IUpdateStatefulSetResponse=} [properties] Properties to set
                 */
                function UpdateStatefulSetResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies an UpdateStatefulSetResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.UpdateStatefulSetResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateStatefulSetResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an UpdateStatefulSetResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.UpdateStatefulSetResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.UpdateStatefulSetResponse} UpdateStatefulSetResponse
                 */
                UpdateStatefulSetResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.UpdateStatefulSetResponse)
                        return object;
                    return new $root.clutch.k8s.v1.UpdateStatefulSetResponse();
                };

                /**
                 * Creates a plain object from an UpdateStatefulSetResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.UpdateStatefulSetResponse
                 * @static
                 * @param {clutch.k8s.v1.UpdateStatefulSetResponse} message UpdateStatefulSetResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateStatefulSetResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this UpdateStatefulSetResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.UpdateStatefulSetResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateStatefulSetResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdateStatefulSetResponse;
            })();

            v1.Service = (function() {

                /**
                 * Properties of a Service.
                 * @memberof clutch.k8s.v1
                 * @interface IService
                 * @property {string|null} [cluster] Service cluster
                 * @property {string|null} [namespace] Service namespace
                 * @property {string|null} [name] Service name
                 * @property {clutch.k8s.v1.Service.Type|null} [type] Service type
                 * @property {Object.<string,string>|null} [labels] Service labels
                 * @property {Object.<string,string>|null} [annotations] Service annotations
                 * @property {Object.<string,string>|null} [selector] Service selector
                 */

                /**
                 * Constructs a new Service.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a Service.
                 * @implements IService
                 * @constructor
                 * @param {clutch.k8s.v1.IService=} [properties] Properties to set
                 */
                function Service(properties) {
                    this.labels = {};
                    this.annotations = {};
                    this.selector = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Service cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.Service
                 * @instance
                 */
                Service.prototype.cluster = "";

                /**
                 * Service namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.Service
                 * @instance
                 */
                Service.prototype.namespace = "";

                /**
                 * Service name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.Service
                 * @instance
                 */
                Service.prototype.name = "";

                /**
                 * Service type.
                 * @member {clutch.k8s.v1.Service.Type} type
                 * @memberof clutch.k8s.v1.Service
                 * @instance
                 */
                Service.prototype.type = 0;

                /**
                 * Service labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.Service
                 * @instance
                 */
                Service.prototype.labels = $util.emptyObject;

                /**
                 * Service annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof clutch.k8s.v1.Service
                 * @instance
                 */
                Service.prototype.annotations = $util.emptyObject;

                /**
                 * Service selector.
                 * @member {Object.<string,string>} selector
                 * @memberof clutch.k8s.v1.Service
                 * @instance
                 */
                Service.prototype.selector = $util.emptyObject;

                /**
                 * Verifies a Service message.
                 * @function verify
                 * @memberof clutch.k8s.v1.Service
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Service.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    if (message.selector != null && message.hasOwnProperty("selector")) {
                        if (!$util.isObject(message.selector))
                            return "selector: object expected";
                        let key = Object.keys(message.selector);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.selector[key[i]]))
                                return "selector: string{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates a Service message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.Service
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.Service} Service
                 */
                Service.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.Service)
                        return object;
                    let message = new $root.clutch.k8s.v1.Service();
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    switch (object.type) {
                    case "UNSPECIFIED":
                    case 0:
                        message.type = 0;
                        break;
                    case "UNKNOWN":
                    case 1:
                        message.type = 1;
                        break;
                    case "CLUSTER_IP":
                    case 2:
                        message.type = 2;
                        break;
                    case "NODE_PORT":
                    case 3:
                        message.type = 3;
                        break;
                    case "LOAD_BALANCER":
                    case 4:
                        message.type = 4;
                        break;
                    case "EXTERNAL_NAME":
                    case 5:
                        message.type = 5;
                        break;
                    }
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.Service.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.Service.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                            message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                    }
                    if (object.selector) {
                        if (typeof object.selector !== "object")
                            throw TypeError(".clutch.k8s.v1.Service.selector: object expected");
                        message.selector = {};
                        for (let keys = Object.keys(object.selector), i = 0; i < keys.length; ++i)
                            message.selector[keys[i]] = String(object.selector[keys[i]]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Service message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.Service
                 * @static
                 * @param {clutch.k8s.v1.Service} message Service
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Service.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.labels = {};
                        object.annotations = {};
                        object.selector = {};
                    }
                    if (options.defaults) {
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    }
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.clutch.k8s.v1.Service.Type[message.type] : message.type;
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = message.annotations[keys2[j]];
                    }
                    if (message.selector && (keys2 = Object.keys(message.selector)).length) {
                        object.selector = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.selector[keys2[j]] = message.selector[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Converts this Service to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.Service
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Service.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Type enum.
                 * @name clutch.k8s.v1.Service.Type
                 * @enum {number}
                 * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                 * @property {number} UNKNOWN=1 UNKNOWN value
                 * @property {number} CLUSTER_IP=2 CLUSTER_IP value
                 * @property {number} NODE_PORT=3 NODE_PORT value
                 * @property {number} LOAD_BALANCER=4 LOAD_BALANCER value
                 * @property {number} EXTERNAL_NAME=5 EXTERNAL_NAME value
                 */
                Service.Type = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNSPECIFIED"] = 0;
                    values[valuesById[1] = "UNKNOWN"] = 1;
                    values[valuesById[2] = "CLUSTER_IP"] = 2;
                    values[valuesById[3] = "NODE_PORT"] = 3;
                    values[valuesById[4] = "LOAD_BALANCER"] = 4;
                    values[valuesById[5] = "EXTERNAL_NAME"] = 5;
                    return values;
                })();

                return Service;
            })();

            v1.DescribeServiceRequest = (function() {

                /**
                 * Properties of a DescribeServiceRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribeServiceRequest
                 * @property {string|null} [clientset] DescribeServiceRequest clientset
                 * @property {string|null} [cluster] DescribeServiceRequest cluster
                 * @property {string|null} [namespace] DescribeServiceRequest namespace
                 * @property {string|null} [name] DescribeServiceRequest name
                 */

                /**
                 * Constructs a new DescribeServiceRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribeServiceRequest.
                 * @implements IDescribeServiceRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribeServiceRequest=} [properties] Properties to set
                 */
                function DescribeServiceRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeServiceRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DescribeServiceRequest
                 * @instance
                 */
                DescribeServiceRequest.prototype.clientset = "";

                /**
                 * DescribeServiceRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DescribeServiceRequest
                 * @instance
                 */
                DescribeServiceRequest.prototype.cluster = "";

                /**
                 * DescribeServiceRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DescribeServiceRequest
                 * @instance
                 */
                DescribeServiceRequest.prototype.namespace = "";

                /**
                 * DescribeServiceRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DescribeServiceRequest
                 * @instance
                 */
                DescribeServiceRequest.prototype.name = "";

                /**
                 * Verifies a DescribeServiceRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribeServiceRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeServiceRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DescribeServiceRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribeServiceRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribeServiceRequest} DescribeServiceRequest
                 */
                DescribeServiceRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribeServiceRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribeServiceRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeServiceRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribeServiceRequest
                 * @static
                 * @param {clutch.k8s.v1.DescribeServiceRequest} message DescribeServiceRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeServiceRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DescribeServiceRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribeServiceRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeServiceRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeServiceRequest;
            })();

            v1.DescribeServiceResponse = (function() {

                /**
                 * Properties of a DescribeServiceResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribeServiceResponse
                 * @property {clutch.k8s.v1.IService|null} [service] DescribeServiceResponse service
                 */

                /**
                 * Constructs a new DescribeServiceResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribeServiceResponse.
                 * @implements IDescribeServiceResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribeServiceResponse=} [properties] Properties to set
                 */
                function DescribeServiceResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeServiceResponse service.
                 * @member {clutch.k8s.v1.IService|null|undefined} service
                 * @memberof clutch.k8s.v1.DescribeServiceResponse
                 * @instance
                 */
                DescribeServiceResponse.prototype.service = null;

                /**
                 * Verifies a DescribeServiceResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribeServiceResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeServiceResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.service != null && message.hasOwnProperty("service")) {
                        let error = $root.clutch.k8s.v1.Service.verify(message.service);
                        if (error)
                            return "service." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DescribeServiceResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribeServiceResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribeServiceResponse} DescribeServiceResponse
                 */
                DescribeServiceResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribeServiceResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribeServiceResponse();
                    if (object.service != null) {
                        if (typeof object.service !== "object")
                            throw TypeError(".clutch.k8s.v1.DescribeServiceResponse.service: object expected");
                        message.service = $root.clutch.k8s.v1.Service.fromObject(object.service);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeServiceResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribeServiceResponse
                 * @static
                 * @param {clutch.k8s.v1.DescribeServiceResponse} message DescribeServiceResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeServiceResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.service = null;
                    if (message.service != null && message.hasOwnProperty("service"))
                        object.service = $root.clutch.k8s.v1.Service.toObject(message.service, options);
                    return object;
                };

                /**
                 * Converts this DescribeServiceResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribeServiceResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeServiceResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeServiceResponse;
            })();

            v1.ListServicesRequest = (function() {

                /**
                 * Properties of a ListServicesRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IListServicesRequest
                 * @property {string|null} [clientset] ListServicesRequest clientset
                 * @property {string|null} [cluster] ListServicesRequest cluster
                 * @property {string|null} [namespace] ListServicesRequest namespace
                 * @property {clutch.k8s.v1.IListOptions|null} [options] ListServicesRequest options
                 */

                /**
                 * Constructs a new ListServicesRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListServicesRequest.
                 * @implements IListServicesRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IListServicesRequest=} [properties] Properties to set
                 */
                function ListServicesRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListServicesRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.ListServicesRequest
                 * @instance
                 */
                ListServicesRequest.prototype.clientset = "";

                /**
                 * ListServicesRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.ListServicesRequest
                 * @instance
                 */
                ListServicesRequest.prototype.cluster = "";

                /**
                 * ListServicesRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.ListServicesRequest
                 * @instance
                 */
                ListServicesRequest.prototype.namespace = "";

                /**
                 * ListServicesRequest options.
                 * @member {clutch.k8s.v1.IListOptions|null|undefined} options
                 * @memberof clutch.k8s.v1.ListServicesRequest
                 * @instance
                 */
                ListServicesRequest.prototype.options = null;

                /**
                 * Verifies a ListServicesRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListServicesRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListServicesRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        let error = $root.clutch.k8s.v1.ListOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ListServicesRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListServicesRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListServicesRequest} ListServicesRequest
                 */
                ListServicesRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListServicesRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListServicesRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".clutch.k8s.v1.ListServicesRequest.options: object expected");
                        message.options = $root.clutch.k8s.v1.ListOptions.fromObject(object.options);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListServicesRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListServicesRequest
                 * @static
                 * @param {clutch.k8s.v1.ListServicesRequest} message ListServicesRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListServicesRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.options = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.clutch.k8s.v1.ListOptions.toObject(message.options, options);
                    return object;
                };

                /**
                 * Converts this ListServicesRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListServicesRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListServicesRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListServicesRequest;
            })();

            v1.ListServicesResponse = (function() {

                /**
                 * Properties of a ListServicesResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IListServicesResponse
                 * @property {Array.<clutch.k8s.v1.IService>|null} [services] ListServicesResponse services
                 */

                /**
                 * Constructs a new ListServicesResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListServicesResponse.
                 * @implements IListServicesResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IListServicesResponse=} [properties] Properties to set
                 */
                function ListServicesResponse(properties) {
                    this.services = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListServicesResponse services.
                 * @member {Array.<clutch.k8s.v1.IService>} services
                 * @memberof clutch.k8s.v1.ListServicesResponse
                 * @instance
                 */
                ListServicesResponse.prototype.services = $util.emptyArray;

                /**
                 * Verifies a ListServicesResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListServicesResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListServicesResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.services != null && message.hasOwnProperty("services")) {
                        if (!Array.isArray(message.services))
                            return "services: array expected";
                        for (let i = 0; i < message.services.length; ++i) {
                            let error = $root.clutch.k8s.v1.Service.verify(message.services[i]);
                            if (error)
                                return "services." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ListServicesResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListServicesResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListServicesResponse} ListServicesResponse
                 */
                ListServicesResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListServicesResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListServicesResponse();
                    if (object.services) {
                        if (!Array.isArray(object.services))
                            throw TypeError(".clutch.k8s.v1.ListServicesResponse.services: array expected");
                        message.services = [];
                        for (let i = 0; i < object.services.length; ++i) {
                            if (typeof object.services[i] !== "object")
                                throw TypeError(".clutch.k8s.v1.ListServicesResponse.services: object expected");
                            message.services[i] = $root.clutch.k8s.v1.Service.fromObject(object.services[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListServicesResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListServicesResponse
                 * @static
                 * @param {clutch.k8s.v1.ListServicesResponse} message ListServicesResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListServicesResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.services = [];
                    if (message.services && message.services.length) {
                        object.services = [];
                        for (let j = 0; j < message.services.length; ++j)
                            object.services[j] = $root.clutch.k8s.v1.Service.toObject(message.services[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ListServicesResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListServicesResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListServicesResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListServicesResponse;
            })();

            v1.DeleteServiceRequest = (function() {

                /**
                 * Properties of a DeleteServiceRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDeleteServiceRequest
                 * @property {string|null} [clientset] DeleteServiceRequest clientset
                 * @property {string|null} [cluster] DeleteServiceRequest cluster
                 * @property {string|null} [namespace] DeleteServiceRequest namespace
                 * @property {string|null} [name] DeleteServiceRequest name
                 */

                /**
                 * Constructs a new DeleteServiceRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeleteServiceRequest.
                 * @implements IDeleteServiceRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDeleteServiceRequest=} [properties] Properties to set
                 */
                function DeleteServiceRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeleteServiceRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DeleteServiceRequest
                 * @instance
                 */
                DeleteServiceRequest.prototype.clientset = "";

                /**
                 * DeleteServiceRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DeleteServiceRequest
                 * @instance
                 */
                DeleteServiceRequest.prototype.cluster = "";

                /**
                 * DeleteServiceRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DeleteServiceRequest
                 * @instance
                 */
                DeleteServiceRequest.prototype.namespace = "";

                /**
                 * DeleteServiceRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DeleteServiceRequest
                 * @instance
                 */
                DeleteServiceRequest.prototype.name = "";

                /**
                 * Verifies a DeleteServiceRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeleteServiceRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteServiceRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DeleteServiceRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeleteServiceRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeleteServiceRequest} DeleteServiceRequest
                 */
                DeleteServiceRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeleteServiceRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DeleteServiceRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DeleteServiceRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeleteServiceRequest
                 * @static
                 * @param {clutch.k8s.v1.DeleteServiceRequest} message DeleteServiceRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteServiceRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DeleteServiceRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeleteServiceRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteServiceRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteServiceRequest;
            })();

            v1.DeleteServiceResponse = (function() {

                /**
                 * Properties of a DeleteServiceResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDeleteServiceResponse
                 */

                /**
                 * Constructs a new DeleteServiceResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeleteServiceResponse.
                 * @implements IDeleteServiceResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDeleteServiceResponse=} [properties] Properties to set
                 */
                function DeleteServiceResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a DeleteServiceResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeleteServiceResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteServiceResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a DeleteServiceResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeleteServiceResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeleteServiceResponse} DeleteServiceResponse
                 */
                DeleteServiceResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeleteServiceResponse)
                        return object;
                    return new $root.clutch.k8s.v1.DeleteServiceResponse();
                };

                /**
                 * Creates a plain object from a DeleteServiceResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeleteServiceResponse
                 * @static
                 * @param {clutch.k8s.v1.DeleteServiceResponse} message DeleteServiceResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteServiceResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this DeleteServiceResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeleteServiceResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteServiceResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteServiceResponse;
            })();

            v1.CronJob = (function() {

                /**
                 * Properties of a CronJob.
                 * @memberof clutch.k8s.v1
                 * @interface ICronJob
                 * @property {string|null} [cluster] CronJob cluster
                 * @property {string|null} [namespace] CronJob namespace
                 * @property {string|null} [name] CronJob name
                 * @property {string|null} [schedule] CronJob schedule
                 * @property {Object.<string,string>|null} [labels] CronJob labels
                 * @property {Object.<string,string>|null} [annotations] CronJob annotations
                 * @property {boolean|null} [suspend] CronJob suspend
                 * @property {number|null} [numActiveJobs] CronJob numActiveJobs
                 * @property {clutch.k8s.v1.CronJob.ConcurrencyPolicy|null} [concurrencyPolicy] CronJob concurrencyPolicy
                 * @property {google.protobuf.IInt64Value|null} [startingDeadlineSeconds] CronJob startingDeadlineSeconds
                 */

                /**
                 * Constructs a new CronJob.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a CronJob.
                 * @implements ICronJob
                 * @constructor
                 * @param {clutch.k8s.v1.ICronJob=} [properties] Properties to set
                 */
                function CronJob(properties) {
                    this.labels = {};
                    this.annotations = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CronJob cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.CronJob
                 * @instance
                 */
                CronJob.prototype.cluster = "";

                /**
                 * CronJob namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.CronJob
                 * @instance
                 */
                CronJob.prototype.namespace = "";

                /**
                 * CronJob name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.CronJob
                 * @instance
                 */
                CronJob.prototype.name = "";

                /**
                 * CronJob schedule.
                 * @member {string} schedule
                 * @memberof clutch.k8s.v1.CronJob
                 * @instance
                 */
                CronJob.prototype.schedule = "";

                /**
                 * CronJob labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.CronJob
                 * @instance
                 */
                CronJob.prototype.labels = $util.emptyObject;

                /**
                 * CronJob annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof clutch.k8s.v1.CronJob
                 * @instance
                 */
                CronJob.prototype.annotations = $util.emptyObject;

                /**
                 * CronJob suspend.
                 * @member {boolean} suspend
                 * @memberof clutch.k8s.v1.CronJob
                 * @instance
                 */
                CronJob.prototype.suspend = false;

                /**
                 * CronJob numActiveJobs.
                 * @member {number} numActiveJobs
                 * @memberof clutch.k8s.v1.CronJob
                 * @instance
                 */
                CronJob.prototype.numActiveJobs = 0;

                /**
                 * CronJob concurrencyPolicy.
                 * @member {clutch.k8s.v1.CronJob.ConcurrencyPolicy} concurrencyPolicy
                 * @memberof clutch.k8s.v1.CronJob
                 * @instance
                 */
                CronJob.prototype.concurrencyPolicy = 0;

                /**
                 * CronJob startingDeadlineSeconds.
                 * @member {google.protobuf.IInt64Value|null|undefined} startingDeadlineSeconds
                 * @memberof clutch.k8s.v1.CronJob
                 * @instance
                 */
                CronJob.prototype.startingDeadlineSeconds = null;

                /**
                 * Verifies a CronJob message.
                 * @function verify
                 * @memberof clutch.k8s.v1.CronJob
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CronJob.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.schedule != null && message.hasOwnProperty("schedule"))
                        if (!$util.isString(message.schedule))
                            return "schedule: string expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    if (message.suspend != null && message.hasOwnProperty("suspend"))
                        if (typeof message.suspend !== "boolean")
                            return "suspend: boolean expected";
                    if (message.numActiveJobs != null && message.hasOwnProperty("numActiveJobs"))
                        if (!$util.isInteger(message.numActiveJobs))
                            return "numActiveJobs: integer expected";
                    if (message.concurrencyPolicy != null && message.hasOwnProperty("concurrencyPolicy"))
                        switch (message.concurrencyPolicy) {
                        default:
                            return "concurrencyPolicy: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.startingDeadlineSeconds != null && message.hasOwnProperty("startingDeadlineSeconds")) {
                        let error = $root.google.protobuf.Int64Value.verify(message.startingDeadlineSeconds);
                        if (error)
                            return "startingDeadlineSeconds." + error;
                    }
                    return null;
                };

                /**
                 * Creates a CronJob message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.CronJob
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.CronJob} CronJob
                 */
                CronJob.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.CronJob)
                        return object;
                    let message = new $root.clutch.k8s.v1.CronJob();
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.schedule != null)
                        message.schedule = String(object.schedule);
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.CronJob.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.CronJob.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                            message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                    }
                    if (object.suspend != null)
                        message.suspend = Boolean(object.suspend);
                    if (object.numActiveJobs != null)
                        message.numActiveJobs = object.numActiveJobs | 0;
                    switch (object.concurrencyPolicy) {
                    case "UNSPECIFIED":
                    case 0:
                        message.concurrencyPolicy = 0;
                        break;
                    case "UNKNOWN":
                    case 1:
                        message.concurrencyPolicy = 1;
                        break;
                    case "ALLOW":
                    case 2:
                        message.concurrencyPolicy = 2;
                        break;
                    case "FORBID":
                    case 3:
                        message.concurrencyPolicy = 3;
                        break;
                    case "REPLACE":
                    case 4:
                        message.concurrencyPolicy = 4;
                        break;
                    }
                    if (object.startingDeadlineSeconds != null) {
                        if (typeof object.startingDeadlineSeconds !== "object")
                            throw TypeError(".clutch.k8s.v1.CronJob.startingDeadlineSeconds: object expected");
                        message.startingDeadlineSeconds = $root.google.protobuf.Int64Value.fromObject(object.startingDeadlineSeconds);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CronJob message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.CronJob
                 * @static
                 * @param {clutch.k8s.v1.CronJob} message CronJob
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CronJob.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.labels = {};
                        object.annotations = {};
                    }
                    if (options.defaults) {
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.schedule = "";
                        object.suspend = false;
                        object.numActiveJobs = 0;
                        object.concurrencyPolicy = options.enums === String ? "UNSPECIFIED" : 0;
                        object.startingDeadlineSeconds = null;
                    }
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.schedule != null && message.hasOwnProperty("schedule"))
                        object.schedule = message.schedule;
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = message.annotations[keys2[j]];
                    }
                    if (message.suspend != null && message.hasOwnProperty("suspend"))
                        object.suspend = message.suspend;
                    if (message.numActiveJobs != null && message.hasOwnProperty("numActiveJobs"))
                        object.numActiveJobs = message.numActiveJobs;
                    if (message.concurrencyPolicy != null && message.hasOwnProperty("concurrencyPolicy"))
                        object.concurrencyPolicy = options.enums === String ? $root.clutch.k8s.v1.CronJob.ConcurrencyPolicy[message.concurrencyPolicy] : message.concurrencyPolicy;
                    if (message.startingDeadlineSeconds != null && message.hasOwnProperty("startingDeadlineSeconds"))
                        object.startingDeadlineSeconds = $root.google.protobuf.Int64Value.toObject(message.startingDeadlineSeconds, options);
                    return object;
                };

                /**
                 * Converts this CronJob to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.CronJob
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CronJob.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * ConcurrencyPolicy enum.
                 * @name clutch.k8s.v1.CronJob.ConcurrencyPolicy
                 * @enum {number}
                 * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                 * @property {number} UNKNOWN=1 UNKNOWN value
                 * @property {number} ALLOW=2 ALLOW value
                 * @property {number} FORBID=3 FORBID value
                 * @property {number} REPLACE=4 REPLACE value
                 */
                CronJob.ConcurrencyPolicy = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNSPECIFIED"] = 0;
                    values[valuesById[1] = "UNKNOWN"] = 1;
                    values[valuesById[2] = "ALLOW"] = 2;
                    values[valuesById[3] = "FORBID"] = 3;
                    values[valuesById[4] = "REPLACE"] = 4;
                    return values;
                })();

                return CronJob;
            })();

            v1.DescribeCronJobRequest = (function() {

                /**
                 * Properties of a DescribeCronJobRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribeCronJobRequest
                 * @property {string|null} [clientset] DescribeCronJobRequest clientset
                 * @property {string|null} [cluster] DescribeCronJobRequest cluster
                 * @property {string|null} [namespace] DescribeCronJobRequest namespace
                 * @property {string|null} [name] DescribeCronJobRequest name
                 */

                /**
                 * Constructs a new DescribeCronJobRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribeCronJobRequest.
                 * @implements IDescribeCronJobRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribeCronJobRequest=} [properties] Properties to set
                 */
                function DescribeCronJobRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeCronJobRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DescribeCronJobRequest
                 * @instance
                 */
                DescribeCronJobRequest.prototype.clientset = "";

                /**
                 * DescribeCronJobRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DescribeCronJobRequest
                 * @instance
                 */
                DescribeCronJobRequest.prototype.cluster = "";

                /**
                 * DescribeCronJobRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DescribeCronJobRequest
                 * @instance
                 */
                DescribeCronJobRequest.prototype.namespace = "";

                /**
                 * DescribeCronJobRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DescribeCronJobRequest
                 * @instance
                 */
                DescribeCronJobRequest.prototype.name = "";

                /**
                 * Verifies a DescribeCronJobRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribeCronJobRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeCronJobRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DescribeCronJobRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribeCronJobRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribeCronJobRequest} DescribeCronJobRequest
                 */
                DescribeCronJobRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribeCronJobRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribeCronJobRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeCronJobRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribeCronJobRequest
                 * @static
                 * @param {clutch.k8s.v1.DescribeCronJobRequest} message DescribeCronJobRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeCronJobRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DescribeCronJobRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribeCronJobRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeCronJobRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeCronJobRequest;
            })();

            v1.DescribeCronJobResponse = (function() {

                /**
                 * Properties of a DescribeCronJobResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribeCronJobResponse
                 * @property {clutch.k8s.v1.ICronJob|null} [cronjob] DescribeCronJobResponse cronjob
                 */

                /**
                 * Constructs a new DescribeCronJobResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribeCronJobResponse.
                 * @implements IDescribeCronJobResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribeCronJobResponse=} [properties] Properties to set
                 */
                function DescribeCronJobResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeCronJobResponse cronjob.
                 * @member {clutch.k8s.v1.ICronJob|null|undefined} cronjob
                 * @memberof clutch.k8s.v1.DescribeCronJobResponse
                 * @instance
                 */
                DescribeCronJobResponse.prototype.cronjob = null;

                /**
                 * Verifies a DescribeCronJobResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribeCronJobResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeCronJobResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cronjob != null && message.hasOwnProperty("cronjob")) {
                        let error = $root.clutch.k8s.v1.CronJob.verify(message.cronjob);
                        if (error)
                            return "cronjob." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DescribeCronJobResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribeCronJobResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribeCronJobResponse} DescribeCronJobResponse
                 */
                DescribeCronJobResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribeCronJobResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribeCronJobResponse();
                    if (object.cronjob != null) {
                        if (typeof object.cronjob !== "object")
                            throw TypeError(".clutch.k8s.v1.DescribeCronJobResponse.cronjob: object expected");
                        message.cronjob = $root.clutch.k8s.v1.CronJob.fromObject(object.cronjob);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeCronJobResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribeCronJobResponse
                 * @static
                 * @param {clutch.k8s.v1.DescribeCronJobResponse} message DescribeCronJobResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeCronJobResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.cronjob = null;
                    if (message.cronjob != null && message.hasOwnProperty("cronjob"))
                        object.cronjob = $root.clutch.k8s.v1.CronJob.toObject(message.cronjob, options);
                    return object;
                };

                /**
                 * Converts this DescribeCronJobResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribeCronJobResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeCronJobResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeCronJobResponse;
            })();

            v1.ListCronJobsRequest = (function() {

                /**
                 * Properties of a ListCronJobsRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IListCronJobsRequest
                 * @property {string|null} [clientset] ListCronJobsRequest clientset
                 * @property {string|null} [cluster] ListCronJobsRequest cluster
                 * @property {string|null} [namespace] ListCronJobsRequest namespace
                 * @property {clutch.k8s.v1.IListOptions|null} [options] ListCronJobsRequest options
                 */

                /**
                 * Constructs a new ListCronJobsRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListCronJobsRequest.
                 * @implements IListCronJobsRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IListCronJobsRequest=} [properties] Properties to set
                 */
                function ListCronJobsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListCronJobsRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.ListCronJobsRequest
                 * @instance
                 */
                ListCronJobsRequest.prototype.clientset = "";

                /**
                 * ListCronJobsRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.ListCronJobsRequest
                 * @instance
                 */
                ListCronJobsRequest.prototype.cluster = "";

                /**
                 * ListCronJobsRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.ListCronJobsRequest
                 * @instance
                 */
                ListCronJobsRequest.prototype.namespace = "";

                /**
                 * ListCronJobsRequest options.
                 * @member {clutch.k8s.v1.IListOptions|null|undefined} options
                 * @memberof clutch.k8s.v1.ListCronJobsRequest
                 * @instance
                 */
                ListCronJobsRequest.prototype.options = null;

                /**
                 * Verifies a ListCronJobsRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListCronJobsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListCronJobsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        let error = $root.clutch.k8s.v1.ListOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ListCronJobsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListCronJobsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListCronJobsRequest} ListCronJobsRequest
                 */
                ListCronJobsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListCronJobsRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListCronJobsRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".clutch.k8s.v1.ListCronJobsRequest.options: object expected");
                        message.options = $root.clutch.k8s.v1.ListOptions.fromObject(object.options);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListCronJobsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListCronJobsRequest
                 * @static
                 * @param {clutch.k8s.v1.ListCronJobsRequest} message ListCronJobsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListCronJobsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.options = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.clutch.k8s.v1.ListOptions.toObject(message.options, options);
                    return object;
                };

                /**
                 * Converts this ListCronJobsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListCronJobsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListCronJobsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListCronJobsRequest;
            })();

            v1.ListCronJobsResponse = (function() {

                /**
                 * Properties of a ListCronJobsResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IListCronJobsResponse
                 * @property {Array.<clutch.k8s.v1.ICronJob>|null} [cronJobs] ListCronJobsResponse cronJobs
                 */

                /**
                 * Constructs a new ListCronJobsResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListCronJobsResponse.
                 * @implements IListCronJobsResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IListCronJobsResponse=} [properties] Properties to set
                 */
                function ListCronJobsResponse(properties) {
                    this.cronJobs = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListCronJobsResponse cronJobs.
                 * @member {Array.<clutch.k8s.v1.ICronJob>} cronJobs
                 * @memberof clutch.k8s.v1.ListCronJobsResponse
                 * @instance
                 */
                ListCronJobsResponse.prototype.cronJobs = $util.emptyArray;

                /**
                 * Verifies a ListCronJobsResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListCronJobsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListCronJobsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cronJobs != null && message.hasOwnProperty("cronJobs")) {
                        if (!Array.isArray(message.cronJobs))
                            return "cronJobs: array expected";
                        for (let i = 0; i < message.cronJobs.length; ++i) {
                            let error = $root.clutch.k8s.v1.CronJob.verify(message.cronJobs[i]);
                            if (error)
                                return "cronJobs." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ListCronJobsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListCronJobsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListCronJobsResponse} ListCronJobsResponse
                 */
                ListCronJobsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListCronJobsResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListCronJobsResponse();
                    if (object.cronJobs) {
                        if (!Array.isArray(object.cronJobs))
                            throw TypeError(".clutch.k8s.v1.ListCronJobsResponse.cronJobs: array expected");
                        message.cronJobs = [];
                        for (let i = 0; i < object.cronJobs.length; ++i) {
                            if (typeof object.cronJobs[i] !== "object")
                                throw TypeError(".clutch.k8s.v1.ListCronJobsResponse.cronJobs: object expected");
                            message.cronJobs[i] = $root.clutch.k8s.v1.CronJob.fromObject(object.cronJobs[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListCronJobsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListCronJobsResponse
                 * @static
                 * @param {clutch.k8s.v1.ListCronJobsResponse} message ListCronJobsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListCronJobsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.cronJobs = [];
                    if (message.cronJobs && message.cronJobs.length) {
                        object.cronJobs = [];
                        for (let j = 0; j < message.cronJobs.length; ++j)
                            object.cronJobs[j] = $root.clutch.k8s.v1.CronJob.toObject(message.cronJobs[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ListCronJobsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListCronJobsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListCronJobsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListCronJobsResponse;
            })();

            v1.DeleteCronJobRequest = (function() {

                /**
                 * Properties of a DeleteCronJobRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDeleteCronJobRequest
                 * @property {string|null} [clientset] DeleteCronJobRequest clientset
                 * @property {string|null} [cluster] DeleteCronJobRequest cluster
                 * @property {string|null} [namespace] DeleteCronJobRequest namespace
                 * @property {string|null} [name] DeleteCronJobRequest name
                 */

                /**
                 * Constructs a new DeleteCronJobRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeleteCronJobRequest.
                 * @implements IDeleteCronJobRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDeleteCronJobRequest=} [properties] Properties to set
                 */
                function DeleteCronJobRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeleteCronJobRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DeleteCronJobRequest
                 * @instance
                 */
                DeleteCronJobRequest.prototype.clientset = "";

                /**
                 * DeleteCronJobRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DeleteCronJobRequest
                 * @instance
                 */
                DeleteCronJobRequest.prototype.cluster = "";

                /**
                 * DeleteCronJobRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DeleteCronJobRequest
                 * @instance
                 */
                DeleteCronJobRequest.prototype.namespace = "";

                /**
                 * DeleteCronJobRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DeleteCronJobRequest
                 * @instance
                 */
                DeleteCronJobRequest.prototype.name = "";

                /**
                 * Verifies a DeleteCronJobRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeleteCronJobRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteCronJobRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DeleteCronJobRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeleteCronJobRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeleteCronJobRequest} DeleteCronJobRequest
                 */
                DeleteCronJobRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeleteCronJobRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DeleteCronJobRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DeleteCronJobRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeleteCronJobRequest
                 * @static
                 * @param {clutch.k8s.v1.DeleteCronJobRequest} message DeleteCronJobRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteCronJobRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DeleteCronJobRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeleteCronJobRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteCronJobRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteCronJobRequest;
            })();

            v1.DeleteCronJobResponse = (function() {

                /**
                 * Properties of a DeleteCronJobResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDeleteCronJobResponse
                 */

                /**
                 * Constructs a new DeleteCronJobResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeleteCronJobResponse.
                 * @implements IDeleteCronJobResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDeleteCronJobResponse=} [properties] Properties to set
                 */
                function DeleteCronJobResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a DeleteCronJobResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeleteCronJobResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteCronJobResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a DeleteCronJobResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeleteCronJobResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeleteCronJobResponse} DeleteCronJobResponse
                 */
                DeleteCronJobResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeleteCronJobResponse)
                        return object;
                    return new $root.clutch.k8s.v1.DeleteCronJobResponse();
                };

                /**
                 * Creates a plain object from a DeleteCronJobResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeleteCronJobResponse
                 * @static
                 * @param {clutch.k8s.v1.DeleteCronJobResponse} message DeleteCronJobResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteCronJobResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this DeleteCronJobResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeleteCronJobResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteCronJobResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteCronJobResponse;
            })();

            v1.ConfigMap = (function() {

                /**
                 * Properties of a ConfigMap.
                 * @memberof clutch.k8s.v1
                 * @interface IConfigMap
                 * @property {string|null} [cluster] ConfigMap cluster
                 * @property {string|null} [namespace] ConfigMap namespace
                 * @property {string|null} [name] ConfigMap name
                 * @property {Object.<string,string>|null} [annotations] ConfigMap annotations
                 * @property {Object.<string,string>|null} [labels] ConfigMap labels
                 * @property {Object.<string,string>|null} [data] ConfigMap data
                 * @property {Object.<string,Uint8Array>|null} [binaryData] ConfigMap binaryData
                 */

                /**
                 * Constructs a new ConfigMap.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ConfigMap.
                 * @implements IConfigMap
                 * @constructor
                 * @param {clutch.k8s.v1.IConfigMap=} [properties] Properties to set
                 */
                function ConfigMap(properties) {
                    this.annotations = {};
                    this.labels = {};
                    this.data = {};
                    this.binaryData = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ConfigMap cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.ConfigMap
                 * @instance
                 */
                ConfigMap.prototype.cluster = "";

                /**
                 * ConfigMap namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.ConfigMap
                 * @instance
                 */
                ConfigMap.prototype.namespace = "";

                /**
                 * ConfigMap name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.ConfigMap
                 * @instance
                 */
                ConfigMap.prototype.name = "";

                /**
                 * ConfigMap annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof clutch.k8s.v1.ConfigMap
                 * @instance
                 */
                ConfigMap.prototype.annotations = $util.emptyObject;

                /**
                 * ConfigMap labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.ConfigMap
                 * @instance
                 */
                ConfigMap.prototype.labels = $util.emptyObject;

                /**
                 * ConfigMap data.
                 * @member {Object.<string,string>} data
                 * @memberof clutch.k8s.v1.ConfigMap
                 * @instance
                 */
                ConfigMap.prototype.data = $util.emptyObject;

                /**
                 * ConfigMap binaryData.
                 * @member {Object.<string,Uint8Array>} binaryData
                 * @memberof clutch.k8s.v1.ConfigMap
                 * @instance
                 */
                ConfigMap.prototype.binaryData = $util.emptyObject;

                /**
                 * Verifies a ConfigMap message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ConfigMap
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConfigMap.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.data != null && message.hasOwnProperty("data")) {
                        if (!$util.isObject(message.data))
                            return "data: object expected";
                        let key = Object.keys(message.data);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.data[key[i]]))
                                return "data: string{k:string} expected";
                    }
                    if (message.binaryData != null && message.hasOwnProperty("binaryData")) {
                        if (!$util.isObject(message.binaryData))
                            return "binaryData: object expected";
                        let key = Object.keys(message.binaryData);
                        for (let i = 0; i < key.length; ++i)
                            if (!(message.binaryData[key[i]] && typeof message.binaryData[key[i]].length === "number" || $util.isString(message.binaryData[key[i]])))
                                return "binaryData: buffer{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates a ConfigMap message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ConfigMap
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ConfigMap} ConfigMap
                 */
                ConfigMap.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ConfigMap)
                        return object;
                    let message = new $root.clutch.k8s.v1.ConfigMap();
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.ConfigMap.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                            message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                    }
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.ConfigMap.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    if (object.data) {
                        if (typeof object.data !== "object")
                            throw TypeError(".clutch.k8s.v1.ConfigMap.data: object expected");
                        message.data = {};
                        for (let keys = Object.keys(object.data), i = 0; i < keys.length; ++i)
                            message.data[keys[i]] = String(object.data[keys[i]]);
                    }
                    if (object.binaryData) {
                        if (typeof object.binaryData !== "object")
                            throw TypeError(".clutch.k8s.v1.ConfigMap.binaryData: object expected");
                        message.binaryData = {};
                        for (let keys = Object.keys(object.binaryData), i = 0; i < keys.length; ++i)
                            if (typeof object.binaryData[keys[i]] === "string")
                                $util.base64.decode(object.binaryData[keys[i]], message.binaryData[keys[i]] = $util.newBuffer($util.base64.length(object.binaryData[keys[i]])), 0);
                            else if (object.binaryData[keys[i]].length)
                                message.binaryData[keys[i]] = object.binaryData[keys[i]];
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ConfigMap message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ConfigMap
                 * @static
                 * @param {clutch.k8s.v1.ConfigMap} message ConfigMap
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConfigMap.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.annotations = {};
                        object.labels = {};
                        object.data = {};
                        object.binaryData = {};
                    }
                    if (options.defaults) {
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    let keys2;
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = message.annotations[keys2[j]];
                    }
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    if (message.data && (keys2 = Object.keys(message.data)).length) {
                        object.data = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.data[keys2[j]] = message.data[keys2[j]];
                    }
                    if (message.binaryData && (keys2 = Object.keys(message.binaryData)).length) {
                        object.binaryData = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.binaryData[keys2[j]] = options.bytes === String ? $util.base64.encode(message.binaryData[keys2[j]], 0, message.binaryData[keys2[j]].length) : options.bytes === Array ? Array.prototype.slice.call(message.binaryData[keys2[j]]) : message.binaryData[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Converts this ConfigMap to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ConfigMap
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConfigMap.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ConfigMap;
            })();

            v1.ListConfigMapsRequest = (function() {

                /**
                 * Properties of a ListConfigMapsRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IListConfigMapsRequest
                 * @property {string|null} [clientset] ListConfigMapsRequest clientset
                 * @property {string|null} [cluster] ListConfigMapsRequest cluster
                 * @property {string|null} [namespace] ListConfigMapsRequest namespace
                 * @property {clutch.k8s.v1.IListOptions|null} [options] ListConfigMapsRequest options
                 */

                /**
                 * Constructs a new ListConfigMapsRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListConfigMapsRequest.
                 * @implements IListConfigMapsRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IListConfigMapsRequest=} [properties] Properties to set
                 */
                function ListConfigMapsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListConfigMapsRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.ListConfigMapsRequest
                 * @instance
                 */
                ListConfigMapsRequest.prototype.clientset = "";

                /**
                 * ListConfigMapsRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.ListConfigMapsRequest
                 * @instance
                 */
                ListConfigMapsRequest.prototype.cluster = "";

                /**
                 * ListConfigMapsRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.ListConfigMapsRequest
                 * @instance
                 */
                ListConfigMapsRequest.prototype.namespace = "";

                /**
                 * ListConfigMapsRequest options.
                 * @member {clutch.k8s.v1.IListOptions|null|undefined} options
                 * @memberof clutch.k8s.v1.ListConfigMapsRequest
                 * @instance
                 */
                ListConfigMapsRequest.prototype.options = null;

                /**
                 * Verifies a ListConfigMapsRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListConfigMapsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListConfigMapsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        let error = $root.clutch.k8s.v1.ListOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ListConfigMapsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListConfigMapsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListConfigMapsRequest} ListConfigMapsRequest
                 */
                ListConfigMapsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListConfigMapsRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListConfigMapsRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".clutch.k8s.v1.ListConfigMapsRequest.options: object expected");
                        message.options = $root.clutch.k8s.v1.ListOptions.fromObject(object.options);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListConfigMapsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListConfigMapsRequest
                 * @static
                 * @param {clutch.k8s.v1.ListConfigMapsRequest} message ListConfigMapsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListConfigMapsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.options = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.clutch.k8s.v1.ListOptions.toObject(message.options, options);
                    return object;
                };

                /**
                 * Converts this ListConfigMapsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListConfigMapsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListConfigMapsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListConfigMapsRequest;
            })();

            v1.ListConfigMapsResponse = (function() {

                /**
                 * Properties of a ListConfigMapsResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IListConfigMapsResponse
                 * @property {Array.<clutch.k8s.v1.IConfigMap>|null} [configMaps] ListConfigMapsResponse configMaps
                 */

                /**
                 * Constructs a new ListConfigMapsResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListConfigMapsResponse.
                 * @implements IListConfigMapsResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IListConfigMapsResponse=} [properties] Properties to set
                 */
                function ListConfigMapsResponse(properties) {
                    this.configMaps = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListConfigMapsResponse configMaps.
                 * @member {Array.<clutch.k8s.v1.IConfigMap>} configMaps
                 * @memberof clutch.k8s.v1.ListConfigMapsResponse
                 * @instance
                 */
                ListConfigMapsResponse.prototype.configMaps = $util.emptyArray;

                /**
                 * Verifies a ListConfigMapsResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListConfigMapsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListConfigMapsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.configMaps != null && message.hasOwnProperty("configMaps")) {
                        if (!Array.isArray(message.configMaps))
                            return "configMaps: array expected";
                        for (let i = 0; i < message.configMaps.length; ++i) {
                            let error = $root.clutch.k8s.v1.ConfigMap.verify(message.configMaps[i]);
                            if (error)
                                return "configMaps." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ListConfigMapsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListConfigMapsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListConfigMapsResponse} ListConfigMapsResponse
                 */
                ListConfigMapsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListConfigMapsResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListConfigMapsResponse();
                    if (object.configMaps) {
                        if (!Array.isArray(object.configMaps))
                            throw TypeError(".clutch.k8s.v1.ListConfigMapsResponse.configMaps: array expected");
                        message.configMaps = [];
                        for (let i = 0; i < object.configMaps.length; ++i) {
                            if (typeof object.configMaps[i] !== "object")
                                throw TypeError(".clutch.k8s.v1.ListConfigMapsResponse.configMaps: object expected");
                            message.configMaps[i] = $root.clutch.k8s.v1.ConfigMap.fromObject(object.configMaps[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListConfigMapsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListConfigMapsResponse
                 * @static
                 * @param {clutch.k8s.v1.ListConfigMapsResponse} message ListConfigMapsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListConfigMapsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.configMaps = [];
                    if (message.configMaps && message.configMaps.length) {
                        object.configMaps = [];
                        for (let j = 0; j < message.configMaps.length; ++j)
                            object.configMaps[j] = $root.clutch.k8s.v1.ConfigMap.toObject(message.configMaps[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ListConfigMapsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListConfigMapsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListConfigMapsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListConfigMapsResponse;
            })();

            v1.DescribeConfigMapRequest = (function() {

                /**
                 * Properties of a DescribeConfigMapRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribeConfigMapRequest
                 * @property {string|null} [clientset] DescribeConfigMapRequest clientset
                 * @property {string|null} [cluster] DescribeConfigMapRequest cluster
                 * @property {string|null} [namespace] DescribeConfigMapRequest namespace
                 * @property {string|null} [name] DescribeConfigMapRequest name
                 */

                /**
                 * Constructs a new DescribeConfigMapRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribeConfigMapRequest.
                 * @implements IDescribeConfigMapRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribeConfigMapRequest=} [properties] Properties to set
                 */
                function DescribeConfigMapRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeConfigMapRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DescribeConfigMapRequest
                 * @instance
                 */
                DescribeConfigMapRequest.prototype.clientset = "";

                /**
                 * DescribeConfigMapRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DescribeConfigMapRequest
                 * @instance
                 */
                DescribeConfigMapRequest.prototype.cluster = "";

                /**
                 * DescribeConfigMapRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DescribeConfigMapRequest
                 * @instance
                 */
                DescribeConfigMapRequest.prototype.namespace = "";

                /**
                 * DescribeConfigMapRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DescribeConfigMapRequest
                 * @instance
                 */
                DescribeConfigMapRequest.prototype.name = "";

                /**
                 * Verifies a DescribeConfigMapRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribeConfigMapRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeConfigMapRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DescribeConfigMapRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribeConfigMapRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribeConfigMapRequest} DescribeConfigMapRequest
                 */
                DescribeConfigMapRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribeConfigMapRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribeConfigMapRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeConfigMapRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribeConfigMapRequest
                 * @static
                 * @param {clutch.k8s.v1.DescribeConfigMapRequest} message DescribeConfigMapRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeConfigMapRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DescribeConfigMapRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribeConfigMapRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeConfigMapRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeConfigMapRequest;
            })();

            v1.DescribeConfigMapResponse = (function() {

                /**
                 * Properties of a DescribeConfigMapResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribeConfigMapResponse
                 * @property {clutch.k8s.v1.IConfigMap|null} [configMap] DescribeConfigMapResponse configMap
                 */

                /**
                 * Constructs a new DescribeConfigMapResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribeConfigMapResponse.
                 * @implements IDescribeConfigMapResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribeConfigMapResponse=} [properties] Properties to set
                 */
                function DescribeConfigMapResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeConfigMapResponse configMap.
                 * @member {clutch.k8s.v1.IConfigMap|null|undefined} configMap
                 * @memberof clutch.k8s.v1.DescribeConfigMapResponse
                 * @instance
                 */
                DescribeConfigMapResponse.prototype.configMap = null;

                /**
                 * Verifies a DescribeConfigMapResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribeConfigMapResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeConfigMapResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.configMap != null && message.hasOwnProperty("configMap")) {
                        let error = $root.clutch.k8s.v1.ConfigMap.verify(message.configMap);
                        if (error)
                            return "configMap." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DescribeConfigMapResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribeConfigMapResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribeConfigMapResponse} DescribeConfigMapResponse
                 */
                DescribeConfigMapResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribeConfigMapResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribeConfigMapResponse();
                    if (object.configMap != null) {
                        if (typeof object.configMap !== "object")
                            throw TypeError(".clutch.k8s.v1.DescribeConfigMapResponse.configMap: object expected");
                        message.configMap = $root.clutch.k8s.v1.ConfigMap.fromObject(object.configMap);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeConfigMapResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribeConfigMapResponse
                 * @static
                 * @param {clutch.k8s.v1.DescribeConfigMapResponse} message DescribeConfigMapResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeConfigMapResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.configMap = null;
                    if (message.configMap != null && message.hasOwnProperty("configMap"))
                        object.configMap = $root.clutch.k8s.v1.ConfigMap.toObject(message.configMap, options);
                    return object;
                };

                /**
                 * Converts this DescribeConfigMapResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribeConfigMapResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeConfigMapResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeConfigMapResponse;
            })();

            v1.DeleteConfigMapRequest = (function() {

                /**
                 * Properties of a DeleteConfigMapRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDeleteConfigMapRequest
                 * @property {string|null} [clientset] DeleteConfigMapRequest clientset
                 * @property {string|null} [cluster] DeleteConfigMapRequest cluster
                 * @property {string|null} [namespace] DeleteConfigMapRequest namespace
                 * @property {string|null} [name] DeleteConfigMapRequest name
                 */

                /**
                 * Constructs a new DeleteConfigMapRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeleteConfigMapRequest.
                 * @implements IDeleteConfigMapRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDeleteConfigMapRequest=} [properties] Properties to set
                 */
                function DeleteConfigMapRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeleteConfigMapRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DeleteConfigMapRequest
                 * @instance
                 */
                DeleteConfigMapRequest.prototype.clientset = "";

                /**
                 * DeleteConfigMapRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DeleteConfigMapRequest
                 * @instance
                 */
                DeleteConfigMapRequest.prototype.cluster = "";

                /**
                 * DeleteConfigMapRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DeleteConfigMapRequest
                 * @instance
                 */
                DeleteConfigMapRequest.prototype.namespace = "";

                /**
                 * DeleteConfigMapRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DeleteConfigMapRequest
                 * @instance
                 */
                DeleteConfigMapRequest.prototype.name = "";

                /**
                 * Verifies a DeleteConfigMapRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeleteConfigMapRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteConfigMapRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DeleteConfigMapRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeleteConfigMapRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeleteConfigMapRequest} DeleteConfigMapRequest
                 */
                DeleteConfigMapRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeleteConfigMapRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DeleteConfigMapRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DeleteConfigMapRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeleteConfigMapRequest
                 * @static
                 * @param {clutch.k8s.v1.DeleteConfigMapRequest} message DeleteConfigMapRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteConfigMapRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DeleteConfigMapRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeleteConfigMapRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteConfigMapRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteConfigMapRequest;
            })();

            v1.DeleteConfigMapResponse = (function() {

                /**
                 * Properties of a DeleteConfigMapResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDeleteConfigMapResponse
                 */

                /**
                 * Constructs a new DeleteConfigMapResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeleteConfigMapResponse.
                 * @implements IDeleteConfigMapResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDeleteConfigMapResponse=} [properties] Properties to set
                 */
                function DeleteConfigMapResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a DeleteConfigMapResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeleteConfigMapResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteConfigMapResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a DeleteConfigMapResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeleteConfigMapResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeleteConfigMapResponse} DeleteConfigMapResponse
                 */
                DeleteConfigMapResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeleteConfigMapResponse)
                        return object;
                    return new $root.clutch.k8s.v1.DeleteConfigMapResponse();
                };

                /**
                 * Creates a plain object from a DeleteConfigMapResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeleteConfigMapResponse
                 * @static
                 * @param {clutch.k8s.v1.DeleteConfigMapResponse} message DeleteConfigMapResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteConfigMapResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this DeleteConfigMapResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeleteConfigMapResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteConfigMapResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteConfigMapResponse;
            })();

            v1.Job = (function() {

                /**
                 * Properties of a Job.
                 * @memberof clutch.k8s.v1
                 * @interface IJob
                 * @property {string|null} [cluster] Job cluster
                 * @property {string|null} [namespace] Job namespace
                 * @property {string|null} [name] Job name
                 * @property {Object.<string,string>|null} [annotations] Job annotations
                 * @property {Object.<string,string>|null} [labels] Job labels
                 */

                /**
                 * Constructs a new Job.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a Job.
                 * @implements IJob
                 * @constructor
                 * @param {clutch.k8s.v1.IJob=} [properties] Properties to set
                 */
                function Job(properties) {
                    this.annotations = {};
                    this.labels = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Job cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.Job
                 * @instance
                 */
                Job.prototype.cluster = "";

                /**
                 * Job namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.Job
                 * @instance
                 */
                Job.prototype.namespace = "";

                /**
                 * Job name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.Job
                 * @instance
                 */
                Job.prototype.name = "";

                /**
                 * Job annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof clutch.k8s.v1.Job
                 * @instance
                 */
                Job.prototype.annotations = $util.emptyObject;

                /**
                 * Job labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.Job
                 * @instance
                 */
                Job.prototype.labels = $util.emptyObject;

                /**
                 * Verifies a Job message.
                 * @function verify
                 * @memberof clutch.k8s.v1.Job
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Job.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates a Job message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.Job
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.Job} Job
                 */
                Job.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.Job)
                        return object;
                    let message = new $root.clutch.k8s.v1.Job();
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.Job.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                            message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                    }
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.Job.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Job message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.Job
                 * @static
                 * @param {clutch.k8s.v1.Job} message Job
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Job.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.annotations = {};
                        object.labels = {};
                    }
                    if (options.defaults) {
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    let keys2;
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = message.annotations[keys2[j]];
                    }
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Converts this Job to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.Job
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Job.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Job;
            })();

            v1.ListJobsRequest = (function() {

                /**
                 * Properties of a ListJobsRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IListJobsRequest
                 * @property {string|null} [clientset] ListJobsRequest clientset
                 * @property {string|null} [cluster] ListJobsRequest cluster
                 * @property {string|null} [namespace] ListJobsRequest namespace
                 * @property {clutch.k8s.v1.IListOptions|null} [options] ListJobsRequest options
                 */

                /**
                 * Constructs a new ListJobsRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListJobsRequest.
                 * @implements IListJobsRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IListJobsRequest=} [properties] Properties to set
                 */
                function ListJobsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListJobsRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.ListJobsRequest
                 * @instance
                 */
                ListJobsRequest.prototype.clientset = "";

                /**
                 * ListJobsRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.ListJobsRequest
                 * @instance
                 */
                ListJobsRequest.prototype.cluster = "";

                /**
                 * ListJobsRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.ListJobsRequest
                 * @instance
                 */
                ListJobsRequest.prototype.namespace = "";

                /**
                 * ListJobsRequest options.
                 * @member {clutch.k8s.v1.IListOptions|null|undefined} options
                 * @memberof clutch.k8s.v1.ListJobsRequest
                 * @instance
                 */
                ListJobsRequest.prototype.options = null;

                /**
                 * Verifies a ListJobsRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListJobsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListJobsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        let error = $root.clutch.k8s.v1.ListOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ListJobsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListJobsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListJobsRequest} ListJobsRequest
                 */
                ListJobsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListJobsRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListJobsRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".clutch.k8s.v1.ListJobsRequest.options: object expected");
                        message.options = $root.clutch.k8s.v1.ListOptions.fromObject(object.options);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListJobsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListJobsRequest
                 * @static
                 * @param {clutch.k8s.v1.ListJobsRequest} message ListJobsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListJobsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.options = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.clutch.k8s.v1.ListOptions.toObject(message.options, options);
                    return object;
                };

                /**
                 * Converts this ListJobsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListJobsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListJobsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListJobsRequest;
            })();

            v1.ListJobsResponse = (function() {

                /**
                 * Properties of a ListJobsResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IListJobsResponse
                 * @property {Array.<clutch.k8s.v1.IJob>|null} [jobs] ListJobsResponse jobs
                 */

                /**
                 * Constructs a new ListJobsResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListJobsResponse.
                 * @implements IListJobsResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IListJobsResponse=} [properties] Properties to set
                 */
                function ListJobsResponse(properties) {
                    this.jobs = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListJobsResponse jobs.
                 * @member {Array.<clutch.k8s.v1.IJob>} jobs
                 * @memberof clutch.k8s.v1.ListJobsResponse
                 * @instance
                 */
                ListJobsResponse.prototype.jobs = $util.emptyArray;

                /**
                 * Verifies a ListJobsResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListJobsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListJobsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.jobs != null && message.hasOwnProperty("jobs")) {
                        if (!Array.isArray(message.jobs))
                            return "jobs: array expected";
                        for (let i = 0; i < message.jobs.length; ++i) {
                            let error = $root.clutch.k8s.v1.Job.verify(message.jobs[i]);
                            if (error)
                                return "jobs." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ListJobsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListJobsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListJobsResponse} ListJobsResponse
                 */
                ListJobsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListJobsResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListJobsResponse();
                    if (object.jobs) {
                        if (!Array.isArray(object.jobs))
                            throw TypeError(".clutch.k8s.v1.ListJobsResponse.jobs: array expected");
                        message.jobs = [];
                        for (let i = 0; i < object.jobs.length; ++i) {
                            if (typeof object.jobs[i] !== "object")
                                throw TypeError(".clutch.k8s.v1.ListJobsResponse.jobs: object expected");
                            message.jobs[i] = $root.clutch.k8s.v1.Job.fromObject(object.jobs[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListJobsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListJobsResponse
                 * @static
                 * @param {clutch.k8s.v1.ListJobsResponse} message ListJobsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListJobsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.jobs = [];
                    if (message.jobs && message.jobs.length) {
                        object.jobs = [];
                        for (let j = 0; j < message.jobs.length; ++j)
                            object.jobs[j] = $root.clutch.k8s.v1.Job.toObject(message.jobs[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ListJobsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListJobsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListJobsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListJobsResponse;
            })();

            v1.DeleteJobRequest = (function() {

                /**
                 * Properties of a DeleteJobRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDeleteJobRequest
                 * @property {string|null} [clientset] DeleteJobRequest clientset
                 * @property {string|null} [cluster] DeleteJobRequest cluster
                 * @property {string|null} [namespace] DeleteJobRequest namespace
                 * @property {string|null} [name] DeleteJobRequest name
                 */

                /**
                 * Constructs a new DeleteJobRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeleteJobRequest.
                 * @implements IDeleteJobRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDeleteJobRequest=} [properties] Properties to set
                 */
                function DeleteJobRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeleteJobRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DeleteJobRequest
                 * @instance
                 */
                DeleteJobRequest.prototype.clientset = "";

                /**
                 * DeleteJobRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DeleteJobRequest
                 * @instance
                 */
                DeleteJobRequest.prototype.cluster = "";

                /**
                 * DeleteJobRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DeleteJobRequest
                 * @instance
                 */
                DeleteJobRequest.prototype.namespace = "";

                /**
                 * DeleteJobRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DeleteJobRequest
                 * @instance
                 */
                DeleteJobRequest.prototype.name = "";

                /**
                 * Verifies a DeleteJobRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeleteJobRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteJobRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DeleteJobRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeleteJobRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeleteJobRequest} DeleteJobRequest
                 */
                DeleteJobRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeleteJobRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DeleteJobRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DeleteJobRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeleteJobRequest
                 * @static
                 * @param {clutch.k8s.v1.DeleteJobRequest} message DeleteJobRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteJobRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DeleteJobRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeleteJobRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteJobRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteJobRequest;
            })();

            v1.DeleteJobResponse = (function() {

                /**
                 * Properties of a DeleteJobResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDeleteJobResponse
                 */

                /**
                 * Constructs a new DeleteJobResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeleteJobResponse.
                 * @implements IDeleteJobResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDeleteJobResponse=} [properties] Properties to set
                 */
                function DeleteJobResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a DeleteJobResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeleteJobResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeleteJobResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a DeleteJobResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeleteJobResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeleteJobResponse} DeleteJobResponse
                 */
                DeleteJobResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeleteJobResponse)
                        return object;
                    return new $root.clutch.k8s.v1.DeleteJobResponse();
                };

                /**
                 * Creates a plain object from a DeleteJobResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeleteJobResponse
                 * @static
                 * @param {clutch.k8s.v1.DeleteJobResponse} message DeleteJobResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeleteJobResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this DeleteJobResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeleteJobResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeleteJobResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeleteJobResponse;
            })();

            v1.JobConfig = (function() {

                /**
                 * Properties of a JobConfig.
                 * @memberof clutch.k8s.v1
                 * @interface IJobConfig
                 * @property {google.protobuf.IValue|null} [value] JobConfig value
                 */

                /**
                 * Constructs a new JobConfig.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a JobConfig.
                 * @implements IJobConfig
                 * @constructor
                 * @param {clutch.k8s.v1.IJobConfig=} [properties] Properties to set
                 */
                function JobConfig(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * JobConfig value.
                 * @member {google.protobuf.IValue|null|undefined} value
                 * @memberof clutch.k8s.v1.JobConfig
                 * @instance
                 */
                JobConfig.prototype.value = null;

                /**
                 * Verifies a JobConfig message.
                 * @function verify
                 * @memberof clutch.k8s.v1.JobConfig
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                JobConfig.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        let error = $root.google.protobuf.Value.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };

                /**
                 * Creates a JobConfig message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.JobConfig
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.JobConfig} JobConfig
                 */
                JobConfig.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.JobConfig)
                        return object;
                    let message = new $root.clutch.k8s.v1.JobConfig();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".clutch.k8s.v1.JobConfig.value: object expected");
                        message.value = $root.google.protobuf.Value.fromObject(object.value);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a JobConfig message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.JobConfig
                 * @static
                 * @param {clutch.k8s.v1.JobConfig} message JobConfig
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                JobConfig.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.google.protobuf.Value.toObject(message.value, options);
                    return object;
                };

                /**
                 * Converts this JobConfig to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.JobConfig
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                JobConfig.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return JobConfig;
            })();

            v1.CreateJobRequest = (function() {

                /**
                 * Properties of a CreateJobRequest.
                 * @memberof clutch.k8s.v1
                 * @interface ICreateJobRequest
                 * @property {string|null} [clientset] CreateJobRequest clientset
                 * @property {string|null} [cluster] CreateJobRequest cluster
                 * @property {string|null} [namespace] CreateJobRequest namespace
                 * @property {clutch.k8s.v1.IJobConfig|null} [jobConfig] CreateJobRequest jobConfig
                 */

                /**
                 * Constructs a new CreateJobRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a CreateJobRequest.
                 * @implements ICreateJobRequest
                 * @constructor
                 * @param {clutch.k8s.v1.ICreateJobRequest=} [properties] Properties to set
                 */
                function CreateJobRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateJobRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.CreateJobRequest
                 * @instance
                 */
                CreateJobRequest.prototype.clientset = "";

                /**
                 * CreateJobRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.CreateJobRequest
                 * @instance
                 */
                CreateJobRequest.prototype.cluster = "";

                /**
                 * CreateJobRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.CreateJobRequest
                 * @instance
                 */
                CreateJobRequest.prototype.namespace = "";

                /**
                 * CreateJobRequest jobConfig.
                 * @member {clutch.k8s.v1.IJobConfig|null|undefined} jobConfig
                 * @memberof clutch.k8s.v1.CreateJobRequest
                 * @instance
                 */
                CreateJobRequest.prototype.jobConfig = null;

                /**
                 * Verifies a CreateJobRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.CreateJobRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateJobRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.jobConfig != null && message.hasOwnProperty("jobConfig")) {
                        let error = $root.clutch.k8s.v1.JobConfig.verify(message.jobConfig);
                        if (error)
                            return "jobConfig." + error;
                    }
                    return null;
                };

                /**
                 * Creates a CreateJobRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.CreateJobRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.CreateJobRequest} CreateJobRequest
                 */
                CreateJobRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.CreateJobRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.CreateJobRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.jobConfig != null) {
                        if (typeof object.jobConfig !== "object")
                            throw TypeError(".clutch.k8s.v1.CreateJobRequest.jobConfig: object expected");
                        message.jobConfig = $root.clutch.k8s.v1.JobConfig.fromObject(object.jobConfig);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateJobRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.CreateJobRequest
                 * @static
                 * @param {clutch.k8s.v1.CreateJobRequest} message CreateJobRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateJobRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.jobConfig = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.jobConfig != null && message.hasOwnProperty("jobConfig"))
                        object.jobConfig = $root.clutch.k8s.v1.JobConfig.toObject(message.jobConfig, options);
                    return object;
                };

                /**
                 * Converts this CreateJobRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.CreateJobRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateJobRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateJobRequest;
            })();

            v1.CreateJobResponse = (function() {

                /**
                 * Properties of a CreateJobResponse.
                 * @memberof clutch.k8s.v1
                 * @interface ICreateJobResponse
                 * @property {clutch.k8s.v1.IJob|null} [job] CreateJobResponse job
                 */

                /**
                 * Constructs a new CreateJobResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a CreateJobResponse.
                 * @implements ICreateJobResponse
                 * @constructor
                 * @param {clutch.k8s.v1.ICreateJobResponse=} [properties] Properties to set
                 */
                function CreateJobResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateJobResponse job.
                 * @member {clutch.k8s.v1.IJob|null|undefined} job
                 * @memberof clutch.k8s.v1.CreateJobResponse
                 * @instance
                 */
                CreateJobResponse.prototype.job = null;

                /**
                 * Verifies a CreateJobResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.CreateJobResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateJobResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.job != null && message.hasOwnProperty("job")) {
                        let error = $root.clutch.k8s.v1.Job.verify(message.job);
                        if (error)
                            return "job." + error;
                    }
                    return null;
                };

                /**
                 * Creates a CreateJobResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.CreateJobResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.CreateJobResponse} CreateJobResponse
                 */
                CreateJobResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.CreateJobResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.CreateJobResponse();
                    if (object.job != null) {
                        if (typeof object.job !== "object")
                            throw TypeError(".clutch.k8s.v1.CreateJobResponse.job: object expected");
                        message.job = $root.clutch.k8s.v1.Job.fromObject(object.job);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateJobResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.CreateJobResponse
                 * @static
                 * @param {clutch.k8s.v1.CreateJobResponse} message CreateJobResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateJobResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.job = null;
                    if (message.job != null && message.hasOwnProperty("job"))
                        object.job = $root.clutch.k8s.v1.Job.toObject(message.job, options);
                    return object;
                };

                /**
                 * Converts this CreateJobResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.CreateJobResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateJobResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateJobResponse;
            })();

            v1.Namespace = (function() {

                /**
                 * Properties of a Namespace.
                 * @memberof clutch.k8s.v1
                 * @interface INamespace
                 * @property {string|null} [cluster] Namespace cluster
                 * @property {string|null} [name] Namespace name
                 * @property {Object.<string,string>|null} [annotations] Namespace annotations
                 * @property {Object.<string,string>|null} [labels] Namespace labels
                 */

                /**
                 * Constructs a new Namespace.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a Namespace.
                 * @implements INamespace
                 * @constructor
                 * @param {clutch.k8s.v1.INamespace=} [properties] Properties to set
                 */
                function Namespace(properties) {
                    this.annotations = {};
                    this.labels = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Namespace cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.Namespace
                 * @instance
                 */
                Namespace.prototype.cluster = "";

                /**
                 * Namespace name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.Namespace
                 * @instance
                 */
                Namespace.prototype.name = "";

                /**
                 * Namespace annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof clutch.k8s.v1.Namespace
                 * @instance
                 */
                Namespace.prototype.annotations = $util.emptyObject;

                /**
                 * Namespace labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.Namespace
                 * @instance
                 */
                Namespace.prototype.labels = $util.emptyObject;

                /**
                 * Verifies a Namespace message.
                 * @function verify
                 * @memberof clutch.k8s.v1.Namespace
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Namespace.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates a Namespace message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.Namespace
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.Namespace} Namespace
                 */
                Namespace.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.Namespace)
                        return object;
                    let message = new $root.clutch.k8s.v1.Namespace();
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.Namespace.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                            message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                    }
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.Namespace.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Namespace message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.Namespace
                 * @static
                 * @param {clutch.k8s.v1.Namespace} message Namespace
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Namespace.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.annotations = {};
                        object.labels = {};
                    }
                    if (options.defaults) {
                        object.cluster = "";
                        object.name = "";
                    }
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    let keys2;
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = message.annotations[keys2[j]];
                    }
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Converts this Namespace to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.Namespace
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Namespace.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Namespace;
            })();

            v1.DescribeNamespaceRequest = (function() {

                /**
                 * Properties of a DescribeNamespaceRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribeNamespaceRequest
                 * @property {string|null} [clientset] DescribeNamespaceRequest clientset
                 * @property {string|null} [cluster] DescribeNamespaceRequest cluster
                 * @property {string|null} [name] DescribeNamespaceRequest name
                 */

                /**
                 * Constructs a new DescribeNamespaceRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribeNamespaceRequest.
                 * @implements IDescribeNamespaceRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribeNamespaceRequest=} [properties] Properties to set
                 */
                function DescribeNamespaceRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeNamespaceRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DescribeNamespaceRequest
                 * @instance
                 */
                DescribeNamespaceRequest.prototype.clientset = "";

                /**
                 * DescribeNamespaceRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DescribeNamespaceRequest
                 * @instance
                 */
                DescribeNamespaceRequest.prototype.cluster = "";

                /**
                 * DescribeNamespaceRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DescribeNamespaceRequest
                 * @instance
                 */
                DescribeNamespaceRequest.prototype.name = "";

                /**
                 * Verifies a DescribeNamespaceRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribeNamespaceRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeNamespaceRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DescribeNamespaceRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribeNamespaceRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribeNamespaceRequest} DescribeNamespaceRequest
                 */
                DescribeNamespaceRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribeNamespaceRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribeNamespaceRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeNamespaceRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribeNamespaceRequest
                 * @static
                 * @param {clutch.k8s.v1.DescribeNamespaceRequest} message DescribeNamespaceRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeNamespaceRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DescribeNamespaceRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribeNamespaceRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeNamespaceRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeNamespaceRequest;
            })();

            v1.DescribeNamespaceResponse = (function() {

                /**
                 * Properties of a DescribeNamespaceResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribeNamespaceResponse
                 * @property {clutch.k8s.v1.INamespace|null} [namespace] DescribeNamespaceResponse namespace
                 */

                /**
                 * Constructs a new DescribeNamespaceResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribeNamespaceResponse.
                 * @implements IDescribeNamespaceResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribeNamespaceResponse=} [properties] Properties to set
                 */
                function DescribeNamespaceResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeNamespaceResponse namespace.
                 * @member {clutch.k8s.v1.INamespace|null|undefined} namespace
                 * @memberof clutch.k8s.v1.DescribeNamespaceResponse
                 * @instance
                 */
                DescribeNamespaceResponse.prototype.namespace = null;

                /**
                 * Verifies a DescribeNamespaceResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribeNamespaceResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeNamespaceResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace")) {
                        let error = $root.clutch.k8s.v1.Namespace.verify(message.namespace);
                        if (error)
                            return "namespace." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DescribeNamespaceResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribeNamespaceResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribeNamespaceResponse} DescribeNamespaceResponse
                 */
                DescribeNamespaceResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribeNamespaceResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribeNamespaceResponse();
                    if (object.namespace != null) {
                        if (typeof object.namespace !== "object")
                            throw TypeError(".clutch.k8s.v1.DescribeNamespaceResponse.namespace: object expected");
                        message.namespace = $root.clutch.k8s.v1.Namespace.fromObject(object.namespace);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeNamespaceResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribeNamespaceResponse
                 * @static
                 * @param {clutch.k8s.v1.DescribeNamespaceResponse} message DescribeNamespaceResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeNamespaceResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.namespace = null;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = $root.clutch.k8s.v1.Namespace.toObject(message.namespace, options);
                    return object;
                };

                /**
                 * Converts this DescribeNamespaceResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribeNamespaceResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeNamespaceResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeNamespaceResponse;
            })();

            /**
             * ObjectKind enum.
             * @name clutch.k8s.v1.ObjectKind
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} UNKNOWN=1 UNKNOWN value
             * @property {number} POD=2 POD value
             */
            v1.ObjectKind = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "UNKNOWN"] = 1;
                values[valuesById[2] = "POD"] = 2;
                return values;
            })();

            v1.Event = (function() {

                /**
                 * Properties of an Event.
                 * @memberof clutch.k8s.v1
                 * @interface IEvent
                 * @property {string|null} [name] Event name
                 * @property {string|null} [reason] Event reason
                 * @property {string|null} [description] Event description
                 * @property {string|null} [cluster] Event cluster
                 * @property {string|null} [namespace] Event namespace
                 * @property {string|null} [involvedObjectName] Event involvedObjectName
                 * @property {clutch.k8s.v1.ObjectKind|null} [kind] Event kind
                 * @property {number|Long|null} [creationTimeMillis] Event creationTimeMillis
                 */

                /**
                 * Constructs a new Event.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an Event.
                 * @implements IEvent
                 * @constructor
                 * @param {clutch.k8s.v1.IEvent=} [properties] Properties to set
                 */
                function Event(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Event name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.Event
                 * @instance
                 */
                Event.prototype.name = "";

                /**
                 * Event reason.
                 * @member {string} reason
                 * @memberof clutch.k8s.v1.Event
                 * @instance
                 */
                Event.prototype.reason = "";

                /**
                 * Event description.
                 * @member {string} description
                 * @memberof clutch.k8s.v1.Event
                 * @instance
                 */
                Event.prototype.description = "";

                /**
                 * Event cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.Event
                 * @instance
                 */
                Event.prototype.cluster = "";

                /**
                 * Event namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.Event
                 * @instance
                 */
                Event.prototype.namespace = "";

                /**
                 * Event involvedObjectName.
                 * @member {string} involvedObjectName
                 * @memberof clutch.k8s.v1.Event
                 * @instance
                 */
                Event.prototype.involvedObjectName = "";

                /**
                 * Event kind.
                 * @member {clutch.k8s.v1.ObjectKind} kind
                 * @memberof clutch.k8s.v1.Event
                 * @instance
                 */
                Event.prototype.kind = 0;

                /**
                 * Event creationTimeMillis.
                 * @member {number|Long} creationTimeMillis
                 * @memberof clutch.k8s.v1.Event
                 * @instance
                 */
                Event.prototype.creationTimeMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Verifies an Event message.
                 * @function verify
                 * @memberof clutch.k8s.v1.Event
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Event.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        if (!$util.isString(message.reason))
                            return "reason: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.involvedObjectName != null && message.hasOwnProperty("involvedObjectName"))
                        if (!$util.isString(message.involvedObjectName))
                            return "involvedObjectName: string expected";
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        switch (message.kind) {
                        default:
                            return "kind: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    if (message.creationTimeMillis != null && message.hasOwnProperty("creationTimeMillis"))
                        if (!$util.isInteger(message.creationTimeMillis) && !(message.creationTimeMillis && $util.isInteger(message.creationTimeMillis.low) && $util.isInteger(message.creationTimeMillis.high)))
                            return "creationTimeMillis: integer|Long expected";
                    return null;
                };

                /**
                 * Creates an Event message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.Event
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.Event} Event
                 */
                Event.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.Event)
                        return object;
                    let message = new $root.clutch.k8s.v1.Event();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.reason != null)
                        message.reason = String(object.reason);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.involvedObjectName != null)
                        message.involvedObjectName = String(object.involvedObjectName);
                    switch (object.kind) {
                    case "UNSPECIFIED":
                    case 0:
                        message.kind = 0;
                        break;
                    case "UNKNOWN":
                    case 1:
                        message.kind = 1;
                        break;
                    case "POD":
                    case 2:
                        message.kind = 2;
                        break;
                    }
                    if (object.creationTimeMillis != null)
                        if ($util.Long)
                            (message.creationTimeMillis = $util.Long.fromValue(object.creationTimeMillis)).unsigned = false;
                        else if (typeof object.creationTimeMillis === "string")
                            message.creationTimeMillis = parseInt(object.creationTimeMillis, 10);
                        else if (typeof object.creationTimeMillis === "number")
                            message.creationTimeMillis = object.creationTimeMillis;
                        else if (typeof object.creationTimeMillis === "object")
                            message.creationTimeMillis = new $util.LongBits(object.creationTimeMillis.low >>> 0, object.creationTimeMillis.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from an Event message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.Event
                 * @static
                 * @param {clutch.k8s.v1.Event} message Event
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Event.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.reason = "";
                        object.description = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.involvedObjectName = "";
                        object.kind = options.enums === String ? "UNSPECIFIED" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.creationTimeMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.creationTimeMillis = options.longs === String ? "0" : 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        object.reason = message.reason;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.involvedObjectName != null && message.hasOwnProperty("involvedObjectName"))
                        object.involvedObjectName = message.involvedObjectName;
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        object.kind = options.enums === String ? $root.clutch.k8s.v1.ObjectKind[message.kind] : message.kind;
                    if (message.creationTimeMillis != null && message.hasOwnProperty("creationTimeMillis"))
                        if (typeof message.creationTimeMillis === "number")
                            object.creationTimeMillis = options.longs === String ? String(message.creationTimeMillis) : message.creationTimeMillis;
                        else
                            object.creationTimeMillis = options.longs === String ? $util.Long.prototype.toString.call(message.creationTimeMillis) : options.longs === Number ? new $util.LongBits(message.creationTimeMillis.low >>> 0, message.creationTimeMillis.high >>> 0).toNumber() : message.creationTimeMillis;
                    return object;
                };

                /**
                 * Converts this Event to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.Event
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Event.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Event;
            })();

            v1.ListEventsRequest = (function() {

                /**
                 * Properties of a ListEventsRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IListEventsRequest
                 * @property {string|null} [clientset] ListEventsRequest clientset
                 * @property {string|null} [cluster] ListEventsRequest cluster
                 * @property {string|null} [namespace] ListEventsRequest namespace
                 * @property {string|null} [objectName] ListEventsRequest objectName
                 * @property {clutch.k8s.v1.ObjectKind|null} [kind] ListEventsRequest kind
                 */

                /**
                 * Constructs a new ListEventsRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListEventsRequest.
                 * @implements IListEventsRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IListEventsRequest=} [properties] Properties to set
                 */
                function ListEventsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListEventsRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.ListEventsRequest
                 * @instance
                 */
                ListEventsRequest.prototype.clientset = "";

                /**
                 * ListEventsRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.ListEventsRequest
                 * @instance
                 */
                ListEventsRequest.prototype.cluster = "";

                /**
                 * ListEventsRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.ListEventsRequest
                 * @instance
                 */
                ListEventsRequest.prototype.namespace = "";

                /**
                 * ListEventsRequest objectName.
                 * @member {string} objectName
                 * @memberof clutch.k8s.v1.ListEventsRequest
                 * @instance
                 */
                ListEventsRequest.prototype.objectName = "";

                /**
                 * ListEventsRequest kind.
                 * @member {clutch.k8s.v1.ObjectKind} kind
                 * @memberof clutch.k8s.v1.ListEventsRequest
                 * @instance
                 */
                ListEventsRequest.prototype.kind = 0;

                /**
                 * Verifies a ListEventsRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListEventsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListEventsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.objectName != null && message.hasOwnProperty("objectName"))
                        if (!$util.isString(message.objectName))
                            return "objectName: string expected";
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        switch (message.kind) {
                        default:
                            return "kind: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a ListEventsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListEventsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListEventsRequest} ListEventsRequest
                 */
                ListEventsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListEventsRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListEventsRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.objectName != null)
                        message.objectName = String(object.objectName);
                    switch (object.kind) {
                    case "UNSPECIFIED":
                    case 0:
                        message.kind = 0;
                        break;
                    case "UNKNOWN":
                    case 1:
                        message.kind = 1;
                        break;
                    case "POD":
                    case 2:
                        message.kind = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListEventsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListEventsRequest
                 * @static
                 * @param {clutch.k8s.v1.ListEventsRequest} message ListEventsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListEventsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.objectName = "";
                        object.kind = options.enums === String ? "UNSPECIFIED" : 0;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.objectName != null && message.hasOwnProperty("objectName"))
                        object.objectName = message.objectName;
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        object.kind = options.enums === String ? $root.clutch.k8s.v1.ObjectKind[message.kind] : message.kind;
                    return object;
                };

                /**
                 * Converts this ListEventsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListEventsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListEventsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListEventsRequest;
            })();

            v1.ListEventsResponse = (function() {

                /**
                 * Properties of a ListEventsResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IListEventsResponse
                 * @property {Array.<clutch.k8s.v1.IEvent>|null} [events] ListEventsResponse events
                 */

                /**
                 * Constructs a new ListEventsResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListEventsResponse.
                 * @implements IListEventsResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IListEventsResponse=} [properties] Properties to set
                 */
                function ListEventsResponse(properties) {
                    this.events = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListEventsResponse events.
                 * @member {Array.<clutch.k8s.v1.IEvent>} events
                 * @memberof clutch.k8s.v1.ListEventsResponse
                 * @instance
                 */
                ListEventsResponse.prototype.events = $util.emptyArray;

                /**
                 * Verifies a ListEventsResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListEventsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListEventsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.events != null && message.hasOwnProperty("events")) {
                        if (!Array.isArray(message.events))
                            return "events: array expected";
                        for (let i = 0; i < message.events.length; ++i) {
                            let error = $root.clutch.k8s.v1.Event.verify(message.events[i]);
                            if (error)
                                return "events." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ListEventsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListEventsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListEventsResponse} ListEventsResponse
                 */
                ListEventsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListEventsResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListEventsResponse();
                    if (object.events) {
                        if (!Array.isArray(object.events))
                            throw TypeError(".clutch.k8s.v1.ListEventsResponse.events: array expected");
                        message.events = [];
                        for (let i = 0; i < object.events.length; ++i) {
                            if (typeof object.events[i] !== "object")
                                throw TypeError(".clutch.k8s.v1.ListEventsResponse.events: object expected");
                            message.events[i] = $root.clutch.k8s.v1.Event.fromObject(object.events[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListEventsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListEventsResponse
                 * @static
                 * @param {clutch.k8s.v1.ListEventsResponse} message ListEventsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListEventsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.events = [];
                    if (message.events && message.events.length) {
                        object.events = [];
                        for (let j = 0; j < message.events.length; ++j)
                            object.events[j] = $root.clutch.k8s.v1.Event.toObject(message.events[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ListEventsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListEventsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListEventsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListEventsResponse;
            })();

            v1.NullableString = (function() {

                /**
                 * Properties of a NullableString.
                 * @memberof clutch.k8s.v1
                 * @interface INullableString
                 * @property {google.protobuf.NullValue|null} ["null"] NullableString null
                 * @property {string|null} [value] NullableString value
                 */

                /**
                 * Constructs a new NullableString.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a NullableString.
                 * @implements INullableString
                 * @constructor
                 * @param {clutch.k8s.v1.INullableString=} [properties] Properties to set
                 */
                function NullableString(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NullableString null.
                 * @member {google.protobuf.NullValue|null|undefined} null
                 * @memberof clutch.k8s.v1.NullableString
                 * @instance
                 */
                NullableString.prototype["null"] = null;

                /**
                 * NullableString value.
                 * @member {string|null|undefined} value
                 * @memberof clutch.k8s.v1.NullableString
                 * @instance
                 */
                NullableString.prototype.value = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * NullableString kind.
                 * @member {"null"|"value"|undefined} kind
                 * @memberof clutch.k8s.v1.NullableString
                 * @instance
                 */
                Object.defineProperty(NullableString.prototype, "kind", {
                    get: $util.oneOfGetter($oneOfFields = ["null", "value"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies a NullableString message.
                 * @function verify
                 * @memberof clutch.k8s.v1.NullableString
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NullableString.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message["null"] != null && message.hasOwnProperty("null")) {
                        properties.kind = 1;
                        switch (message["null"]) {
                        default:
                            return "null: enum value expected";
                        case 0:
                            break;
                        }
                    }
                    if (message.value != null && message.hasOwnProperty("value")) {
                        if (properties.kind === 1)
                            return "kind: multiple values";
                        properties.kind = 1;
                        if (!$util.isString(message.value))
                            return "value: string expected";
                    }
                    return null;
                };

                /**
                 * Creates a NullableString message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.NullableString
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.NullableString} NullableString
                 */
                NullableString.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.NullableString)
                        return object;
                    let message = new $root.clutch.k8s.v1.NullableString();
                    switch (object["null"]) {
                    case "NULL_VALUE":
                    case 0:
                        message["null"] = 0;
                        break;
                    }
                    if (object.value != null)
                        message.value = String(object.value);
                    return message;
                };

                /**
                 * Creates a plain object from a NullableString message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.NullableString
                 * @static
                 * @param {clutch.k8s.v1.NullableString} message NullableString
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NullableString.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message["null"] != null && message.hasOwnProperty("null")) {
                        object["null"] = options.enums === String ? $root.google.protobuf.NullValue[message["null"]] : message["null"];
                        if (options.oneofs)
                            object.kind = "null";
                    }
                    if (message.value != null && message.hasOwnProperty("value")) {
                        object.value = message.value;
                        if (options.oneofs)
                            object.kind = "value";
                    }
                    return object;
                };

                /**
                 * Converts this NullableString to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.NullableString
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NullableString.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NullableString;
            })();

            v1.ExpectedObjectMetaFields = (function() {

                /**
                 * Properties of an ExpectedObjectMetaFields.
                 * @memberof clutch.k8s.v1
                 * @interface IExpectedObjectMetaFields
                 * @property {Object.<string,clutch.k8s.v1.INullableString>|null} [labels] ExpectedObjectMetaFields labels
                 * @property {Object.<string,clutch.k8s.v1.INullableString>|null} [annotations] ExpectedObjectMetaFields annotations
                 */

                /**
                 * Constructs a new ExpectedObjectMetaFields.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an ExpectedObjectMetaFields.
                 * @implements IExpectedObjectMetaFields
                 * @constructor
                 * @param {clutch.k8s.v1.IExpectedObjectMetaFields=} [properties] Properties to set
                 */
                function ExpectedObjectMetaFields(properties) {
                    this.labels = {};
                    this.annotations = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExpectedObjectMetaFields labels.
                 * @member {Object.<string,clutch.k8s.v1.INullableString>} labels
                 * @memberof clutch.k8s.v1.ExpectedObjectMetaFields
                 * @instance
                 */
                ExpectedObjectMetaFields.prototype.labels = $util.emptyObject;

                /**
                 * ExpectedObjectMetaFields annotations.
                 * @member {Object.<string,clutch.k8s.v1.INullableString>} annotations
                 * @memberof clutch.k8s.v1.ExpectedObjectMetaFields
                 * @instance
                 */
                ExpectedObjectMetaFields.prototype.annotations = $util.emptyObject;

                /**
                 * Verifies an ExpectedObjectMetaFields message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ExpectedObjectMetaFields
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExpectedObjectMetaFields.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.clutch.k8s.v1.NullableString.verify(message.labels[key[i]]);
                            if (error)
                                return "labels." + error;
                        }
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.clutch.k8s.v1.NullableString.verify(message.annotations[key[i]]);
                            if (error)
                                return "annotations." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an ExpectedObjectMetaFields message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ExpectedObjectMetaFields
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ExpectedObjectMetaFields} ExpectedObjectMetaFields
                 */
                ExpectedObjectMetaFields.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ExpectedObjectMetaFields)
                        return object;
                    let message = new $root.clutch.k8s.v1.ExpectedObjectMetaFields();
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.ExpectedObjectMetaFields.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i) {
                            if (typeof object.labels[keys[i]] !== "object")
                                throw TypeError(".clutch.k8s.v1.ExpectedObjectMetaFields.labels: object expected");
                            message.labels[keys[i]] = $root.clutch.k8s.v1.NullableString.fromObject(object.labels[keys[i]]);
                        }
                    }
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.ExpectedObjectMetaFields.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i) {
                            if (typeof object.annotations[keys[i]] !== "object")
                                throw TypeError(".clutch.k8s.v1.ExpectedObjectMetaFields.annotations: object expected");
                            message.annotations[keys[i]] = $root.clutch.k8s.v1.NullableString.fromObject(object.annotations[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ExpectedObjectMetaFields message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ExpectedObjectMetaFields
                 * @static
                 * @param {clutch.k8s.v1.ExpectedObjectMetaFields} message ExpectedObjectMetaFields
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExpectedObjectMetaFields.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.labels = {};
                        object.annotations = {};
                    }
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = $root.clutch.k8s.v1.NullableString.toObject(message.labels[keys2[j]], options);
                    }
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = $root.clutch.k8s.v1.NullableString.toObject(message.annotations[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Converts this ExpectedObjectMetaFields to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ExpectedObjectMetaFields
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExpectedObjectMetaFields.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExpectedObjectMetaFields;
            })();

            v1.ObjectMetaFields = (function() {

                /**
                 * Properties of an ObjectMetaFields.
                 * @memberof clutch.k8s.v1
                 * @interface IObjectMetaFields
                 * @property {Object.<string,string>|null} [labels] ObjectMetaFields labels
                 * @property {Object.<string,string>|null} [annotations] ObjectMetaFields annotations
                 */

                /**
                 * Constructs a new ObjectMetaFields.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an ObjectMetaFields.
                 * @implements IObjectMetaFields
                 * @constructor
                 * @param {clutch.k8s.v1.IObjectMetaFields=} [properties] Properties to set
                 */
                function ObjectMetaFields(properties) {
                    this.labels = {};
                    this.annotations = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ObjectMetaFields labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.ObjectMetaFields
                 * @instance
                 */
                ObjectMetaFields.prototype.labels = $util.emptyObject;

                /**
                 * ObjectMetaFields annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof clutch.k8s.v1.ObjectMetaFields
                 * @instance
                 */
                ObjectMetaFields.prototype.annotations = $util.emptyObject;

                /**
                 * Verifies an ObjectMetaFields message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ObjectMetaFields
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ObjectMetaFields.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates an ObjectMetaFields message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ObjectMetaFields
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ObjectMetaFields} ObjectMetaFields
                 */
                ObjectMetaFields.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ObjectMetaFields)
                        return object;
                    let message = new $root.clutch.k8s.v1.ObjectMetaFields();
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.ObjectMetaFields.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.ObjectMetaFields.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                            message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ObjectMetaFields message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ObjectMetaFields
                 * @static
                 * @param {clutch.k8s.v1.ObjectMetaFields} message ObjectMetaFields
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ObjectMetaFields.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.labels = {};
                        object.annotations = {};
                    }
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = message.annotations[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Converts this ObjectMetaFields to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ObjectMetaFields
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ObjectMetaFields.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ObjectMetaFields;
            })();

            v1.RemoveObjectMetaFields = (function() {

                /**
                 * Properties of a RemoveObjectMetaFields.
                 * @memberof clutch.k8s.v1
                 * @interface IRemoveObjectMetaFields
                 * @property {Array.<string>|null} [labels] RemoveObjectMetaFields labels
                 * @property {Array.<string>|null} [annotations] RemoveObjectMetaFields annotations
                 */

                /**
                 * Constructs a new RemoveObjectMetaFields.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a RemoveObjectMetaFields.
                 * @implements IRemoveObjectMetaFields
                 * @constructor
                 * @param {clutch.k8s.v1.IRemoveObjectMetaFields=} [properties] Properties to set
                 */
                function RemoveObjectMetaFields(properties) {
                    this.labels = [];
                    this.annotations = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RemoveObjectMetaFields labels.
                 * @member {Array.<string>} labels
                 * @memberof clutch.k8s.v1.RemoveObjectMetaFields
                 * @instance
                 */
                RemoveObjectMetaFields.prototype.labels = $util.emptyArray;

                /**
                 * RemoveObjectMetaFields annotations.
                 * @member {Array.<string>} annotations
                 * @memberof clutch.k8s.v1.RemoveObjectMetaFields
                 * @instance
                 */
                RemoveObjectMetaFields.prototype.annotations = $util.emptyArray;

                /**
                 * Verifies a RemoveObjectMetaFields message.
                 * @function verify
                 * @memberof clutch.k8s.v1.RemoveObjectMetaFields
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RemoveObjectMetaFields.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!Array.isArray(message.labels))
                            return "labels: array expected";
                        for (let i = 0; i < message.labels.length; ++i)
                            if (!$util.isString(message.labels[i]))
                                return "labels: string[] expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!Array.isArray(message.annotations))
                            return "annotations: array expected";
                        for (let i = 0; i < message.annotations.length; ++i)
                            if (!$util.isString(message.annotations[i]))
                                return "annotations: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a RemoveObjectMetaFields message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.RemoveObjectMetaFields
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.RemoveObjectMetaFields} RemoveObjectMetaFields
                 */
                RemoveObjectMetaFields.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.RemoveObjectMetaFields)
                        return object;
                    let message = new $root.clutch.k8s.v1.RemoveObjectMetaFields();
                    if (object.labels) {
                        if (!Array.isArray(object.labels))
                            throw TypeError(".clutch.k8s.v1.RemoveObjectMetaFields.labels: array expected");
                        message.labels = [];
                        for (let i = 0; i < object.labels.length; ++i)
                            message.labels[i] = String(object.labels[i]);
                    }
                    if (object.annotations) {
                        if (!Array.isArray(object.annotations))
                            throw TypeError(".clutch.k8s.v1.RemoveObjectMetaFields.annotations: array expected");
                        message.annotations = [];
                        for (let i = 0; i < object.annotations.length; ++i)
                            message.annotations[i] = String(object.annotations[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RemoveObjectMetaFields message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.RemoveObjectMetaFields
                 * @static
                 * @param {clutch.k8s.v1.RemoveObjectMetaFields} message RemoveObjectMetaFields
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RemoveObjectMetaFields.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.labels = [];
                        object.annotations = [];
                    }
                    if (message.labels && message.labels.length) {
                        object.labels = [];
                        for (let j = 0; j < message.labels.length; ++j)
                            object.labels[j] = message.labels[j];
                    }
                    if (message.annotations && message.annotations.length) {
                        object.annotations = [];
                        for (let j = 0; j < message.annotations.length; ++j)
                            object.annotations[j] = message.annotations[j];
                    }
                    return object;
                };

                /**
                 * Converts this RemoveObjectMetaFields to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.RemoveObjectMetaFields
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RemoveObjectMetaFields.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RemoveObjectMetaFields;
            })();

            v1.Node = (function() {

                /**
                 * Properties of a Node.
                 * @memberof clutch.k8s.v1
                 * @interface INode
                 * @property {string|null} [name] Node name
                 * @property {string|null} [cluster] Node cluster
                 * @property {boolean|null} [unschedulable] Node unschedulable
                 */

                /**
                 * Constructs a new Node.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a Node.
                 * @implements INode
                 * @constructor
                 * @param {clutch.k8s.v1.INode=} [properties] Properties to set
                 */
                function Node(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Node name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.Node
                 * @instance
                 */
                Node.prototype.name = "";

                /**
                 * Node cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.Node
                 * @instance
                 */
                Node.prototype.cluster = "";

                /**
                 * Node unschedulable.
                 * @member {boolean} unschedulable
                 * @memberof clutch.k8s.v1.Node
                 * @instance
                 */
                Node.prototype.unschedulable = false;

                /**
                 * Verifies a Node message.
                 * @function verify
                 * @memberof clutch.k8s.v1.Node
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Node.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.unschedulable != null && message.hasOwnProperty("unschedulable"))
                        if (typeof message.unschedulable !== "boolean")
                            return "unschedulable: boolean expected";
                    return null;
                };

                /**
                 * Creates a Node message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.Node
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.Node} Node
                 */
                Node.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.Node)
                        return object;
                    let message = new $root.clutch.k8s.v1.Node();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.unschedulable != null)
                        message.unschedulable = Boolean(object.unschedulable);
                    return message;
                };

                /**
                 * Creates a plain object from a Node message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.Node
                 * @static
                 * @param {clutch.k8s.v1.Node} message Node
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Node.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.cluster = "";
                        object.unschedulable = false;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.unschedulable != null && message.hasOwnProperty("unschedulable"))
                        object.unschedulable = message.unschedulable;
                    return object;
                };

                /**
                 * Converts this Node to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.Node
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Node.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Node;
            })();

            v1.DescribeNodeRequest = (function() {

                /**
                 * Properties of a DescribeNodeRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribeNodeRequest
                 * @property {string|null} [clientset] DescribeNodeRequest clientset
                 * @property {string|null} [cluster] DescribeNodeRequest cluster
                 * @property {string|null} [name] DescribeNodeRequest name
                 */

                /**
                 * Constructs a new DescribeNodeRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribeNodeRequest.
                 * @implements IDescribeNodeRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribeNodeRequest=} [properties] Properties to set
                 */
                function DescribeNodeRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeNodeRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DescribeNodeRequest
                 * @instance
                 */
                DescribeNodeRequest.prototype.clientset = "";

                /**
                 * DescribeNodeRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DescribeNodeRequest
                 * @instance
                 */
                DescribeNodeRequest.prototype.cluster = "";

                /**
                 * DescribeNodeRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DescribeNodeRequest
                 * @instance
                 */
                DescribeNodeRequest.prototype.name = "";

                /**
                 * Verifies a DescribeNodeRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribeNodeRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeNodeRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DescribeNodeRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribeNodeRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribeNodeRequest} DescribeNodeRequest
                 */
                DescribeNodeRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribeNodeRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribeNodeRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeNodeRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribeNodeRequest
                 * @static
                 * @param {clutch.k8s.v1.DescribeNodeRequest} message DescribeNodeRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeNodeRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DescribeNodeRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribeNodeRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeNodeRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeNodeRequest;
            })();

            v1.DescribeNodeResponse = (function() {

                /**
                 * Properties of a DescribeNodeResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribeNodeResponse
                 * @property {clutch.k8s.v1.INode|null} [node] DescribeNodeResponse node
                 */

                /**
                 * Constructs a new DescribeNodeResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribeNodeResponse.
                 * @implements IDescribeNodeResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribeNodeResponse=} [properties] Properties to set
                 */
                function DescribeNodeResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribeNodeResponse node.
                 * @member {clutch.k8s.v1.INode|null|undefined} node
                 * @memberof clutch.k8s.v1.DescribeNodeResponse
                 * @instance
                 */
                DescribeNodeResponse.prototype.node = null;

                /**
                 * Verifies a DescribeNodeResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribeNodeResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribeNodeResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.node != null && message.hasOwnProperty("node")) {
                        let error = $root.clutch.k8s.v1.Node.verify(message.node);
                        if (error)
                            return "node." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DescribeNodeResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribeNodeResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribeNodeResponse} DescribeNodeResponse
                 */
                DescribeNodeResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribeNodeResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribeNodeResponse();
                    if (object.node != null) {
                        if (typeof object.node !== "object")
                            throw TypeError(".clutch.k8s.v1.DescribeNodeResponse.node: object expected");
                        message.node = $root.clutch.k8s.v1.Node.fromObject(object.node);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DescribeNodeResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribeNodeResponse
                 * @static
                 * @param {clutch.k8s.v1.DescribeNodeResponse} message DescribeNodeResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribeNodeResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.node = null;
                    if (message.node != null && message.hasOwnProperty("node"))
                        object.node = $root.clutch.k8s.v1.Node.toObject(message.node, options);
                    return object;
                };

                /**
                 * Converts this DescribeNodeResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribeNodeResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribeNodeResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribeNodeResponse;
            })();

            v1.UpdateNodeRequest = (function() {

                /**
                 * Properties of an UpdateNodeRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IUpdateNodeRequest
                 * @property {string|null} [clientset] UpdateNodeRequest clientset
                 * @property {string|null} [cluster] UpdateNodeRequest cluster
                 * @property {string|null} [name] UpdateNodeRequest name
                 * @property {boolean|null} [unschedulable] UpdateNodeRequest unschedulable
                 */

                /**
                 * Constructs a new UpdateNodeRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an UpdateNodeRequest.
                 * @implements IUpdateNodeRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IUpdateNodeRequest=} [properties] Properties to set
                 */
                function UpdateNodeRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdateNodeRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.UpdateNodeRequest
                 * @instance
                 */
                UpdateNodeRequest.prototype.clientset = "";

                /**
                 * UpdateNodeRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.UpdateNodeRequest
                 * @instance
                 */
                UpdateNodeRequest.prototype.cluster = "";

                /**
                 * UpdateNodeRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.UpdateNodeRequest
                 * @instance
                 */
                UpdateNodeRequest.prototype.name = "";

                /**
                 * UpdateNodeRequest unschedulable.
                 * @member {boolean} unschedulable
                 * @memberof clutch.k8s.v1.UpdateNodeRequest
                 * @instance
                 */
                UpdateNodeRequest.prototype.unschedulable = false;

                /**
                 * Verifies an UpdateNodeRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.UpdateNodeRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateNodeRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.unschedulable != null && message.hasOwnProperty("unschedulable"))
                        if (typeof message.unschedulable !== "boolean")
                            return "unschedulable: boolean expected";
                    return null;
                };

                /**
                 * Creates an UpdateNodeRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.UpdateNodeRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.UpdateNodeRequest} UpdateNodeRequest
                 */
                UpdateNodeRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.UpdateNodeRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.UpdateNodeRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.unschedulable != null)
                        message.unschedulable = Boolean(object.unschedulable);
                    return message;
                };

                /**
                 * Creates a plain object from an UpdateNodeRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.UpdateNodeRequest
                 * @static
                 * @param {clutch.k8s.v1.UpdateNodeRequest} message UpdateNodeRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateNodeRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.name = "";
                        object.unschedulable = false;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.unschedulable != null && message.hasOwnProperty("unschedulable"))
                        object.unschedulable = message.unschedulable;
                    return object;
                };

                /**
                 * Converts this UpdateNodeRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.UpdateNodeRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateNodeRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdateNodeRequest;
            })();

            v1.UpdateNodeResponse = (function() {

                /**
                 * Properties of an UpdateNodeResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IUpdateNodeResponse
                 */

                /**
                 * Constructs a new UpdateNodeResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an UpdateNodeResponse.
                 * @implements IUpdateNodeResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IUpdateNodeResponse=} [properties] Properties to set
                 */
                function UpdateNodeResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies an UpdateNodeResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.UpdateNodeResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateNodeResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an UpdateNodeResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.UpdateNodeResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.UpdateNodeResponse} UpdateNodeResponse
                 */
                UpdateNodeResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.UpdateNodeResponse)
                        return object;
                    return new $root.clutch.k8s.v1.UpdateNodeResponse();
                };

                /**
                 * Creates a plain object from an UpdateNodeResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.UpdateNodeResponse
                 * @static
                 * @param {clutch.k8s.v1.UpdateNodeResponse} message UpdateNodeResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateNodeResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this UpdateNodeResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.UpdateNodeResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateNodeResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdateNodeResponse;
            })();

            v1.Status = (function() {

                /**
                 * Properties of a Status.
                 * @memberof clutch.k8s.v1
                 * @interface IStatus
                 * @property {string|null} [status] Status status
                 * @property {string|null} [message] Status message
                 * @property {string|null} [reason] Status reason
                 * @property {number|null} [code] Status code
                 * @property {clutch.k8s.v1.IStatusDetails|null} [details] Status details
                 */

                /**
                 * Constructs a new Status.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a Status.
                 * @implements IStatus
                 * @constructor
                 * @param {clutch.k8s.v1.IStatus=} [properties] Properties to set
                 */
                function Status(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Status status.
                 * @member {string} status
                 * @memberof clutch.k8s.v1.Status
                 * @instance
                 */
                Status.prototype.status = "";

                /**
                 * Status message.
                 * @member {string} message
                 * @memberof clutch.k8s.v1.Status
                 * @instance
                 */
                Status.prototype.message = "";

                /**
                 * Status reason.
                 * @member {string} reason
                 * @memberof clutch.k8s.v1.Status
                 * @instance
                 */
                Status.prototype.reason = "";

                /**
                 * Status code.
                 * @member {number} code
                 * @memberof clutch.k8s.v1.Status
                 * @instance
                 */
                Status.prototype.code = 0;

                /**
                 * Status details.
                 * @member {clutch.k8s.v1.IStatusDetails|null|undefined} details
                 * @memberof clutch.k8s.v1.Status
                 * @instance
                 */
                Status.prototype.details = null;

                /**
                 * Verifies a Status message.
                 * @function verify
                 * @memberof clutch.k8s.v1.Status
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Status.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status"))
                        if (!$util.isString(message.status))
                            return "status: string expected";
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        if (!$util.isString(message.reason))
                            return "reason: string expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (!$util.isInteger(message.code))
                            return "code: integer expected";
                    if (message.details != null && message.hasOwnProperty("details")) {
                        let error = $root.clutch.k8s.v1.StatusDetails.verify(message.details);
                        if (error)
                            return "details." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Status message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.Status
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.Status} Status
                 */
                Status.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.Status)
                        return object;
                    let message = new $root.clutch.k8s.v1.Status();
                    if (object.status != null)
                        message.status = String(object.status);
                    if (object.message != null)
                        message.message = String(object.message);
                    if (object.reason != null)
                        message.reason = String(object.reason);
                    if (object.code != null)
                        message.code = object.code | 0;
                    if (object.details != null) {
                        if (typeof object.details !== "object")
                            throw TypeError(".clutch.k8s.v1.Status.details: object expected");
                        message.details = $root.clutch.k8s.v1.StatusDetails.fromObject(object.details);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Status message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.Status
                 * @static
                 * @param {clutch.k8s.v1.Status} message Status
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Status.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.status = "";
                        object.message = "";
                        object.reason = "";
                        object.code = 0;
                        object.details = null;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = message.status;
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    if (message.reason != null && message.hasOwnProperty("reason"))
                        object.reason = message.reason;
                    if (message.code != null && message.hasOwnProperty("code"))
                        object.code = message.code;
                    if (message.details != null && message.hasOwnProperty("details"))
                        object.details = $root.clutch.k8s.v1.StatusDetails.toObject(message.details, options);
                    return object;
                };

                /**
                 * Converts this Status to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.Status
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Status.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Status;
            })();

            v1.StatusDetails = (function() {

                /**
                 * Properties of a StatusDetails.
                 * @memberof clutch.k8s.v1
                 * @interface IStatusDetails
                 * @property {string|null} [name] StatusDetails name
                 * @property {string|null} [group] StatusDetails group
                 * @property {string|null} [kind] StatusDetails kind
                 * @property {string|null} [uid] StatusDetails uid
                 * @property {Array.<clutch.k8s.v1.IStatusCause>|null} [causes] StatusDetails causes
                 */

                /**
                 * Constructs a new StatusDetails.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a StatusDetails.
                 * @implements IStatusDetails
                 * @constructor
                 * @param {clutch.k8s.v1.IStatusDetails=} [properties] Properties to set
                 */
                function StatusDetails(properties) {
                    this.causes = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StatusDetails name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.StatusDetails
                 * @instance
                 */
                StatusDetails.prototype.name = "";

                /**
                 * StatusDetails group.
                 * @member {string} group
                 * @memberof clutch.k8s.v1.StatusDetails
                 * @instance
                 */
                StatusDetails.prototype.group = "";

                /**
                 * StatusDetails kind.
                 * @member {string} kind
                 * @memberof clutch.k8s.v1.StatusDetails
                 * @instance
                 */
                StatusDetails.prototype.kind = "";

                /**
                 * StatusDetails uid.
                 * @member {string} uid
                 * @memberof clutch.k8s.v1.StatusDetails
                 * @instance
                 */
                StatusDetails.prototype.uid = "";

                /**
                 * StatusDetails causes.
                 * @member {Array.<clutch.k8s.v1.IStatusCause>} causes
                 * @memberof clutch.k8s.v1.StatusDetails
                 * @instance
                 */
                StatusDetails.prototype.causes = $util.emptyArray;

                /**
                 * Verifies a StatusDetails message.
                 * @function verify
                 * @memberof clutch.k8s.v1.StatusDetails
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StatusDetails.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.group != null && message.hasOwnProperty("group"))
                        if (!$util.isString(message.group))
                            return "group: string expected";
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        if (!$util.isString(message.kind))
                            return "kind: string expected";
                    if (message.uid != null && message.hasOwnProperty("uid"))
                        if (!$util.isString(message.uid))
                            return "uid: string expected";
                    if (message.causes != null && message.hasOwnProperty("causes")) {
                        if (!Array.isArray(message.causes))
                            return "causes: array expected";
                        for (let i = 0; i < message.causes.length; ++i) {
                            let error = $root.clutch.k8s.v1.StatusCause.verify(message.causes[i]);
                            if (error)
                                return "causes." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a StatusDetails message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.StatusDetails
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.StatusDetails} StatusDetails
                 */
                StatusDetails.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.StatusDetails)
                        return object;
                    let message = new $root.clutch.k8s.v1.StatusDetails();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.group != null)
                        message.group = String(object.group);
                    if (object.kind != null)
                        message.kind = String(object.kind);
                    if (object.uid != null)
                        message.uid = String(object.uid);
                    if (object.causes) {
                        if (!Array.isArray(object.causes))
                            throw TypeError(".clutch.k8s.v1.StatusDetails.causes: array expected");
                        message.causes = [];
                        for (let i = 0; i < object.causes.length; ++i) {
                            if (typeof object.causes[i] !== "object")
                                throw TypeError(".clutch.k8s.v1.StatusDetails.causes: object expected");
                            message.causes[i] = $root.clutch.k8s.v1.StatusCause.fromObject(object.causes[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a StatusDetails message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.StatusDetails
                 * @static
                 * @param {clutch.k8s.v1.StatusDetails} message StatusDetails
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StatusDetails.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.causes = [];
                    if (options.defaults) {
                        object.name = "";
                        object.group = "";
                        object.kind = "";
                        object.uid = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.group != null && message.hasOwnProperty("group"))
                        object.group = message.group;
                    if (message.kind != null && message.hasOwnProperty("kind"))
                        object.kind = message.kind;
                    if (message.uid != null && message.hasOwnProperty("uid"))
                        object.uid = message.uid;
                    if (message.causes && message.causes.length) {
                        object.causes = [];
                        for (let j = 0; j < message.causes.length; ++j)
                            object.causes[j] = $root.clutch.k8s.v1.StatusCause.toObject(message.causes[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this StatusDetails to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.StatusDetails
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StatusDetails.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return StatusDetails;
            })();

            v1.StatusCause = (function() {

                /**
                 * Properties of a StatusCause.
                 * @memberof clutch.k8s.v1
                 * @interface IStatusCause
                 * @property {string|null} [type] StatusCause type
                 * @property {string|null} [message] StatusCause message
                 * @property {string|null} [field] StatusCause field
                 */

                /**
                 * Constructs a new StatusCause.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a StatusCause.
                 * @implements IStatusCause
                 * @constructor
                 * @param {clutch.k8s.v1.IStatusCause=} [properties] Properties to set
                 */
                function StatusCause(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StatusCause type.
                 * @member {string} type
                 * @memberof clutch.k8s.v1.StatusCause
                 * @instance
                 */
                StatusCause.prototype.type = "";

                /**
                 * StatusCause message.
                 * @member {string} message
                 * @memberof clutch.k8s.v1.StatusCause
                 * @instance
                 */
                StatusCause.prototype.message = "";

                /**
                 * StatusCause field.
                 * @member {string} field
                 * @memberof clutch.k8s.v1.StatusCause
                 * @instance
                 */
                StatusCause.prototype.field = "";

                /**
                 * Verifies a StatusCause message.
                 * @function verify
                 * @memberof clutch.k8s.v1.StatusCause
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StatusCause.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        if (!$util.isString(message.type))
                            return "type: string expected";
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    if (message.field != null && message.hasOwnProperty("field"))
                        if (!$util.isString(message.field))
                            return "field: string expected";
                    return null;
                };

                /**
                 * Creates a StatusCause message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.StatusCause
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.StatusCause} StatusCause
                 */
                StatusCause.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.StatusCause)
                        return object;
                    let message = new $root.clutch.k8s.v1.StatusCause();
                    if (object.type != null)
                        message.type = String(object.type);
                    if (object.message != null)
                        message.message = String(object.message);
                    if (object.field != null)
                        message.field = String(object.field);
                    return message;
                };

                /**
                 * Creates a plain object from a StatusCause message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.StatusCause
                 * @static
                 * @param {clutch.k8s.v1.StatusCause} message StatusCause
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StatusCause.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.type = "";
                        object.message = "";
                        object.field = "";
                    }
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = message.type;
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    if (message.field != null && message.hasOwnProperty("field"))
                        object.field = message.field;
                    return object;
                };

                /**
                 * Converts this StatusCause to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.StatusCause
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StatusCause.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return StatusCause;
            })();

            return v1;
        })();

        return k8s;
    })();

    clutch.metrics = (function() {

        /**
         * Namespace metrics.
         * @memberof clutch
         * @namespace
         */
        const metrics = {};

        metrics.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.metrics
             * @namespace
             */
            const v1 = {};

            v1.MetricsAPI = (function() {

                /**
                 * Constructs a new MetricsAPI service.
                 * @memberof clutch.metrics.v1
                 * @classdesc Represents a MetricsAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function MetricsAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (MetricsAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = MetricsAPI;

                /**
                 * Callback as used by {@link clutch.metrics.v1.MetricsAPI#getMetrics}.
                 * @memberof clutch.metrics.v1.MetricsAPI
                 * @typedef GetMetricsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.metrics.v1.GetMetricsResponse} [response] GetMetricsResponse
                 */

                /**
                 * Calls GetMetrics.
                 * @function getMetrics
                 * @memberof clutch.metrics.v1.MetricsAPI
                 * @instance
                 * @param {clutch.metrics.v1.IGetMetricsRequest} request GetMetricsRequest message or plain object
                 * @param {clutch.metrics.v1.MetricsAPI.GetMetricsCallback} callback Node-style callback called with the error, if any, and GetMetricsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(MetricsAPI.prototype.getMetrics = function getMetrics(request, callback) {
                    return this.rpcCall(getMetrics, $root.clutch.metrics.v1.GetMetricsRequest, $root.clutch.metrics.v1.GetMetricsResponse, request, callback);
                }, "name", { value: "GetMetrics" });

                /**
                 * Calls GetMetrics.
                 * @function getMetrics
                 * @memberof clutch.metrics.v1.MetricsAPI
                 * @instance
                 * @param {clutch.metrics.v1.IGetMetricsRequest} request GetMetricsRequest message or plain object
                 * @returns {Promise<clutch.metrics.v1.GetMetricsResponse>} Promise
                 * @variation 2
                 */

                return MetricsAPI;
            })();

            v1.Query = (function() {

                /**
                 * Properties of a Query.
                 * @memberof clutch.metrics.v1
                 * @interface IQuery
                 * @property {string|null} [expression] prometheus expression query string
                 * @property {number|Long|null} [startTimeMs] inclusive
                 * @property {number|Long|null} [endTimeMs] inclusive
                 * @property {number|Long|null} [stepMs] default is 1 minute (60000)
                 */

                /**
                 * Constructs a new Query.
                 * @memberof clutch.metrics.v1
                 * @classdesc Represents a Query.
                 * @implements IQuery
                 * @constructor
                 * @param {clutch.metrics.v1.IQuery=} [properties] Properties to set
                 */
                function Query(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * prometheus expression query string
                 * @member {string} expression
                 * @memberof clutch.metrics.v1.Query
                 * @instance
                 */
                Query.prototype.expression = "";

                /**
                 * inclusive
                 * @member {number|Long} startTimeMs
                 * @memberof clutch.metrics.v1.Query
                 * @instance
                 */
                Query.prototype.startTimeMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * inclusive
                 * @member {number|Long} endTimeMs
                 * @memberof clutch.metrics.v1.Query
                 * @instance
                 */
                Query.prototype.endTimeMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * default is 1 minute (60000)
                 * @member {number|Long} stepMs
                 * @memberof clutch.metrics.v1.Query
                 * @instance
                 */
                Query.prototype.stepMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Verifies a Query message.
                 * @function verify
                 * @memberof clutch.metrics.v1.Query
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Query.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.expression != null && message.hasOwnProperty("expression"))
                        if (!$util.isString(message.expression))
                            return "expression: string expected";
                    if (message.startTimeMs != null && message.hasOwnProperty("startTimeMs"))
                        if (!$util.isInteger(message.startTimeMs) && !(message.startTimeMs && $util.isInteger(message.startTimeMs.low) && $util.isInteger(message.startTimeMs.high)))
                            return "startTimeMs: integer|Long expected";
                    if (message.endTimeMs != null && message.hasOwnProperty("endTimeMs"))
                        if (!$util.isInteger(message.endTimeMs) && !(message.endTimeMs && $util.isInteger(message.endTimeMs.low) && $util.isInteger(message.endTimeMs.high)))
                            return "endTimeMs: integer|Long expected";
                    if (message.stepMs != null && message.hasOwnProperty("stepMs"))
                        if (!$util.isInteger(message.stepMs) && !(message.stepMs && $util.isInteger(message.stepMs.low) && $util.isInteger(message.stepMs.high)))
                            return "stepMs: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a Query message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.metrics.v1.Query
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.metrics.v1.Query} Query
                 */
                Query.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.metrics.v1.Query)
                        return object;
                    let message = new $root.clutch.metrics.v1.Query();
                    if (object.expression != null)
                        message.expression = String(object.expression);
                    if (object.startTimeMs != null)
                        if ($util.Long)
                            (message.startTimeMs = $util.Long.fromValue(object.startTimeMs)).unsigned = false;
                        else if (typeof object.startTimeMs === "string")
                            message.startTimeMs = parseInt(object.startTimeMs, 10);
                        else if (typeof object.startTimeMs === "number")
                            message.startTimeMs = object.startTimeMs;
                        else if (typeof object.startTimeMs === "object")
                            message.startTimeMs = new $util.LongBits(object.startTimeMs.low >>> 0, object.startTimeMs.high >>> 0).toNumber();
                    if (object.endTimeMs != null)
                        if ($util.Long)
                            (message.endTimeMs = $util.Long.fromValue(object.endTimeMs)).unsigned = false;
                        else if (typeof object.endTimeMs === "string")
                            message.endTimeMs = parseInt(object.endTimeMs, 10);
                        else if (typeof object.endTimeMs === "number")
                            message.endTimeMs = object.endTimeMs;
                        else if (typeof object.endTimeMs === "object")
                            message.endTimeMs = new $util.LongBits(object.endTimeMs.low >>> 0, object.endTimeMs.high >>> 0).toNumber();
                    if (object.stepMs != null)
                        if ($util.Long)
                            (message.stepMs = $util.Long.fromValue(object.stepMs)).unsigned = false;
                        else if (typeof object.stepMs === "string")
                            message.stepMs = parseInt(object.stepMs, 10);
                        else if (typeof object.stepMs === "number")
                            message.stepMs = object.stepMs;
                        else if (typeof object.stepMs === "object")
                            message.stepMs = new $util.LongBits(object.stepMs.low >>> 0, object.stepMs.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a Query message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.metrics.v1.Query
                 * @static
                 * @param {clutch.metrics.v1.Query} message Query
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Query.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.expression = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.startTimeMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.startTimeMs = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.endTimeMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.endTimeMs = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.stepMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.stepMs = options.longs === String ? "0" : 0;
                    }
                    if (message.expression != null && message.hasOwnProperty("expression"))
                        object.expression = message.expression;
                    if (message.startTimeMs != null && message.hasOwnProperty("startTimeMs"))
                        if (typeof message.startTimeMs === "number")
                            object.startTimeMs = options.longs === String ? String(message.startTimeMs) : message.startTimeMs;
                        else
                            object.startTimeMs = options.longs === String ? $util.Long.prototype.toString.call(message.startTimeMs) : options.longs === Number ? new $util.LongBits(message.startTimeMs.low >>> 0, message.startTimeMs.high >>> 0).toNumber() : message.startTimeMs;
                    if (message.endTimeMs != null && message.hasOwnProperty("endTimeMs"))
                        if (typeof message.endTimeMs === "number")
                            object.endTimeMs = options.longs === String ? String(message.endTimeMs) : message.endTimeMs;
                        else
                            object.endTimeMs = options.longs === String ? $util.Long.prototype.toString.call(message.endTimeMs) : options.longs === Number ? new $util.LongBits(message.endTimeMs.low >>> 0, message.endTimeMs.high >>> 0).toNumber() : message.endTimeMs;
                    if (message.stepMs != null && message.hasOwnProperty("stepMs"))
                        if (typeof message.stepMs === "number")
                            object.stepMs = options.longs === String ? String(message.stepMs) : message.stepMs;
                        else
                            object.stepMs = options.longs === String ? $util.Long.prototype.toString.call(message.stepMs) : options.longs === Number ? new $util.LongBits(message.stepMs.low >>> 0, message.stepMs.high >>> 0).toNumber() : message.stepMs;
                    return object;
                };

                /**
                 * Converts this Query to JSON.
                 * @function toJSON
                 * @memberof clutch.metrics.v1.Query
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Query.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Query;
            })();

            v1.GetMetricsRequest = (function() {

                /**
                 * Properties of a GetMetricsRequest.
                 * @memberof clutch.metrics.v1
                 * @interface IGetMetricsRequest
                 * @property {Array.<clutch.metrics.v1.IQuery>|null} [metricQueries] GetMetricsRequest metricQueries
                 */

                /**
                 * Constructs a new GetMetricsRequest.
                 * @memberof clutch.metrics.v1
                 * @classdesc Represents a GetMetricsRequest.
                 * @implements IGetMetricsRequest
                 * @constructor
                 * @param {clutch.metrics.v1.IGetMetricsRequest=} [properties] Properties to set
                 */
                function GetMetricsRequest(properties) {
                    this.metricQueries = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetMetricsRequest metricQueries.
                 * @member {Array.<clutch.metrics.v1.IQuery>} metricQueries
                 * @memberof clutch.metrics.v1.GetMetricsRequest
                 * @instance
                 */
                GetMetricsRequest.prototype.metricQueries = $util.emptyArray;

                /**
                 * Verifies a GetMetricsRequest message.
                 * @function verify
                 * @memberof clutch.metrics.v1.GetMetricsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetMetricsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.metricQueries != null && message.hasOwnProperty("metricQueries")) {
                        if (!Array.isArray(message.metricQueries))
                            return "metricQueries: array expected";
                        for (let i = 0; i < message.metricQueries.length; ++i) {
                            let error = $root.clutch.metrics.v1.Query.verify(message.metricQueries[i]);
                            if (error)
                                return "metricQueries." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetMetricsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.metrics.v1.GetMetricsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.metrics.v1.GetMetricsRequest} GetMetricsRequest
                 */
                GetMetricsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.metrics.v1.GetMetricsRequest)
                        return object;
                    let message = new $root.clutch.metrics.v1.GetMetricsRequest();
                    if (object.metricQueries) {
                        if (!Array.isArray(object.metricQueries))
                            throw TypeError(".clutch.metrics.v1.GetMetricsRequest.metricQueries: array expected");
                        message.metricQueries = [];
                        for (let i = 0; i < object.metricQueries.length; ++i) {
                            if (typeof object.metricQueries[i] !== "object")
                                throw TypeError(".clutch.metrics.v1.GetMetricsRequest.metricQueries: object expected");
                            message.metricQueries[i] = $root.clutch.metrics.v1.Query.fromObject(object.metricQueries[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetMetricsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.metrics.v1.GetMetricsRequest
                 * @static
                 * @param {clutch.metrics.v1.GetMetricsRequest} message GetMetricsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetMetricsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.metricQueries = [];
                    if (message.metricQueries && message.metricQueries.length) {
                        object.metricQueries = [];
                        for (let j = 0; j < message.metricQueries.length; ++j)
                            object.metricQueries[j] = $root.clutch.metrics.v1.Query.toObject(message.metricQueries[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetMetricsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.metrics.v1.GetMetricsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetMetricsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetMetricsRequest;
            })();

            v1.Metric = (function() {

                /**
                 * Properties of a Metric.
                 * @memberof clutch.metrics.v1
                 * @interface IMetric
                 * @property {number|null} [value] Metric value
                 * @property {number|Long|null} [timestampMs] Metric timestampMs
                 * @property {Object.<string,string>|null} [labels] metric labels (tags) have a key and a value
                 */

                /**
                 * Constructs a new Metric.
                 * @memberof clutch.metrics.v1
                 * @classdesc Represents a Metric.
                 * @implements IMetric
                 * @constructor
                 * @param {clutch.metrics.v1.IMetric=} [properties] Properties to set
                 */
                function Metric(properties) {
                    this.labels = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Metric value.
                 * @member {number} value
                 * @memberof clutch.metrics.v1.Metric
                 * @instance
                 */
                Metric.prototype.value = 0;

                /**
                 * Metric timestampMs.
                 * @member {number|Long} timestampMs
                 * @memberof clutch.metrics.v1.Metric
                 * @instance
                 */
                Metric.prototype.timestampMs = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * metric labels (tags) have a key and a value
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.metrics.v1.Metric
                 * @instance
                 */
                Metric.prototype.labels = $util.emptyObject;

                /**
                 * Verifies a Metric message.
                 * @function verify
                 * @memberof clutch.metrics.v1.Metric
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Metric.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value"))
                        if (typeof message.value !== "number")
                            return "value: number expected";
                    if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                        if (!$util.isInteger(message.timestampMs) && !(message.timestampMs && $util.isInteger(message.timestampMs.low) && $util.isInteger(message.timestampMs.high)))
                            return "timestampMs: integer|Long expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates a Metric message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.metrics.v1.Metric
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.metrics.v1.Metric} Metric
                 */
                Metric.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.metrics.v1.Metric)
                        return object;
                    let message = new $root.clutch.metrics.v1.Metric();
                    if (object.value != null)
                        message.value = Number(object.value);
                    if (object.timestampMs != null)
                        if ($util.Long)
                            (message.timestampMs = $util.Long.fromValue(object.timestampMs)).unsigned = false;
                        else if (typeof object.timestampMs === "string")
                            message.timestampMs = parseInt(object.timestampMs, 10);
                        else if (typeof object.timestampMs === "number")
                            message.timestampMs = object.timestampMs;
                        else if (typeof object.timestampMs === "object")
                            message.timestampMs = new $util.LongBits(object.timestampMs.low >>> 0, object.timestampMs.high >>> 0).toNumber();
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.metrics.v1.Metric.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Metric message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.metrics.v1.Metric
                 * @static
                 * @param {clutch.metrics.v1.Metric} message Metric
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Metric.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.labels = {};
                    if (options.defaults) {
                        object.value = 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.timestampMs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.timestampMs = options.longs === String ? "0" : 0;
                    }
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                    if (message.timestampMs != null && message.hasOwnProperty("timestampMs"))
                        if (typeof message.timestampMs === "number")
                            object.timestampMs = options.longs === String ? String(message.timestampMs) : message.timestampMs;
                        else
                            object.timestampMs = options.longs === String ? $util.Long.prototype.toString.call(message.timestampMs) : options.longs === Number ? new $util.LongBits(message.timestampMs.low >>> 0, message.timestampMs.high >>> 0).toNumber() : message.timestampMs;
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Converts this Metric to JSON.
                 * @function toJSON
                 * @memberof clutch.metrics.v1.Metric
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Metric.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Metric;
            })();

            v1.Metrics = (function() {

                /**
                 * Properties of a Metrics.
                 * @memberof clutch.metrics.v1
                 * @interface IMetrics
                 * @property {Array.<clutch.metrics.v1.IMetric>|null} [metrics] Metrics metrics
                 */

                /**
                 * Constructs a new Metrics.
                 * @memberof clutch.metrics.v1
                 * @classdesc Represents a Metrics.
                 * @implements IMetrics
                 * @constructor
                 * @param {clutch.metrics.v1.IMetrics=} [properties] Properties to set
                 */
                function Metrics(properties) {
                    this.metrics = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Metrics metrics.
                 * @member {Array.<clutch.metrics.v1.IMetric>} metrics
                 * @memberof clutch.metrics.v1.Metrics
                 * @instance
                 */
                Metrics.prototype.metrics = $util.emptyArray;

                /**
                 * Verifies a Metrics message.
                 * @function verify
                 * @memberof clutch.metrics.v1.Metrics
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Metrics.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.metrics != null && message.hasOwnProperty("metrics")) {
                        if (!Array.isArray(message.metrics))
                            return "metrics: array expected";
                        for (let i = 0; i < message.metrics.length; ++i) {
                            let error = $root.clutch.metrics.v1.Metric.verify(message.metrics[i]);
                            if (error)
                                return "metrics." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Metrics message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.metrics.v1.Metrics
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.metrics.v1.Metrics} Metrics
                 */
                Metrics.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.metrics.v1.Metrics)
                        return object;
                    let message = new $root.clutch.metrics.v1.Metrics();
                    if (object.metrics) {
                        if (!Array.isArray(object.metrics))
                            throw TypeError(".clutch.metrics.v1.Metrics.metrics: array expected");
                        message.metrics = [];
                        for (let i = 0; i < object.metrics.length; ++i) {
                            if (typeof object.metrics[i] !== "object")
                                throw TypeError(".clutch.metrics.v1.Metrics.metrics: object expected");
                            message.metrics[i] = $root.clutch.metrics.v1.Metric.fromObject(object.metrics[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Metrics message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.metrics.v1.Metrics
                 * @static
                 * @param {clutch.metrics.v1.Metrics} message Metrics
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Metrics.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.metrics = [];
                    if (message.metrics && message.metrics.length) {
                        object.metrics = [];
                        for (let j = 0; j < message.metrics.length; ++j)
                            object.metrics[j] = $root.clutch.metrics.v1.Metric.toObject(message.metrics[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Metrics to JSON.
                 * @function toJSON
                 * @memberof clutch.metrics.v1.Metrics
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Metrics.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Metrics;
            })();

            v1.GetMetricsResponse = (function() {

                /**
                 * Properties of a GetMetricsResponse.
                 * @memberof clutch.metrics.v1
                 * @interface IGetMetricsResponse
                 * @property {Object.<string,clutch.metrics.v1.IMetrics>|null} [queryResults] A mapping of individual queries to their respective results
                 */

                /**
                 * Constructs a new GetMetricsResponse.
                 * @memberof clutch.metrics.v1
                 * @classdesc Represents a GetMetricsResponse.
                 * @implements IGetMetricsResponse
                 * @constructor
                 * @param {clutch.metrics.v1.IGetMetricsResponse=} [properties] Properties to set
                 */
                function GetMetricsResponse(properties) {
                    this.queryResults = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * A mapping of individual queries to their respective results
                 * @member {Object.<string,clutch.metrics.v1.IMetrics>} queryResults
                 * @memberof clutch.metrics.v1.GetMetricsResponse
                 * @instance
                 */
                GetMetricsResponse.prototype.queryResults = $util.emptyObject;

                /**
                 * Verifies a GetMetricsResponse message.
                 * @function verify
                 * @memberof clutch.metrics.v1.GetMetricsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetMetricsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.queryResults != null && message.hasOwnProperty("queryResults")) {
                        if (!$util.isObject(message.queryResults))
                            return "queryResults: object expected";
                        let key = Object.keys(message.queryResults);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.clutch.metrics.v1.Metrics.verify(message.queryResults[key[i]]);
                            if (error)
                                return "queryResults." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetMetricsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.metrics.v1.GetMetricsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.metrics.v1.GetMetricsResponse} GetMetricsResponse
                 */
                GetMetricsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.metrics.v1.GetMetricsResponse)
                        return object;
                    let message = new $root.clutch.metrics.v1.GetMetricsResponse();
                    if (object.queryResults) {
                        if (typeof object.queryResults !== "object")
                            throw TypeError(".clutch.metrics.v1.GetMetricsResponse.queryResults: object expected");
                        message.queryResults = {};
                        for (let keys = Object.keys(object.queryResults), i = 0; i < keys.length; ++i) {
                            if (typeof object.queryResults[keys[i]] !== "object")
                                throw TypeError(".clutch.metrics.v1.GetMetricsResponse.queryResults: object expected");
                            message.queryResults[keys[i]] = $root.clutch.metrics.v1.Metrics.fromObject(object.queryResults[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetMetricsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.metrics.v1.GetMetricsResponse
                 * @static
                 * @param {clutch.metrics.v1.GetMetricsResponse} message GetMetricsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetMetricsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.queryResults = {};
                    let keys2;
                    if (message.queryResults && (keys2 = Object.keys(message.queryResults)).length) {
                        object.queryResults = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.queryResults[keys2[j]] = $root.clutch.metrics.v1.Metrics.toObject(message.queryResults[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetMetricsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.metrics.v1.GetMetricsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetMetricsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetMetricsResponse;
            })();

            return v1;
        })();

        return metrics;
    })();

    clutch.project = (function() {

        /**
         * Namespace project.
         * @memberof clutch
         * @namespace
         */
        const project = {};

        project.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.project
             * @namespace
             */
            const v1 = {};

            v1.ProjectAPI = (function() {

                /**
                 * Constructs a new ProjectAPI service.
                 * @memberof clutch.project.v1
                 * @classdesc Represents a ProjectAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function ProjectAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (ProjectAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ProjectAPI;

                /**
                 * Callback as used by {@link clutch.project.v1.ProjectAPI#getProjects}.
                 * @memberof clutch.project.v1.ProjectAPI
                 * @typedef GetProjectsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.project.v1.GetProjectsResponse} [response] GetProjectsResponse
                 */

                /**
                 * Calls GetProjects.
                 * @function getProjects
                 * @memberof clutch.project.v1.ProjectAPI
                 * @instance
                 * @param {clutch.project.v1.IGetProjectsRequest} request GetProjectsRequest message or plain object
                 * @param {clutch.project.v1.ProjectAPI.GetProjectsCallback} callback Node-style callback called with the error, if any, and GetProjectsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ProjectAPI.prototype.getProjects = function getProjects(request, callback) {
                    return this.rpcCall(getProjects, $root.clutch.project.v1.GetProjectsRequest, $root.clutch.project.v1.GetProjectsResponse, request, callback);
                }, "name", { value: "GetProjects" });

                /**
                 * Calls GetProjects.
                 * @function getProjects
                 * @memberof clutch.project.v1.ProjectAPI
                 * @instance
                 * @param {clutch.project.v1.IGetProjectsRequest} request GetProjectsRequest message or plain object
                 * @returns {Promise<clutch.project.v1.GetProjectsResponse>} Promise
                 * @variation 2
                 */

                return ProjectAPI;
            })();

            v1.GetProjectsRequest = (function() {

                /**
                 * Properties of a GetProjectsRequest.
                 * @memberof clutch.project.v1
                 * @interface IGetProjectsRequest
                 * @property {Array.<string>|null} [projects] GetProjectsRequest projects
                 * @property {Array.<string>|null} [users] GetProjectsRequest users
                 * @property {boolean|null} [excludeDependencies] GetProjectsRequest excludeDependencies
                 */

                /**
                 * Constructs a new GetProjectsRequest.
                 * @memberof clutch.project.v1
                 * @classdesc Represents a GetProjectsRequest.
                 * @implements IGetProjectsRequest
                 * @constructor
                 * @param {clutch.project.v1.IGetProjectsRequest=} [properties] Properties to set
                 */
                function GetProjectsRequest(properties) {
                    this.projects = [];
                    this.users = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetProjectsRequest projects.
                 * @member {Array.<string>} projects
                 * @memberof clutch.project.v1.GetProjectsRequest
                 * @instance
                 */
                GetProjectsRequest.prototype.projects = $util.emptyArray;

                /**
                 * GetProjectsRequest users.
                 * @member {Array.<string>} users
                 * @memberof clutch.project.v1.GetProjectsRequest
                 * @instance
                 */
                GetProjectsRequest.prototype.users = $util.emptyArray;

                /**
                 * GetProjectsRequest excludeDependencies.
                 * @member {boolean} excludeDependencies
                 * @memberof clutch.project.v1.GetProjectsRequest
                 * @instance
                 */
                GetProjectsRequest.prototype.excludeDependencies = false;

                /**
                 * Verifies a GetProjectsRequest message.
                 * @function verify
                 * @memberof clutch.project.v1.GetProjectsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetProjectsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.projects != null && message.hasOwnProperty("projects")) {
                        if (!Array.isArray(message.projects))
                            return "projects: array expected";
                        for (let i = 0; i < message.projects.length; ++i)
                            if (!$util.isString(message.projects[i]))
                                return "projects: string[] expected";
                    }
                    if (message.users != null && message.hasOwnProperty("users")) {
                        if (!Array.isArray(message.users))
                            return "users: array expected";
                        for (let i = 0; i < message.users.length; ++i)
                            if (!$util.isString(message.users[i]))
                                return "users: string[] expected";
                    }
                    if (message.excludeDependencies != null && message.hasOwnProperty("excludeDependencies"))
                        if (typeof message.excludeDependencies !== "boolean")
                            return "excludeDependencies: boolean expected";
                    return null;
                };

                /**
                 * Creates a GetProjectsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.project.v1.GetProjectsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.project.v1.GetProjectsRequest} GetProjectsRequest
                 */
                GetProjectsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.project.v1.GetProjectsRequest)
                        return object;
                    let message = new $root.clutch.project.v1.GetProjectsRequest();
                    if (object.projects) {
                        if (!Array.isArray(object.projects))
                            throw TypeError(".clutch.project.v1.GetProjectsRequest.projects: array expected");
                        message.projects = [];
                        for (let i = 0; i < object.projects.length; ++i)
                            message.projects[i] = String(object.projects[i]);
                    }
                    if (object.users) {
                        if (!Array.isArray(object.users))
                            throw TypeError(".clutch.project.v1.GetProjectsRequest.users: array expected");
                        message.users = [];
                        for (let i = 0; i < object.users.length; ++i)
                            message.users[i] = String(object.users[i]);
                    }
                    if (object.excludeDependencies != null)
                        message.excludeDependencies = Boolean(object.excludeDependencies);
                    return message;
                };

                /**
                 * Creates a plain object from a GetProjectsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.project.v1.GetProjectsRequest
                 * @static
                 * @param {clutch.project.v1.GetProjectsRequest} message GetProjectsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetProjectsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.projects = [];
                        object.users = [];
                    }
                    if (options.defaults)
                        object.excludeDependencies = false;
                    if (message.projects && message.projects.length) {
                        object.projects = [];
                        for (let j = 0; j < message.projects.length; ++j)
                            object.projects[j] = message.projects[j];
                    }
                    if (message.users && message.users.length) {
                        object.users = [];
                        for (let j = 0; j < message.users.length; ++j)
                            object.users[j] = message.users[j];
                    }
                    if (message.excludeDependencies != null && message.hasOwnProperty("excludeDependencies"))
                        object.excludeDependencies = message.excludeDependencies;
                    return object;
                };

                /**
                 * Converts this GetProjectsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.project.v1.GetProjectsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetProjectsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetProjectsRequest;
            })();

            v1.ProjectResult = (function() {

                /**
                 * Properties of a ProjectResult.
                 * @memberof clutch.project.v1
                 * @interface IProjectResult
                 * @property {clutch.project.v1.ProjectResult.IFrom|null} [from] ProjectResult from
                 * @property {clutch.core.project.v1.IProject|null} [project] ProjectResult project
                 */

                /**
                 * Constructs a new ProjectResult.
                 * @memberof clutch.project.v1
                 * @classdesc Represents a ProjectResult.
                 * @implements IProjectResult
                 * @constructor
                 * @param {clutch.project.v1.IProjectResult=} [properties] Properties to set
                 */
                function ProjectResult(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ProjectResult from.
                 * @member {clutch.project.v1.ProjectResult.IFrom|null|undefined} from
                 * @memberof clutch.project.v1.ProjectResult
                 * @instance
                 */
                ProjectResult.prototype.from = null;

                /**
                 * ProjectResult project.
                 * @member {clutch.core.project.v1.IProject|null|undefined} project
                 * @memberof clutch.project.v1.ProjectResult
                 * @instance
                 */
                ProjectResult.prototype.project = null;

                /**
                 * Verifies a ProjectResult message.
                 * @function verify
                 * @memberof clutch.project.v1.ProjectResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ProjectResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.from != null && message.hasOwnProperty("from")) {
                        let error = $root.clutch.project.v1.ProjectResult.From.verify(message.from);
                        if (error)
                            return "from." + error;
                    }
                    if (message.project != null && message.hasOwnProperty("project")) {
                        let error = $root.clutch.core.project.v1.Project.verify(message.project);
                        if (error)
                            return "project." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ProjectResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.project.v1.ProjectResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.project.v1.ProjectResult} ProjectResult
                 */
                ProjectResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.project.v1.ProjectResult)
                        return object;
                    let message = new $root.clutch.project.v1.ProjectResult();
                    if (object.from != null) {
                        if (typeof object.from !== "object")
                            throw TypeError(".clutch.project.v1.ProjectResult.from: object expected");
                        message.from = $root.clutch.project.v1.ProjectResult.From.fromObject(object.from);
                    }
                    if (object.project != null) {
                        if (typeof object.project !== "object")
                            throw TypeError(".clutch.project.v1.ProjectResult.project: object expected");
                        message.project = $root.clutch.core.project.v1.Project.fromObject(object.project);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ProjectResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.project.v1.ProjectResult
                 * @static
                 * @param {clutch.project.v1.ProjectResult} message ProjectResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ProjectResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.from = null;
                        object.project = null;
                    }
                    if (message.from != null && message.hasOwnProperty("from"))
                        object.from = $root.clutch.project.v1.ProjectResult.From.toObject(message.from, options);
                    if (message.project != null && message.hasOwnProperty("project"))
                        object.project = $root.clutch.core.project.v1.Project.toObject(message.project, options);
                    return object;
                };

                /**
                 * Converts this ProjectResult to JSON.
                 * @function toJSON
                 * @memberof clutch.project.v1.ProjectResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ProjectResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                ProjectResult.From = (function() {

                    /**
                     * Properties of a From.
                     * @memberof clutch.project.v1.ProjectResult
                     * @interface IFrom
                     * @property {boolean|null} [selected] From selected
                     * @property {Array.<string>|null} [users] From users
                     */

                    /**
                     * Constructs a new From.
                     * @memberof clutch.project.v1.ProjectResult
                     * @classdesc Represents a From.
                     * @implements IFrom
                     * @constructor
                     * @param {clutch.project.v1.ProjectResult.IFrom=} [properties] Properties to set
                     */
                    function From(properties) {
                        this.users = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * From selected.
                     * @member {boolean} selected
                     * @memberof clutch.project.v1.ProjectResult.From
                     * @instance
                     */
                    From.prototype.selected = false;

                    /**
                     * From users.
                     * @member {Array.<string>} users
                     * @memberof clutch.project.v1.ProjectResult.From
                     * @instance
                     */
                    From.prototype.users = $util.emptyArray;

                    /**
                     * Verifies a From message.
                     * @function verify
                     * @memberof clutch.project.v1.ProjectResult.From
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    From.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.selected != null && message.hasOwnProperty("selected"))
                            if (typeof message.selected !== "boolean")
                                return "selected: boolean expected";
                        if (message.users != null && message.hasOwnProperty("users")) {
                            if (!Array.isArray(message.users))
                                return "users: array expected";
                            for (let i = 0; i < message.users.length; ++i)
                                if (!$util.isString(message.users[i]))
                                    return "users: string[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a From message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.project.v1.ProjectResult.From
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.project.v1.ProjectResult.From} From
                     */
                    From.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.project.v1.ProjectResult.From)
                            return object;
                        let message = new $root.clutch.project.v1.ProjectResult.From();
                        if (object.selected != null)
                            message.selected = Boolean(object.selected);
                        if (object.users) {
                            if (!Array.isArray(object.users))
                                throw TypeError(".clutch.project.v1.ProjectResult.From.users: array expected");
                            message.users = [];
                            for (let i = 0; i < object.users.length; ++i)
                                message.users[i] = String(object.users[i]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a From message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.project.v1.ProjectResult.From
                     * @static
                     * @param {clutch.project.v1.ProjectResult.From} message From
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    From.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.users = [];
                        if (options.defaults)
                            object.selected = false;
                        if (message.selected != null && message.hasOwnProperty("selected"))
                            object.selected = message.selected;
                        if (message.users && message.users.length) {
                            object.users = [];
                            for (let j = 0; j < message.users.length; ++j)
                                object.users[j] = message.users[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this From to JSON.
                     * @function toJSON
                     * @memberof clutch.project.v1.ProjectResult.From
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    From.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return From;
                })();

                return ProjectResult;
            })();

            v1.GetProjectsResponse = (function() {

                /**
                 * Properties of a GetProjectsResponse.
                 * @memberof clutch.project.v1
                 * @interface IGetProjectsResponse
                 * @property {Object.<string,clutch.project.v1.IProjectResult>|null} [results] GetProjectsResponse results
                 * @property {Array.<google.rpc.IStatus>|null} [partialFailures] GetProjectsResponse partialFailures
                 */

                /**
                 * Constructs a new GetProjectsResponse.
                 * @memberof clutch.project.v1
                 * @classdesc Represents a GetProjectsResponse.
                 * @implements IGetProjectsResponse
                 * @constructor
                 * @param {clutch.project.v1.IGetProjectsResponse=} [properties] Properties to set
                 */
                function GetProjectsResponse(properties) {
                    this.results = {};
                    this.partialFailures = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetProjectsResponse results.
                 * @member {Object.<string,clutch.project.v1.IProjectResult>} results
                 * @memberof clutch.project.v1.GetProjectsResponse
                 * @instance
                 */
                GetProjectsResponse.prototype.results = $util.emptyObject;

                /**
                 * GetProjectsResponse partialFailures.
                 * @member {Array.<google.rpc.IStatus>} partialFailures
                 * @memberof clutch.project.v1.GetProjectsResponse
                 * @instance
                 */
                GetProjectsResponse.prototype.partialFailures = $util.emptyArray;

                /**
                 * Verifies a GetProjectsResponse message.
                 * @function verify
                 * @memberof clutch.project.v1.GetProjectsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetProjectsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.results != null && message.hasOwnProperty("results")) {
                        if (!$util.isObject(message.results))
                            return "results: object expected";
                        let key = Object.keys(message.results);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.clutch.project.v1.ProjectResult.verify(message.results[key[i]]);
                            if (error)
                                return "results." + error;
                        }
                    }
                    if (message.partialFailures != null && message.hasOwnProperty("partialFailures")) {
                        if (!Array.isArray(message.partialFailures))
                            return "partialFailures: array expected";
                        for (let i = 0; i < message.partialFailures.length; ++i) {
                            let error = $root.google.rpc.Status.verify(message.partialFailures[i]);
                            if (error)
                                return "partialFailures." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetProjectsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.project.v1.GetProjectsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.project.v1.GetProjectsResponse} GetProjectsResponse
                 */
                GetProjectsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.project.v1.GetProjectsResponse)
                        return object;
                    let message = new $root.clutch.project.v1.GetProjectsResponse();
                    if (object.results) {
                        if (typeof object.results !== "object")
                            throw TypeError(".clutch.project.v1.GetProjectsResponse.results: object expected");
                        message.results = {};
                        for (let keys = Object.keys(object.results), i = 0; i < keys.length; ++i) {
                            if (typeof object.results[keys[i]] !== "object")
                                throw TypeError(".clutch.project.v1.GetProjectsResponse.results: object expected");
                            message.results[keys[i]] = $root.clutch.project.v1.ProjectResult.fromObject(object.results[keys[i]]);
                        }
                    }
                    if (object.partialFailures) {
                        if (!Array.isArray(object.partialFailures))
                            throw TypeError(".clutch.project.v1.GetProjectsResponse.partialFailures: array expected");
                        message.partialFailures = [];
                        for (let i = 0; i < object.partialFailures.length; ++i) {
                            if (typeof object.partialFailures[i] !== "object")
                                throw TypeError(".clutch.project.v1.GetProjectsResponse.partialFailures: object expected");
                            message.partialFailures[i] = $root.google.rpc.Status.fromObject(object.partialFailures[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetProjectsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.project.v1.GetProjectsResponse
                 * @static
                 * @param {clutch.project.v1.GetProjectsResponse} message GetProjectsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetProjectsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.partialFailures = [];
                    if (options.objects || options.defaults)
                        object.results = {};
                    let keys2;
                    if (message.results && (keys2 = Object.keys(message.results)).length) {
                        object.results = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.results[keys2[j]] = $root.clutch.project.v1.ProjectResult.toObject(message.results[keys2[j]], options);
                    }
                    if (message.partialFailures && message.partialFailures.length) {
                        object.partialFailures = [];
                        for (let j = 0; j < message.partialFailures.length; ++j)
                            object.partialFailures[j] = $root.google.rpc.Status.toObject(message.partialFailures[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetProjectsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.project.v1.GetProjectsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetProjectsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetProjectsResponse;
            })();

            return v1;
        })();

        return project;
    })();

    clutch.proxy = (function() {

        /**
         * Namespace proxy.
         * @memberof clutch
         * @namespace
         */
        const proxy = {};

        proxy.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.proxy
             * @namespace
             */
            const v1 = {};

            v1.ProxyAPI = (function() {

                /**
                 * Constructs a new ProxyAPI service.
                 * @memberof clutch.proxy.v1
                 * @classdesc Represents a ProxyAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function ProxyAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (ProxyAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ProxyAPI;

                /**
                 * Callback as used by {@link clutch.proxy.v1.ProxyAPI#requestProxy}.
                 * @memberof clutch.proxy.v1.ProxyAPI
                 * @typedef RequestProxyCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.proxy.v1.RequestProxyResponse} [response] RequestProxyResponse
                 */

                /**
                 * Calls RequestProxy.
                 * @function requestProxy
                 * @memberof clutch.proxy.v1.ProxyAPI
                 * @instance
                 * @param {clutch.proxy.v1.IRequestProxyRequest} request RequestProxyRequest message or plain object
                 * @param {clutch.proxy.v1.ProxyAPI.RequestProxyCallback} callback Node-style callback called with the error, if any, and RequestProxyResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ProxyAPI.prototype.requestProxy = function requestProxy(request, callback) {
                    return this.rpcCall(requestProxy, $root.clutch.proxy.v1.RequestProxyRequest, $root.clutch.proxy.v1.RequestProxyResponse, request, callback);
                }, "name", { value: "RequestProxy" });

                /**
                 * Calls RequestProxy.
                 * @function requestProxy
                 * @memberof clutch.proxy.v1.ProxyAPI
                 * @instance
                 * @param {clutch.proxy.v1.IRequestProxyRequest} request RequestProxyRequest message or plain object
                 * @returns {Promise<clutch.proxy.v1.RequestProxyResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.proxy.v1.ProxyAPI#requestProxyGet}.
                 * @memberof clutch.proxy.v1.ProxyAPI
                 * @typedef RequestProxyGetCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.proxy.v1.RequestProxyGetResponse} [response] RequestProxyGetResponse
                 */

                /**
                 * Calls RequestProxyGet.
                 * @function requestProxyGet
                 * @memberof clutch.proxy.v1.ProxyAPI
                 * @instance
                 * @param {clutch.proxy.v1.IRequestProxyGetRequest} request RequestProxyGetRequest message or plain object
                 * @param {clutch.proxy.v1.ProxyAPI.RequestProxyGetCallback} callback Node-style callback called with the error, if any, and RequestProxyGetResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ProxyAPI.prototype.requestProxyGet = function requestProxyGet(request, callback) {
                    return this.rpcCall(requestProxyGet, $root.clutch.proxy.v1.RequestProxyGetRequest, $root.clutch.proxy.v1.RequestProxyGetResponse, request, callback);
                }, "name", { value: "RequestProxyGet" });

                /**
                 * Calls RequestProxyGet.
                 * @function requestProxyGet
                 * @memberof clutch.proxy.v1.ProxyAPI
                 * @instance
                 * @param {clutch.proxy.v1.IRequestProxyGetRequest} request RequestProxyGetRequest message or plain object
                 * @returns {Promise<clutch.proxy.v1.RequestProxyGetResponse>} Promise
                 * @variation 2
                 */

                return ProxyAPI;
            })();

            v1.RequestProxyRequest = (function() {

                /**
                 * Properties of a RequestProxyRequest.
                 * @memberof clutch.proxy.v1
                 * @interface IRequestProxyRequest
                 * @property {string|null} [service] RequestProxyRequest service
                 * @property {string|null} [httpMethod] RequestProxyRequest httpMethod
                 * @property {string|null} [path] RequestProxyRequest path
                 * @property {google.protobuf.IValue|null} [request] RequestProxyRequest request
                 */

                /**
                 * Constructs a new RequestProxyRequest.
                 * @memberof clutch.proxy.v1
                 * @classdesc Represents a RequestProxyRequest.
                 * @implements IRequestProxyRequest
                 * @constructor
                 * @param {clutch.proxy.v1.IRequestProxyRequest=} [properties] Properties to set
                 */
                function RequestProxyRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RequestProxyRequest service.
                 * @member {string} service
                 * @memberof clutch.proxy.v1.RequestProxyRequest
                 * @instance
                 */
                RequestProxyRequest.prototype.service = "";

                /**
                 * RequestProxyRequest httpMethod.
                 * @member {string} httpMethod
                 * @memberof clutch.proxy.v1.RequestProxyRequest
                 * @instance
                 */
                RequestProxyRequest.prototype.httpMethod = "";

                /**
                 * RequestProxyRequest path.
                 * @member {string} path
                 * @memberof clutch.proxy.v1.RequestProxyRequest
                 * @instance
                 */
                RequestProxyRequest.prototype.path = "";

                /**
                 * RequestProxyRequest request.
                 * @member {google.protobuf.IValue|null|undefined} request
                 * @memberof clutch.proxy.v1.RequestProxyRequest
                 * @instance
                 */
                RequestProxyRequest.prototype.request = null;

                /**
                 * Verifies a RequestProxyRequest message.
                 * @function verify
                 * @memberof clutch.proxy.v1.RequestProxyRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RequestProxyRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.service != null && message.hasOwnProperty("service"))
                        if (!$util.isString(message.service))
                            return "service: string expected";
                    if (message.httpMethod != null && message.hasOwnProperty("httpMethod"))
                        if (!$util.isString(message.httpMethod))
                            return "httpMethod: string expected";
                    if (message.path != null && message.hasOwnProperty("path"))
                        if (!$util.isString(message.path))
                            return "path: string expected";
                    if (message.request != null && message.hasOwnProperty("request")) {
                        let error = $root.google.protobuf.Value.verify(message.request);
                        if (error)
                            return "request." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RequestProxyRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.proxy.v1.RequestProxyRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.proxy.v1.RequestProxyRequest} RequestProxyRequest
                 */
                RequestProxyRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.proxy.v1.RequestProxyRequest)
                        return object;
                    let message = new $root.clutch.proxy.v1.RequestProxyRequest();
                    if (object.service != null)
                        message.service = String(object.service);
                    if (object.httpMethod != null)
                        message.httpMethod = String(object.httpMethod);
                    if (object.path != null)
                        message.path = String(object.path);
                    if (object.request != null) {
                        if (typeof object.request !== "object")
                            throw TypeError(".clutch.proxy.v1.RequestProxyRequest.request: object expected");
                        message.request = $root.google.protobuf.Value.fromObject(object.request);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RequestProxyRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.proxy.v1.RequestProxyRequest
                 * @static
                 * @param {clutch.proxy.v1.RequestProxyRequest} message RequestProxyRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RequestProxyRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.service = "";
                        object.httpMethod = "";
                        object.path = "";
                        object.request = null;
                    }
                    if (message.service != null && message.hasOwnProperty("service"))
                        object.service = message.service;
                    if (message.httpMethod != null && message.hasOwnProperty("httpMethod"))
                        object.httpMethod = message.httpMethod;
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = message.path;
                    if (message.request != null && message.hasOwnProperty("request"))
                        object.request = $root.google.protobuf.Value.toObject(message.request, options);
                    return object;
                };

                /**
                 * Converts this RequestProxyRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.proxy.v1.RequestProxyRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RequestProxyRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RequestProxyRequest;
            })();

            v1.RequestProxyResponse = (function() {

                /**
                 * Properties of a RequestProxyResponse.
                 * @memberof clutch.proxy.v1
                 * @interface IRequestProxyResponse
                 * @property {number|null} [httpStatus] RequestProxyResponse httpStatus
                 * @property {Object.<string,google.protobuf.IListValue>|null} [headers] RequestProxyResponse headers
                 * @property {google.protobuf.IValue|null} [response] RequestProxyResponse response
                 */

                /**
                 * Constructs a new RequestProxyResponse.
                 * @memberof clutch.proxy.v1
                 * @classdesc Represents a RequestProxyResponse.
                 * @implements IRequestProxyResponse
                 * @constructor
                 * @param {clutch.proxy.v1.IRequestProxyResponse=} [properties] Properties to set
                 */
                function RequestProxyResponse(properties) {
                    this.headers = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RequestProxyResponse httpStatus.
                 * @member {number} httpStatus
                 * @memberof clutch.proxy.v1.RequestProxyResponse
                 * @instance
                 */
                RequestProxyResponse.prototype.httpStatus = 0;

                /**
                 * RequestProxyResponse headers.
                 * @member {Object.<string,google.protobuf.IListValue>} headers
                 * @memberof clutch.proxy.v1.RequestProxyResponse
                 * @instance
                 */
                RequestProxyResponse.prototype.headers = $util.emptyObject;

                /**
                 * RequestProxyResponse response.
                 * @member {google.protobuf.IValue|null|undefined} response
                 * @memberof clutch.proxy.v1.RequestProxyResponse
                 * @instance
                 */
                RequestProxyResponse.prototype.response = null;

                /**
                 * Verifies a RequestProxyResponse message.
                 * @function verify
                 * @memberof clutch.proxy.v1.RequestProxyResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RequestProxyResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.httpStatus != null && message.hasOwnProperty("httpStatus"))
                        if (!$util.isInteger(message.httpStatus))
                            return "httpStatus: integer expected";
                    if (message.headers != null && message.hasOwnProperty("headers")) {
                        if (!$util.isObject(message.headers))
                            return "headers: object expected";
                        let key = Object.keys(message.headers);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.google.protobuf.ListValue.verify(message.headers[key[i]]);
                            if (error)
                                return "headers." + error;
                        }
                    }
                    if (message.response != null && message.hasOwnProperty("response")) {
                        let error = $root.google.protobuf.Value.verify(message.response);
                        if (error)
                            return "response." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RequestProxyResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.proxy.v1.RequestProxyResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.proxy.v1.RequestProxyResponse} RequestProxyResponse
                 */
                RequestProxyResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.proxy.v1.RequestProxyResponse)
                        return object;
                    let message = new $root.clutch.proxy.v1.RequestProxyResponse();
                    if (object.httpStatus != null)
                        message.httpStatus = object.httpStatus | 0;
                    if (object.headers) {
                        if (typeof object.headers !== "object")
                            throw TypeError(".clutch.proxy.v1.RequestProxyResponse.headers: object expected");
                        message.headers = {};
                        for (let keys = Object.keys(object.headers), i = 0; i < keys.length; ++i) {
                            if (typeof object.headers[keys[i]] !== "object")
                                throw TypeError(".clutch.proxy.v1.RequestProxyResponse.headers: object expected");
                            message.headers[keys[i]] = $root.google.protobuf.ListValue.fromObject(object.headers[keys[i]]);
                        }
                    }
                    if (object.response != null) {
                        if (typeof object.response !== "object")
                            throw TypeError(".clutch.proxy.v1.RequestProxyResponse.response: object expected");
                        message.response = $root.google.protobuf.Value.fromObject(object.response);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RequestProxyResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.proxy.v1.RequestProxyResponse
                 * @static
                 * @param {clutch.proxy.v1.RequestProxyResponse} message RequestProxyResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RequestProxyResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.headers = {};
                    if (options.defaults) {
                        object.httpStatus = 0;
                        object.response = null;
                    }
                    if (message.httpStatus != null && message.hasOwnProperty("httpStatus"))
                        object.httpStatus = message.httpStatus;
                    let keys2;
                    if (message.headers && (keys2 = Object.keys(message.headers)).length) {
                        object.headers = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.headers[keys2[j]] = $root.google.protobuf.ListValue.toObject(message.headers[keys2[j]], options);
                    }
                    if (message.response != null && message.hasOwnProperty("response"))
                        object.response = $root.google.protobuf.Value.toObject(message.response, options);
                    return object;
                };

                /**
                 * Converts this RequestProxyResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.proxy.v1.RequestProxyResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RequestProxyResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RequestProxyResponse;
            })();

            v1.RequestProxyGetRequest = (function() {

                /**
                 * Properties of a RequestProxyGetRequest.
                 * @memberof clutch.proxy.v1
                 * @interface IRequestProxyGetRequest
                 * @property {string|null} [service] RequestProxyGetRequest service
                 * @property {string|null} [httpMethod] RequestProxyGetRequest httpMethod
                 * @property {string|null} [path] RequestProxyGetRequest path
                 * @property {google.protobuf.IValue|null} [request] RequestProxyGetRequest request
                 */

                /**
                 * Constructs a new RequestProxyGetRequest.
                 * @memberof clutch.proxy.v1
                 * @classdesc Represents a RequestProxyGetRequest.
                 * @implements IRequestProxyGetRequest
                 * @constructor
                 * @param {clutch.proxy.v1.IRequestProxyGetRequest=} [properties] Properties to set
                 */
                function RequestProxyGetRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RequestProxyGetRequest service.
                 * @member {string} service
                 * @memberof clutch.proxy.v1.RequestProxyGetRequest
                 * @instance
                 */
                RequestProxyGetRequest.prototype.service = "";

                /**
                 * RequestProxyGetRequest httpMethod.
                 * @member {string} httpMethod
                 * @memberof clutch.proxy.v1.RequestProxyGetRequest
                 * @instance
                 */
                RequestProxyGetRequest.prototype.httpMethod = "";

                /**
                 * RequestProxyGetRequest path.
                 * @member {string} path
                 * @memberof clutch.proxy.v1.RequestProxyGetRequest
                 * @instance
                 */
                RequestProxyGetRequest.prototype.path = "";

                /**
                 * RequestProxyGetRequest request.
                 * @member {google.protobuf.IValue|null|undefined} request
                 * @memberof clutch.proxy.v1.RequestProxyGetRequest
                 * @instance
                 */
                RequestProxyGetRequest.prototype.request = null;

                /**
                 * Verifies a RequestProxyGetRequest message.
                 * @function verify
                 * @memberof clutch.proxy.v1.RequestProxyGetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RequestProxyGetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.service != null && message.hasOwnProperty("service"))
                        if (!$util.isString(message.service))
                            return "service: string expected";
                    if (message.httpMethod != null && message.hasOwnProperty("httpMethod"))
                        if (!$util.isString(message.httpMethod))
                            return "httpMethod: string expected";
                    if (message.path != null && message.hasOwnProperty("path"))
                        if (!$util.isString(message.path))
                            return "path: string expected";
                    if (message.request != null && message.hasOwnProperty("request")) {
                        let error = $root.google.protobuf.Value.verify(message.request);
                        if (error)
                            return "request." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RequestProxyGetRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.proxy.v1.RequestProxyGetRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.proxy.v1.RequestProxyGetRequest} RequestProxyGetRequest
                 */
                RequestProxyGetRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.proxy.v1.RequestProxyGetRequest)
                        return object;
                    let message = new $root.clutch.proxy.v1.RequestProxyGetRequest();
                    if (object.service != null)
                        message.service = String(object.service);
                    if (object.httpMethod != null)
                        message.httpMethod = String(object.httpMethod);
                    if (object.path != null)
                        message.path = String(object.path);
                    if (object.request != null) {
                        if (typeof object.request !== "object")
                            throw TypeError(".clutch.proxy.v1.RequestProxyGetRequest.request: object expected");
                        message.request = $root.google.protobuf.Value.fromObject(object.request);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RequestProxyGetRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.proxy.v1.RequestProxyGetRequest
                 * @static
                 * @param {clutch.proxy.v1.RequestProxyGetRequest} message RequestProxyGetRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RequestProxyGetRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.service = "";
                        object.httpMethod = "";
                        object.path = "";
                        object.request = null;
                    }
                    if (message.service != null && message.hasOwnProperty("service"))
                        object.service = message.service;
                    if (message.httpMethod != null && message.hasOwnProperty("httpMethod"))
                        object.httpMethod = message.httpMethod;
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = message.path;
                    if (message.request != null && message.hasOwnProperty("request"))
                        object.request = $root.google.protobuf.Value.toObject(message.request, options);
                    return object;
                };

                /**
                 * Converts this RequestProxyGetRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.proxy.v1.RequestProxyGetRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RequestProxyGetRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RequestProxyGetRequest;
            })();

            v1.RequestProxyGetResponse = (function() {

                /**
                 * Properties of a RequestProxyGetResponse.
                 * @memberof clutch.proxy.v1
                 * @interface IRequestProxyGetResponse
                 * @property {number|null} [httpStatus] RequestProxyGetResponse httpStatus
                 * @property {Object.<string,google.protobuf.IListValue>|null} [headers] RequestProxyGetResponse headers
                 * @property {google.protobuf.IValue|null} [response] RequestProxyGetResponse response
                 */

                /**
                 * Constructs a new RequestProxyGetResponse.
                 * @memberof clutch.proxy.v1
                 * @classdesc Represents a RequestProxyGetResponse.
                 * @implements IRequestProxyGetResponse
                 * @constructor
                 * @param {clutch.proxy.v1.IRequestProxyGetResponse=} [properties] Properties to set
                 */
                function RequestProxyGetResponse(properties) {
                    this.headers = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RequestProxyGetResponse httpStatus.
                 * @member {number} httpStatus
                 * @memberof clutch.proxy.v1.RequestProxyGetResponse
                 * @instance
                 */
                RequestProxyGetResponse.prototype.httpStatus = 0;

                /**
                 * RequestProxyGetResponse headers.
                 * @member {Object.<string,google.protobuf.IListValue>} headers
                 * @memberof clutch.proxy.v1.RequestProxyGetResponse
                 * @instance
                 */
                RequestProxyGetResponse.prototype.headers = $util.emptyObject;

                /**
                 * RequestProxyGetResponse response.
                 * @member {google.protobuf.IValue|null|undefined} response
                 * @memberof clutch.proxy.v1.RequestProxyGetResponse
                 * @instance
                 */
                RequestProxyGetResponse.prototype.response = null;

                /**
                 * Verifies a RequestProxyGetResponse message.
                 * @function verify
                 * @memberof clutch.proxy.v1.RequestProxyGetResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RequestProxyGetResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.httpStatus != null && message.hasOwnProperty("httpStatus"))
                        if (!$util.isInteger(message.httpStatus))
                            return "httpStatus: integer expected";
                    if (message.headers != null && message.hasOwnProperty("headers")) {
                        if (!$util.isObject(message.headers))
                            return "headers: object expected";
                        let key = Object.keys(message.headers);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.google.protobuf.ListValue.verify(message.headers[key[i]]);
                            if (error)
                                return "headers." + error;
                        }
                    }
                    if (message.response != null && message.hasOwnProperty("response")) {
                        let error = $root.google.protobuf.Value.verify(message.response);
                        if (error)
                            return "response." + error;
                    }
                    return null;
                };

                /**
                 * Creates a RequestProxyGetResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.proxy.v1.RequestProxyGetResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.proxy.v1.RequestProxyGetResponse} RequestProxyGetResponse
                 */
                RequestProxyGetResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.proxy.v1.RequestProxyGetResponse)
                        return object;
                    let message = new $root.clutch.proxy.v1.RequestProxyGetResponse();
                    if (object.httpStatus != null)
                        message.httpStatus = object.httpStatus | 0;
                    if (object.headers) {
                        if (typeof object.headers !== "object")
                            throw TypeError(".clutch.proxy.v1.RequestProxyGetResponse.headers: object expected");
                        message.headers = {};
                        for (let keys = Object.keys(object.headers), i = 0; i < keys.length; ++i) {
                            if (typeof object.headers[keys[i]] !== "object")
                                throw TypeError(".clutch.proxy.v1.RequestProxyGetResponse.headers: object expected");
                            message.headers[keys[i]] = $root.google.protobuf.ListValue.fromObject(object.headers[keys[i]]);
                        }
                    }
                    if (object.response != null) {
                        if (typeof object.response !== "object")
                            throw TypeError(".clutch.proxy.v1.RequestProxyGetResponse.response: object expected");
                        message.response = $root.google.protobuf.Value.fromObject(object.response);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RequestProxyGetResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.proxy.v1.RequestProxyGetResponse
                 * @static
                 * @param {clutch.proxy.v1.RequestProxyGetResponse} message RequestProxyGetResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RequestProxyGetResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.headers = {};
                    if (options.defaults) {
                        object.httpStatus = 0;
                        object.response = null;
                    }
                    if (message.httpStatus != null && message.hasOwnProperty("httpStatus"))
                        object.httpStatus = message.httpStatus;
                    let keys2;
                    if (message.headers && (keys2 = Object.keys(message.headers)).length) {
                        object.headers = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.headers[keys2[j]] = $root.google.protobuf.ListValue.toObject(message.headers[keys2[j]], options);
                    }
                    if (message.response != null && message.hasOwnProperty("response"))
                        object.response = $root.google.protobuf.Value.toObject(message.response, options);
                    return object;
                };

                /**
                 * Converts this RequestProxyGetResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.proxy.v1.RequestProxyGetResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RequestProxyGetResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RequestProxyGetResponse;
            })();

            return v1;
        })();

        return proxy;
    })();

    clutch.resolver = (function() {

        /**
         * Namespace resolver.
         * @memberof clutch
         * @namespace
         */
        const resolver = {};

        resolver.aws = (function() {

            /**
             * Namespace aws.
             * @memberof clutch.resolver
             * @namespace
             */
            const aws = {};

            aws.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.resolver.aws
                 * @namespace
                 */
                const v1 = {};

                v1.InstanceID = (function() {

                    /**
                     * Properties of an InstanceID.
                     * @memberof clutch.resolver.aws.v1
                     * @interface IInstanceID
                     * @property {string|null} [id] InstanceID id
                     * @property {string|null} [region] InstanceID region
                     * @property {string|null} [account] InstanceID account
                     */

                    /**
                     * Constructs a new InstanceID.
                     * @memberof clutch.resolver.aws.v1
                     * @classdesc Represents an InstanceID.
                     * @implements IInstanceID
                     * @constructor
                     * @param {clutch.resolver.aws.v1.IInstanceID=} [properties] Properties to set
                     */
                    function InstanceID(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * InstanceID id.
                     * @member {string} id
                     * @memberof clutch.resolver.aws.v1.InstanceID
                     * @instance
                     */
                    InstanceID.prototype.id = "";

                    /**
                     * InstanceID region.
                     * @member {string} region
                     * @memberof clutch.resolver.aws.v1.InstanceID
                     * @instance
                     */
                    InstanceID.prototype.region = "";

                    /**
                     * InstanceID account.
                     * @member {string} account
                     * @memberof clutch.resolver.aws.v1.InstanceID
                     * @instance
                     */
                    InstanceID.prototype.account = "";

                    /**
                     * Verifies an InstanceID message.
                     * @function verify
                     * @memberof clutch.resolver.aws.v1.InstanceID
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    InstanceID.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates an InstanceID message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.aws.v1.InstanceID
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.aws.v1.InstanceID} InstanceID
                     */
                    InstanceID.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.aws.v1.InstanceID)
                            return object;
                        let message = new $root.clutch.resolver.aws.v1.InstanceID();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from an InstanceID message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.aws.v1.InstanceID
                     * @static
                     * @param {clutch.resolver.aws.v1.InstanceID} message InstanceID
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    InstanceID.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.id = "";
                            object.region = "";
                            object.account = "";
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this InstanceID to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.aws.v1.InstanceID
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    InstanceID.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return InstanceID;
                })();

                v1.AutoscalingGroupName = (function() {

                    /**
                     * Properties of an AutoscalingGroupName.
                     * @memberof clutch.resolver.aws.v1
                     * @interface IAutoscalingGroupName
                     * @property {string|null} [name] AutoscalingGroupName name
                     * @property {string|null} [region] AutoscalingGroupName region
                     * @property {string|null} [account] AutoscalingGroupName account
                     */

                    /**
                     * Constructs a new AutoscalingGroupName.
                     * @memberof clutch.resolver.aws.v1
                     * @classdesc Represents an AutoscalingGroupName.
                     * @implements IAutoscalingGroupName
                     * @constructor
                     * @param {clutch.resolver.aws.v1.IAutoscalingGroupName=} [properties] Properties to set
                     */
                    function AutoscalingGroupName(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * AutoscalingGroupName name.
                     * @member {string} name
                     * @memberof clutch.resolver.aws.v1.AutoscalingGroupName
                     * @instance
                     */
                    AutoscalingGroupName.prototype.name = "";

                    /**
                     * AutoscalingGroupName region.
                     * @member {string} region
                     * @memberof clutch.resolver.aws.v1.AutoscalingGroupName
                     * @instance
                     */
                    AutoscalingGroupName.prototype.region = "";

                    /**
                     * AutoscalingGroupName account.
                     * @member {string} account
                     * @memberof clutch.resolver.aws.v1.AutoscalingGroupName
                     * @instance
                     */
                    AutoscalingGroupName.prototype.account = "";

                    /**
                     * Verifies an AutoscalingGroupName message.
                     * @function verify
                     * @memberof clutch.resolver.aws.v1.AutoscalingGroupName
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AutoscalingGroupName.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates an AutoscalingGroupName message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.aws.v1.AutoscalingGroupName
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.aws.v1.AutoscalingGroupName} AutoscalingGroupName
                     */
                    AutoscalingGroupName.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.aws.v1.AutoscalingGroupName)
                            return object;
                        let message = new $root.clutch.resolver.aws.v1.AutoscalingGroupName();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from an AutoscalingGroupName message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.aws.v1.AutoscalingGroupName
                     * @static
                     * @param {clutch.resolver.aws.v1.AutoscalingGroupName} message AutoscalingGroupName
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AutoscalingGroupName.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.region = "";
                            object.account = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this AutoscalingGroupName to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.aws.v1.AutoscalingGroupName
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AutoscalingGroupName.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return AutoscalingGroupName;
                })();

                v1.KinesisStreamName = (function() {

                    /**
                     * Properties of a KinesisStreamName.
                     * @memberof clutch.resolver.aws.v1
                     * @interface IKinesisStreamName
                     * @property {string|null} [name] KinesisStreamName name
                     * @property {string|null} [region] KinesisStreamName region
                     * @property {string|null} [account] KinesisStreamName account
                     */

                    /**
                     * Constructs a new KinesisStreamName.
                     * @memberof clutch.resolver.aws.v1
                     * @classdesc Represents a KinesisStreamName.
                     * @implements IKinesisStreamName
                     * @constructor
                     * @param {clutch.resolver.aws.v1.IKinesisStreamName=} [properties] Properties to set
                     */
                    function KinesisStreamName(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * KinesisStreamName name.
                     * @member {string} name
                     * @memberof clutch.resolver.aws.v1.KinesisStreamName
                     * @instance
                     */
                    KinesisStreamName.prototype.name = "";

                    /**
                     * KinesisStreamName region.
                     * @member {string} region
                     * @memberof clutch.resolver.aws.v1.KinesisStreamName
                     * @instance
                     */
                    KinesisStreamName.prototype.region = "";

                    /**
                     * KinesisStreamName account.
                     * @member {string} account
                     * @memberof clutch.resolver.aws.v1.KinesisStreamName
                     * @instance
                     */
                    KinesisStreamName.prototype.account = "";

                    /**
                     * Verifies a KinesisStreamName message.
                     * @function verify
                     * @memberof clutch.resolver.aws.v1.KinesisStreamName
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    KinesisStreamName.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates a KinesisStreamName message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.aws.v1.KinesisStreamName
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.aws.v1.KinesisStreamName} KinesisStreamName
                     */
                    KinesisStreamName.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.aws.v1.KinesisStreamName)
                            return object;
                        let message = new $root.clutch.resolver.aws.v1.KinesisStreamName();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from a KinesisStreamName message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.aws.v1.KinesisStreamName
                     * @static
                     * @param {clutch.resolver.aws.v1.KinesisStreamName} message KinesisStreamName
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    KinesisStreamName.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.region = "";
                            object.account = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this KinesisStreamName to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.aws.v1.KinesisStreamName
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    KinesisStreamName.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return KinesisStreamName;
                })();

                v1.DynamodbTableName = (function() {

                    /**
                     * Properties of a DynamodbTableName.
                     * @memberof clutch.resolver.aws.v1
                     * @interface IDynamodbTableName
                     * @property {string|null} [name] DynamodbTableName name
                     * @property {string|null} [region] DynamodbTableName region
                     * @property {string|null} [account] DynamodbTableName account
                     */

                    /**
                     * Constructs a new DynamodbTableName.
                     * @memberof clutch.resolver.aws.v1
                     * @classdesc Represents a DynamodbTableName.
                     * @implements IDynamodbTableName
                     * @constructor
                     * @param {clutch.resolver.aws.v1.IDynamodbTableName=} [properties] Properties to set
                     */
                    function DynamodbTableName(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * DynamodbTableName name.
                     * @member {string} name
                     * @memberof clutch.resolver.aws.v1.DynamodbTableName
                     * @instance
                     */
                    DynamodbTableName.prototype.name = "";

                    /**
                     * DynamodbTableName region.
                     * @member {string} region
                     * @memberof clutch.resolver.aws.v1.DynamodbTableName
                     * @instance
                     */
                    DynamodbTableName.prototype.region = "";

                    /**
                     * DynamodbTableName account.
                     * @member {string} account
                     * @memberof clutch.resolver.aws.v1.DynamodbTableName
                     * @instance
                     */
                    DynamodbTableName.prototype.account = "";

                    /**
                     * Verifies a DynamodbTableName message.
                     * @function verify
                     * @memberof clutch.resolver.aws.v1.DynamodbTableName
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    DynamodbTableName.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.account != null && message.hasOwnProperty("account"))
                            if (!$util.isString(message.account))
                                return "account: string expected";
                        return null;
                    };

                    /**
                     * Creates a DynamodbTableName message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.aws.v1.DynamodbTableName
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.aws.v1.DynamodbTableName} DynamodbTableName
                     */
                    DynamodbTableName.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.aws.v1.DynamodbTableName)
                            return object;
                        let message = new $root.clutch.resolver.aws.v1.DynamodbTableName();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.account != null)
                            message.account = String(object.account);
                        return message;
                    };

                    /**
                     * Creates a plain object from a DynamodbTableName message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.aws.v1.DynamodbTableName
                     * @static
                     * @param {clutch.resolver.aws.v1.DynamodbTableName} message DynamodbTableName
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    DynamodbTableName.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.region = "";
                            object.account = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.account != null && message.hasOwnProperty("account"))
                            object.account = message.account;
                        return object;
                    };

                    /**
                     * Converts this DynamodbTableName to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.aws.v1.DynamodbTableName
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    DynamodbTableName.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return DynamodbTableName;
                })();

                return v1;
            })();

            return aws;
        })();

        resolver.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.resolver
             * @namespace
             */
            const v1 = {};

            v1.StringField = (function() {

                /**
                 * Properties of a StringField.
                 * @memberof clutch.resolver.v1
                 * @interface IStringField
                 * @property {string|null} [placeholder] StringField placeholder
                 * @property {string|null} [defaultValue] StringField defaultValue
                 */

                /**
                 * Constructs a new StringField.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a StringField.
                 * @implements IStringField
                 * @constructor
                 * @param {clutch.resolver.v1.IStringField=} [properties] Properties to set
                 */
                function StringField(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StringField placeholder.
                 * @member {string} placeholder
                 * @memberof clutch.resolver.v1.StringField
                 * @instance
                 */
                StringField.prototype.placeholder = "";

                /**
                 * StringField defaultValue.
                 * @member {string} defaultValue
                 * @memberof clutch.resolver.v1.StringField
                 * @instance
                 */
                StringField.prototype.defaultValue = "";

                /**
                 * Verifies a StringField message.
                 * @function verify
                 * @memberof clutch.resolver.v1.StringField
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StringField.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.placeholder != null && message.hasOwnProperty("placeholder"))
                        if (!$util.isString(message.placeholder))
                            return "placeholder: string expected";
                    if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                        if (!$util.isString(message.defaultValue))
                            return "defaultValue: string expected";
                    return null;
                };

                /**
                 * Creates a StringField message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.StringField
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.StringField} StringField
                 */
                StringField.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.StringField)
                        return object;
                    let message = new $root.clutch.resolver.v1.StringField();
                    if (object.placeholder != null)
                        message.placeholder = String(object.placeholder);
                    if (object.defaultValue != null)
                        message.defaultValue = String(object.defaultValue);
                    return message;
                };

                /**
                 * Creates a plain object from a StringField message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.StringField
                 * @static
                 * @param {clutch.resolver.v1.StringField} message StringField
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StringField.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.placeholder = "";
                        object.defaultValue = "";
                    }
                    if (message.placeholder != null && message.hasOwnProperty("placeholder"))
                        object.placeholder = message.placeholder;
                    if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                        object.defaultValue = message.defaultValue;
                    return object;
                };

                /**
                 * Converts this StringField to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.StringField
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StringField.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return StringField;
            })();

            v1.Option = (function() {

                /**
                 * Properties of an Option.
                 * @memberof clutch.resolver.v1
                 * @interface IOption
                 * @property {string|null} [displayName] Option displayName
                 * @property {string|null} [stringValue] Option stringValue
                 */

                /**
                 * Constructs a new Option.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents an Option.
                 * @implements IOption
                 * @constructor
                 * @param {clutch.resolver.v1.IOption=} [properties] Properties to set
                 */
                function Option(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Option displayName.
                 * @member {string} displayName
                 * @memberof clutch.resolver.v1.Option
                 * @instance
                 */
                Option.prototype.displayName = "";

                /**
                 * Option stringValue.
                 * @member {string|null|undefined} stringValue
                 * @memberof clutch.resolver.v1.Option
                 * @instance
                 */
                Option.prototype.stringValue = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Option value.
                 * @member {"stringValue"|undefined} value
                 * @memberof clutch.resolver.v1.Option
                 * @instance
                 */
                Object.defineProperty(Option.prototype, "value", {
                    get: $util.oneOfGetter($oneOfFields = ["stringValue"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies an Option message.
                 * @function verify
                 * @memberof clutch.resolver.v1.Option
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Option.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        if (!$util.isString(message.displayName))
                            return "displayName: string expected";
                    if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                        properties.value = 1;
                        if (!$util.isString(message.stringValue))
                            return "stringValue: string expected";
                    }
                    return null;
                };

                /**
                 * Creates an Option message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.Option
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.Option} Option
                 */
                Option.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.Option)
                        return object;
                    let message = new $root.clutch.resolver.v1.Option();
                    if (object.displayName != null)
                        message.displayName = String(object.displayName);
                    if (object.stringValue != null)
                        message.stringValue = String(object.stringValue);
                    return message;
                };

                /**
                 * Creates a plain object from an Option message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.Option
                 * @static
                 * @param {clutch.resolver.v1.Option} message Option
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Option.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.displayName = "";
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        object.displayName = message.displayName;
                    if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                        object.stringValue = message.stringValue;
                        if (options.oneofs)
                            object.value = "stringValue";
                    }
                    return object;
                };

                /**
                 * Converts this Option to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.Option
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Option.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Option;
            })();

            v1.OptionField = (function() {

                /**
                 * Properties of an OptionField.
                 * @memberof clutch.resolver.v1
                 * @interface IOptionField
                 * @property {boolean|null} [includeAllOption] OptionField includeAllOption
                 * @property {Array.<string>|null} [includeDynamicOptions] OptionField includeDynamicOptions
                 * @property {Array.<clutch.resolver.v1.IOption>|null} [options] OptionField options
                 */

                /**
                 * Constructs a new OptionField.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents an OptionField.
                 * @implements IOptionField
                 * @constructor
                 * @param {clutch.resolver.v1.IOptionField=} [properties] Properties to set
                 */
                function OptionField(properties) {
                    this.includeDynamicOptions = [];
                    this.options = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * OptionField includeAllOption.
                 * @member {boolean} includeAllOption
                 * @memberof clutch.resolver.v1.OptionField
                 * @instance
                 */
                OptionField.prototype.includeAllOption = false;

                /**
                 * OptionField includeDynamicOptions.
                 * @member {Array.<string>} includeDynamicOptions
                 * @memberof clutch.resolver.v1.OptionField
                 * @instance
                 */
                OptionField.prototype.includeDynamicOptions = $util.emptyArray;

                /**
                 * OptionField options.
                 * @member {Array.<clutch.resolver.v1.IOption>} options
                 * @memberof clutch.resolver.v1.OptionField
                 * @instance
                 */
                OptionField.prototype.options = $util.emptyArray;

                /**
                 * Verifies an OptionField message.
                 * @function verify
                 * @memberof clutch.resolver.v1.OptionField
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OptionField.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.includeAllOption != null && message.hasOwnProperty("includeAllOption"))
                        if (typeof message.includeAllOption !== "boolean")
                            return "includeAllOption: boolean expected";
                    if (message.includeDynamicOptions != null && message.hasOwnProperty("includeDynamicOptions")) {
                        if (!Array.isArray(message.includeDynamicOptions))
                            return "includeDynamicOptions: array expected";
                        for (let i = 0; i < message.includeDynamicOptions.length; ++i)
                            if (!$util.isString(message.includeDynamicOptions[i]))
                                return "includeDynamicOptions: string[] expected";
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        if (!Array.isArray(message.options))
                            return "options: array expected";
                        for (let i = 0; i < message.options.length; ++i) {
                            let error = $root.clutch.resolver.v1.Option.verify(message.options[i]);
                            if (error)
                                return "options." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an OptionField message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.OptionField
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.OptionField} OptionField
                 */
                OptionField.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.OptionField)
                        return object;
                    let message = new $root.clutch.resolver.v1.OptionField();
                    if (object.includeAllOption != null)
                        message.includeAllOption = Boolean(object.includeAllOption);
                    if (object.includeDynamicOptions) {
                        if (!Array.isArray(object.includeDynamicOptions))
                            throw TypeError(".clutch.resolver.v1.OptionField.includeDynamicOptions: array expected");
                        message.includeDynamicOptions = [];
                        for (let i = 0; i < object.includeDynamicOptions.length; ++i)
                            message.includeDynamicOptions[i] = String(object.includeDynamicOptions[i]);
                    }
                    if (object.options) {
                        if (!Array.isArray(object.options))
                            throw TypeError(".clutch.resolver.v1.OptionField.options: array expected");
                        message.options = [];
                        for (let i = 0; i < object.options.length; ++i) {
                            if (typeof object.options[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.OptionField.options: object expected");
                            message.options[i] = $root.clutch.resolver.v1.Option.fromObject(object.options[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an OptionField message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.OptionField
                 * @static
                 * @param {clutch.resolver.v1.OptionField} message OptionField
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OptionField.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.includeDynamicOptions = [];
                        object.options = [];
                    }
                    if (options.defaults)
                        object.includeAllOption = false;
                    if (message.includeAllOption != null && message.hasOwnProperty("includeAllOption"))
                        object.includeAllOption = message.includeAllOption;
                    if (message.includeDynamicOptions && message.includeDynamicOptions.length) {
                        object.includeDynamicOptions = [];
                        for (let j = 0; j < message.includeDynamicOptions.length; ++j)
                            object.includeDynamicOptions[j] = message.includeDynamicOptions[j];
                    }
                    if (message.options && message.options.length) {
                        object.options = [];
                        for (let j = 0; j < message.options.length; ++j)
                            object.options[j] = $root.clutch.resolver.v1.Option.toObject(message.options[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this OptionField to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.OptionField
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OptionField.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return OptionField;
            })();

            v1.Field = (function() {

                /**
                 * Properties of a Field.
                 * @memberof clutch.resolver.v1
                 * @interface IField
                 * @property {string|null} [name] Field name
                 * @property {clutch.resolver.v1.IFieldMetadata|null} [metadata] Field metadata
                 */

                /**
                 * Constructs a new Field.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a Field.
                 * @implements IField
                 * @constructor
                 * @param {clutch.resolver.v1.IField=} [properties] Properties to set
                 */
                function Field(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Field name.
                 * @member {string} name
                 * @memberof clutch.resolver.v1.Field
                 * @instance
                 */
                Field.prototype.name = "";

                /**
                 * Field metadata.
                 * @member {clutch.resolver.v1.IFieldMetadata|null|undefined} metadata
                 * @memberof clutch.resolver.v1.Field
                 * @instance
                 */
                Field.prototype.metadata = null;

                /**
                 * Verifies a Field message.
                 * @function verify
                 * @memberof clutch.resolver.v1.Field
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Field.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        let error = $root.clutch.resolver.v1.FieldMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Field message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.Field
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.Field} Field
                 */
                Field.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.Field)
                        return object;
                    let message = new $root.clutch.resolver.v1.Field();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.metadata != null) {
                        if (typeof object.metadata !== "object")
                            throw TypeError(".clutch.resolver.v1.Field.metadata: object expected");
                        message.metadata = $root.clutch.resolver.v1.FieldMetadata.fromObject(object.metadata);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Field message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.Field
                 * @static
                 * @param {clutch.resolver.v1.Field} message Field
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Field.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.metadata = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        object.metadata = $root.clutch.resolver.v1.FieldMetadata.toObject(message.metadata, options);
                    return object;
                };

                /**
                 * Converts this Field to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.Field
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Field.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Field;
            })();

            v1.FieldMetadata = (function() {

                /**
                 * Properties of a FieldMetadata.
                 * @memberof clutch.resolver.v1
                 * @interface IFieldMetadata
                 * @property {string|null} [displayName] FieldMetadata displayName
                 * @property {boolean|null} [required] FieldMetadata required
                 * @property {clutch.resolver.v1.IStringField|null} [stringField] FieldMetadata stringField
                 * @property {clutch.resolver.v1.IOptionField|null} [optionField] FieldMetadata optionField
                 */

                /**
                 * Constructs a new FieldMetadata.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a FieldMetadata.
                 * @implements IFieldMetadata
                 * @constructor
                 * @param {clutch.resolver.v1.IFieldMetadata=} [properties] Properties to set
                 */
                function FieldMetadata(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FieldMetadata displayName.
                 * @member {string} displayName
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @instance
                 */
                FieldMetadata.prototype.displayName = "";

                /**
                 * FieldMetadata required.
                 * @member {boolean} required
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @instance
                 */
                FieldMetadata.prototype.required = false;

                /**
                 * FieldMetadata stringField.
                 * @member {clutch.resolver.v1.IStringField|null|undefined} stringField
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @instance
                 */
                FieldMetadata.prototype.stringField = null;

                /**
                 * FieldMetadata optionField.
                 * @member {clutch.resolver.v1.IOptionField|null|undefined} optionField
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @instance
                 */
                FieldMetadata.prototype.optionField = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * FieldMetadata type.
                 * @member {"stringField"|"optionField"|undefined} type
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @instance
                 */
                Object.defineProperty(FieldMetadata.prototype, "type", {
                    get: $util.oneOfGetter($oneOfFields = ["stringField", "optionField"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies a FieldMetadata message.
                 * @function verify
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        if (!$util.isString(message.displayName))
                            return "displayName: string expected";
                    if (message.required != null && message.hasOwnProperty("required"))
                        if (typeof message.required !== "boolean")
                            return "required: boolean expected";
                    if (message.stringField != null && message.hasOwnProperty("stringField")) {
                        properties.type = 1;
                        {
                            let error = $root.clutch.resolver.v1.StringField.verify(message.stringField);
                            if (error)
                                return "stringField." + error;
                        }
                    }
                    if (message.optionField != null && message.hasOwnProperty("optionField")) {
                        if (properties.type === 1)
                            return "type: multiple values";
                        properties.type = 1;
                        {
                            let error = $root.clutch.resolver.v1.OptionField.verify(message.optionField);
                            if (error)
                                return "optionField." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a FieldMetadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.FieldMetadata} FieldMetadata
                 */
                FieldMetadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.FieldMetadata)
                        return object;
                    let message = new $root.clutch.resolver.v1.FieldMetadata();
                    if (object.displayName != null)
                        message.displayName = String(object.displayName);
                    if (object.required != null)
                        message.required = Boolean(object.required);
                    if (object.stringField != null) {
                        if (typeof object.stringField !== "object")
                            throw TypeError(".clutch.resolver.v1.FieldMetadata.stringField: object expected");
                        message.stringField = $root.clutch.resolver.v1.StringField.fromObject(object.stringField);
                    }
                    if (object.optionField != null) {
                        if (typeof object.optionField !== "object")
                            throw TypeError(".clutch.resolver.v1.FieldMetadata.optionField: object expected");
                        message.optionField = $root.clutch.resolver.v1.OptionField.fromObject(object.optionField);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FieldMetadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @static
                 * @param {clutch.resolver.v1.FieldMetadata} message FieldMetadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldMetadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.displayName = "";
                        object.required = false;
                    }
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        object.displayName = message.displayName;
                    if (message.required != null && message.hasOwnProperty("required"))
                        object.required = message.required;
                    if (message.stringField != null && message.hasOwnProperty("stringField")) {
                        object.stringField = $root.clutch.resolver.v1.StringField.toObject(message.stringField, options);
                        if (options.oneofs)
                            object.type = "stringField";
                    }
                    if (message.optionField != null && message.hasOwnProperty("optionField")) {
                        object.optionField = $root.clutch.resolver.v1.OptionField.toObject(message.optionField, options);
                        if (options.oneofs)
                            object.type = "optionField";
                    }
                    return object;
                };

                /**
                 * Converts this FieldMetadata to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldMetadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FieldMetadata;
            })();

            v1.SearchMetadata = (function() {

                /**
                 * Properties of a SearchMetadata.
                 * @memberof clutch.resolver.v1
                 * @interface ISearchMetadata
                 * @property {boolean|null} [enabled] SearchMetadata enabled
                 * @property {boolean|null} [autocompleteEnabled] SearchMetadata autocompleteEnabled
                 */

                /**
                 * Constructs a new SearchMetadata.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a SearchMetadata.
                 * @implements ISearchMetadata
                 * @constructor
                 * @param {clutch.resolver.v1.ISearchMetadata=} [properties] Properties to set
                 */
                function SearchMetadata(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SearchMetadata enabled.
                 * @member {boolean} enabled
                 * @memberof clutch.resolver.v1.SearchMetadata
                 * @instance
                 */
                SearchMetadata.prototype.enabled = false;

                /**
                 * SearchMetadata autocompleteEnabled.
                 * @member {boolean} autocompleteEnabled
                 * @memberof clutch.resolver.v1.SearchMetadata
                 * @instance
                 */
                SearchMetadata.prototype.autocompleteEnabled = false;

                /**
                 * Verifies a SearchMetadata message.
                 * @function verify
                 * @memberof clutch.resolver.v1.SearchMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SearchMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.enabled != null && message.hasOwnProperty("enabled"))
                        if (typeof message.enabled !== "boolean")
                            return "enabled: boolean expected";
                    if (message.autocompleteEnabled != null && message.hasOwnProperty("autocompleteEnabled"))
                        if (typeof message.autocompleteEnabled !== "boolean")
                            return "autocompleteEnabled: boolean expected";
                    return null;
                };

                /**
                 * Creates a SearchMetadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.SearchMetadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.SearchMetadata} SearchMetadata
                 */
                SearchMetadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.SearchMetadata)
                        return object;
                    let message = new $root.clutch.resolver.v1.SearchMetadata();
                    if (object.enabled != null)
                        message.enabled = Boolean(object.enabled);
                    if (object.autocompleteEnabled != null)
                        message.autocompleteEnabled = Boolean(object.autocompleteEnabled);
                    return message;
                };

                /**
                 * Creates a plain object from a SearchMetadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.SearchMetadata
                 * @static
                 * @param {clutch.resolver.v1.SearchMetadata} message SearchMetadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SearchMetadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.enabled = false;
                        object.autocompleteEnabled = false;
                    }
                    if (message.enabled != null && message.hasOwnProperty("enabled"))
                        object.enabled = message.enabled;
                    if (message.autocompleteEnabled != null && message.hasOwnProperty("autocompleteEnabled"))
                        object.autocompleteEnabled = message.autocompleteEnabled;
                    return object;
                };

                /**
                 * Converts this SearchMetadata to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.SearchMetadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SearchMetadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SearchMetadata;
            })();

            v1.SchemaMetadata = (function() {

                /**
                 * Properties of a SchemaMetadata.
                 * @memberof clutch.resolver.v1
                 * @interface ISchemaMetadata
                 * @property {string|null} [displayName] SchemaMetadata displayName
                 * @property {boolean|null} [searchable] SchemaMetadata searchable
                 * @property {clutch.resolver.v1.ISearchMetadata|null} [search] SchemaMetadata search
                 */

                /**
                 * Constructs a new SchemaMetadata.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a SchemaMetadata.
                 * @implements ISchemaMetadata
                 * @constructor
                 * @param {clutch.resolver.v1.ISchemaMetadata=} [properties] Properties to set
                 */
                function SchemaMetadata(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SchemaMetadata displayName.
                 * @member {string} displayName
                 * @memberof clutch.resolver.v1.SchemaMetadata
                 * @instance
                 */
                SchemaMetadata.prototype.displayName = "";

                /**
                 * SchemaMetadata searchable.
                 * @member {boolean} searchable
                 * @memberof clutch.resolver.v1.SchemaMetadata
                 * @instance
                 */
                SchemaMetadata.prototype.searchable = false;

                /**
                 * SchemaMetadata search.
                 * @member {clutch.resolver.v1.ISearchMetadata|null|undefined} search
                 * @memberof clutch.resolver.v1.SchemaMetadata
                 * @instance
                 */
                SchemaMetadata.prototype.search = null;

                /**
                 * Verifies a SchemaMetadata message.
                 * @function verify
                 * @memberof clutch.resolver.v1.SchemaMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SchemaMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        if (!$util.isString(message.displayName))
                            return "displayName: string expected";
                    if (message.searchable != null && message.hasOwnProperty("searchable"))
                        if (typeof message.searchable !== "boolean")
                            return "searchable: boolean expected";
                    if (message.search != null && message.hasOwnProperty("search")) {
                        let error = $root.clutch.resolver.v1.SearchMetadata.verify(message.search);
                        if (error)
                            return "search." + error;
                    }
                    return null;
                };

                /**
                 * Creates a SchemaMetadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.SchemaMetadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.SchemaMetadata} SchemaMetadata
                 */
                SchemaMetadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.SchemaMetadata)
                        return object;
                    let message = new $root.clutch.resolver.v1.SchemaMetadata();
                    if (object.displayName != null)
                        message.displayName = String(object.displayName);
                    if (object.searchable != null)
                        message.searchable = Boolean(object.searchable);
                    if (object.search != null) {
                        if (typeof object.search !== "object")
                            throw TypeError(".clutch.resolver.v1.SchemaMetadata.search: object expected");
                        message.search = $root.clutch.resolver.v1.SearchMetadata.fromObject(object.search);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SchemaMetadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.SchemaMetadata
                 * @static
                 * @param {clutch.resolver.v1.SchemaMetadata} message SchemaMetadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SchemaMetadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.displayName = "";
                        object.searchable = false;
                        object.search = null;
                    }
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        object.displayName = message.displayName;
                    if (message.searchable != null && message.hasOwnProperty("searchable"))
                        object.searchable = message.searchable;
                    if (message.search != null && message.hasOwnProperty("search"))
                        object.search = $root.clutch.resolver.v1.SearchMetadata.toObject(message.search, options);
                    return object;
                };

                /**
                 * Converts this SchemaMetadata to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.SchemaMetadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SchemaMetadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SchemaMetadata;
            })();

            v1.Schema = (function() {

                /**
                 * Properties of a Schema.
                 * @memberof clutch.resolver.v1
                 * @interface ISchema
                 * @property {string|null} [typeUrl] Schema typeUrl
                 * @property {clutch.resolver.v1.ISchemaMetadata|null} [metadata] Schema metadata
                 * @property {Array.<clutch.resolver.v1.IField>|null} [fields] Schema fields
                 * @property {google.rpc.IStatus|null} [error] Schema error
                 */

                /**
                 * Constructs a new Schema.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a Schema.
                 * @implements ISchema
                 * @constructor
                 * @param {clutch.resolver.v1.ISchema=} [properties] Properties to set
                 */
                function Schema(properties) {
                    this.fields = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Schema typeUrl.
                 * @member {string} typeUrl
                 * @memberof clutch.resolver.v1.Schema
                 * @instance
                 */
                Schema.prototype.typeUrl = "";

                /**
                 * Schema metadata.
                 * @member {clutch.resolver.v1.ISchemaMetadata|null|undefined} metadata
                 * @memberof clutch.resolver.v1.Schema
                 * @instance
                 */
                Schema.prototype.metadata = null;

                /**
                 * Schema fields.
                 * @member {Array.<clutch.resolver.v1.IField>} fields
                 * @memberof clutch.resolver.v1.Schema
                 * @instance
                 */
                Schema.prototype.fields = $util.emptyArray;

                /**
                 * Schema error.
                 * @member {google.rpc.IStatus|null|undefined} error
                 * @memberof clutch.resolver.v1.Schema
                 * @instance
                 */
                Schema.prototype.error = null;

                /**
                 * Verifies a Schema message.
                 * @function verify
                 * @memberof clutch.resolver.v1.Schema
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Schema.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        if (!$util.isString(message.typeUrl))
                            return "typeUrl: string expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        let error = $root.clutch.resolver.v1.SchemaMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    if (message.fields != null && message.hasOwnProperty("fields")) {
                        if (!Array.isArray(message.fields))
                            return "fields: array expected";
                        for (let i = 0; i < message.fields.length; ++i) {
                            let error = $root.clutch.resolver.v1.Field.verify(message.fields[i]);
                            if (error)
                                return "fields." + error;
                        }
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        let error = $root.google.rpc.Status.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Schema message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.Schema
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.Schema} Schema
                 */
                Schema.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.Schema)
                        return object;
                    let message = new $root.clutch.resolver.v1.Schema();
                    if (object.typeUrl != null)
                        message.typeUrl = String(object.typeUrl);
                    if (object.metadata != null) {
                        if (typeof object.metadata !== "object")
                            throw TypeError(".clutch.resolver.v1.Schema.metadata: object expected");
                        message.metadata = $root.clutch.resolver.v1.SchemaMetadata.fromObject(object.metadata);
                    }
                    if (object.fields) {
                        if (!Array.isArray(object.fields))
                            throw TypeError(".clutch.resolver.v1.Schema.fields: array expected");
                        message.fields = [];
                        for (let i = 0; i < object.fields.length; ++i) {
                            if (typeof object.fields[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.Schema.fields: object expected");
                            message.fields[i] = $root.clutch.resolver.v1.Field.fromObject(object.fields[i]);
                        }
                    }
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".clutch.resolver.v1.Schema.error: object expected");
                        message.error = $root.google.rpc.Status.fromObject(object.error);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Schema message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.Schema
                 * @static
                 * @param {clutch.resolver.v1.Schema} message Schema
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Schema.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.fields = [];
                    if (options.defaults) {
                        object.typeUrl = "";
                        object.metadata = null;
                        object.error = null;
                    }
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        object.typeUrl = message.typeUrl;
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        object.metadata = $root.clutch.resolver.v1.SchemaMetadata.toObject(message.metadata, options);
                    if (message.fields && message.fields.length) {
                        object.fields = [];
                        for (let j = 0; j < message.fields.length; ++j)
                            object.fields[j] = $root.clutch.resolver.v1.Field.toObject(message.fields[j], options);
                    }
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.google.rpc.Status.toObject(message.error, options);
                    return object;
                };

                /**
                 * Converts this Schema to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.Schema
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Schema.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Schema;
            })();

            v1.ResolverAPI = (function() {

                /**
                 * Constructs a new ResolverAPI service.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a ResolverAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function ResolverAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (ResolverAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ResolverAPI;

                /**
                 * Callback as used by {@link clutch.resolver.v1.ResolverAPI#getObjectSchemas}.
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @typedef GetObjectSchemasCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.resolver.v1.GetObjectSchemasResponse} [response] GetObjectSchemasResponse
                 */

                /**
                 * Calls GetObjectSchemas.
                 * @function getObjectSchemas
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @instance
                 * @param {clutch.resolver.v1.IGetObjectSchemasRequest} request GetObjectSchemasRequest message or plain object
                 * @param {clutch.resolver.v1.ResolverAPI.GetObjectSchemasCallback} callback Node-style callback called with the error, if any, and GetObjectSchemasResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ResolverAPI.prototype.getObjectSchemas = function getObjectSchemas(request, callback) {
                    return this.rpcCall(getObjectSchemas, $root.clutch.resolver.v1.GetObjectSchemasRequest, $root.clutch.resolver.v1.GetObjectSchemasResponse, request, callback);
                }, "name", { value: "GetObjectSchemas" });

                /**
                 * Calls GetObjectSchemas.
                 * @function getObjectSchemas
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @instance
                 * @param {clutch.resolver.v1.IGetObjectSchemasRequest} request GetObjectSchemasRequest message or plain object
                 * @returns {Promise<clutch.resolver.v1.GetObjectSchemasResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.resolver.v1.ResolverAPI#search}.
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @typedef SearchCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.resolver.v1.SearchResponse} [response] SearchResponse
                 */

                /**
                 * Calls Search.
                 * @function search
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @instance
                 * @param {clutch.resolver.v1.ISearchRequest} request SearchRequest message or plain object
                 * @param {clutch.resolver.v1.ResolverAPI.SearchCallback} callback Node-style callback called with the error, if any, and SearchResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ResolverAPI.prototype.search = function search(request, callback) {
                    return this.rpcCall(search, $root.clutch.resolver.v1.SearchRequest, $root.clutch.resolver.v1.SearchResponse, request, callback);
                }, "name", { value: "Search" });

                /**
                 * Calls Search.
                 * @function search
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @instance
                 * @param {clutch.resolver.v1.ISearchRequest} request SearchRequest message or plain object
                 * @returns {Promise<clutch.resolver.v1.SearchResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.resolver.v1.ResolverAPI#resolve}.
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @typedef ResolveCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.resolver.v1.ResolveResponse} [response] ResolveResponse
                 */

                /**
                 * Calls Resolve.
                 * @function resolve
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @instance
                 * @param {clutch.resolver.v1.IResolveRequest} request ResolveRequest message or plain object
                 * @param {clutch.resolver.v1.ResolverAPI.ResolveCallback} callback Node-style callback called with the error, if any, and ResolveResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ResolverAPI.prototype.resolve = function resolve(request, callback) {
                    return this.rpcCall(resolve, $root.clutch.resolver.v1.ResolveRequest, $root.clutch.resolver.v1.ResolveResponse, request, callback);
                }, "name", { value: "Resolve" });

                /**
                 * Calls Resolve.
                 * @function resolve
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @instance
                 * @param {clutch.resolver.v1.IResolveRequest} request ResolveRequest message or plain object
                 * @returns {Promise<clutch.resolver.v1.ResolveResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.resolver.v1.ResolverAPI#autocomplete}.
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @typedef AutocompleteCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.resolver.v1.AutocompleteResponse} [response] AutocompleteResponse
                 */

                /**
                 * Calls Autocomplete.
                 * @function autocomplete
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @instance
                 * @param {clutch.resolver.v1.IAutocompleteRequest} request AutocompleteRequest message or plain object
                 * @param {clutch.resolver.v1.ResolverAPI.AutocompleteCallback} callback Node-style callback called with the error, if any, and AutocompleteResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ResolverAPI.prototype.autocomplete = function autocomplete(request, callback) {
                    return this.rpcCall(autocomplete, $root.clutch.resolver.v1.AutocompleteRequest, $root.clutch.resolver.v1.AutocompleteResponse, request, callback);
                }, "name", { value: "Autocomplete" });

                /**
                 * Calls Autocomplete.
                 * @function autocomplete
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @instance
                 * @param {clutch.resolver.v1.IAutocompleteRequest} request AutocompleteRequest message or plain object
                 * @returns {Promise<clutch.resolver.v1.AutocompleteResponse>} Promise
                 * @variation 2
                 */

                return ResolverAPI;
            })();

            v1.AutocompleteResult = (function() {

                /**
                 * Properties of an AutocompleteResult.
                 * @memberof clutch.resolver.v1
                 * @interface IAutocompleteResult
                 * @property {string|null} [id] AutocompleteResult id
                 * @property {string|null} [label] AutocompleteResult label
                 */

                /**
                 * Constructs a new AutocompleteResult.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents an AutocompleteResult.
                 * @implements IAutocompleteResult
                 * @constructor
                 * @param {clutch.resolver.v1.IAutocompleteResult=} [properties] Properties to set
                 */
                function AutocompleteResult(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AutocompleteResult id.
                 * @member {string} id
                 * @memberof clutch.resolver.v1.AutocompleteResult
                 * @instance
                 */
                AutocompleteResult.prototype.id = "";

                /**
                 * AutocompleteResult label.
                 * @member {string} label
                 * @memberof clutch.resolver.v1.AutocompleteResult
                 * @instance
                 */
                AutocompleteResult.prototype.label = "";

                /**
                 * Verifies an AutocompleteResult message.
                 * @function verify
                 * @memberof clutch.resolver.v1.AutocompleteResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AutocompleteResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.label != null && message.hasOwnProperty("label"))
                        if (!$util.isString(message.label))
                            return "label: string expected";
                    return null;
                };

                /**
                 * Creates an AutocompleteResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.AutocompleteResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.AutocompleteResult} AutocompleteResult
                 */
                AutocompleteResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.AutocompleteResult)
                        return object;
                    let message = new $root.clutch.resolver.v1.AutocompleteResult();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.label != null)
                        message.label = String(object.label);
                    return message;
                };

                /**
                 * Creates a plain object from an AutocompleteResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.AutocompleteResult
                 * @static
                 * @param {clutch.resolver.v1.AutocompleteResult} message AutocompleteResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AutocompleteResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.id = "";
                        object.label = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.label != null && message.hasOwnProperty("label"))
                        object.label = message.label;
                    return object;
                };

                /**
                 * Converts this AutocompleteResult to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.AutocompleteResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AutocompleteResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AutocompleteResult;
            })();

            v1.AutocompleteRequest = (function() {

                /**
                 * Properties of an AutocompleteRequest.
                 * @memberof clutch.resolver.v1
                 * @interface IAutocompleteRequest
                 * @property {string|null} [want] AutocompleteRequest want
                 * @property {string|null} [search] AutocompleteRequest search
                 * @property {number|Long|null} [limit] AutocompleteRequest limit
                 */

                /**
                 * Constructs a new AutocompleteRequest.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents an AutocompleteRequest.
                 * @implements IAutocompleteRequest
                 * @constructor
                 * @param {clutch.resolver.v1.IAutocompleteRequest=} [properties] Properties to set
                 */
                function AutocompleteRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AutocompleteRequest want.
                 * @member {string} want
                 * @memberof clutch.resolver.v1.AutocompleteRequest
                 * @instance
                 */
                AutocompleteRequest.prototype.want = "";

                /**
                 * AutocompleteRequest search.
                 * @member {string} search
                 * @memberof clutch.resolver.v1.AutocompleteRequest
                 * @instance
                 */
                AutocompleteRequest.prototype.search = "";

                /**
                 * AutocompleteRequest limit.
                 * @member {number|Long} limit
                 * @memberof clutch.resolver.v1.AutocompleteRequest
                 * @instance
                 */
                AutocompleteRequest.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * Verifies an AutocompleteRequest message.
                 * @function verify
                 * @memberof clutch.resolver.v1.AutocompleteRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AutocompleteRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.want != null && message.hasOwnProperty("want"))
                        if (!$util.isString(message.want))
                            return "want: string expected";
                    if (message.search != null && message.hasOwnProperty("search"))
                        if (!$util.isString(message.search))
                            return "search: string expected";
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                            return "limit: integer|Long expected";
                    return null;
                };

                /**
                 * Creates an AutocompleteRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.AutocompleteRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.AutocompleteRequest} AutocompleteRequest
                 */
                AutocompleteRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.AutocompleteRequest)
                        return object;
                    let message = new $root.clutch.resolver.v1.AutocompleteRequest();
                    if (object.want != null)
                        message.want = String(object.want);
                    if (object.search != null)
                        message.search = String(object.search);
                    if (object.limit != null)
                        if ($util.Long)
                            (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                        else if (typeof object.limit === "string")
                            message.limit = parseInt(object.limit, 10);
                        else if (typeof object.limit === "number")
                            message.limit = object.limit;
                        else if (typeof object.limit === "object")
                            message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
                    return message;
                };

                /**
                 * Creates a plain object from an AutocompleteRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.AutocompleteRequest
                 * @static
                 * @param {clutch.resolver.v1.AutocompleteRequest} message AutocompleteRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AutocompleteRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.want = "";
                        object.search = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.limit = options.longs === String ? "0" : 0;
                    }
                    if (message.want != null && message.hasOwnProperty("want"))
                        object.want = message.want;
                    if (message.search != null && message.hasOwnProperty("search"))
                        object.search = message.search;
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (typeof message.limit === "number")
                            object.limit = options.longs === String ? String(message.limit) : message.limit;
                        else
                            object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
                    return object;
                };

                /**
                 * Converts this AutocompleteRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.AutocompleteRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AutocompleteRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AutocompleteRequest;
            })();

            v1.AutocompleteResponse = (function() {

                /**
                 * Properties of an AutocompleteResponse.
                 * @memberof clutch.resolver.v1
                 * @interface IAutocompleteResponse
                 * @property {Array.<clutch.resolver.v1.IAutocompleteResult>|null} [results] AutocompleteResponse results
                 */

                /**
                 * Constructs a new AutocompleteResponse.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents an AutocompleteResponse.
                 * @implements IAutocompleteResponse
                 * @constructor
                 * @param {clutch.resolver.v1.IAutocompleteResponse=} [properties] Properties to set
                 */
                function AutocompleteResponse(properties) {
                    this.results = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * AutocompleteResponse results.
                 * @member {Array.<clutch.resolver.v1.IAutocompleteResult>} results
                 * @memberof clutch.resolver.v1.AutocompleteResponse
                 * @instance
                 */
                AutocompleteResponse.prototype.results = $util.emptyArray;

                /**
                 * Verifies an AutocompleteResponse message.
                 * @function verify
                 * @memberof clutch.resolver.v1.AutocompleteResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                AutocompleteResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.results != null && message.hasOwnProperty("results")) {
                        if (!Array.isArray(message.results))
                            return "results: array expected";
                        for (let i = 0; i < message.results.length; ++i) {
                            let error = $root.clutch.resolver.v1.AutocompleteResult.verify(message.results[i]);
                            if (error)
                                return "results." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an AutocompleteResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.AutocompleteResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.AutocompleteResponse} AutocompleteResponse
                 */
                AutocompleteResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.AutocompleteResponse)
                        return object;
                    let message = new $root.clutch.resolver.v1.AutocompleteResponse();
                    if (object.results) {
                        if (!Array.isArray(object.results))
                            throw TypeError(".clutch.resolver.v1.AutocompleteResponse.results: array expected");
                        message.results = [];
                        for (let i = 0; i < object.results.length; ++i) {
                            if (typeof object.results[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.AutocompleteResponse.results: object expected");
                            message.results[i] = $root.clutch.resolver.v1.AutocompleteResult.fromObject(object.results[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an AutocompleteResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.AutocompleteResponse
                 * @static
                 * @param {clutch.resolver.v1.AutocompleteResponse} message AutocompleteResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                AutocompleteResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.results = [];
                    if (message.results && message.results.length) {
                        object.results = [];
                        for (let j = 0; j < message.results.length; ++j)
                            object.results[j] = $root.clutch.resolver.v1.AutocompleteResult.toObject(message.results[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this AutocompleteResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.AutocompleteResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                AutocompleteResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return AutocompleteResponse;
            })();

            v1.ResolveRequest = (function() {

                /**
                 * Properties of a ResolveRequest.
                 * @memberof clutch.resolver.v1
                 * @interface IResolveRequest
                 * @property {string|null} [want] ResolveRequest want
                 * @property {google.protobuf.IAny|null} [have] ResolveRequest have
                 * @property {number|null} [limit] ResolveRequest limit
                 */

                /**
                 * Constructs a new ResolveRequest.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a ResolveRequest.
                 * @implements IResolveRequest
                 * @constructor
                 * @param {clutch.resolver.v1.IResolveRequest=} [properties] Properties to set
                 */
                function ResolveRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ResolveRequest want.
                 * @member {string} want
                 * @memberof clutch.resolver.v1.ResolveRequest
                 * @instance
                 */
                ResolveRequest.prototype.want = "";

                /**
                 * ResolveRequest have.
                 * @member {google.protobuf.IAny|null|undefined} have
                 * @memberof clutch.resolver.v1.ResolveRequest
                 * @instance
                 */
                ResolveRequest.prototype.have = null;

                /**
                 * ResolveRequest limit.
                 * @member {number} limit
                 * @memberof clutch.resolver.v1.ResolveRequest
                 * @instance
                 */
                ResolveRequest.prototype.limit = 0;

                /**
                 * Verifies a ResolveRequest message.
                 * @function verify
                 * @memberof clutch.resolver.v1.ResolveRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ResolveRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.want != null && message.hasOwnProperty("want"))
                        if (!$util.isString(message.want))
                            return "want: string expected";
                    if (message.have != null && message.hasOwnProperty("have")) {
                        let error = $root.google.protobuf.Any.verify(message.have);
                        if (error)
                            return "have." + error;
                    }
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    return null;
                };

                /**
                 * Creates a ResolveRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.ResolveRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.ResolveRequest} ResolveRequest
                 */
                ResolveRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.ResolveRequest)
                        return object;
                    let message = new $root.clutch.resolver.v1.ResolveRequest();
                    if (object.want != null)
                        message.want = String(object.want);
                    if (object.have != null) {
                        if (typeof object.have !== "object")
                            throw TypeError(".clutch.resolver.v1.ResolveRequest.have: object expected");
                        message.have = $root.google.protobuf.Any.fromObject(object.have);
                    }
                    if (object.limit != null)
                        message.limit = object.limit >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ResolveRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.ResolveRequest
                 * @static
                 * @param {clutch.resolver.v1.ResolveRequest} message ResolveRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ResolveRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.want = "";
                        object.have = null;
                        object.limit = 0;
                    }
                    if (message.want != null && message.hasOwnProperty("want"))
                        object.want = message.want;
                    if (message.have != null && message.hasOwnProperty("have"))
                        object.have = $root.google.protobuf.Any.toObject(message.have, options);
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        object.limit = message.limit;
                    return object;
                };

                /**
                 * Converts this ResolveRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.ResolveRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ResolveRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ResolveRequest;
            })();

            v1.ResolveResponse = (function() {

                /**
                 * Properties of a ResolveResponse.
                 * @memberof clutch.resolver.v1
                 * @interface IResolveResponse
                 * @property {Array.<google.protobuf.IAny>|null} [results] ResolveResponse results
                 * @property {Array.<google.rpc.IStatus>|null} [partialFailures] ResolveResponse partialFailures
                 */

                /**
                 * Constructs a new ResolveResponse.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a ResolveResponse.
                 * @implements IResolveResponse
                 * @constructor
                 * @param {clutch.resolver.v1.IResolveResponse=} [properties] Properties to set
                 */
                function ResolveResponse(properties) {
                    this.results = [];
                    this.partialFailures = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ResolveResponse results.
                 * @member {Array.<google.protobuf.IAny>} results
                 * @memberof clutch.resolver.v1.ResolveResponse
                 * @instance
                 */
                ResolveResponse.prototype.results = $util.emptyArray;

                /**
                 * ResolveResponse partialFailures.
                 * @member {Array.<google.rpc.IStatus>} partialFailures
                 * @memberof clutch.resolver.v1.ResolveResponse
                 * @instance
                 */
                ResolveResponse.prototype.partialFailures = $util.emptyArray;

                /**
                 * Verifies a ResolveResponse message.
                 * @function verify
                 * @memberof clutch.resolver.v1.ResolveResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ResolveResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.results != null && message.hasOwnProperty("results")) {
                        if (!Array.isArray(message.results))
                            return "results: array expected";
                        for (let i = 0; i < message.results.length; ++i) {
                            let error = $root.google.protobuf.Any.verify(message.results[i]);
                            if (error)
                                return "results." + error;
                        }
                    }
                    if (message.partialFailures != null && message.hasOwnProperty("partialFailures")) {
                        if (!Array.isArray(message.partialFailures))
                            return "partialFailures: array expected";
                        for (let i = 0; i < message.partialFailures.length; ++i) {
                            let error = $root.google.rpc.Status.verify(message.partialFailures[i]);
                            if (error)
                                return "partialFailures." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ResolveResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.ResolveResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.ResolveResponse} ResolveResponse
                 */
                ResolveResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.ResolveResponse)
                        return object;
                    let message = new $root.clutch.resolver.v1.ResolveResponse();
                    if (object.results) {
                        if (!Array.isArray(object.results))
                            throw TypeError(".clutch.resolver.v1.ResolveResponse.results: array expected");
                        message.results = [];
                        for (let i = 0; i < object.results.length; ++i) {
                            if (typeof object.results[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.ResolveResponse.results: object expected");
                            message.results[i] = $root.google.protobuf.Any.fromObject(object.results[i]);
                        }
                    }
                    if (object.partialFailures) {
                        if (!Array.isArray(object.partialFailures))
                            throw TypeError(".clutch.resolver.v1.ResolveResponse.partialFailures: array expected");
                        message.partialFailures = [];
                        for (let i = 0; i < object.partialFailures.length; ++i) {
                            if (typeof object.partialFailures[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.ResolveResponse.partialFailures: object expected");
                            message.partialFailures[i] = $root.google.rpc.Status.fromObject(object.partialFailures[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ResolveResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.ResolveResponse
                 * @static
                 * @param {clutch.resolver.v1.ResolveResponse} message ResolveResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ResolveResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.results = [];
                        object.partialFailures = [];
                    }
                    if (message.results && message.results.length) {
                        object.results = [];
                        for (let j = 0; j < message.results.length; ++j)
                            object.results[j] = $root.google.protobuf.Any.toObject(message.results[j], options);
                    }
                    if (message.partialFailures && message.partialFailures.length) {
                        object.partialFailures = [];
                        for (let j = 0; j < message.partialFailures.length; ++j)
                            object.partialFailures[j] = $root.google.rpc.Status.toObject(message.partialFailures[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ResolveResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.ResolveResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ResolveResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ResolveResponse;
            })();

            v1.SearchRequest = (function() {

                /**
                 * Properties of a SearchRequest.
                 * @memberof clutch.resolver.v1
                 * @interface ISearchRequest
                 * @property {string|null} [want] SearchRequest want
                 * @property {string|null} [query] SearchRequest query
                 * @property {number|null} [limit] SearchRequest limit
                 */

                /**
                 * Constructs a new SearchRequest.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a SearchRequest.
                 * @implements ISearchRequest
                 * @constructor
                 * @param {clutch.resolver.v1.ISearchRequest=} [properties] Properties to set
                 */
                function SearchRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SearchRequest want.
                 * @member {string} want
                 * @memberof clutch.resolver.v1.SearchRequest
                 * @instance
                 */
                SearchRequest.prototype.want = "";

                /**
                 * SearchRequest query.
                 * @member {string} query
                 * @memberof clutch.resolver.v1.SearchRequest
                 * @instance
                 */
                SearchRequest.prototype.query = "";

                /**
                 * SearchRequest limit.
                 * @member {number} limit
                 * @memberof clutch.resolver.v1.SearchRequest
                 * @instance
                 */
                SearchRequest.prototype.limit = 0;

                /**
                 * Verifies a SearchRequest message.
                 * @function verify
                 * @memberof clutch.resolver.v1.SearchRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SearchRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.want != null && message.hasOwnProperty("want"))
                        if (!$util.isString(message.want))
                            return "want: string expected";
                    if (message.query != null && message.hasOwnProperty("query"))
                        if (!$util.isString(message.query))
                            return "query: string expected";
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    return null;
                };

                /**
                 * Creates a SearchRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.SearchRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.SearchRequest} SearchRequest
                 */
                SearchRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.SearchRequest)
                        return object;
                    let message = new $root.clutch.resolver.v1.SearchRequest();
                    if (object.want != null)
                        message.want = String(object.want);
                    if (object.query != null)
                        message.query = String(object.query);
                    if (object.limit != null)
                        message.limit = object.limit >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a SearchRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.SearchRequest
                 * @static
                 * @param {clutch.resolver.v1.SearchRequest} message SearchRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SearchRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.want = "";
                        object.query = "";
                        object.limit = 0;
                    }
                    if (message.want != null && message.hasOwnProperty("want"))
                        object.want = message.want;
                    if (message.query != null && message.hasOwnProperty("query"))
                        object.query = message.query;
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        object.limit = message.limit;
                    return object;
                };

                /**
                 * Converts this SearchRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.SearchRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SearchRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SearchRequest;
            })();

            v1.SearchResponse = (function() {

                /**
                 * Properties of a SearchResponse.
                 * @memberof clutch.resolver.v1
                 * @interface ISearchResponse
                 * @property {Array.<google.protobuf.IAny>|null} [results] SearchResponse results
                 * @property {Array.<google.rpc.IStatus>|null} [partialFailures] SearchResponse partialFailures
                 */

                /**
                 * Constructs a new SearchResponse.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a SearchResponse.
                 * @implements ISearchResponse
                 * @constructor
                 * @param {clutch.resolver.v1.ISearchResponse=} [properties] Properties to set
                 */
                function SearchResponse(properties) {
                    this.results = [];
                    this.partialFailures = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SearchResponse results.
                 * @member {Array.<google.protobuf.IAny>} results
                 * @memberof clutch.resolver.v1.SearchResponse
                 * @instance
                 */
                SearchResponse.prototype.results = $util.emptyArray;

                /**
                 * SearchResponse partialFailures.
                 * @member {Array.<google.rpc.IStatus>} partialFailures
                 * @memberof clutch.resolver.v1.SearchResponse
                 * @instance
                 */
                SearchResponse.prototype.partialFailures = $util.emptyArray;

                /**
                 * Verifies a SearchResponse message.
                 * @function verify
                 * @memberof clutch.resolver.v1.SearchResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SearchResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.results != null && message.hasOwnProperty("results")) {
                        if (!Array.isArray(message.results))
                            return "results: array expected";
                        for (let i = 0; i < message.results.length; ++i) {
                            let error = $root.google.protobuf.Any.verify(message.results[i]);
                            if (error)
                                return "results." + error;
                        }
                    }
                    if (message.partialFailures != null && message.hasOwnProperty("partialFailures")) {
                        if (!Array.isArray(message.partialFailures))
                            return "partialFailures: array expected";
                        for (let i = 0; i < message.partialFailures.length; ++i) {
                            let error = $root.google.rpc.Status.verify(message.partialFailures[i]);
                            if (error)
                                return "partialFailures." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SearchResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.SearchResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.SearchResponse} SearchResponse
                 */
                SearchResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.SearchResponse)
                        return object;
                    let message = new $root.clutch.resolver.v1.SearchResponse();
                    if (object.results) {
                        if (!Array.isArray(object.results))
                            throw TypeError(".clutch.resolver.v1.SearchResponse.results: array expected");
                        message.results = [];
                        for (let i = 0; i < object.results.length; ++i) {
                            if (typeof object.results[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.SearchResponse.results: object expected");
                            message.results[i] = $root.google.protobuf.Any.fromObject(object.results[i]);
                        }
                    }
                    if (object.partialFailures) {
                        if (!Array.isArray(object.partialFailures))
                            throw TypeError(".clutch.resolver.v1.SearchResponse.partialFailures: array expected");
                        message.partialFailures = [];
                        for (let i = 0; i < object.partialFailures.length; ++i) {
                            if (typeof object.partialFailures[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.SearchResponse.partialFailures: object expected");
                            message.partialFailures[i] = $root.google.rpc.Status.fromObject(object.partialFailures[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SearchResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.SearchResponse
                 * @static
                 * @param {clutch.resolver.v1.SearchResponse} message SearchResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SearchResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.results = [];
                        object.partialFailures = [];
                    }
                    if (message.results && message.results.length) {
                        object.results = [];
                        for (let j = 0; j < message.results.length; ++j)
                            object.results[j] = $root.google.protobuf.Any.toObject(message.results[j], options);
                    }
                    if (message.partialFailures && message.partialFailures.length) {
                        object.partialFailures = [];
                        for (let j = 0; j < message.partialFailures.length; ++j)
                            object.partialFailures[j] = $root.google.rpc.Status.toObject(message.partialFailures[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SearchResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.SearchResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SearchResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SearchResponse;
            })();

            v1.GetObjectSchemasRequest = (function() {

                /**
                 * Properties of a GetObjectSchemasRequest.
                 * @memberof clutch.resolver.v1
                 * @interface IGetObjectSchemasRequest
                 * @property {string|null} [typeUrl] GetObjectSchemasRequest typeUrl
                 */

                /**
                 * Constructs a new GetObjectSchemasRequest.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a GetObjectSchemasRequest.
                 * @implements IGetObjectSchemasRequest
                 * @constructor
                 * @param {clutch.resolver.v1.IGetObjectSchemasRequest=} [properties] Properties to set
                 */
                function GetObjectSchemasRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetObjectSchemasRequest typeUrl.
                 * @member {string} typeUrl
                 * @memberof clutch.resolver.v1.GetObjectSchemasRequest
                 * @instance
                 */
                GetObjectSchemasRequest.prototype.typeUrl = "";

                /**
                 * Verifies a GetObjectSchemasRequest message.
                 * @function verify
                 * @memberof clutch.resolver.v1.GetObjectSchemasRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetObjectSchemasRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        if (!$util.isString(message.typeUrl))
                            return "typeUrl: string expected";
                    return null;
                };

                /**
                 * Creates a GetObjectSchemasRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.GetObjectSchemasRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.GetObjectSchemasRequest} GetObjectSchemasRequest
                 */
                GetObjectSchemasRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.GetObjectSchemasRequest)
                        return object;
                    let message = new $root.clutch.resolver.v1.GetObjectSchemasRequest();
                    if (object.typeUrl != null)
                        message.typeUrl = String(object.typeUrl);
                    return message;
                };

                /**
                 * Creates a plain object from a GetObjectSchemasRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.GetObjectSchemasRequest
                 * @static
                 * @param {clutch.resolver.v1.GetObjectSchemasRequest} message GetObjectSchemasRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetObjectSchemasRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.typeUrl = "";
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        object.typeUrl = message.typeUrl;
                    return object;
                };

                /**
                 * Converts this GetObjectSchemasRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.GetObjectSchemasRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetObjectSchemasRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetObjectSchemasRequest;
            })();

            v1.GetObjectSchemasResponse = (function() {

                /**
                 * Properties of a GetObjectSchemasResponse.
                 * @memberof clutch.resolver.v1
                 * @interface IGetObjectSchemasResponse
                 * @property {string|null} [typeUrl] GetObjectSchemasResponse typeUrl
                 * @property {Array.<clutch.resolver.v1.ISchema>|null} [schemas] GetObjectSchemasResponse schemas
                 */

                /**
                 * Constructs a new GetObjectSchemasResponse.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a GetObjectSchemasResponse.
                 * @implements IGetObjectSchemasResponse
                 * @constructor
                 * @param {clutch.resolver.v1.IGetObjectSchemasResponse=} [properties] Properties to set
                 */
                function GetObjectSchemasResponse(properties) {
                    this.schemas = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetObjectSchemasResponse typeUrl.
                 * @member {string} typeUrl
                 * @memberof clutch.resolver.v1.GetObjectSchemasResponse
                 * @instance
                 */
                GetObjectSchemasResponse.prototype.typeUrl = "";

                /**
                 * GetObjectSchemasResponse schemas.
                 * @member {Array.<clutch.resolver.v1.ISchema>} schemas
                 * @memberof clutch.resolver.v1.GetObjectSchemasResponse
                 * @instance
                 */
                GetObjectSchemasResponse.prototype.schemas = $util.emptyArray;

                /**
                 * Verifies a GetObjectSchemasResponse message.
                 * @function verify
                 * @memberof clutch.resolver.v1.GetObjectSchemasResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetObjectSchemasResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        if (!$util.isString(message.typeUrl))
                            return "typeUrl: string expected";
                    if (message.schemas != null && message.hasOwnProperty("schemas")) {
                        if (!Array.isArray(message.schemas))
                            return "schemas: array expected";
                        for (let i = 0; i < message.schemas.length; ++i) {
                            let error = $root.clutch.resolver.v1.Schema.verify(message.schemas[i]);
                            if (error)
                                return "schemas." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetObjectSchemasResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.GetObjectSchemasResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.GetObjectSchemasResponse} GetObjectSchemasResponse
                 */
                GetObjectSchemasResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.GetObjectSchemasResponse)
                        return object;
                    let message = new $root.clutch.resolver.v1.GetObjectSchemasResponse();
                    if (object.typeUrl != null)
                        message.typeUrl = String(object.typeUrl);
                    if (object.schemas) {
                        if (!Array.isArray(object.schemas))
                            throw TypeError(".clutch.resolver.v1.GetObjectSchemasResponse.schemas: array expected");
                        message.schemas = [];
                        for (let i = 0; i < object.schemas.length; ++i) {
                            if (typeof object.schemas[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.GetObjectSchemasResponse.schemas: object expected");
                            message.schemas[i] = $root.clutch.resolver.v1.Schema.fromObject(object.schemas[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetObjectSchemasResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.GetObjectSchemasResponse
                 * @static
                 * @param {clutch.resolver.v1.GetObjectSchemasResponse} message GetObjectSchemasResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetObjectSchemasResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.schemas = [];
                    if (options.defaults)
                        object.typeUrl = "";
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        object.typeUrl = message.typeUrl;
                    if (message.schemas && message.schemas.length) {
                        object.schemas = [];
                        for (let j = 0; j < message.schemas.length; ++j)
                            object.schemas[j] = $root.clutch.resolver.v1.Schema.toObject(message.schemas[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetObjectSchemasResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.GetObjectSchemasResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetObjectSchemasResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetObjectSchemasResponse;
            })();

            return v1;
        })();

        resolver.k8s = (function() {

            /**
             * Namespace k8s.
             * @memberof clutch.resolver
             * @namespace
             */
            const k8s = {};

            k8s.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.resolver.k8s
                 * @namespace
                 */
                const v1 = {};

                v1.PodID = (function() {

                    /**
                     * Properties of a PodID.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface IPodID
                     * @property {string|null} [name] PodID name
                     * @property {string|null} [clientset] PodID clientset
                     * @property {string|null} [namespace] PodID namespace
                     */

                    /**
                     * Constructs a new PodID.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a PodID.
                     * @implements IPodID
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.IPodID=} [properties] Properties to set
                     */
                    function PodID(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PodID name.
                     * @member {string} name
                     * @memberof clutch.resolver.k8s.v1.PodID
                     * @instance
                     */
                    PodID.prototype.name = "";

                    /**
                     * PodID clientset.
                     * @member {string} clientset
                     * @memberof clutch.resolver.k8s.v1.PodID
                     * @instance
                     */
                    PodID.prototype.clientset = "";

                    /**
                     * PodID namespace.
                     * @member {string} namespace
                     * @memberof clutch.resolver.k8s.v1.PodID
                     * @instance
                     */
                    PodID.prototype.namespace = "";

                    /**
                     * Verifies a PodID message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.PodID
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PodID.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            if (!$util.isString(message.clientset))
                                return "clientset: string expected";
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            if (!$util.isString(message.namespace))
                                return "namespace: string expected";
                        return null;
                    };

                    /**
                     * Creates a PodID message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.PodID
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.PodID} PodID
                     */
                    PodID.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.PodID)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.PodID();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.clientset != null)
                            message.clientset = String(object.clientset);
                        if (object.namespace != null)
                            message.namespace = String(object.namespace);
                        return message;
                    };

                    /**
                     * Creates a plain object from a PodID message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.PodID
                     * @static
                     * @param {clutch.resolver.k8s.v1.PodID} message PodID
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PodID.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.clientset = "";
                            object.namespace = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            object.clientset = message.clientset;
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            object.namespace = message.namespace;
                        return object;
                    };

                    /**
                     * Converts this PodID to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.PodID
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PodID.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return PodID;
                })();

                v1.IPAddress = (function() {

                    /**
                     * Properties of a IPAddress.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface IIPAddress
                     * @property {string|null} [ipAddress] IPAddress ipAddress
                     */

                    /**
                     * Constructs a new IPAddress.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a IPAddress.
                     * @implements IIPAddress
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.IIPAddress=} [properties] Properties to set
                     */
                    function IPAddress(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * IPAddress ipAddress.
                     * @member {string} ipAddress
                     * @memberof clutch.resolver.k8s.v1.IPAddress
                     * @instance
                     */
                    IPAddress.prototype.ipAddress = "";

                    /**
                     * Verifies a IPAddress message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.IPAddress
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    IPAddress.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                            if (!$util.isString(message.ipAddress))
                                return "ipAddress: string expected";
                        return null;
                    };

                    /**
                     * Creates a IPAddress message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.IPAddress
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.IPAddress} IPAddress
                     */
                    IPAddress.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.IPAddress)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.IPAddress();
                        if (object.ipAddress != null)
                            message.ipAddress = String(object.ipAddress);
                        return message;
                    };

                    /**
                     * Creates a plain object from a IPAddress message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.IPAddress
                     * @static
                     * @param {clutch.resolver.k8s.v1.IPAddress} message IPAddress
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    IPAddress.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.ipAddress = "";
                        if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                            object.ipAddress = message.ipAddress;
                        return object;
                    };

                    /**
                     * Converts this IPAddress to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.IPAddress
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    IPAddress.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return IPAddress;
                })();

                v1.HPAName = (function() {

                    /**
                     * Properties of a HPAName.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface IHPAName
                     * @property {string|null} [name] HPAName name
                     * @property {string|null} [clientset] HPAName clientset
                     * @property {string|null} [namespace] HPAName namespace
                     */

                    /**
                     * Constructs a new HPAName.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a HPAName.
                     * @implements IHPAName
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.IHPAName=} [properties] Properties to set
                     */
                    function HPAName(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * HPAName name.
                     * @member {string} name
                     * @memberof clutch.resolver.k8s.v1.HPAName
                     * @instance
                     */
                    HPAName.prototype.name = "";

                    /**
                     * HPAName clientset.
                     * @member {string} clientset
                     * @memberof clutch.resolver.k8s.v1.HPAName
                     * @instance
                     */
                    HPAName.prototype.clientset = "";

                    /**
                     * HPAName namespace.
                     * @member {string} namespace
                     * @memberof clutch.resolver.k8s.v1.HPAName
                     * @instance
                     */
                    HPAName.prototype.namespace = "";

                    /**
                     * Verifies a HPAName message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.HPAName
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    HPAName.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            if (!$util.isString(message.clientset))
                                return "clientset: string expected";
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            if (!$util.isString(message.namespace))
                                return "namespace: string expected";
                        return null;
                    };

                    /**
                     * Creates a HPAName message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.HPAName
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.HPAName} HPAName
                     */
                    HPAName.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.HPAName)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.HPAName();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.clientset != null)
                            message.clientset = String(object.clientset);
                        if (object.namespace != null)
                            message.namespace = String(object.namespace);
                        return message;
                    };

                    /**
                     * Creates a plain object from a HPAName message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.HPAName
                     * @static
                     * @param {clutch.resolver.k8s.v1.HPAName} message HPAName
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    HPAName.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.clientset = "";
                            object.namespace = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            object.clientset = message.clientset;
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            object.namespace = message.namespace;
                        return object;
                    };

                    /**
                     * Converts this HPAName to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.HPAName
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    HPAName.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return HPAName;
                })();

                v1.Deployment = (function() {

                    /**
                     * Properties of a Deployment.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface IDeployment
                     * @property {string|null} [name] Deployment name
                     * @property {string|null} [clientset] Deployment clientset
                     * @property {string|null} [namespace] Deployment namespace
                     */

                    /**
                     * Constructs a new Deployment.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a Deployment.
                     * @implements IDeployment
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.IDeployment=} [properties] Properties to set
                     */
                    function Deployment(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Deployment name.
                     * @member {string} name
                     * @memberof clutch.resolver.k8s.v1.Deployment
                     * @instance
                     */
                    Deployment.prototype.name = "";

                    /**
                     * Deployment clientset.
                     * @member {string} clientset
                     * @memberof clutch.resolver.k8s.v1.Deployment
                     * @instance
                     */
                    Deployment.prototype.clientset = "";

                    /**
                     * Deployment namespace.
                     * @member {string} namespace
                     * @memberof clutch.resolver.k8s.v1.Deployment
                     * @instance
                     */
                    Deployment.prototype.namespace = "";

                    /**
                     * Verifies a Deployment message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.Deployment
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Deployment.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            if (!$util.isString(message.clientset))
                                return "clientset: string expected";
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            if (!$util.isString(message.namespace))
                                return "namespace: string expected";
                        return null;
                    };

                    /**
                     * Creates a Deployment message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.Deployment
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.Deployment} Deployment
                     */
                    Deployment.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.Deployment)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.Deployment();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.clientset != null)
                            message.clientset = String(object.clientset);
                        if (object.namespace != null)
                            message.namespace = String(object.namespace);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Deployment message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.Deployment
                     * @static
                     * @param {clutch.resolver.k8s.v1.Deployment} message Deployment
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Deployment.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.clientset = "";
                            object.namespace = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            object.clientset = message.clientset;
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            object.namespace = message.namespace;
                        return object;
                    };

                    /**
                     * Converts this Deployment to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.Deployment
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Deployment.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Deployment;
                })();

                v1.StatefulSet = (function() {

                    /**
                     * Properties of a StatefulSet.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface IStatefulSet
                     * @property {string|null} [name] StatefulSet name
                     * @property {string|null} [clientset] StatefulSet clientset
                     * @property {string|null} [namespace] StatefulSet namespace
                     */

                    /**
                     * Constructs a new StatefulSet.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a StatefulSet.
                     * @implements IStatefulSet
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.IStatefulSet=} [properties] Properties to set
                     */
                    function StatefulSet(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * StatefulSet name.
                     * @member {string} name
                     * @memberof clutch.resolver.k8s.v1.StatefulSet
                     * @instance
                     */
                    StatefulSet.prototype.name = "";

                    /**
                     * StatefulSet clientset.
                     * @member {string} clientset
                     * @memberof clutch.resolver.k8s.v1.StatefulSet
                     * @instance
                     */
                    StatefulSet.prototype.clientset = "";

                    /**
                     * StatefulSet namespace.
                     * @member {string} namespace
                     * @memberof clutch.resolver.k8s.v1.StatefulSet
                     * @instance
                     */
                    StatefulSet.prototype.namespace = "";

                    /**
                     * Verifies a StatefulSet message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.StatefulSet
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    StatefulSet.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            if (!$util.isString(message.clientset))
                                return "clientset: string expected";
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            if (!$util.isString(message.namespace))
                                return "namespace: string expected";
                        return null;
                    };

                    /**
                     * Creates a StatefulSet message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.StatefulSet
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.StatefulSet} StatefulSet
                     */
                    StatefulSet.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.StatefulSet)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.StatefulSet();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.clientset != null)
                            message.clientset = String(object.clientset);
                        if (object.namespace != null)
                            message.namespace = String(object.namespace);
                        return message;
                    };

                    /**
                     * Creates a plain object from a StatefulSet message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.StatefulSet
                     * @static
                     * @param {clutch.resolver.k8s.v1.StatefulSet} message StatefulSet
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    StatefulSet.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.clientset = "";
                            object.namespace = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            object.clientset = message.clientset;
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            object.namespace = message.namespace;
                        return object;
                    };

                    /**
                     * Converts this StatefulSet to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.StatefulSet
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    StatefulSet.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return StatefulSet;
                })();

                v1.Service = (function() {

                    /**
                     * Properties of a Service.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface IService
                     * @property {string|null} [name] Service name
                     * @property {string|null} [clientset] Service clientset
                     * @property {string|null} [namespace] Service namespace
                     */

                    /**
                     * Constructs a new Service.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a Service.
                     * @implements IService
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.IService=} [properties] Properties to set
                     */
                    function Service(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Service name.
                     * @member {string} name
                     * @memberof clutch.resolver.k8s.v1.Service
                     * @instance
                     */
                    Service.prototype.name = "";

                    /**
                     * Service clientset.
                     * @member {string} clientset
                     * @memberof clutch.resolver.k8s.v1.Service
                     * @instance
                     */
                    Service.prototype.clientset = "";

                    /**
                     * Service namespace.
                     * @member {string} namespace
                     * @memberof clutch.resolver.k8s.v1.Service
                     * @instance
                     */
                    Service.prototype.namespace = "";

                    /**
                     * Verifies a Service message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.Service
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Service.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            if (!$util.isString(message.clientset))
                                return "clientset: string expected";
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            if (!$util.isString(message.namespace))
                                return "namespace: string expected";
                        return null;
                    };

                    /**
                     * Creates a Service message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.Service
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.Service} Service
                     */
                    Service.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.Service)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.Service();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.clientset != null)
                            message.clientset = String(object.clientset);
                        if (object.namespace != null)
                            message.namespace = String(object.namespace);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Service message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.Service
                     * @static
                     * @param {clutch.resolver.k8s.v1.Service} message Service
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Service.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.clientset = "";
                            object.namespace = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            object.clientset = message.clientset;
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            object.namespace = message.namespace;
                        return object;
                    };

                    /**
                     * Converts this Service to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.Service
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Service.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Service;
                })();

                v1.CronJob = (function() {

                    /**
                     * Properties of a CronJob.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface ICronJob
                     * @property {string|null} [name] CronJob name
                     * @property {string|null} [clientset] CronJob clientset
                     * @property {string|null} [namespace] CronJob namespace
                     */

                    /**
                     * Constructs a new CronJob.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a CronJob.
                     * @implements ICronJob
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.ICronJob=} [properties] Properties to set
                     */
                    function CronJob(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CronJob name.
                     * @member {string} name
                     * @memberof clutch.resolver.k8s.v1.CronJob
                     * @instance
                     */
                    CronJob.prototype.name = "";

                    /**
                     * CronJob clientset.
                     * @member {string} clientset
                     * @memberof clutch.resolver.k8s.v1.CronJob
                     * @instance
                     */
                    CronJob.prototype.clientset = "";

                    /**
                     * CronJob namespace.
                     * @member {string} namespace
                     * @memberof clutch.resolver.k8s.v1.CronJob
                     * @instance
                     */
                    CronJob.prototype.namespace = "";

                    /**
                     * Verifies a CronJob message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.CronJob
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CronJob.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            if (!$util.isString(message.clientset))
                                return "clientset: string expected";
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            if (!$util.isString(message.namespace))
                                return "namespace: string expected";
                        return null;
                    };

                    /**
                     * Creates a CronJob message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.CronJob
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.CronJob} CronJob
                     */
                    CronJob.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.CronJob)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.CronJob();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.clientset != null)
                            message.clientset = String(object.clientset);
                        if (object.namespace != null)
                            message.namespace = String(object.namespace);
                        return message;
                    };

                    /**
                     * Creates a plain object from a CronJob message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.CronJob
                     * @static
                     * @param {clutch.resolver.k8s.v1.CronJob} message CronJob
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CronJob.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.clientset = "";
                            object.namespace = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            object.clientset = message.clientset;
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            object.namespace = message.namespace;
                        return object;
                    };

                    /**
                     * Converts this CronJob to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.CronJob
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CronJob.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CronJob;
                })();

                v1.ConfigMap = (function() {

                    /**
                     * Properties of a ConfigMap.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface IConfigMap
                     * @property {string|null} [name] ConfigMap name
                     * @property {string|null} [clientset] ConfigMap clientset
                     * @property {string|null} [namespace] ConfigMap namespace
                     */

                    /**
                     * Constructs a new ConfigMap.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a ConfigMap.
                     * @implements IConfigMap
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.IConfigMap=} [properties] Properties to set
                     */
                    function ConfigMap(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ConfigMap name.
                     * @member {string} name
                     * @memberof clutch.resolver.k8s.v1.ConfigMap
                     * @instance
                     */
                    ConfigMap.prototype.name = "";

                    /**
                     * ConfigMap clientset.
                     * @member {string} clientset
                     * @memberof clutch.resolver.k8s.v1.ConfigMap
                     * @instance
                     */
                    ConfigMap.prototype.clientset = "";

                    /**
                     * ConfigMap namespace.
                     * @member {string} namespace
                     * @memberof clutch.resolver.k8s.v1.ConfigMap
                     * @instance
                     */
                    ConfigMap.prototype.namespace = "";

                    /**
                     * Verifies a ConfigMap message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.ConfigMap
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ConfigMap.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            if (!$util.isString(message.clientset))
                                return "clientset: string expected";
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            if (!$util.isString(message.namespace))
                                return "namespace: string expected";
                        return null;
                    };

                    /**
                     * Creates a ConfigMap message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.ConfigMap
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.ConfigMap} ConfigMap
                     */
                    ConfigMap.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.ConfigMap)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.ConfigMap();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.clientset != null)
                            message.clientset = String(object.clientset);
                        if (object.namespace != null)
                            message.namespace = String(object.namespace);
                        return message;
                    };

                    /**
                     * Creates a plain object from a ConfigMap message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.ConfigMap
                     * @static
                     * @param {clutch.resolver.k8s.v1.ConfigMap} message ConfigMap
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ConfigMap.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.clientset = "";
                            object.namespace = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            object.clientset = message.clientset;
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            object.namespace = message.namespace;
                        return object;
                    };

                    /**
                     * Converts this ConfigMap to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.ConfigMap
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ConfigMap.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ConfigMap;
                })();

                v1.Job = (function() {

                    /**
                     * Properties of a Job.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface IJob
                     * @property {string|null} [name] Job name
                     * @property {string|null} [clientset] Job clientset
                     * @property {string|null} [namespace] Job namespace
                     */

                    /**
                     * Constructs a new Job.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a Job.
                     * @implements IJob
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.IJob=} [properties] Properties to set
                     */
                    function Job(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Job name.
                     * @member {string} name
                     * @memberof clutch.resolver.k8s.v1.Job
                     * @instance
                     */
                    Job.prototype.name = "";

                    /**
                     * Job clientset.
                     * @member {string} clientset
                     * @memberof clutch.resolver.k8s.v1.Job
                     * @instance
                     */
                    Job.prototype.clientset = "";

                    /**
                     * Job namespace.
                     * @member {string} namespace
                     * @memberof clutch.resolver.k8s.v1.Job
                     * @instance
                     */
                    Job.prototype.namespace = "";

                    /**
                     * Verifies a Job message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.Job
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Job.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            if (!$util.isString(message.clientset))
                                return "clientset: string expected";
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            if (!$util.isString(message.namespace))
                                return "namespace: string expected";
                        return null;
                    };

                    /**
                     * Creates a Job message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.Job
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.Job} Job
                     */
                    Job.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.Job)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.Job();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.clientset != null)
                            message.clientset = String(object.clientset);
                        if (object.namespace != null)
                            message.namespace = String(object.namespace);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Job message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.Job
                     * @static
                     * @param {clutch.resolver.k8s.v1.Job} message Job
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Job.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.clientset = "";
                            object.namespace = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            object.clientset = message.clientset;
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            object.namespace = message.namespace;
                        return object;
                    };

                    /**
                     * Converts this Job to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.Job
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Job.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Job;
                })();

                v1.Namespace = (function() {

                    /**
                     * Properties of a Namespace.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface INamespace
                     * @property {string|null} [name] Namespace name
                     * @property {string|null} [clientset] Namespace clientset
                     */

                    /**
                     * Constructs a new Namespace.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a Namespace.
                     * @implements INamespace
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.INamespace=} [properties] Properties to set
                     */
                    function Namespace(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Namespace name.
                     * @member {string} name
                     * @memberof clutch.resolver.k8s.v1.Namespace
                     * @instance
                     */
                    Namespace.prototype.name = "";

                    /**
                     * Namespace clientset.
                     * @member {string} clientset
                     * @memberof clutch.resolver.k8s.v1.Namespace
                     * @instance
                     */
                    Namespace.prototype.clientset = "";

                    /**
                     * Verifies a Namespace message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.Namespace
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Namespace.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            if (!$util.isString(message.clientset))
                                return "clientset: string expected";
                        return null;
                    };

                    /**
                     * Creates a Namespace message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.Namespace
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.Namespace} Namespace
                     */
                    Namespace.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.Namespace)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.Namespace();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.clientset != null)
                            message.clientset = String(object.clientset);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Namespace message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.Namespace
                     * @static
                     * @param {clutch.resolver.k8s.v1.Namespace} message Namespace
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Namespace.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.clientset = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            object.clientset = message.clientset;
                        return object;
                    };

                    /**
                     * Converts this Namespace to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.Namespace
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Namespace.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Namespace;
                })();

                v1.Node = (function() {

                    /**
                     * Properties of a Node.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface INode
                     * @property {string|null} [name] Node name
                     * @property {string|null} [cluster] Node cluster
                     * @property {string|null} [clientset] Node clientset
                     */

                    /**
                     * Constructs a new Node.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a Node.
                     * @implements INode
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.INode=} [properties] Properties to set
                     */
                    function Node(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Node name.
                     * @member {string} name
                     * @memberof clutch.resolver.k8s.v1.Node
                     * @instance
                     */
                    Node.prototype.name = "";

                    /**
                     * Node cluster.
                     * @member {string} cluster
                     * @memberof clutch.resolver.k8s.v1.Node
                     * @instance
                     */
                    Node.prototype.cluster = "";

                    /**
                     * Node clientset.
                     * @member {string} clientset
                     * @memberof clutch.resolver.k8s.v1.Node
                     * @instance
                     */
                    Node.prototype.clientset = "";

                    /**
                     * Verifies a Node message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.Node
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Node.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.cluster != null && message.hasOwnProperty("cluster"))
                            if (!$util.isString(message.cluster))
                                return "cluster: string expected";
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            if (!$util.isString(message.clientset))
                                return "clientset: string expected";
                        return null;
                    };

                    /**
                     * Creates a Node message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.Node
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.Node} Node
                     */
                    Node.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.Node)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.Node();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.cluster != null)
                            message.cluster = String(object.cluster);
                        if (object.clientset != null)
                            message.clientset = String(object.clientset);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Node message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.Node
                     * @static
                     * @param {clutch.resolver.k8s.v1.Node} message Node
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Node.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.cluster = "";
                            object.clientset = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.cluster != null && message.hasOwnProperty("cluster"))
                            object.cluster = message.cluster;
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            object.clientset = message.clientset;
                        return object;
                    };

                    /**
                     * Converts this Node to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.Node
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Node.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Node;
                })();

                return v1;
            })();

            return k8s;
        })();

        return resolver;
    })();

    clutch.shortlink = (function() {

        /**
         * Namespace shortlink.
         * @memberof clutch
         * @namespace
         */
        const shortlink = {};

        shortlink.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.shortlink
             * @namespace
             */
            const v1 = {};

            v1.ShortlinkAPI = (function() {

                /**
                 * Constructs a new ShortlinkAPI service.
                 * @memberof clutch.shortlink.v1
                 * @classdesc Represents a ShortlinkAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function ShortlinkAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (ShortlinkAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ShortlinkAPI;

                /**
                 * Callback as used by {@link clutch.shortlink.v1.ShortlinkAPI#create}.
                 * @memberof clutch.shortlink.v1.ShortlinkAPI
                 * @typedef CreateCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.shortlink.v1.CreateResponse} [response] CreateResponse
                 */

                /**
                 * Calls Create.
                 * @function create
                 * @memberof clutch.shortlink.v1.ShortlinkAPI
                 * @instance
                 * @param {clutch.shortlink.v1.ICreateRequest} request CreateRequest message or plain object
                 * @param {clutch.shortlink.v1.ShortlinkAPI.CreateCallback} callback Node-style callback called with the error, if any, and CreateResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ShortlinkAPI.prototype.create = function create(request, callback) {
                    return this.rpcCall(create, $root.clutch.shortlink.v1.CreateRequest, $root.clutch.shortlink.v1.CreateResponse, request, callback);
                }, "name", { value: "Create" });

                /**
                 * Calls Create.
                 * @function create
                 * @memberof clutch.shortlink.v1.ShortlinkAPI
                 * @instance
                 * @param {clutch.shortlink.v1.ICreateRequest} request CreateRequest message or plain object
                 * @returns {Promise<clutch.shortlink.v1.CreateResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.shortlink.v1.ShortlinkAPI#get}.
                 * @memberof clutch.shortlink.v1.ShortlinkAPI
                 * @typedef GetCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.shortlink.v1.GetResponse} [response] GetResponse
                 */

                /**
                 * Calls Get.
                 * @function get
                 * @memberof clutch.shortlink.v1.ShortlinkAPI
                 * @instance
                 * @param {clutch.shortlink.v1.IGetRequest} request GetRequest message or plain object
                 * @param {clutch.shortlink.v1.ShortlinkAPI.GetCallback} callback Node-style callback called with the error, if any, and GetResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ShortlinkAPI.prototype.get = function get(request, callback) {
                    return this.rpcCall(get, $root.clutch.shortlink.v1.GetRequest, $root.clutch.shortlink.v1.GetResponse, request, callback);
                }, "name", { value: "Get" });

                /**
                 * Calls Get.
                 * @function get
                 * @memberof clutch.shortlink.v1.ShortlinkAPI
                 * @instance
                 * @param {clutch.shortlink.v1.IGetRequest} request GetRequest message or plain object
                 * @returns {Promise<clutch.shortlink.v1.GetResponse>} Promise
                 * @variation 2
                 */

                return ShortlinkAPI;
            })();

            v1.CreateRequest = (function() {

                /**
                 * Properties of a CreateRequest.
                 * @memberof clutch.shortlink.v1
                 * @interface ICreateRequest
                 * @property {string|null} [path] CreateRequest path
                 * @property {Array.<clutch.shortlink.v1.IShareableState>|null} [state] CreateRequest state
                 */

                /**
                 * Constructs a new CreateRequest.
                 * @memberof clutch.shortlink.v1
                 * @classdesc Represents a CreateRequest.
                 * @implements ICreateRequest
                 * @constructor
                 * @param {clutch.shortlink.v1.ICreateRequest=} [properties] Properties to set
                 */
                function CreateRequest(properties) {
                    this.state = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateRequest path.
                 * @member {string} path
                 * @memberof clutch.shortlink.v1.CreateRequest
                 * @instance
                 */
                CreateRequest.prototype.path = "";

                /**
                 * CreateRequest state.
                 * @member {Array.<clutch.shortlink.v1.IShareableState>} state
                 * @memberof clutch.shortlink.v1.CreateRequest
                 * @instance
                 */
                CreateRequest.prototype.state = $util.emptyArray;

                /**
                 * Verifies a CreateRequest message.
                 * @function verify
                 * @memberof clutch.shortlink.v1.CreateRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path"))
                        if (!$util.isString(message.path))
                            return "path: string expected";
                    if (message.state != null && message.hasOwnProperty("state")) {
                        if (!Array.isArray(message.state))
                            return "state: array expected";
                        for (let i = 0; i < message.state.length; ++i) {
                            let error = $root.clutch.shortlink.v1.ShareableState.verify(message.state[i]);
                            if (error)
                                return "state." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a CreateRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.shortlink.v1.CreateRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.shortlink.v1.CreateRequest} CreateRequest
                 */
                CreateRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.shortlink.v1.CreateRequest)
                        return object;
                    let message = new $root.clutch.shortlink.v1.CreateRequest();
                    if (object.path != null)
                        message.path = String(object.path);
                    if (object.state) {
                        if (!Array.isArray(object.state))
                            throw TypeError(".clutch.shortlink.v1.CreateRequest.state: array expected");
                        message.state = [];
                        for (let i = 0; i < object.state.length; ++i) {
                            if (typeof object.state[i] !== "object")
                                throw TypeError(".clutch.shortlink.v1.CreateRequest.state: object expected");
                            message.state[i] = $root.clutch.shortlink.v1.ShareableState.fromObject(object.state[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.shortlink.v1.CreateRequest
                 * @static
                 * @param {clutch.shortlink.v1.CreateRequest} message CreateRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.state = [];
                    if (options.defaults)
                        object.path = "";
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = message.path;
                    if (message.state && message.state.length) {
                        object.state = [];
                        for (let j = 0; j < message.state.length; ++j)
                            object.state[j] = $root.clutch.shortlink.v1.ShareableState.toObject(message.state[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this CreateRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.shortlink.v1.CreateRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateRequest;
            })();

            v1.CreateResponse = (function() {

                /**
                 * Properties of a CreateResponse.
                 * @memberof clutch.shortlink.v1
                 * @interface ICreateResponse
                 * @property {string|null} [hash] CreateResponse hash
                 */

                /**
                 * Constructs a new CreateResponse.
                 * @memberof clutch.shortlink.v1
                 * @classdesc Represents a CreateResponse.
                 * @implements ICreateResponse
                 * @constructor
                 * @param {clutch.shortlink.v1.ICreateResponse=} [properties] Properties to set
                 */
                function CreateResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateResponse hash.
                 * @member {string} hash
                 * @memberof clutch.shortlink.v1.CreateResponse
                 * @instance
                 */
                CreateResponse.prototype.hash = "";

                /**
                 * Verifies a CreateResponse message.
                 * @function verify
                 * @memberof clutch.shortlink.v1.CreateResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.hash != null && message.hasOwnProperty("hash"))
                        if (!$util.isString(message.hash))
                            return "hash: string expected";
                    return null;
                };

                /**
                 * Creates a CreateResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.shortlink.v1.CreateResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.shortlink.v1.CreateResponse} CreateResponse
                 */
                CreateResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.shortlink.v1.CreateResponse)
                        return object;
                    let message = new $root.clutch.shortlink.v1.CreateResponse();
                    if (object.hash != null)
                        message.hash = String(object.hash);
                    return message;
                };

                /**
                 * Creates a plain object from a CreateResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.shortlink.v1.CreateResponse
                 * @static
                 * @param {clutch.shortlink.v1.CreateResponse} message CreateResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.hash = "";
                    if (message.hash != null && message.hasOwnProperty("hash"))
                        object.hash = message.hash;
                    return object;
                };

                /**
                 * Converts this CreateResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.shortlink.v1.CreateResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateResponse;
            })();

            v1.GetRequest = (function() {

                /**
                 * Properties of a GetRequest.
                 * @memberof clutch.shortlink.v1
                 * @interface IGetRequest
                 * @property {string|null} [hash] GetRequest hash
                 */

                /**
                 * Constructs a new GetRequest.
                 * @memberof clutch.shortlink.v1
                 * @classdesc Represents a GetRequest.
                 * @implements IGetRequest
                 * @constructor
                 * @param {clutch.shortlink.v1.IGetRequest=} [properties] Properties to set
                 */
                function GetRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetRequest hash.
                 * @member {string} hash
                 * @memberof clutch.shortlink.v1.GetRequest
                 * @instance
                 */
                GetRequest.prototype.hash = "";

                /**
                 * Verifies a GetRequest message.
                 * @function verify
                 * @memberof clutch.shortlink.v1.GetRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.hash != null && message.hasOwnProperty("hash"))
                        if (!$util.isString(message.hash))
                            return "hash: string expected";
                    return null;
                };

                /**
                 * Creates a GetRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.shortlink.v1.GetRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.shortlink.v1.GetRequest} GetRequest
                 */
                GetRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.shortlink.v1.GetRequest)
                        return object;
                    let message = new $root.clutch.shortlink.v1.GetRequest();
                    if (object.hash != null)
                        message.hash = String(object.hash);
                    return message;
                };

                /**
                 * Creates a plain object from a GetRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.shortlink.v1.GetRequest
                 * @static
                 * @param {clutch.shortlink.v1.GetRequest} message GetRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.hash = "";
                    if (message.hash != null && message.hasOwnProperty("hash"))
                        object.hash = message.hash;
                    return object;
                };

                /**
                 * Converts this GetRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.shortlink.v1.GetRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetRequest;
            })();

            v1.GetResponse = (function() {

                /**
                 * Properties of a GetResponse.
                 * @memberof clutch.shortlink.v1
                 * @interface IGetResponse
                 * @property {string|null} [path] GetResponse path
                 * @property {Array.<clutch.shortlink.v1.IShareableState>|null} [state] GetResponse state
                 */

                /**
                 * Constructs a new GetResponse.
                 * @memberof clutch.shortlink.v1
                 * @classdesc Represents a GetResponse.
                 * @implements IGetResponse
                 * @constructor
                 * @param {clutch.shortlink.v1.IGetResponse=} [properties] Properties to set
                 */
                function GetResponse(properties) {
                    this.state = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetResponse path.
                 * @member {string} path
                 * @memberof clutch.shortlink.v1.GetResponse
                 * @instance
                 */
                GetResponse.prototype.path = "";

                /**
                 * GetResponse state.
                 * @member {Array.<clutch.shortlink.v1.IShareableState>} state
                 * @memberof clutch.shortlink.v1.GetResponse
                 * @instance
                 */
                GetResponse.prototype.state = $util.emptyArray;

                /**
                 * Verifies a GetResponse message.
                 * @function verify
                 * @memberof clutch.shortlink.v1.GetResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path"))
                        if (!$util.isString(message.path))
                            return "path: string expected";
                    if (message.state != null && message.hasOwnProperty("state")) {
                        if (!Array.isArray(message.state))
                            return "state: array expected";
                        for (let i = 0; i < message.state.length; ++i) {
                            let error = $root.clutch.shortlink.v1.ShareableState.verify(message.state[i]);
                            if (error)
                                return "state." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.shortlink.v1.GetResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.shortlink.v1.GetResponse} GetResponse
                 */
                GetResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.shortlink.v1.GetResponse)
                        return object;
                    let message = new $root.clutch.shortlink.v1.GetResponse();
                    if (object.path != null)
                        message.path = String(object.path);
                    if (object.state) {
                        if (!Array.isArray(object.state))
                            throw TypeError(".clutch.shortlink.v1.GetResponse.state: array expected");
                        message.state = [];
                        for (let i = 0; i < object.state.length; ++i) {
                            if (typeof object.state[i] !== "object")
                                throw TypeError(".clutch.shortlink.v1.GetResponse.state: object expected");
                            message.state[i] = $root.clutch.shortlink.v1.ShareableState.fromObject(object.state[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.shortlink.v1.GetResponse
                 * @static
                 * @param {clutch.shortlink.v1.GetResponse} message GetResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.state = [];
                    if (options.defaults)
                        object.path = "";
                    if (message.path != null && message.hasOwnProperty("path"))
                        object.path = message.path;
                    if (message.state && message.state.length) {
                        object.state = [];
                        for (let j = 0; j < message.state.length; ++j)
                            object.state[j] = $root.clutch.shortlink.v1.ShareableState.toObject(message.state[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.shortlink.v1.GetResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetResponse;
            })();

            v1.ShareableState = (function() {

                /**
                 * Properties of a ShareableState.
                 * @memberof clutch.shortlink.v1
                 * @interface IShareableState
                 * @property {string|null} [key] ShareableState key
                 * @property {google.protobuf.IValue|null} [state] ShareableState state
                 */

                /**
                 * Constructs a new ShareableState.
                 * @memberof clutch.shortlink.v1
                 * @classdesc Represents a ShareableState.
                 * @implements IShareableState
                 * @constructor
                 * @param {clutch.shortlink.v1.IShareableState=} [properties] Properties to set
                 */
                function ShareableState(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ShareableState key.
                 * @member {string} key
                 * @memberof clutch.shortlink.v1.ShareableState
                 * @instance
                 */
                ShareableState.prototype.key = "";

                /**
                 * ShareableState state.
                 * @member {google.protobuf.IValue|null|undefined} state
                 * @memberof clutch.shortlink.v1.ShareableState
                 * @instance
                 */
                ShareableState.prototype.state = null;

                /**
                 * Verifies a ShareableState message.
                 * @function verify
                 * @memberof clutch.shortlink.v1.ShareableState
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ShareableState.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.key != null && message.hasOwnProperty("key"))
                        if (!$util.isString(message.key))
                            return "key: string expected";
                    if (message.state != null && message.hasOwnProperty("state")) {
                        let error = $root.google.protobuf.Value.verify(message.state);
                        if (error)
                            return "state." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ShareableState message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.shortlink.v1.ShareableState
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.shortlink.v1.ShareableState} ShareableState
                 */
                ShareableState.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.shortlink.v1.ShareableState)
                        return object;
                    let message = new $root.clutch.shortlink.v1.ShareableState();
                    if (object.key != null)
                        message.key = String(object.key);
                    if (object.state != null) {
                        if (typeof object.state !== "object")
                            throw TypeError(".clutch.shortlink.v1.ShareableState.state: object expected");
                        message.state = $root.google.protobuf.Value.fromObject(object.state);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ShareableState message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.shortlink.v1.ShareableState
                 * @static
                 * @param {clutch.shortlink.v1.ShareableState} message ShareableState
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ShareableState.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.key = "";
                        object.state = null;
                    }
                    if (message.key != null && message.hasOwnProperty("key"))
                        object.key = message.key;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = $root.google.protobuf.Value.toObject(message.state, options);
                    return object;
                };

                /**
                 * Converts this ShareableState to JSON.
                 * @function toJSON
                 * @memberof clutch.shortlink.v1.ShareableState
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ShareableState.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ShareableState;
            })();

            return v1;
        })();

        return shortlink;
    })();

    clutch.sourcegraph = (function() {

        /**
         * Namespace sourcegraph.
         * @memberof clutch
         * @namespace
         */
        const sourcegraph = {};

        sourcegraph.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.sourcegraph
             * @namespace
             */
            const v1 = {};

            v1.CompareCommitsRequest = (function() {

                /**
                 * Properties of a CompareCommitsRequest.
                 * @memberof clutch.sourcegraph.v1
                 * @interface ICompareCommitsRequest
                 * @property {string|null} [repository] CompareCommitsRequest repository
                 * @property {string|null} [base] CompareCommitsRequest base
                 * @property {string|null} [head] CompareCommitsRequest head
                 */

                /**
                 * Constructs a new CompareCommitsRequest.
                 * @memberof clutch.sourcegraph.v1
                 * @classdesc Represents a CompareCommitsRequest.
                 * @implements ICompareCommitsRequest
                 * @constructor
                 * @param {clutch.sourcegraph.v1.ICompareCommitsRequest=} [properties] Properties to set
                 */
                function CompareCommitsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CompareCommitsRequest repository.
                 * @member {string} repository
                 * @memberof clutch.sourcegraph.v1.CompareCommitsRequest
                 * @instance
                 */
                CompareCommitsRequest.prototype.repository = "";

                /**
                 * CompareCommitsRequest base.
                 * @member {string} base
                 * @memberof clutch.sourcegraph.v1.CompareCommitsRequest
                 * @instance
                 */
                CompareCommitsRequest.prototype.base = "";

                /**
                 * CompareCommitsRequest head.
                 * @member {string} head
                 * @memberof clutch.sourcegraph.v1.CompareCommitsRequest
                 * @instance
                 */
                CompareCommitsRequest.prototype.head = "";

                /**
                 * Verifies a CompareCommitsRequest message.
                 * @function verify
                 * @memberof clutch.sourcegraph.v1.CompareCommitsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CompareCommitsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.repository != null && message.hasOwnProperty("repository"))
                        if (!$util.isString(message.repository))
                            return "repository: string expected";
                    if (message.base != null && message.hasOwnProperty("base"))
                        if (!$util.isString(message.base))
                            return "base: string expected";
                    if (message.head != null && message.hasOwnProperty("head"))
                        if (!$util.isString(message.head))
                            return "head: string expected";
                    return null;
                };

                /**
                 * Creates a CompareCommitsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.sourcegraph.v1.CompareCommitsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.sourcegraph.v1.CompareCommitsRequest} CompareCommitsRequest
                 */
                CompareCommitsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.sourcegraph.v1.CompareCommitsRequest)
                        return object;
                    let message = new $root.clutch.sourcegraph.v1.CompareCommitsRequest();
                    if (object.repository != null)
                        message.repository = String(object.repository);
                    if (object.base != null)
                        message.base = String(object.base);
                    if (object.head != null)
                        message.head = String(object.head);
                    return message;
                };

                /**
                 * Creates a plain object from a CompareCommitsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.sourcegraph.v1.CompareCommitsRequest
                 * @static
                 * @param {clutch.sourcegraph.v1.CompareCommitsRequest} message CompareCommitsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CompareCommitsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.repository = "";
                        object.base = "";
                        object.head = "";
                    }
                    if (message.repository != null && message.hasOwnProperty("repository"))
                        object.repository = message.repository;
                    if (message.base != null && message.hasOwnProperty("base"))
                        object.base = message.base;
                    if (message.head != null && message.hasOwnProperty("head"))
                        object.head = message.head;
                    return object;
                };

                /**
                 * Converts this CompareCommitsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.sourcegraph.v1.CompareCommitsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CompareCommitsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CompareCommitsRequest;
            })();

            v1.CompareCommitsResponse = (function() {

                /**
                 * Properties of a CompareCommitsResponse.
                 * @memberof clutch.sourcegraph.v1
                 * @interface ICompareCommitsResponse
                 * @property {Array.<clutch.sourcegraph.v1.ICommit>|null} [commits] CompareCommitsResponse commits
                 */

                /**
                 * Constructs a new CompareCommitsResponse.
                 * @memberof clutch.sourcegraph.v1
                 * @classdesc Represents a CompareCommitsResponse.
                 * @implements ICompareCommitsResponse
                 * @constructor
                 * @param {clutch.sourcegraph.v1.ICompareCommitsResponse=} [properties] Properties to set
                 */
                function CompareCommitsResponse(properties) {
                    this.commits = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CompareCommitsResponse commits.
                 * @member {Array.<clutch.sourcegraph.v1.ICommit>} commits
                 * @memberof clutch.sourcegraph.v1.CompareCommitsResponse
                 * @instance
                 */
                CompareCommitsResponse.prototype.commits = $util.emptyArray;

                /**
                 * Verifies a CompareCommitsResponse message.
                 * @function verify
                 * @memberof clutch.sourcegraph.v1.CompareCommitsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CompareCommitsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.commits != null && message.hasOwnProperty("commits")) {
                        if (!Array.isArray(message.commits))
                            return "commits: array expected";
                        for (let i = 0; i < message.commits.length; ++i) {
                            let error = $root.clutch.sourcegraph.v1.Commit.verify(message.commits[i]);
                            if (error)
                                return "commits." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a CompareCommitsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.sourcegraph.v1.CompareCommitsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.sourcegraph.v1.CompareCommitsResponse} CompareCommitsResponse
                 */
                CompareCommitsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.sourcegraph.v1.CompareCommitsResponse)
                        return object;
                    let message = new $root.clutch.sourcegraph.v1.CompareCommitsResponse();
                    if (object.commits) {
                        if (!Array.isArray(object.commits))
                            throw TypeError(".clutch.sourcegraph.v1.CompareCommitsResponse.commits: array expected");
                        message.commits = [];
                        for (let i = 0; i < object.commits.length; ++i) {
                            if (typeof object.commits[i] !== "object")
                                throw TypeError(".clutch.sourcegraph.v1.CompareCommitsResponse.commits: object expected");
                            message.commits[i] = $root.clutch.sourcegraph.v1.Commit.fromObject(object.commits[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CompareCommitsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.sourcegraph.v1.CompareCommitsResponse
                 * @static
                 * @param {clutch.sourcegraph.v1.CompareCommitsResponse} message CompareCommitsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CompareCommitsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.commits = [];
                    if (message.commits && message.commits.length) {
                        object.commits = [];
                        for (let j = 0; j < message.commits.length; ++j)
                            object.commits[j] = $root.clutch.sourcegraph.v1.Commit.toObject(message.commits[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this CompareCommitsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.sourcegraph.v1.CompareCommitsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CompareCommitsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CompareCommitsResponse;
            })();

            v1.Commit = (function() {

                /**
                 * Properties of a Commit.
                 * @memberof clutch.sourcegraph.v1
                 * @interface ICommit
                 * @property {string|null} [oid] Commit oid
                 * @property {string|null} [email] Commit email
                 * @property {string|null} [message] Commit message
                 * @property {string|null} [displayName] Commit displayName
                 */

                /**
                 * Constructs a new Commit.
                 * @memberof clutch.sourcegraph.v1
                 * @classdesc Represents a Commit.
                 * @implements ICommit
                 * @constructor
                 * @param {clutch.sourcegraph.v1.ICommit=} [properties] Properties to set
                 */
                function Commit(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Commit oid.
                 * @member {string} oid
                 * @memberof clutch.sourcegraph.v1.Commit
                 * @instance
                 */
                Commit.prototype.oid = "";

                /**
                 * Commit email.
                 * @member {string} email
                 * @memberof clutch.sourcegraph.v1.Commit
                 * @instance
                 */
                Commit.prototype.email = "";

                /**
                 * Commit message.
                 * @member {string} message
                 * @memberof clutch.sourcegraph.v1.Commit
                 * @instance
                 */
                Commit.prototype.message = "";

                /**
                 * Commit displayName.
                 * @member {string} displayName
                 * @memberof clutch.sourcegraph.v1.Commit
                 * @instance
                 */
                Commit.prototype.displayName = "";

                /**
                 * Verifies a Commit message.
                 * @function verify
                 * @memberof clutch.sourcegraph.v1.Commit
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Commit.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.oid != null && message.hasOwnProperty("oid"))
                        if (!$util.isString(message.oid))
                            return "oid: string expected";
                    if (message.email != null && message.hasOwnProperty("email"))
                        if (!$util.isString(message.email))
                            return "email: string expected";
                    if (message.message != null && message.hasOwnProperty("message"))
                        if (!$util.isString(message.message))
                            return "message: string expected";
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        if (!$util.isString(message.displayName))
                            return "displayName: string expected";
                    return null;
                };

                /**
                 * Creates a Commit message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.sourcegraph.v1.Commit
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.sourcegraph.v1.Commit} Commit
                 */
                Commit.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.sourcegraph.v1.Commit)
                        return object;
                    let message = new $root.clutch.sourcegraph.v1.Commit();
                    if (object.oid != null)
                        message.oid = String(object.oid);
                    if (object.email != null)
                        message.email = String(object.email);
                    if (object.message != null)
                        message.message = String(object.message);
                    if (object.displayName != null)
                        message.displayName = String(object.displayName);
                    return message;
                };

                /**
                 * Creates a plain object from a Commit message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.sourcegraph.v1.Commit
                 * @static
                 * @param {clutch.sourcegraph.v1.Commit} message Commit
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Commit.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.oid = "";
                        object.email = "";
                        object.message = "";
                        object.displayName = "";
                    }
                    if (message.oid != null && message.hasOwnProperty("oid"))
                        object.oid = message.oid;
                    if (message.email != null && message.hasOwnProperty("email"))
                        object.email = message.email;
                    if (message.message != null && message.hasOwnProperty("message"))
                        object.message = message.message;
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        object.displayName = message.displayName;
                    return object;
                };

                /**
                 * Converts this Commit to JSON.
                 * @function toJSON
                 * @memberof clutch.sourcegraph.v1.Commit
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Commit.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Commit;
            })();

            return v1;
        })();

        return sourcegraph;
    })();

    clutch.timeseries = (function() {

        /**
         * Namespace timeseries.
         * @memberof clutch
         * @namespace
         */
        const timeseries = {};

        timeseries.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.timeseries
             * @namespace
             */
            const v1 = {};

            v1.TimeRange = (function() {

                /**
                 * Properties of a TimeRange.
                 * @memberof clutch.timeseries.v1
                 * @interface ITimeRange
                 * @property {number|Long|null} [startMillis] TimeRange startMillis
                 * @property {number|Long|null} [endMillis] TimeRange endMillis
                 */

                /**
                 * Constructs a new TimeRange.
                 * @memberof clutch.timeseries.v1
                 * @classdesc Represents a TimeRange.
                 * @implements ITimeRange
                 * @constructor
                 * @param {clutch.timeseries.v1.ITimeRange=} [properties] Properties to set
                 */
                function TimeRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TimeRange startMillis.
                 * @member {number|Long} startMillis
                 * @memberof clutch.timeseries.v1.TimeRange
                 * @instance
                 */
                TimeRange.prototype.startMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * TimeRange endMillis.
                 * @member {number|Long} endMillis
                 * @memberof clutch.timeseries.v1.TimeRange
                 * @instance
                 */
                TimeRange.prototype.endMillis = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                /**
                 * Verifies a TimeRange message.
                 * @function verify
                 * @memberof clutch.timeseries.v1.TimeRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TimeRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.startMillis != null && message.hasOwnProperty("startMillis"))
                        if (!$util.isInteger(message.startMillis) && !(message.startMillis && $util.isInteger(message.startMillis.low) && $util.isInteger(message.startMillis.high)))
                            return "startMillis: integer|Long expected";
                    if (message.endMillis != null && message.hasOwnProperty("endMillis"))
                        if (!$util.isInteger(message.endMillis) && !(message.endMillis && $util.isInteger(message.endMillis.low) && $util.isInteger(message.endMillis.high)))
                            return "endMillis: integer|Long expected";
                    return null;
                };

                /**
                 * Creates a TimeRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.timeseries.v1.TimeRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.timeseries.v1.TimeRange} TimeRange
                 */
                TimeRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.timeseries.v1.TimeRange)
                        return object;
                    let message = new $root.clutch.timeseries.v1.TimeRange();
                    if (object.startMillis != null)
                        if ($util.Long)
                            (message.startMillis = $util.Long.fromValue(object.startMillis)).unsigned = false;
                        else if (typeof object.startMillis === "string")
                            message.startMillis = parseInt(object.startMillis, 10);
                        else if (typeof object.startMillis === "number")
                            message.startMillis = object.startMillis;
                        else if (typeof object.startMillis === "object")
                            message.startMillis = new $util.LongBits(object.startMillis.low >>> 0, object.startMillis.high >>> 0).toNumber();
                    if (object.endMillis != null)
                        if ($util.Long)
                            (message.endMillis = $util.Long.fromValue(object.endMillis)).unsigned = false;
                        else if (typeof object.endMillis === "string")
                            message.endMillis = parseInt(object.endMillis, 10);
                        else if (typeof object.endMillis === "number")
                            message.endMillis = object.endMillis;
                        else if (typeof object.endMillis === "object")
                            message.endMillis = new $util.LongBits(object.endMillis.low >>> 0, object.endMillis.high >>> 0).toNumber();
                    return message;
                };

                /**
                 * Creates a plain object from a TimeRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.timeseries.v1.TimeRange
                 * @static
                 * @param {clutch.timeseries.v1.TimeRange} message TimeRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TimeRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.startMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.startMillis = options.longs === String ? "0" : 0;
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, false);
                            object.endMillis = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.endMillis = options.longs === String ? "0" : 0;
                    }
                    if (message.startMillis != null && message.hasOwnProperty("startMillis"))
                        if (typeof message.startMillis === "number")
                            object.startMillis = options.longs === String ? String(message.startMillis) : message.startMillis;
                        else
                            object.startMillis = options.longs === String ? $util.Long.prototype.toString.call(message.startMillis) : options.longs === Number ? new $util.LongBits(message.startMillis.low >>> 0, message.startMillis.high >>> 0).toNumber() : message.startMillis;
                    if (message.endMillis != null && message.hasOwnProperty("endMillis"))
                        if (typeof message.endMillis === "number")
                            object.endMillis = options.longs === String ? String(message.endMillis) : message.endMillis;
                        else
                            object.endMillis = options.longs === String ? $util.Long.prototype.toString.call(message.endMillis) : options.longs === Number ? new $util.LongBits(message.endMillis.low >>> 0, message.endMillis.high >>> 0).toNumber() : message.endMillis;
                    return object;
                };

                /**
                 * Converts this TimeRange to JSON.
                 * @function toJSON
                 * @memberof clutch.timeseries.v1.TimeRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TimeRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TimeRange;
            })();

            v1.Point = (function() {

                /**
                 * Properties of a Point.
                 * @memberof clutch.timeseries.v1
                 * @interface IPoint
                 * @property {clutch.timeseries.v1.ITimeRange|null} [range] Point range
                 * @property {number|Long|null} [millis] Point millis
                 * @property {google.protobuf.IAny|null} [pb] Point pb
                 * @property {string|null} [description] Point description
                 * @property {string|null} [href] Point href
                 */

                /**
                 * Constructs a new Point.
                 * @memberof clutch.timeseries.v1
                 * @classdesc Represents a Point.
                 * @implements IPoint
                 * @constructor
                 * @param {clutch.timeseries.v1.IPoint=} [properties] Properties to set
                 */
                function Point(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Point range.
                 * @member {clutch.timeseries.v1.ITimeRange|null|undefined} range
                 * @memberof clutch.timeseries.v1.Point
                 * @instance
                 */
                Point.prototype.range = null;

                /**
                 * Point millis.
                 * @member {number|Long|null|undefined} millis
                 * @memberof clutch.timeseries.v1.Point
                 * @instance
                 */
                Point.prototype.millis = null;

                /**
                 * Point pb.
                 * @member {google.protobuf.IAny|null|undefined} pb
                 * @memberof clutch.timeseries.v1.Point
                 * @instance
                 */
                Point.prototype.pb = null;

                /**
                 * Point description.
                 * @member {string} description
                 * @memberof clutch.timeseries.v1.Point
                 * @instance
                 */
                Point.prototype.description = "";

                /**
                 * Point href.
                 * @member {string} href
                 * @memberof clutch.timeseries.v1.Point
                 * @instance
                 */
                Point.prototype.href = "";

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Point timestamp.
                 * @member {"range"|"millis"|undefined} timestamp
                 * @memberof clutch.timeseries.v1.Point
                 * @instance
                 */
                Object.defineProperty(Point.prototype, "timestamp", {
                    get: $util.oneOfGetter($oneOfFields = ["range", "millis"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies a Point message.
                 * @function verify
                 * @memberof clutch.timeseries.v1.Point
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Point.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.range != null && message.hasOwnProperty("range")) {
                        properties.timestamp = 1;
                        {
                            let error = $root.clutch.timeseries.v1.TimeRange.verify(message.range);
                            if (error)
                                return "range." + error;
                        }
                    }
                    if (message.millis != null && message.hasOwnProperty("millis")) {
                        if (properties.timestamp === 1)
                            return "timestamp: multiple values";
                        properties.timestamp = 1;
                        if (!$util.isInteger(message.millis) && !(message.millis && $util.isInteger(message.millis.low) && $util.isInteger(message.millis.high)))
                            return "millis: integer|Long expected";
                    }
                    if (message.pb != null && message.hasOwnProperty("pb")) {
                        let error = $root.google.protobuf.Any.verify(message.pb);
                        if (error)
                            return "pb." + error;
                    }
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.href != null && message.hasOwnProperty("href"))
                        if (!$util.isString(message.href))
                            return "href: string expected";
                    return null;
                };

                /**
                 * Creates a Point message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.timeseries.v1.Point
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.timeseries.v1.Point} Point
                 */
                Point.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.timeseries.v1.Point)
                        return object;
                    let message = new $root.clutch.timeseries.v1.Point();
                    if (object.range != null) {
                        if (typeof object.range !== "object")
                            throw TypeError(".clutch.timeseries.v1.Point.range: object expected");
                        message.range = $root.clutch.timeseries.v1.TimeRange.fromObject(object.range);
                    }
                    if (object.millis != null)
                        if ($util.Long)
                            (message.millis = $util.Long.fromValue(object.millis)).unsigned = false;
                        else if (typeof object.millis === "string")
                            message.millis = parseInt(object.millis, 10);
                        else if (typeof object.millis === "number")
                            message.millis = object.millis;
                        else if (typeof object.millis === "object")
                            message.millis = new $util.LongBits(object.millis.low >>> 0, object.millis.high >>> 0).toNumber();
                    if (object.pb != null) {
                        if (typeof object.pb !== "object")
                            throw TypeError(".clutch.timeseries.v1.Point.pb: object expected");
                        message.pb = $root.google.protobuf.Any.fromObject(object.pb);
                    }
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.href != null)
                        message.href = String(object.href);
                    return message;
                };

                /**
                 * Creates a plain object from a Point message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.timeseries.v1.Point
                 * @static
                 * @param {clutch.timeseries.v1.Point} message Point
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Point.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.pb = null;
                        object.description = "";
                        object.href = "";
                    }
                    if (message.range != null && message.hasOwnProperty("range")) {
                        object.range = $root.clutch.timeseries.v1.TimeRange.toObject(message.range, options);
                        if (options.oneofs)
                            object.timestamp = "range";
                    }
                    if (message.millis != null && message.hasOwnProperty("millis")) {
                        if (typeof message.millis === "number")
                            object.millis = options.longs === String ? String(message.millis) : message.millis;
                        else
                            object.millis = options.longs === String ? $util.Long.prototype.toString.call(message.millis) : options.longs === Number ? new $util.LongBits(message.millis.low >>> 0, message.millis.high >>> 0).toNumber() : message.millis;
                        if (options.oneofs)
                            object.timestamp = "millis";
                    }
                    if (message.pb != null && message.hasOwnProperty("pb"))
                        object.pb = $root.google.protobuf.Any.toObject(message.pb, options);
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.href != null && message.hasOwnProperty("href"))
                        object.href = message.href;
                    return object;
                };

                /**
                 * Converts this Point to JSON.
                 * @function toJSON
                 * @memberof clutch.timeseries.v1.Point
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Point.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Point;
            })();

            return v1;
        })();

        return timeseries;
    })();

    clutch.topology = (function() {

        /**
         * Namespace topology.
         * @memberof clutch
         * @namespace
         */
        const topology = {};

        topology.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.topology
             * @namespace
             */
            const v1 = {};

            v1.TopologyAPI = (function() {

                /**
                 * Constructs a new TopologyAPI service.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a TopologyAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function TopologyAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (TopologyAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TopologyAPI;

                /**
                 * Callback as used by {@link clutch.topology.v1.TopologyAPI#getTopology}.
                 * @memberof clutch.topology.v1.TopologyAPI
                 * @typedef GetTopologyCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.topology.v1.GetTopologyResponse} [response] GetTopologyResponse
                 */

                /**
                 * Calls GetTopology.
                 * @function getTopology
                 * @memberof clutch.topology.v1.TopologyAPI
                 * @instance
                 * @param {clutch.topology.v1.IGetTopologyRequest} request GetTopologyRequest message or plain object
                 * @param {clutch.topology.v1.TopologyAPI.GetTopologyCallback} callback Node-style callback called with the error, if any, and GetTopologyResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TopologyAPI.prototype.getTopology = function getTopology(request, callback) {
                    return this.rpcCall(getTopology, $root.clutch.topology.v1.GetTopologyRequest, $root.clutch.topology.v1.GetTopologyResponse, request, callback);
                }, "name", { value: "GetTopology" });

                /**
                 * Calls GetTopology.
                 * @function getTopology
                 * @memberof clutch.topology.v1.TopologyAPI
                 * @instance
                 * @param {clutch.topology.v1.IGetTopologyRequest} request GetTopologyRequest message or plain object
                 * @returns {Promise<clutch.topology.v1.GetTopologyResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.topology.v1.TopologyAPI#search}.
                 * @memberof clutch.topology.v1.TopologyAPI
                 * @typedef SearchCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.topology.v1.SearchResponse} [response] SearchResponse
                 */

                /**
                 * Calls Search.
                 * @function search
                 * @memberof clutch.topology.v1.TopologyAPI
                 * @instance
                 * @param {clutch.topology.v1.ISearchRequest} request SearchRequest message or plain object
                 * @param {clutch.topology.v1.TopologyAPI.SearchCallback} callback Node-style callback called with the error, if any, and SearchResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TopologyAPI.prototype.search = function search(request, callback) {
                    return this.rpcCall(search, $root.clutch.topology.v1.SearchRequest, $root.clutch.topology.v1.SearchResponse, request, callback);
                }, "name", { value: "Search" });

                /**
                 * Calls Search.
                 * @function search
                 * @memberof clutch.topology.v1.TopologyAPI
                 * @instance
                 * @param {clutch.topology.v1.ISearchRequest} request SearchRequest message or plain object
                 * @returns {Promise<clutch.topology.v1.SearchResponse>} Promise
                 * @variation 2
                 */

                return TopologyAPI;
            })();

            v1.GetTopologyRequest = (function() {

                /**
                 * Properties of a GetTopologyRequest.
                 * @memberof clutch.topology.v1
                 * @interface IGetTopologyRequest
                 * @property {Array.<clutch.topology.v1.IQuery>|null} [queries] GetTopologyRequest queries
                 */

                /**
                 * Constructs a new GetTopologyRequest.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a GetTopologyRequest.
                 * @implements IGetTopologyRequest
                 * @constructor
                 * @param {clutch.topology.v1.IGetTopologyRequest=} [properties] Properties to set
                 */
                function GetTopologyRequest(properties) {
                    this.queries = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetTopologyRequest queries.
                 * @member {Array.<clutch.topology.v1.IQuery>} queries
                 * @memberof clutch.topology.v1.GetTopologyRequest
                 * @instance
                 */
                GetTopologyRequest.prototype.queries = $util.emptyArray;

                /**
                 * Verifies a GetTopologyRequest message.
                 * @function verify
                 * @memberof clutch.topology.v1.GetTopologyRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetTopologyRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.queries != null && message.hasOwnProperty("queries")) {
                        if (!Array.isArray(message.queries))
                            return "queries: array expected";
                        for (let i = 0; i < message.queries.length; ++i) {
                            let error = $root.clutch.topology.v1.Query.verify(message.queries[i]);
                            if (error)
                                return "queries." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetTopologyRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.GetTopologyRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.GetTopologyRequest} GetTopologyRequest
                 */
                GetTopologyRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.GetTopologyRequest)
                        return object;
                    let message = new $root.clutch.topology.v1.GetTopologyRequest();
                    if (object.queries) {
                        if (!Array.isArray(object.queries))
                            throw TypeError(".clutch.topology.v1.GetTopologyRequest.queries: array expected");
                        message.queries = [];
                        for (let i = 0; i < object.queries.length; ++i) {
                            if (typeof object.queries[i] !== "object")
                                throw TypeError(".clutch.topology.v1.GetTopologyRequest.queries: object expected");
                            message.queries[i] = $root.clutch.topology.v1.Query.fromObject(object.queries[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetTopologyRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.GetTopologyRequest
                 * @static
                 * @param {clutch.topology.v1.GetTopologyRequest} message GetTopologyRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetTopologyRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.queries = [];
                    if (message.queries && message.queries.length) {
                        object.queries = [];
                        for (let j = 0; j < message.queries.length; ++j)
                            object.queries[j] = $root.clutch.topology.v1.Query.toObject(message.queries[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetTopologyRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.GetTopologyRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetTopologyRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetTopologyRequest;
            })();

            v1.GetTopologyResponse = (function() {

                /**
                 * Properties of a GetTopologyResponse.
                 * @memberof clutch.topology.v1
                 * @interface IGetTopologyResponse
                 * @property {Array.<clutch.topology.v1.IQueryResult>|null} [results] GetTopologyResponse results
                 */

                /**
                 * Constructs a new GetTopologyResponse.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a GetTopologyResponse.
                 * @implements IGetTopologyResponse
                 * @constructor
                 * @param {clutch.topology.v1.IGetTopologyResponse=} [properties] Properties to set
                 */
                function GetTopologyResponse(properties) {
                    this.results = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetTopologyResponse results.
                 * @member {Array.<clutch.topology.v1.IQueryResult>} results
                 * @memberof clutch.topology.v1.GetTopologyResponse
                 * @instance
                 */
                GetTopologyResponse.prototype.results = $util.emptyArray;

                /**
                 * Verifies a GetTopologyResponse message.
                 * @function verify
                 * @memberof clutch.topology.v1.GetTopologyResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetTopologyResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.results != null && message.hasOwnProperty("results")) {
                        if (!Array.isArray(message.results))
                            return "results: array expected";
                        for (let i = 0; i < message.results.length; ++i) {
                            let error = $root.clutch.topology.v1.QueryResult.verify(message.results[i]);
                            if (error)
                                return "results." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetTopologyResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.GetTopologyResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.GetTopologyResponse} GetTopologyResponse
                 */
                GetTopologyResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.GetTopologyResponse)
                        return object;
                    let message = new $root.clutch.topology.v1.GetTopologyResponse();
                    if (object.results) {
                        if (!Array.isArray(object.results))
                            throw TypeError(".clutch.topology.v1.GetTopologyResponse.results: array expected");
                        message.results = [];
                        for (let i = 0; i < object.results.length; ++i) {
                            if (typeof object.results[i] !== "object")
                                throw TypeError(".clutch.topology.v1.GetTopologyResponse.results: object expected");
                            message.results[i] = $root.clutch.topology.v1.QueryResult.fromObject(object.results[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetTopologyResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.GetTopologyResponse
                 * @static
                 * @param {clutch.topology.v1.GetTopologyResponse} message GetTopologyResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetTopologyResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.results = [];
                    if (message.results && message.results.length) {
                        object.results = [];
                        for (let j = 0; j < message.results.length; ++j)
                            object.results[j] = $root.clutch.topology.v1.QueryResult.toObject(message.results[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetTopologyResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.GetTopologyResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetTopologyResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetTopologyResponse;
            })();

            v1.SearchRequest = (function() {

                /**
                 * Properties of a SearchRequest.
                 * @memberof clutch.topology.v1
                 * @interface ISearchRequest
                 * @property {clutch.topology.v1.SearchRequest.ISort|null} [sort] SearchRequest sort
                 * @property {string|null} [pageToken] SearchRequest pageToken
                 * @property {number|Long|null} [limit] SearchRequest limit
                 * @property {clutch.topology.v1.SearchRequest.IFilter|null} [filter] SearchRequest filter
                 */

                /**
                 * Constructs a new SearchRequest.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a SearchRequest.
                 * @implements ISearchRequest
                 * @constructor
                 * @param {clutch.topology.v1.ISearchRequest=} [properties] Properties to set
                 */
                function SearchRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SearchRequest sort.
                 * @member {clutch.topology.v1.SearchRequest.ISort|null|undefined} sort
                 * @memberof clutch.topology.v1.SearchRequest
                 * @instance
                 */
                SearchRequest.prototype.sort = null;

                /**
                 * SearchRequest pageToken.
                 * @member {string} pageToken
                 * @memberof clutch.topology.v1.SearchRequest
                 * @instance
                 */
                SearchRequest.prototype.pageToken = "";

                /**
                 * SearchRequest limit.
                 * @member {number|Long} limit
                 * @memberof clutch.topology.v1.SearchRequest
                 * @instance
                 */
                SearchRequest.prototype.limit = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                /**
                 * SearchRequest filter.
                 * @member {clutch.topology.v1.SearchRequest.IFilter|null|undefined} filter
                 * @memberof clutch.topology.v1.SearchRequest
                 * @instance
                 */
                SearchRequest.prototype.filter = null;

                /**
                 * Verifies a SearchRequest message.
                 * @function verify
                 * @memberof clutch.topology.v1.SearchRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SearchRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.sort != null && message.hasOwnProperty("sort")) {
                        let error = $root.clutch.topology.v1.SearchRequest.Sort.verify(message.sort);
                        if (error)
                            return "sort." + error;
                    }
                    if (message.pageToken != null && message.hasOwnProperty("pageToken"))
                        if (!$util.isString(message.pageToken))
                            return "pageToken: string expected";
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit) && !(message.limit && $util.isInteger(message.limit.low) && $util.isInteger(message.limit.high)))
                            return "limit: integer|Long expected";
                    if (message.filter != null && message.hasOwnProperty("filter")) {
                        let error = $root.clutch.topology.v1.SearchRequest.Filter.verify(message.filter);
                        if (error)
                            return "filter." + error;
                    }
                    return null;
                };

                /**
                 * Creates a SearchRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.SearchRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.SearchRequest} SearchRequest
                 */
                SearchRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.SearchRequest)
                        return object;
                    let message = new $root.clutch.topology.v1.SearchRequest();
                    if (object.sort != null) {
                        if (typeof object.sort !== "object")
                            throw TypeError(".clutch.topology.v1.SearchRequest.sort: object expected");
                        message.sort = $root.clutch.topology.v1.SearchRequest.Sort.fromObject(object.sort);
                    }
                    if (object.pageToken != null)
                        message.pageToken = String(object.pageToken);
                    if (object.limit != null)
                        if ($util.Long)
                            (message.limit = $util.Long.fromValue(object.limit)).unsigned = true;
                        else if (typeof object.limit === "string")
                            message.limit = parseInt(object.limit, 10);
                        else if (typeof object.limit === "number")
                            message.limit = object.limit;
                        else if (typeof object.limit === "object")
                            message.limit = new $util.LongBits(object.limit.low >>> 0, object.limit.high >>> 0).toNumber(true);
                    if (object.filter != null) {
                        if (typeof object.filter !== "object")
                            throw TypeError(".clutch.topology.v1.SearchRequest.filter: object expected");
                        message.filter = $root.clutch.topology.v1.SearchRequest.Filter.fromObject(object.filter);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SearchRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.SearchRequest
                 * @static
                 * @param {clutch.topology.v1.SearchRequest} message SearchRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SearchRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.sort = null;
                        object.pageToken = "";
                        if ($util.Long) {
                            let long = new $util.Long(0, 0, true);
                            object.limit = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                        } else
                            object.limit = options.longs === String ? "0" : 0;
                        object.filter = null;
                    }
                    if (message.sort != null && message.hasOwnProperty("sort"))
                        object.sort = $root.clutch.topology.v1.SearchRequest.Sort.toObject(message.sort, options);
                    if (message.pageToken != null && message.hasOwnProperty("pageToken"))
                        object.pageToken = message.pageToken;
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (typeof message.limit === "number")
                            object.limit = options.longs === String ? String(message.limit) : message.limit;
                        else
                            object.limit = options.longs === String ? $util.Long.prototype.toString.call(message.limit) : options.longs === Number ? new $util.LongBits(message.limit.low >>> 0, message.limit.high >>> 0).toNumber(true) : message.limit;
                    if (message.filter != null && message.hasOwnProperty("filter"))
                        object.filter = $root.clutch.topology.v1.SearchRequest.Filter.toObject(message.filter, options);
                    return object;
                };

                /**
                 * Converts this SearchRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.SearchRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SearchRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                SearchRequest.Sort = (function() {

                    /**
                     * Properties of a Sort.
                     * @memberof clutch.topology.v1.SearchRequest
                     * @interface ISort
                     * @property {clutch.topology.v1.SearchRequest.Sort.Direction|null} [direction] Sort direction
                     * @property {string|null} [field] Sort field
                     */

                    /**
                     * Constructs a new Sort.
                     * @memberof clutch.topology.v1.SearchRequest
                     * @classdesc Represents a Sort.
                     * @implements ISort
                     * @constructor
                     * @param {clutch.topology.v1.SearchRequest.ISort=} [properties] Properties to set
                     */
                    function Sort(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Sort direction.
                     * @member {clutch.topology.v1.SearchRequest.Sort.Direction} direction
                     * @memberof clutch.topology.v1.SearchRequest.Sort
                     * @instance
                     */
                    Sort.prototype.direction = 0;

                    /**
                     * Sort field.
                     * @member {string} field
                     * @memberof clutch.topology.v1.SearchRequest.Sort
                     * @instance
                     */
                    Sort.prototype.field = "";

                    /**
                     * Verifies a Sort message.
                     * @function verify
                     * @memberof clutch.topology.v1.SearchRequest.Sort
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Sort.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.direction != null && message.hasOwnProperty("direction"))
                            switch (message.direction) {
                            default:
                                return "direction: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        if (message.field != null && message.hasOwnProperty("field"))
                            if (!$util.isString(message.field))
                                return "field: string expected";
                        return null;
                    };

                    /**
                     * Creates a Sort message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.topology.v1.SearchRequest.Sort
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.topology.v1.SearchRequest.Sort} Sort
                     */
                    Sort.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.topology.v1.SearchRequest.Sort)
                            return object;
                        let message = new $root.clutch.topology.v1.SearchRequest.Sort();
                        switch (object.direction) {
                        case "UNSPECIFIED":
                        case 0:
                            message.direction = 0;
                            break;
                        case "ASCENDING":
                        case 1:
                            message.direction = 1;
                            break;
                        case "DESCENDING":
                        case 2:
                            message.direction = 2;
                            break;
                        }
                        if (object.field != null)
                            message.field = String(object.field);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Sort message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.topology.v1.SearchRequest.Sort
                     * @static
                     * @param {clutch.topology.v1.SearchRequest.Sort} message Sort
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Sort.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.direction = options.enums === String ? "UNSPECIFIED" : 0;
                            object.field = "";
                        }
                        if (message.direction != null && message.hasOwnProperty("direction"))
                            object.direction = options.enums === String ? $root.clutch.topology.v1.SearchRequest.Sort.Direction[message.direction] : message.direction;
                        if (message.field != null && message.hasOwnProperty("field"))
                            object.field = message.field;
                        return object;
                    };

                    /**
                     * Converts this Sort to JSON.
                     * @function toJSON
                     * @memberof clutch.topology.v1.SearchRequest.Sort
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Sort.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Direction enum.
                     * @name clutch.topology.v1.SearchRequest.Sort.Direction
                     * @enum {number}
                     * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                     * @property {number} ASCENDING=1 ASCENDING value
                     * @property {number} DESCENDING=2 DESCENDING value
                     */
                    Sort.Direction = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNSPECIFIED"] = 0;
                        values[valuesById[1] = "ASCENDING"] = 1;
                        values[valuesById[2] = "DESCENDING"] = 2;
                        return values;
                    })();

                    return Sort;
                })();

                SearchRequest.Filter = (function() {

                    /**
                     * Properties of a Filter.
                     * @memberof clutch.topology.v1.SearchRequest
                     * @interface IFilter
                     * @property {clutch.topology.v1.SearchRequest.Filter.ISearch|null} [search] Filter search
                     * @property {string|null} [typeUrl] Filter typeUrl
                     * @property {Object.<string,string>|null} [metadata] Filter metadata
                     */

                    /**
                     * Constructs a new Filter.
                     * @memberof clutch.topology.v1.SearchRequest
                     * @classdesc Represents a Filter.
                     * @implements IFilter
                     * @constructor
                     * @param {clutch.topology.v1.SearchRequest.IFilter=} [properties] Properties to set
                     */
                    function Filter(properties) {
                        this.metadata = {};
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Filter search.
                     * @member {clutch.topology.v1.SearchRequest.Filter.ISearch|null|undefined} search
                     * @memberof clutch.topology.v1.SearchRequest.Filter
                     * @instance
                     */
                    Filter.prototype.search = null;

                    /**
                     * Filter typeUrl.
                     * @member {string} typeUrl
                     * @memberof clutch.topology.v1.SearchRequest.Filter
                     * @instance
                     */
                    Filter.prototype.typeUrl = "";

                    /**
                     * Filter metadata.
                     * @member {Object.<string,string>} metadata
                     * @memberof clutch.topology.v1.SearchRequest.Filter
                     * @instance
                     */
                    Filter.prototype.metadata = $util.emptyObject;

                    /**
                     * Verifies a Filter message.
                     * @function verify
                     * @memberof clutch.topology.v1.SearchRequest.Filter
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Filter.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.search != null && message.hasOwnProperty("search")) {
                            let error = $root.clutch.topology.v1.SearchRequest.Filter.Search.verify(message.search);
                            if (error)
                                return "search." + error;
                        }
                        if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                            if (!$util.isString(message.typeUrl))
                                return "typeUrl: string expected";
                        if (message.metadata != null && message.hasOwnProperty("metadata")) {
                            if (!$util.isObject(message.metadata))
                                return "metadata: object expected";
                            let key = Object.keys(message.metadata);
                            for (let i = 0; i < key.length; ++i)
                                if (!$util.isString(message.metadata[key[i]]))
                                    return "metadata: string{k:string} expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Filter message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.topology.v1.SearchRequest.Filter
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.topology.v1.SearchRequest.Filter} Filter
                     */
                    Filter.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.topology.v1.SearchRequest.Filter)
                            return object;
                        let message = new $root.clutch.topology.v1.SearchRequest.Filter();
                        if (object.search != null) {
                            if (typeof object.search !== "object")
                                throw TypeError(".clutch.topology.v1.SearchRequest.Filter.search: object expected");
                            message.search = $root.clutch.topology.v1.SearchRequest.Filter.Search.fromObject(object.search);
                        }
                        if (object.typeUrl != null)
                            message.typeUrl = String(object.typeUrl);
                        if (object.metadata) {
                            if (typeof object.metadata !== "object")
                                throw TypeError(".clutch.topology.v1.SearchRequest.Filter.metadata: object expected");
                            message.metadata = {};
                            for (let keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i)
                                message.metadata[keys[i]] = String(object.metadata[keys[i]]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Filter message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.topology.v1.SearchRequest.Filter
                     * @static
                     * @param {clutch.topology.v1.SearchRequest.Filter} message Filter
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Filter.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.objects || options.defaults)
                            object.metadata = {};
                        if (options.defaults) {
                            object.search = null;
                            object.typeUrl = "";
                        }
                        if (message.search != null && message.hasOwnProperty("search"))
                            object.search = $root.clutch.topology.v1.SearchRequest.Filter.Search.toObject(message.search, options);
                        if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                            object.typeUrl = message.typeUrl;
                        let keys2;
                        if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                            object.metadata = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.metadata[keys2[j]] = message.metadata[keys2[j]];
                        }
                        return object;
                    };

                    /**
                     * Converts this Filter to JSON.
                     * @function toJSON
                     * @memberof clutch.topology.v1.SearchRequest.Filter
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Filter.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Filter.Search = (function() {

                        /**
                         * Properties of a Search.
                         * @memberof clutch.topology.v1.SearchRequest.Filter
                         * @interface ISearch
                         * @property {string|null} [field] Search field
                         * @property {string|null} [text] Search text
                         */

                        /**
                         * Constructs a new Search.
                         * @memberof clutch.topology.v1.SearchRequest.Filter
                         * @classdesc Represents a Search.
                         * @implements ISearch
                         * @constructor
                         * @param {clutch.topology.v1.SearchRequest.Filter.ISearch=} [properties] Properties to set
                         */
                        function Search(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Search field.
                         * @member {string} field
                         * @memberof clutch.topology.v1.SearchRequest.Filter.Search
                         * @instance
                         */
                        Search.prototype.field = "";

                        /**
                         * Search text.
                         * @member {string} text
                         * @memberof clutch.topology.v1.SearchRequest.Filter.Search
                         * @instance
                         */
                        Search.prototype.text = "";

                        /**
                         * Verifies a Search message.
                         * @function verify
                         * @memberof clutch.topology.v1.SearchRequest.Filter.Search
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Search.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.field != null && message.hasOwnProperty("field"))
                                if (!$util.isString(message.field))
                                    return "field: string expected";
                            if (message.text != null && message.hasOwnProperty("text"))
                                if (!$util.isString(message.text))
                                    return "text: string expected";
                            return null;
                        };

                        /**
                         * Creates a Search message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.topology.v1.SearchRequest.Filter.Search
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.topology.v1.SearchRequest.Filter.Search} Search
                         */
                        Search.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.topology.v1.SearchRequest.Filter.Search)
                                return object;
                            let message = new $root.clutch.topology.v1.SearchRequest.Filter.Search();
                            if (object.field != null)
                                message.field = String(object.field);
                            if (object.text != null)
                                message.text = String(object.text);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Search message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.topology.v1.SearchRequest.Filter.Search
                         * @static
                         * @param {clutch.topology.v1.SearchRequest.Filter.Search} message Search
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Search.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.field = "";
                                object.text = "";
                            }
                            if (message.field != null && message.hasOwnProperty("field"))
                                object.field = message.field;
                            if (message.text != null && message.hasOwnProperty("text"))
                                object.text = message.text;
                            return object;
                        };

                        /**
                         * Converts this Search to JSON.
                         * @function toJSON
                         * @memberof clutch.topology.v1.SearchRequest.Filter.Search
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Search.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Search;
                    })();

                    return Filter;
                })();

                return SearchRequest;
            })();

            v1.SearchResponse = (function() {

                /**
                 * Properties of a SearchResponse.
                 * @memberof clutch.topology.v1
                 * @interface ISearchResponse
                 * @property {Array.<clutch.topology.v1.IResource>|null} [resources] SearchResponse resources
                 * @property {string|null} [nextPageToken] SearchResponse nextPageToken
                 */

                /**
                 * Constructs a new SearchResponse.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a SearchResponse.
                 * @implements ISearchResponse
                 * @constructor
                 * @param {clutch.topology.v1.ISearchResponse=} [properties] Properties to set
                 */
                function SearchResponse(properties) {
                    this.resources = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SearchResponse resources.
                 * @member {Array.<clutch.topology.v1.IResource>} resources
                 * @memberof clutch.topology.v1.SearchResponse
                 * @instance
                 */
                SearchResponse.prototype.resources = $util.emptyArray;

                /**
                 * SearchResponse nextPageToken.
                 * @member {string} nextPageToken
                 * @memberof clutch.topology.v1.SearchResponse
                 * @instance
                 */
                SearchResponse.prototype.nextPageToken = "";

                /**
                 * Verifies a SearchResponse message.
                 * @function verify
                 * @memberof clutch.topology.v1.SearchResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SearchResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resources != null && message.hasOwnProperty("resources")) {
                        if (!Array.isArray(message.resources))
                            return "resources: array expected";
                        for (let i = 0; i < message.resources.length; ++i) {
                            let error = $root.clutch.topology.v1.Resource.verify(message.resources[i]);
                            if (error)
                                return "resources." + error;
                        }
                    }
                    if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                        if (!$util.isString(message.nextPageToken))
                            return "nextPageToken: string expected";
                    return null;
                };

                /**
                 * Creates a SearchResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.SearchResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.SearchResponse} SearchResponse
                 */
                SearchResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.SearchResponse)
                        return object;
                    let message = new $root.clutch.topology.v1.SearchResponse();
                    if (object.resources) {
                        if (!Array.isArray(object.resources))
                            throw TypeError(".clutch.topology.v1.SearchResponse.resources: array expected");
                        message.resources = [];
                        for (let i = 0; i < object.resources.length; ++i) {
                            if (typeof object.resources[i] !== "object")
                                throw TypeError(".clutch.topology.v1.SearchResponse.resources: object expected");
                            message.resources[i] = $root.clutch.topology.v1.Resource.fromObject(object.resources[i]);
                        }
                    }
                    if (object.nextPageToken != null)
                        message.nextPageToken = String(object.nextPageToken);
                    return message;
                };

                /**
                 * Creates a plain object from a SearchResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.SearchResponse
                 * @static
                 * @param {clutch.topology.v1.SearchResponse} message SearchResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SearchResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.resources = [];
                    if (options.defaults)
                        object.nextPageToken = "";
                    if (message.resources && message.resources.length) {
                        object.resources = [];
                        for (let j = 0; j < message.resources.length; ++j)
                            object.resources[j] = $root.clutch.topology.v1.Resource.toObject(message.resources[j], options);
                    }
                    if (message.nextPageToken != null && message.hasOwnProperty("nextPageToken"))
                        object.nextPageToken = message.nextPageToken;
                    return object;
                };

                /**
                 * Converts this SearchResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.SearchResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SearchResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SearchResponse;
            })();

            v1.FeatureQuery = (function() {

                /**
                 * Properties of a FeatureQuery.
                 * @memberof clutch.topology.v1
                 * @interface IFeatureQuery
                 * @property {string|null} [name] FeatureQuery name
                 * @property {Array.<string>|null} [values] FeatureQuery values
                 */

                /**
                 * Constructs a new FeatureQuery.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a FeatureQuery.
                 * @implements IFeatureQuery
                 * @constructor
                 * @param {clutch.topology.v1.IFeatureQuery=} [properties] Properties to set
                 */
                function FeatureQuery(properties) {
                    this.values = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FeatureQuery name.
                 * @member {string} name
                 * @memberof clutch.topology.v1.FeatureQuery
                 * @instance
                 */
                FeatureQuery.prototype.name = "";

                /**
                 * FeatureQuery values.
                 * @member {Array.<string>} values
                 * @memberof clutch.topology.v1.FeatureQuery
                 * @instance
                 */
                FeatureQuery.prototype.values = $util.emptyArray;

                /**
                 * Verifies a FeatureQuery message.
                 * @function verify
                 * @memberof clutch.topology.v1.FeatureQuery
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FeatureQuery.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (let i = 0; i < message.values.length; ++i)
                            if (!$util.isString(message.values[i]))
                                return "values: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a FeatureQuery message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.FeatureQuery
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.FeatureQuery} FeatureQuery
                 */
                FeatureQuery.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.FeatureQuery)
                        return object;
                    let message = new $root.clutch.topology.v1.FeatureQuery();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".clutch.topology.v1.FeatureQuery.values: array expected");
                        message.values = [];
                        for (let i = 0; i < object.values.length; ++i)
                            message.values[i] = String(object.values[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FeatureQuery message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.FeatureQuery
                 * @static
                 * @param {clutch.topology.v1.FeatureQuery} message FeatureQuery
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FeatureQuery.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (options.defaults)
                        object.name = "";
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (let j = 0; j < message.values.length; ++j)
                            object.values[j] = message.values[j];
                    }
                    return object;
                };

                /**
                 * Converts this FeatureQuery to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.FeatureQuery
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FeatureQuery.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FeatureQuery;
            })();

            v1.Constraint = (function() {

                /**
                 * Properties of a Constraint.
                 * @memberof clutch.topology.v1
                 * @interface IConstraint
                 * @property {clutch.topology.v1.Constraint.Operator|null} [operator] Constraint operator
                 * @property {google.protobuf.IValue|null} [value] Constraint value
                 */

                /**
                 * Constructs a new Constraint.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a Constraint.
                 * @implements IConstraint
                 * @constructor
                 * @param {clutch.topology.v1.IConstraint=} [properties] Properties to set
                 */
                function Constraint(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Constraint operator.
                 * @member {clutch.topology.v1.Constraint.Operator} operator
                 * @memberof clutch.topology.v1.Constraint
                 * @instance
                 */
                Constraint.prototype.operator = 0;

                /**
                 * Constraint value.
                 * @member {google.protobuf.IValue|null|undefined} value
                 * @memberof clutch.topology.v1.Constraint
                 * @instance
                 */
                Constraint.prototype.value = null;

                /**
                 * Verifies a Constraint message.
                 * @function verify
                 * @memberof clutch.topology.v1.Constraint
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Constraint.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.operator != null && message.hasOwnProperty("operator"))
                        switch (message.operator) {
                        default:
                            return "operator: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                            break;
                        }
                    if (message.value != null && message.hasOwnProperty("value")) {
                        let error = $root.google.protobuf.Value.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Constraint message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.Constraint
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.Constraint} Constraint
                 */
                Constraint.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.Constraint)
                        return object;
                    let message = new $root.clutch.topology.v1.Constraint();
                    switch (object.operator) {
                    case "UNSPECIFIED":
                    case 0:
                        message.operator = 0;
                        break;
                    case "EQUAL":
                    case 1:
                        message.operator = 1;
                        break;
                    case "NOT_EQUAL":
                    case 2:
                        message.operator = 2;
                        break;
                    case "GREATER_THAN":
                    case 3:
                        message.operator = 3;
                        break;
                    case "GREATER_THAN_OR_EQUAL":
                    case 4:
                        message.operator = 4;
                        break;
                    case "LESS_THAN":
                    case 5:
                        message.operator = 5;
                        break;
                    case "LESS_THAN_OR_EQUAL":
                    case 6:
                        message.operator = 6;
                        break;
                    case "CONTAINS_STRING":
                    case 7:
                        message.operator = 7;
                        break;
                    case "CONTAINS_VALUE":
                    case 8:
                        message.operator = 8;
                        break;
                    case "CONTAINS_KEY":
                    case 9:
                        message.operator = 9;
                        break;
                    }
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".clutch.topology.v1.Constraint.value: object expected");
                        message.value = $root.google.protobuf.Value.fromObject(object.value);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Constraint message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.Constraint
                 * @static
                 * @param {clutch.topology.v1.Constraint} message Constraint
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Constraint.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.operator = options.enums === String ? "UNSPECIFIED" : 0;
                        object.value = null;
                    }
                    if (message.operator != null && message.hasOwnProperty("operator"))
                        object.operator = options.enums === String ? $root.clutch.topology.v1.Constraint.Operator[message.operator] : message.operator;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.google.protobuf.Value.toObject(message.value, options);
                    return object;
                };

                /**
                 * Converts this Constraint to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.Constraint
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Constraint.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Operator enum.
                 * @name clutch.topology.v1.Constraint.Operator
                 * @enum {number}
                 * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                 * @property {number} EQUAL=1 EQUAL value
                 * @property {number} NOT_EQUAL=2 NOT_EQUAL value
                 * @property {number} GREATER_THAN=3 GREATER_THAN value
                 * @property {number} GREATER_THAN_OR_EQUAL=4 GREATER_THAN_OR_EQUAL value
                 * @property {number} LESS_THAN=5 LESS_THAN value
                 * @property {number} LESS_THAN_OR_EQUAL=6 LESS_THAN_OR_EQUAL value
                 * @property {number} CONTAINS_STRING=7 CONTAINS_STRING value
                 * @property {number} CONTAINS_VALUE=8 CONTAINS_VALUE value
                 * @property {number} CONTAINS_KEY=9 CONTAINS_KEY value
                 */
                Constraint.Operator = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNSPECIFIED"] = 0;
                    values[valuesById[1] = "EQUAL"] = 1;
                    values[valuesById[2] = "NOT_EQUAL"] = 2;
                    values[valuesById[3] = "GREATER_THAN"] = 3;
                    values[valuesById[4] = "GREATER_THAN_OR_EQUAL"] = 4;
                    values[valuesById[5] = "LESS_THAN"] = 5;
                    values[valuesById[6] = "LESS_THAN_OR_EQUAL"] = 6;
                    values[valuesById[7] = "CONTAINS_STRING"] = 7;
                    values[valuesById[8] = "CONTAINS_VALUE"] = 8;
                    values[valuesById[9] = "CONTAINS_KEY"] = 9;
                    return values;
                })();

                return Constraint;
            })();

            v1.MetadataQuery = (function() {

                /**
                 * Properties of a MetadataQuery.
                 * @memberof clutch.topology.v1
                 * @interface IMetadataQuery
                 * @property {string|null} [name] MetadataQuery name
                 * @property {google.protobuf.IStruct|null} [params] MetadataQuery params
                 * @property {clutch.topology.v1.MetadataQuery.Aggregation|null} [aggregation] MetadataQuery aggregation
                 * @property {Array.<clutch.topology.v1.IConstraint>|null} [constraints] MetadataQuery constraints
                 */

                /**
                 * Constructs a new MetadataQuery.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a MetadataQuery.
                 * @implements IMetadataQuery
                 * @constructor
                 * @param {clutch.topology.v1.IMetadataQuery=} [properties] Properties to set
                 */
                function MetadataQuery(properties) {
                    this.constraints = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MetadataQuery name.
                 * @member {string} name
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @instance
                 */
                MetadataQuery.prototype.name = "";

                /**
                 * MetadataQuery params.
                 * @member {google.protobuf.IStruct|null|undefined} params
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @instance
                 */
                MetadataQuery.prototype.params = null;

                /**
                 * MetadataQuery aggregation.
                 * @member {clutch.topology.v1.MetadataQuery.Aggregation} aggregation
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @instance
                 */
                MetadataQuery.prototype.aggregation = 0;

                /**
                 * MetadataQuery constraints.
                 * @member {Array.<clutch.topology.v1.IConstraint>} constraints
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @instance
                 */
                MetadataQuery.prototype.constraints = $util.emptyArray;

                /**
                 * Verifies a MetadataQuery message.
                 * @function verify
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MetadataQuery.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        let error = $root.google.protobuf.Struct.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    if (message.aggregation != null && message.hasOwnProperty("aggregation"))
                        switch (message.aggregation) {
                        default:
                            return "aggregation: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    if (message.constraints != null && message.hasOwnProperty("constraints")) {
                        if (!Array.isArray(message.constraints))
                            return "constraints: array expected";
                        for (let i = 0; i < message.constraints.length; ++i) {
                            let error = $root.clutch.topology.v1.Constraint.verify(message.constraints[i]);
                            if (error)
                                return "constraints." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MetadataQuery message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.MetadataQuery} MetadataQuery
                 */
                MetadataQuery.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.MetadataQuery)
                        return object;
                    let message = new $root.clutch.topology.v1.MetadataQuery();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".clutch.topology.v1.MetadataQuery.params: object expected");
                        message.params = $root.google.protobuf.Struct.fromObject(object.params);
                    }
                    switch (object.aggregation) {
                    case "UNSPECIFIED":
                    case 0:
                        message.aggregation = 0;
                        break;
                    case "SUM":
                    case 1:
                        message.aggregation = 1;
                        break;
                    case "AVERAGE":
                    case 2:
                        message.aggregation = 2;
                        break;
                    case "MEDIAN":
                    case 3:
                        message.aggregation = 3;
                        break;
                    case "MODE":
                    case 4:
                        message.aggregation = 4;
                        break;
                    case "MIN":
                    case 5:
                        message.aggregation = 5;
                        break;
                    case "MAX":
                    case 6:
                        message.aggregation = 6;
                        break;
                    case "COUNT":
                    case 7:
                        message.aggregation = 7;
                        break;
                    }
                    if (object.constraints) {
                        if (!Array.isArray(object.constraints))
                            throw TypeError(".clutch.topology.v1.MetadataQuery.constraints: array expected");
                        message.constraints = [];
                        for (let i = 0; i < object.constraints.length; ++i) {
                            if (typeof object.constraints[i] !== "object")
                                throw TypeError(".clutch.topology.v1.MetadataQuery.constraints: object expected");
                            message.constraints[i] = $root.clutch.topology.v1.Constraint.fromObject(object.constraints[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MetadataQuery message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @static
                 * @param {clutch.topology.v1.MetadataQuery} message MetadataQuery
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MetadataQuery.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.constraints = [];
                    if (options.defaults) {
                        object.name = "";
                        object.params = null;
                        object.aggregation = options.enums === String ? "UNSPECIFIED" : 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.google.protobuf.Struct.toObject(message.params, options);
                    if (message.aggregation != null && message.hasOwnProperty("aggregation"))
                        object.aggregation = options.enums === String ? $root.clutch.topology.v1.MetadataQuery.Aggregation[message.aggregation] : message.aggregation;
                    if (message.constraints && message.constraints.length) {
                        object.constraints = [];
                        for (let j = 0; j < message.constraints.length; ++j)
                            object.constraints[j] = $root.clutch.topology.v1.Constraint.toObject(message.constraints[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MetadataQuery to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MetadataQuery.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Aggregation enum.
                 * @name clutch.topology.v1.MetadataQuery.Aggregation
                 * @enum {number}
                 * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                 * @property {number} SUM=1 SUM value
                 * @property {number} AVERAGE=2 AVERAGE value
                 * @property {number} MEDIAN=3 MEDIAN value
                 * @property {number} MODE=4 MODE value
                 * @property {number} MIN=5 MIN value
                 * @property {number} MAX=6 MAX value
                 * @property {number} COUNT=7 COUNT value
                 */
                MetadataQuery.Aggregation = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNSPECIFIED"] = 0;
                    values[valuesById[1] = "SUM"] = 1;
                    values[valuesById[2] = "AVERAGE"] = 2;
                    values[valuesById[3] = "MEDIAN"] = 3;
                    values[valuesById[4] = "MODE"] = 4;
                    values[valuesById[5] = "MIN"] = 5;
                    values[valuesById[6] = "MAX"] = 6;
                    values[valuesById[7] = "COUNT"] = 7;
                    return values;
                })();

                return MetadataQuery;
            })();

            v1.Query = (function() {

                /**
                 * Properties of a Query.
                 * @memberof clutch.topology.v1
                 * @interface IQuery
                 * @property {Array.<clutch.topology.v1.IFeatureQuery>|null} [features] Query features
                 * @property {Array.<clutch.topology.v1.IMetadataQuery>|null} [nodeMetadata] Query nodeMetadata
                 * @property {Array.<clutch.topology.v1.IMetadataQuery>|null} [edgeMetadata] Query edgeMetadata
                 * @property {number|null} [sourceDepth] Query sourceDepth
                 * @property {number|null} [targetDepth] Query targetDepth
                 */

                /**
                 * Constructs a new Query.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a Query.
                 * @implements IQuery
                 * @constructor
                 * @param {clutch.topology.v1.IQuery=} [properties] Properties to set
                 */
                function Query(properties) {
                    this.features = [];
                    this.nodeMetadata = [];
                    this.edgeMetadata = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Query features.
                 * @member {Array.<clutch.topology.v1.IFeatureQuery>} features
                 * @memberof clutch.topology.v1.Query
                 * @instance
                 */
                Query.prototype.features = $util.emptyArray;

                /**
                 * Query nodeMetadata.
                 * @member {Array.<clutch.topology.v1.IMetadataQuery>} nodeMetadata
                 * @memberof clutch.topology.v1.Query
                 * @instance
                 */
                Query.prototype.nodeMetadata = $util.emptyArray;

                /**
                 * Query edgeMetadata.
                 * @member {Array.<clutch.topology.v1.IMetadataQuery>} edgeMetadata
                 * @memberof clutch.topology.v1.Query
                 * @instance
                 */
                Query.prototype.edgeMetadata = $util.emptyArray;

                /**
                 * Query sourceDepth.
                 * @member {number} sourceDepth
                 * @memberof clutch.topology.v1.Query
                 * @instance
                 */
                Query.prototype.sourceDepth = 0;

                /**
                 * Query targetDepth.
                 * @member {number} targetDepth
                 * @memberof clutch.topology.v1.Query
                 * @instance
                 */
                Query.prototype.targetDepth = 0;

                /**
                 * Verifies a Query message.
                 * @function verify
                 * @memberof clutch.topology.v1.Query
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Query.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.features != null && message.hasOwnProperty("features")) {
                        if (!Array.isArray(message.features))
                            return "features: array expected";
                        for (let i = 0; i < message.features.length; ++i) {
                            let error = $root.clutch.topology.v1.FeatureQuery.verify(message.features[i]);
                            if (error)
                                return "features." + error;
                        }
                    }
                    if (message.nodeMetadata != null && message.hasOwnProperty("nodeMetadata")) {
                        if (!Array.isArray(message.nodeMetadata))
                            return "nodeMetadata: array expected";
                        for (let i = 0; i < message.nodeMetadata.length; ++i) {
                            let error = $root.clutch.topology.v1.MetadataQuery.verify(message.nodeMetadata[i]);
                            if (error)
                                return "nodeMetadata." + error;
                        }
                    }
                    if (message.edgeMetadata != null && message.hasOwnProperty("edgeMetadata")) {
                        if (!Array.isArray(message.edgeMetadata))
                            return "edgeMetadata: array expected";
                        for (let i = 0; i < message.edgeMetadata.length; ++i) {
                            let error = $root.clutch.topology.v1.MetadataQuery.verify(message.edgeMetadata[i]);
                            if (error)
                                return "edgeMetadata." + error;
                        }
                    }
                    if (message.sourceDepth != null && message.hasOwnProperty("sourceDepth"))
                        if (!$util.isInteger(message.sourceDepth))
                            return "sourceDepth: integer expected";
                    if (message.targetDepth != null && message.hasOwnProperty("targetDepth"))
                        if (!$util.isInteger(message.targetDepth))
                            return "targetDepth: integer expected";
                    return null;
                };

                /**
                 * Creates a Query message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.Query
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.Query} Query
                 */
                Query.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.Query)
                        return object;
                    let message = new $root.clutch.topology.v1.Query();
                    if (object.features) {
                        if (!Array.isArray(object.features))
                            throw TypeError(".clutch.topology.v1.Query.features: array expected");
                        message.features = [];
                        for (let i = 0; i < object.features.length; ++i) {
                            if (typeof object.features[i] !== "object")
                                throw TypeError(".clutch.topology.v1.Query.features: object expected");
                            message.features[i] = $root.clutch.topology.v1.FeatureQuery.fromObject(object.features[i]);
                        }
                    }
                    if (object.nodeMetadata) {
                        if (!Array.isArray(object.nodeMetadata))
                            throw TypeError(".clutch.topology.v1.Query.nodeMetadata: array expected");
                        message.nodeMetadata = [];
                        for (let i = 0; i < object.nodeMetadata.length; ++i) {
                            if (typeof object.nodeMetadata[i] !== "object")
                                throw TypeError(".clutch.topology.v1.Query.nodeMetadata: object expected");
                            message.nodeMetadata[i] = $root.clutch.topology.v1.MetadataQuery.fromObject(object.nodeMetadata[i]);
                        }
                    }
                    if (object.edgeMetadata) {
                        if (!Array.isArray(object.edgeMetadata))
                            throw TypeError(".clutch.topology.v1.Query.edgeMetadata: array expected");
                        message.edgeMetadata = [];
                        for (let i = 0; i < object.edgeMetadata.length; ++i) {
                            if (typeof object.edgeMetadata[i] !== "object")
                                throw TypeError(".clutch.topology.v1.Query.edgeMetadata: object expected");
                            message.edgeMetadata[i] = $root.clutch.topology.v1.MetadataQuery.fromObject(object.edgeMetadata[i]);
                        }
                    }
                    if (object.sourceDepth != null)
                        message.sourceDepth = object.sourceDepth >>> 0;
                    if (object.targetDepth != null)
                        message.targetDepth = object.targetDepth >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Query message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.Query
                 * @static
                 * @param {clutch.topology.v1.Query} message Query
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Query.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.features = [];
                        object.nodeMetadata = [];
                        object.edgeMetadata = [];
                    }
                    if (options.defaults) {
                        object.sourceDepth = 0;
                        object.targetDepth = 0;
                    }
                    if (message.features && message.features.length) {
                        object.features = [];
                        for (let j = 0; j < message.features.length; ++j)
                            object.features[j] = $root.clutch.topology.v1.FeatureQuery.toObject(message.features[j], options);
                    }
                    if (message.sourceDepth != null && message.hasOwnProperty("sourceDepth"))
                        object.sourceDepth = message.sourceDepth;
                    if (message.targetDepth != null && message.hasOwnProperty("targetDepth"))
                        object.targetDepth = message.targetDepth;
                    if (message.nodeMetadata && message.nodeMetadata.length) {
                        object.nodeMetadata = [];
                        for (let j = 0; j < message.nodeMetadata.length; ++j)
                            object.nodeMetadata[j] = $root.clutch.topology.v1.MetadataQuery.toObject(message.nodeMetadata[j], options);
                    }
                    if (message.edgeMetadata && message.edgeMetadata.length) {
                        object.edgeMetadata = [];
                        for (let j = 0; j < message.edgeMetadata.length; ++j)
                            object.edgeMetadata[j] = $root.clutch.topology.v1.MetadataQuery.toObject(message.edgeMetadata[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Query to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.Query
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Query.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Query;
            })();

            v1.QueryResult = (function() {

                /**
                 * Properties of a QueryResult.
                 * @memberof clutch.topology.v1
                 * @interface IQueryResult
                 * @property {google.rpc.IStatus|null} [status] QueryResult status
                 * @property {clutch.topology.v1.IQuery|null} [query] QueryResult query
                 * @property {Array.<string>|null} [matchedNodeIds] QueryResult matchedNodeIds
                 * @property {Object.<string,clutch.topology.v1.INode>|null} [nodes] QueryResult nodes
                 * @property {Object.<string,clutch.topology.v1.IEdge>|null} [edges] QueryResult edges
                 */

                /**
                 * Constructs a new QueryResult.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a QueryResult.
                 * @implements IQueryResult
                 * @constructor
                 * @param {clutch.topology.v1.IQueryResult=} [properties] Properties to set
                 */
                function QueryResult(properties) {
                    this.matchedNodeIds = [];
                    this.nodes = {};
                    this.edges = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * QueryResult status.
                 * @member {google.rpc.IStatus|null|undefined} status
                 * @memberof clutch.topology.v1.QueryResult
                 * @instance
                 */
                QueryResult.prototype.status = null;

                /**
                 * QueryResult query.
                 * @member {clutch.topology.v1.IQuery|null|undefined} query
                 * @memberof clutch.topology.v1.QueryResult
                 * @instance
                 */
                QueryResult.prototype.query = null;

                /**
                 * QueryResult matchedNodeIds.
                 * @member {Array.<string>} matchedNodeIds
                 * @memberof clutch.topology.v1.QueryResult
                 * @instance
                 */
                QueryResult.prototype.matchedNodeIds = $util.emptyArray;

                /**
                 * QueryResult nodes.
                 * @member {Object.<string,clutch.topology.v1.INode>} nodes
                 * @memberof clutch.topology.v1.QueryResult
                 * @instance
                 */
                QueryResult.prototype.nodes = $util.emptyObject;

                /**
                 * QueryResult edges.
                 * @member {Object.<string,clutch.topology.v1.IEdge>} edges
                 * @memberof clutch.topology.v1.QueryResult
                 * @instance
                 */
                QueryResult.prototype.edges = $util.emptyObject;

                /**
                 * Verifies a QueryResult message.
                 * @function verify
                 * @memberof clutch.topology.v1.QueryResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status")) {
                        let error = $root.google.rpc.Status.verify(message.status);
                        if (error)
                            return "status." + error;
                    }
                    if (message.query != null && message.hasOwnProperty("query")) {
                        let error = $root.clutch.topology.v1.Query.verify(message.query);
                        if (error)
                            return "query." + error;
                    }
                    if (message.matchedNodeIds != null && message.hasOwnProperty("matchedNodeIds")) {
                        if (!Array.isArray(message.matchedNodeIds))
                            return "matchedNodeIds: array expected";
                        for (let i = 0; i < message.matchedNodeIds.length; ++i)
                            if (!$util.isString(message.matchedNodeIds[i]))
                                return "matchedNodeIds: string[] expected";
                    }
                    if (message.nodes != null && message.hasOwnProperty("nodes")) {
                        if (!$util.isObject(message.nodes))
                            return "nodes: object expected";
                        let key = Object.keys(message.nodes);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.clutch.topology.v1.Node.verify(message.nodes[key[i]]);
                            if (error)
                                return "nodes." + error;
                        }
                    }
                    if (message.edges != null && message.hasOwnProperty("edges")) {
                        if (!$util.isObject(message.edges))
                            return "edges: object expected";
                        let key = Object.keys(message.edges);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.clutch.topology.v1.Edge.verify(message.edges[key[i]]);
                            if (error)
                                return "edges." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a QueryResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.QueryResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.QueryResult} QueryResult
                 */
                QueryResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.QueryResult)
                        return object;
                    let message = new $root.clutch.topology.v1.QueryResult();
                    if (object.status != null) {
                        if (typeof object.status !== "object")
                            throw TypeError(".clutch.topology.v1.QueryResult.status: object expected");
                        message.status = $root.google.rpc.Status.fromObject(object.status);
                    }
                    if (object.query != null) {
                        if (typeof object.query !== "object")
                            throw TypeError(".clutch.topology.v1.QueryResult.query: object expected");
                        message.query = $root.clutch.topology.v1.Query.fromObject(object.query);
                    }
                    if (object.matchedNodeIds) {
                        if (!Array.isArray(object.matchedNodeIds))
                            throw TypeError(".clutch.topology.v1.QueryResult.matchedNodeIds: array expected");
                        message.matchedNodeIds = [];
                        for (let i = 0; i < object.matchedNodeIds.length; ++i)
                            message.matchedNodeIds[i] = String(object.matchedNodeIds[i]);
                    }
                    if (object.nodes) {
                        if (typeof object.nodes !== "object")
                            throw TypeError(".clutch.topology.v1.QueryResult.nodes: object expected");
                        message.nodes = {};
                        for (let keys = Object.keys(object.nodes), i = 0; i < keys.length; ++i) {
                            if (typeof object.nodes[keys[i]] !== "object")
                                throw TypeError(".clutch.topology.v1.QueryResult.nodes: object expected");
                            message.nodes[keys[i]] = $root.clutch.topology.v1.Node.fromObject(object.nodes[keys[i]]);
                        }
                    }
                    if (object.edges) {
                        if (typeof object.edges !== "object")
                            throw TypeError(".clutch.topology.v1.QueryResult.edges: object expected");
                        message.edges = {};
                        for (let keys = Object.keys(object.edges), i = 0; i < keys.length; ++i) {
                            if (typeof object.edges[keys[i]] !== "object")
                                throw TypeError(".clutch.topology.v1.QueryResult.edges: object expected");
                            message.edges[keys[i]] = $root.clutch.topology.v1.Edge.fromObject(object.edges[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a QueryResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.QueryResult
                 * @static
                 * @param {clutch.topology.v1.QueryResult} message QueryResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.matchedNodeIds = [];
                    if (options.objects || options.defaults) {
                        object.nodes = {};
                        object.edges = {};
                    }
                    if (options.defaults) {
                        object.status = null;
                        object.query = null;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = $root.google.rpc.Status.toObject(message.status, options);
                    if (message.query != null && message.hasOwnProperty("query"))
                        object.query = $root.clutch.topology.v1.Query.toObject(message.query, options);
                    if (message.matchedNodeIds && message.matchedNodeIds.length) {
                        object.matchedNodeIds = [];
                        for (let j = 0; j < message.matchedNodeIds.length; ++j)
                            object.matchedNodeIds[j] = message.matchedNodeIds[j];
                    }
                    let keys2;
                    if (message.nodes && (keys2 = Object.keys(message.nodes)).length) {
                        object.nodes = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.nodes[keys2[j]] = $root.clutch.topology.v1.Node.toObject(message.nodes[keys2[j]], options);
                    }
                    if (message.edges && (keys2 = Object.keys(message.edges)).length) {
                        object.edges = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.edges[keys2[j]] = $root.clutch.topology.v1.Edge.toObject(message.edges[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Converts this QueryResult to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.QueryResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return QueryResult;
            })();

            v1.Node = (function() {

                /**
                 * Properties of a Node.
                 * @memberof clutch.topology.v1
                 * @interface INode
                 * @property {string|null} [id] Node id
                 * @property {Object.<string,string>|null} [features] Node features
                 * @property {Object.<string,google.protobuf.IValue>|null} [metadata] Node metadata
                 */

                /**
                 * Constructs a new Node.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a Node.
                 * @implements INode
                 * @constructor
                 * @param {clutch.topology.v1.INode=} [properties] Properties to set
                 */
                function Node(properties) {
                    this.features = {};
                    this.metadata = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Node id.
                 * @member {string} id
                 * @memberof clutch.topology.v1.Node
                 * @instance
                 */
                Node.prototype.id = "";

                /**
                 * Node features.
                 * @member {Object.<string,string>} features
                 * @memberof clutch.topology.v1.Node
                 * @instance
                 */
                Node.prototype.features = $util.emptyObject;

                /**
                 * Node metadata.
                 * @member {Object.<string,google.protobuf.IValue>} metadata
                 * @memberof clutch.topology.v1.Node
                 * @instance
                 */
                Node.prototype.metadata = $util.emptyObject;

                /**
                 * Verifies a Node message.
                 * @function verify
                 * @memberof clutch.topology.v1.Node
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Node.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.features != null && message.hasOwnProperty("features")) {
                        if (!$util.isObject(message.features))
                            return "features: object expected";
                        let key = Object.keys(message.features);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.features[key[i]]))
                                return "features: string{k:string} expected";
                    }
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        if (!$util.isObject(message.metadata))
                            return "metadata: object expected";
                        let key = Object.keys(message.metadata);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.google.protobuf.Value.verify(message.metadata[key[i]]);
                            if (error)
                                return "metadata." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Node message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.Node
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.Node} Node
                 */
                Node.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.Node)
                        return object;
                    let message = new $root.clutch.topology.v1.Node();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.features) {
                        if (typeof object.features !== "object")
                            throw TypeError(".clutch.topology.v1.Node.features: object expected");
                        message.features = {};
                        for (let keys = Object.keys(object.features), i = 0; i < keys.length; ++i)
                            message.features[keys[i]] = String(object.features[keys[i]]);
                    }
                    if (object.metadata) {
                        if (typeof object.metadata !== "object")
                            throw TypeError(".clutch.topology.v1.Node.metadata: object expected");
                        message.metadata = {};
                        for (let keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i) {
                            if (typeof object.metadata[keys[i]] !== "object")
                                throw TypeError(".clutch.topology.v1.Node.metadata: object expected");
                            message.metadata[keys[i]] = $root.google.protobuf.Value.fromObject(object.metadata[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Node message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.Node
                 * @static
                 * @param {clutch.topology.v1.Node} message Node
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Node.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.features = {};
                        object.metadata = {};
                    }
                    if (options.defaults)
                        object.id = "";
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    let keys2;
                    if (message.features && (keys2 = Object.keys(message.features)).length) {
                        object.features = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.features[keys2[j]] = message.features[keys2[j]];
                    }
                    if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                        object.metadata = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.metadata[keys2[j]] = $root.google.protobuf.Value.toObject(message.metadata[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Converts this Node to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.Node
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Node.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Node;
            })();

            v1.Edge = (function() {

                /**
                 * Properties of an Edge.
                 * @memberof clutch.topology.v1
                 * @interface IEdge
                 * @property {string|null} [id] Edge id
                 * @property {string|null} [sourceNodeId] Edge sourceNodeId
                 * @property {string|null} [targetNodeId] Edge targetNodeId
                 * @property {Object.<string,google.protobuf.IValue>|null} [metadata] Edge metadata
                 */

                /**
                 * Constructs a new Edge.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents an Edge.
                 * @implements IEdge
                 * @constructor
                 * @param {clutch.topology.v1.IEdge=} [properties] Properties to set
                 */
                function Edge(properties) {
                    this.metadata = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Edge id.
                 * @member {string} id
                 * @memberof clutch.topology.v1.Edge
                 * @instance
                 */
                Edge.prototype.id = "";

                /**
                 * Edge sourceNodeId.
                 * @member {string} sourceNodeId
                 * @memberof clutch.topology.v1.Edge
                 * @instance
                 */
                Edge.prototype.sourceNodeId = "";

                /**
                 * Edge targetNodeId.
                 * @member {string} targetNodeId
                 * @memberof clutch.topology.v1.Edge
                 * @instance
                 */
                Edge.prototype.targetNodeId = "";

                /**
                 * Edge metadata.
                 * @member {Object.<string,google.protobuf.IValue>} metadata
                 * @memberof clutch.topology.v1.Edge
                 * @instance
                 */
                Edge.prototype.metadata = $util.emptyObject;

                /**
                 * Verifies an Edge message.
                 * @function verify
                 * @memberof clutch.topology.v1.Edge
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Edge.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.sourceNodeId != null && message.hasOwnProperty("sourceNodeId"))
                        if (!$util.isString(message.sourceNodeId))
                            return "sourceNodeId: string expected";
                    if (message.targetNodeId != null && message.hasOwnProperty("targetNodeId"))
                        if (!$util.isString(message.targetNodeId))
                            return "targetNodeId: string expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        if (!$util.isObject(message.metadata))
                            return "metadata: object expected";
                        let key = Object.keys(message.metadata);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.google.protobuf.Value.verify(message.metadata[key[i]]);
                            if (error)
                                return "metadata." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Edge message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.Edge
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.Edge} Edge
                 */
                Edge.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.Edge)
                        return object;
                    let message = new $root.clutch.topology.v1.Edge();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.sourceNodeId != null)
                        message.sourceNodeId = String(object.sourceNodeId);
                    if (object.targetNodeId != null)
                        message.targetNodeId = String(object.targetNodeId);
                    if (object.metadata) {
                        if (typeof object.metadata !== "object")
                            throw TypeError(".clutch.topology.v1.Edge.metadata: object expected");
                        message.metadata = {};
                        for (let keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i) {
                            if (typeof object.metadata[keys[i]] !== "object")
                                throw TypeError(".clutch.topology.v1.Edge.metadata: object expected");
                            message.metadata[keys[i]] = $root.google.protobuf.Value.fromObject(object.metadata[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Edge message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.Edge
                 * @static
                 * @param {clutch.topology.v1.Edge} message Edge
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Edge.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.metadata = {};
                    if (options.defaults) {
                        object.id = "";
                        object.sourceNodeId = "";
                        object.targetNodeId = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.sourceNodeId != null && message.hasOwnProperty("sourceNodeId"))
                        object.sourceNodeId = message.sourceNodeId;
                    if (message.targetNodeId != null && message.hasOwnProperty("targetNodeId"))
                        object.targetNodeId = message.targetNodeId;
                    let keys2;
                    if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                        object.metadata = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.metadata[keys2[j]] = $root.google.protobuf.Value.toObject(message.metadata[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Converts this Edge to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.Edge
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Edge.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Edge;
            })();

            v1.Resource = (function() {

                /**
                 * Properties of a Resource.
                 * @memberof clutch.topology.v1
                 * @interface IResource
                 * @property {string|null} [id] Resource id
                 * @property {google.protobuf.IAny|null} [pb] Resource pb
                 * @property {Object.<string,google.protobuf.IValue>|null} [metadata] Resource metadata
                 */

                /**
                 * Constructs a new Resource.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a Resource.
                 * @implements IResource
                 * @constructor
                 * @param {clutch.topology.v1.IResource=} [properties] Properties to set
                 */
                function Resource(properties) {
                    this.metadata = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Resource id.
                 * @member {string} id
                 * @memberof clutch.topology.v1.Resource
                 * @instance
                 */
                Resource.prototype.id = "";

                /**
                 * Resource pb.
                 * @member {google.protobuf.IAny|null|undefined} pb
                 * @memberof clutch.topology.v1.Resource
                 * @instance
                 */
                Resource.prototype.pb = null;

                /**
                 * Resource metadata.
                 * @member {Object.<string,google.protobuf.IValue>} metadata
                 * @memberof clutch.topology.v1.Resource
                 * @instance
                 */
                Resource.prototype.metadata = $util.emptyObject;

                /**
                 * Verifies a Resource message.
                 * @function verify
                 * @memberof clutch.topology.v1.Resource
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Resource.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.pb != null && message.hasOwnProperty("pb")) {
                        let error = $root.google.protobuf.Any.verify(message.pb);
                        if (error)
                            return "pb." + error;
                    }
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        if (!$util.isObject(message.metadata))
                            return "metadata: object expected";
                        let key = Object.keys(message.metadata);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.google.protobuf.Value.verify(message.metadata[key[i]]);
                            if (error)
                                return "metadata." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Resource message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.Resource
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.Resource} Resource
                 */
                Resource.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.Resource)
                        return object;
                    let message = new $root.clutch.topology.v1.Resource();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.pb != null) {
                        if (typeof object.pb !== "object")
                            throw TypeError(".clutch.topology.v1.Resource.pb: object expected");
                        message.pb = $root.google.protobuf.Any.fromObject(object.pb);
                    }
                    if (object.metadata) {
                        if (typeof object.metadata !== "object")
                            throw TypeError(".clutch.topology.v1.Resource.metadata: object expected");
                        message.metadata = {};
                        for (let keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i) {
                            if (typeof object.metadata[keys[i]] !== "object")
                                throw TypeError(".clutch.topology.v1.Resource.metadata: object expected");
                            message.metadata[keys[i]] = $root.google.protobuf.Value.fromObject(object.metadata[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Resource message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.Resource
                 * @static
                 * @param {clutch.topology.v1.Resource} message Resource
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Resource.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.metadata = {};
                    if (options.defaults) {
                        object.id = "";
                        object.pb = null;
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.pb != null && message.hasOwnProperty("pb"))
                        object.pb = $root.google.protobuf.Any.toObject(message.pb, options);
                    let keys2;
                    if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                        object.metadata = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.metadata[keys2[j]] = $root.google.protobuf.Value.toObject(message.metadata[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Converts this Resource to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.Resource
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Resource.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Resource;
            })();

            v1.UpdateCacheRequest = (function() {

                /**
                 * Properties of an UpdateCacheRequest.
                 * @memberof clutch.topology.v1
                 * @interface IUpdateCacheRequest
                 * @property {clutch.topology.v1.IResource|null} [resource] UpdateCacheRequest resource
                 * @property {clutch.topology.v1.UpdateCacheRequest.Action|null} [action] UpdateCacheRequest action
                 */

                /**
                 * Constructs a new UpdateCacheRequest.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents an UpdateCacheRequest.
                 * @implements IUpdateCacheRequest
                 * @constructor
                 * @param {clutch.topology.v1.IUpdateCacheRequest=} [properties] Properties to set
                 */
                function UpdateCacheRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdateCacheRequest resource.
                 * @member {clutch.topology.v1.IResource|null|undefined} resource
                 * @memberof clutch.topology.v1.UpdateCacheRequest
                 * @instance
                 */
                UpdateCacheRequest.prototype.resource = null;

                /**
                 * UpdateCacheRequest action.
                 * @member {clutch.topology.v1.UpdateCacheRequest.Action} action
                 * @memberof clutch.topology.v1.UpdateCacheRequest
                 * @instance
                 */
                UpdateCacheRequest.prototype.action = 0;

                /**
                 * Verifies an UpdateCacheRequest message.
                 * @function verify
                 * @memberof clutch.topology.v1.UpdateCacheRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateCacheRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.resource != null && message.hasOwnProperty("resource")) {
                        let error = $root.clutch.topology.v1.Resource.verify(message.resource);
                        if (error)
                            return "resource." + error;
                    }
                    if (message.action != null && message.hasOwnProperty("action"))
                        switch (message.action) {
                        default:
                            return "action: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates an UpdateCacheRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.UpdateCacheRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.UpdateCacheRequest} UpdateCacheRequest
                 */
                UpdateCacheRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.UpdateCacheRequest)
                        return object;
                    let message = new $root.clutch.topology.v1.UpdateCacheRequest();
                    if (object.resource != null) {
                        if (typeof object.resource !== "object")
                            throw TypeError(".clutch.topology.v1.UpdateCacheRequest.resource: object expected");
                        message.resource = $root.clutch.topology.v1.Resource.fromObject(object.resource);
                    }
                    switch (object.action) {
                    case "UNSPECIFIED":
                    case 0:
                        message.action = 0;
                        break;
                    case "CREATE_OR_UPDATE":
                    case 1:
                        message.action = 1;
                        break;
                    case "DELETE":
                    case 2:
                        message.action = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an UpdateCacheRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.UpdateCacheRequest
                 * @static
                 * @param {clutch.topology.v1.UpdateCacheRequest} message UpdateCacheRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateCacheRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.resource = null;
                        object.action = options.enums === String ? "UNSPECIFIED" : 0;
                    }
                    if (message.resource != null && message.hasOwnProperty("resource"))
                        object.resource = $root.clutch.topology.v1.Resource.toObject(message.resource, options);
                    if (message.action != null && message.hasOwnProperty("action"))
                        object.action = options.enums === String ? $root.clutch.topology.v1.UpdateCacheRequest.Action[message.action] : message.action;
                    return object;
                };

                /**
                 * Converts this UpdateCacheRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.UpdateCacheRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateCacheRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Action enum.
                 * @name clutch.topology.v1.UpdateCacheRequest.Action
                 * @enum {number}
                 * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                 * @property {number} CREATE_OR_UPDATE=1 CREATE_OR_UPDATE value
                 * @property {number} DELETE=2 DELETE value
                 */
                UpdateCacheRequest.Action = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNSPECIFIED"] = 0;
                    values[valuesById[1] = "CREATE_OR_UPDATE"] = 1;
                    values[valuesById[2] = "DELETE"] = 2;
                    return values;
                })();

                return UpdateCacheRequest;
            })();

            return v1;
        })();

        return topology;
    })();

    return clutch;
})();

export const validate = $root.validate = (() => {

    /**
     * Namespace validate.
     * @exports validate
     * @namespace
     */
    const validate = {};

    validate.FieldRules = (function() {

        /**
         * Properties of a FieldRules.
         * @memberof validate
         * @interface IFieldRules
         * @property {validate.IMessageRules|null} [message] FieldRules message
         * @property {validate.IFloatRules|null} [float] FieldRules float
         * @property {validate.IDoubleRules|null} [double] FieldRules double
         * @property {validate.IInt32Rules|null} [int32] FieldRules int32
         * @property {validate.IInt64Rules|null} [int64] FieldRules int64
         * @property {validate.IUInt32Rules|null} [uint32] FieldRules uint32
         * @property {validate.IUInt64Rules|null} [uint64] FieldRules uint64
         * @property {validate.ISInt32Rules|null} [sint32] FieldRules sint32
         * @property {validate.ISInt64Rules|null} [sint64] FieldRules sint64
         * @property {validate.IFixed32Rules|null} [fixed32] FieldRules fixed32
         * @property {validate.IFixed64Rules|null} [fixed64] FieldRules fixed64
         * @property {validate.ISFixed32Rules|null} [sfixed32] FieldRules sfixed32
         * @property {validate.ISFixed64Rules|null} [sfixed64] FieldRules sfixed64
         * @property {validate.IBoolRules|null} [bool] FieldRules bool
         * @property {validate.IStringRules|null} [string] FieldRules string
         * @property {validate.IBytesRules|null} [bytes] FieldRules bytes
         * @property {validate.IEnumRules|null} ["enum"] FieldRules enum
         * @property {validate.IRepeatedRules|null} [repeated] FieldRules repeated
         * @property {validate.IMapRules|null} [map] FieldRules map
         * @property {validate.IAnyRules|null} [any] FieldRules any
         * @property {validate.IDurationRules|null} [duration] FieldRules duration
         * @property {validate.ITimestampRules|null} [timestamp] FieldRules timestamp
         */

        /**
         * Constructs a new FieldRules.
         * @memberof validate
         * @classdesc Represents a FieldRules.
         * @implements IFieldRules
         * @constructor
         * @param {validate.IFieldRules=} [properties] Properties to set
         */
        function FieldRules(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FieldRules message.
         * @member {validate.IMessageRules|null|undefined} message
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.message = null;

        /**
         * FieldRules float.
         * @member {validate.IFloatRules|null|undefined} float
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.float = null;

        /**
         * FieldRules double.
         * @member {validate.IDoubleRules|null|undefined} double
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.double = null;

        /**
         * FieldRules int32.
         * @member {validate.IInt32Rules|null|undefined} int32
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.int32 = null;

        /**
         * FieldRules int64.
         * @member {validate.IInt64Rules|null|undefined} int64
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.int64 = null;

        /**
         * FieldRules uint32.
         * @member {validate.IUInt32Rules|null|undefined} uint32
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.uint32 = null;

        /**
         * FieldRules uint64.
         * @member {validate.IUInt64Rules|null|undefined} uint64
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.uint64 = null;

        /**
         * FieldRules sint32.
         * @member {validate.ISInt32Rules|null|undefined} sint32
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.sint32 = null;

        /**
         * FieldRules sint64.
         * @member {validate.ISInt64Rules|null|undefined} sint64
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.sint64 = null;

        /**
         * FieldRules fixed32.
         * @member {validate.IFixed32Rules|null|undefined} fixed32
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.fixed32 = null;

        /**
         * FieldRules fixed64.
         * @member {validate.IFixed64Rules|null|undefined} fixed64
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.fixed64 = null;

        /**
         * FieldRules sfixed32.
         * @member {validate.ISFixed32Rules|null|undefined} sfixed32
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.sfixed32 = null;

        /**
         * FieldRules sfixed64.
         * @member {validate.ISFixed64Rules|null|undefined} sfixed64
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.sfixed64 = null;

        /**
         * FieldRules bool.
         * @member {validate.IBoolRules|null|undefined} bool
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.bool = null;

        /**
         * FieldRules string.
         * @member {validate.IStringRules|null|undefined} string
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.string = null;

        /**
         * FieldRules bytes.
         * @member {validate.IBytesRules|null|undefined} bytes
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.bytes = null;

        /**
         * FieldRules enum.
         * @member {validate.IEnumRules|null|undefined} enum
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype["enum"] = null;

        /**
         * FieldRules repeated.
         * @member {validate.IRepeatedRules|null|undefined} repeated
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.repeated = null;

        /**
         * FieldRules map.
         * @member {validate.IMapRules|null|undefined} map
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.map = null;

        /**
         * FieldRules any.
         * @member {validate.IAnyRules|null|undefined} any
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.any = null;

        /**
         * FieldRules duration.
         * @member {validate.IDurationRules|null|undefined} duration
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.duration = null;

        /**
         * FieldRules timestamp.
         * @member {validate.ITimestampRules|null|undefined} timestamp
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.timestamp = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * FieldRules type.
         * @member {"float"|"double"|"int32"|"int64"|"uint32"|"uint64"|"sint32"|"sint64"|"fixed32"|"fixed64"|"sfixed32"|"sfixed64"|"bool"|"string"|"bytes"|"enum"|"repeated"|"map"|"any"|"duration"|"timestamp"|undefined} type
         * @memberof validate.FieldRules
         * @instance
         */
        Object.defineProperty(FieldRules.prototype, "type", {
            get: $util.oneOfGetter($oneOfFields = ["float", "double", "int32", "int64", "uint32", "uint64", "sint32", "sint64", "fixed32", "fixed64", "sfixed32", "sfixed64", "bool", "string", "bytes", "enum", "repeated", "map", "any", "duration", "timestamp"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Verifies a FieldRules message.
         * @function verify
         * @memberof validate.FieldRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FieldRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.message != null && message.hasOwnProperty("message")) {
                let error = $root.validate.MessageRules.verify(message.message);
                if (error)
                    return "message." + error;
            }
            if (message.float != null && message.hasOwnProperty("float")) {
                properties.type = 1;
                {
                    let error = $root.validate.FloatRules.verify(message.float);
                    if (error)
                        return "float." + error;
                }
            }
            if (message.double != null && message.hasOwnProperty("double")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.DoubleRules.verify(message.double);
                    if (error)
                        return "double." + error;
                }
            }
            if (message.int32 != null && message.hasOwnProperty("int32")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.Int32Rules.verify(message.int32);
                    if (error)
                        return "int32." + error;
                }
            }
            if (message.int64 != null && message.hasOwnProperty("int64")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.Int64Rules.verify(message.int64);
                    if (error)
                        return "int64." + error;
                }
            }
            if (message.uint32 != null && message.hasOwnProperty("uint32")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.UInt32Rules.verify(message.uint32);
                    if (error)
                        return "uint32." + error;
                }
            }
            if (message.uint64 != null && message.hasOwnProperty("uint64")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.UInt64Rules.verify(message.uint64);
                    if (error)
                        return "uint64." + error;
                }
            }
            if (message.sint32 != null && message.hasOwnProperty("sint32")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.SInt32Rules.verify(message.sint32);
                    if (error)
                        return "sint32." + error;
                }
            }
            if (message.sint64 != null && message.hasOwnProperty("sint64")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.SInt64Rules.verify(message.sint64);
                    if (error)
                        return "sint64." + error;
                }
            }
            if (message.fixed32 != null && message.hasOwnProperty("fixed32")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.Fixed32Rules.verify(message.fixed32);
                    if (error)
                        return "fixed32." + error;
                }
            }
            if (message.fixed64 != null && message.hasOwnProperty("fixed64")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.Fixed64Rules.verify(message.fixed64);
                    if (error)
                        return "fixed64." + error;
                }
            }
            if (message.sfixed32 != null && message.hasOwnProperty("sfixed32")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.SFixed32Rules.verify(message.sfixed32);
                    if (error)
                        return "sfixed32." + error;
                }
            }
            if (message.sfixed64 != null && message.hasOwnProperty("sfixed64")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.SFixed64Rules.verify(message.sfixed64);
                    if (error)
                        return "sfixed64." + error;
                }
            }
            if (message.bool != null && message.hasOwnProperty("bool")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.BoolRules.verify(message.bool);
                    if (error)
                        return "bool." + error;
                }
            }
            if (message.string != null && message.hasOwnProperty("string")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.StringRules.verify(message.string);
                    if (error)
                        return "string." + error;
                }
            }
            if (message.bytes != null && message.hasOwnProperty("bytes")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.BytesRules.verify(message.bytes);
                    if (error)
                        return "bytes." + error;
                }
            }
            if (message["enum"] != null && message.hasOwnProperty("enum")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.EnumRules.verify(message["enum"]);
                    if (error)
                        return "enum." + error;
                }
            }
            if (message.repeated != null && message.hasOwnProperty("repeated")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.RepeatedRules.verify(message.repeated);
                    if (error)
                        return "repeated." + error;
                }
            }
            if (message.map != null && message.hasOwnProperty("map")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.MapRules.verify(message.map);
                    if (error)
                        return "map." + error;
                }
            }
            if (message.any != null && message.hasOwnProperty("any")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.AnyRules.verify(message.any);
                    if (error)
                        return "any." + error;
                }
            }
            if (message.duration != null && message.hasOwnProperty("duration")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.DurationRules.verify(message.duration);
                    if (error)
                        return "duration." + error;
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.TimestampRules.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FieldRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.FieldRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.FieldRules} FieldRules
         */
        FieldRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.FieldRules)
                return object;
            let message = new $root.validate.FieldRules();
            if (object.message != null) {
                if (typeof object.message !== "object")
                    throw TypeError(".validate.FieldRules.message: object expected");
                message.message = $root.validate.MessageRules.fromObject(object.message);
            }
            if (object.float != null) {
                if (typeof object.float !== "object")
                    throw TypeError(".validate.FieldRules.float: object expected");
                message.float = $root.validate.FloatRules.fromObject(object.float);
            }
            if (object.double != null) {
                if (typeof object.double !== "object")
                    throw TypeError(".validate.FieldRules.double: object expected");
                message.double = $root.validate.DoubleRules.fromObject(object.double);
            }
            if (object.int32 != null) {
                if (typeof object.int32 !== "object")
                    throw TypeError(".validate.FieldRules.int32: object expected");
                message.int32 = $root.validate.Int32Rules.fromObject(object.int32);
            }
            if (object.int64 != null) {
                if (typeof object.int64 !== "object")
                    throw TypeError(".validate.FieldRules.int64: object expected");
                message.int64 = $root.validate.Int64Rules.fromObject(object.int64);
            }
            if (object.uint32 != null) {
                if (typeof object.uint32 !== "object")
                    throw TypeError(".validate.FieldRules.uint32: object expected");
                message.uint32 = $root.validate.UInt32Rules.fromObject(object.uint32);
            }
            if (object.uint64 != null) {
                if (typeof object.uint64 !== "object")
                    throw TypeError(".validate.FieldRules.uint64: object expected");
                message.uint64 = $root.validate.UInt64Rules.fromObject(object.uint64);
            }
            if (object.sint32 != null) {
                if (typeof object.sint32 !== "object")
                    throw TypeError(".validate.FieldRules.sint32: object expected");
                message.sint32 = $root.validate.SInt32Rules.fromObject(object.sint32);
            }
            if (object.sint64 != null) {
                if (typeof object.sint64 !== "object")
                    throw TypeError(".validate.FieldRules.sint64: object expected");
                message.sint64 = $root.validate.SInt64Rules.fromObject(object.sint64);
            }
            if (object.fixed32 != null) {
                if (typeof object.fixed32 !== "object")
                    throw TypeError(".validate.FieldRules.fixed32: object expected");
                message.fixed32 = $root.validate.Fixed32Rules.fromObject(object.fixed32);
            }
            if (object.fixed64 != null) {
                if (typeof object.fixed64 !== "object")
                    throw TypeError(".validate.FieldRules.fixed64: object expected");
                message.fixed64 = $root.validate.Fixed64Rules.fromObject(object.fixed64);
            }
            if (object.sfixed32 != null) {
                if (typeof object.sfixed32 !== "object")
                    throw TypeError(".validate.FieldRules.sfixed32: object expected");
                message.sfixed32 = $root.validate.SFixed32Rules.fromObject(object.sfixed32);
            }
            if (object.sfixed64 != null) {
                if (typeof object.sfixed64 !== "object")
                    throw TypeError(".validate.FieldRules.sfixed64: object expected");
                message.sfixed64 = $root.validate.SFixed64Rules.fromObject(object.sfixed64);
            }
            if (object.bool != null) {
                if (typeof object.bool !== "object")
                    throw TypeError(".validate.FieldRules.bool: object expected");
                message.bool = $root.validate.BoolRules.fromObject(object.bool);
            }
            if (object.string != null) {
                if (typeof object.string !== "object")
                    throw TypeError(".validate.FieldRules.string: object expected");
                message.string = $root.validate.StringRules.fromObject(object.string);
            }
            if (object.bytes != null) {
                if (typeof object.bytes !== "object")
                    throw TypeError(".validate.FieldRules.bytes: object expected");
                message.bytes = $root.validate.BytesRules.fromObject(object.bytes);
            }
            if (object["enum"] != null) {
                if (typeof object["enum"] !== "object")
                    throw TypeError(".validate.FieldRules.enum: object expected");
                message["enum"] = $root.validate.EnumRules.fromObject(object["enum"]);
            }
            if (object.repeated != null) {
                if (typeof object.repeated !== "object")
                    throw TypeError(".validate.FieldRules.repeated: object expected");
                message.repeated = $root.validate.RepeatedRules.fromObject(object.repeated);
            }
            if (object.map != null) {
                if (typeof object.map !== "object")
                    throw TypeError(".validate.FieldRules.map: object expected");
                message.map = $root.validate.MapRules.fromObject(object.map);
            }
            if (object.any != null) {
                if (typeof object.any !== "object")
                    throw TypeError(".validate.FieldRules.any: object expected");
                message.any = $root.validate.AnyRules.fromObject(object.any);
            }
            if (object.duration != null) {
                if (typeof object.duration !== "object")
                    throw TypeError(".validate.FieldRules.duration: object expected");
                message.duration = $root.validate.DurationRules.fromObject(object.duration);
            }
            if (object.timestamp != null) {
                if (typeof object.timestamp !== "object")
                    throw TypeError(".validate.FieldRules.timestamp: object expected");
                message.timestamp = $root.validate.TimestampRules.fromObject(object.timestamp);
            }
            return message;
        };

        /**
         * Creates a plain object from a FieldRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.FieldRules
         * @static
         * @param {validate.FieldRules} message FieldRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FieldRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.message = null;
            if (message.float != null && message.hasOwnProperty("float")) {
                object.float = $root.validate.FloatRules.toObject(message.float, options);
                if (options.oneofs)
                    object.type = "float";
            }
            if (message.double != null && message.hasOwnProperty("double")) {
                object.double = $root.validate.DoubleRules.toObject(message.double, options);
                if (options.oneofs)
                    object.type = "double";
            }
            if (message.int32 != null && message.hasOwnProperty("int32")) {
                object.int32 = $root.validate.Int32Rules.toObject(message.int32, options);
                if (options.oneofs)
                    object.type = "int32";
            }
            if (message.int64 != null && message.hasOwnProperty("int64")) {
                object.int64 = $root.validate.Int64Rules.toObject(message.int64, options);
                if (options.oneofs)
                    object.type = "int64";
            }
            if (message.uint32 != null && message.hasOwnProperty("uint32")) {
                object.uint32 = $root.validate.UInt32Rules.toObject(message.uint32, options);
                if (options.oneofs)
                    object.type = "uint32";
            }
            if (message.uint64 != null && message.hasOwnProperty("uint64")) {
                object.uint64 = $root.validate.UInt64Rules.toObject(message.uint64, options);
                if (options.oneofs)
                    object.type = "uint64";
            }
            if (message.sint32 != null && message.hasOwnProperty("sint32")) {
                object.sint32 = $root.validate.SInt32Rules.toObject(message.sint32, options);
                if (options.oneofs)
                    object.type = "sint32";
            }
            if (message.sint64 != null && message.hasOwnProperty("sint64")) {
                object.sint64 = $root.validate.SInt64Rules.toObject(message.sint64, options);
                if (options.oneofs)
                    object.type = "sint64";
            }
            if (message.fixed32 != null && message.hasOwnProperty("fixed32")) {
                object.fixed32 = $root.validate.Fixed32Rules.toObject(message.fixed32, options);
                if (options.oneofs)
                    object.type = "fixed32";
            }
            if (message.fixed64 != null && message.hasOwnProperty("fixed64")) {
                object.fixed64 = $root.validate.Fixed64Rules.toObject(message.fixed64, options);
                if (options.oneofs)
                    object.type = "fixed64";
            }
            if (message.sfixed32 != null && message.hasOwnProperty("sfixed32")) {
                object.sfixed32 = $root.validate.SFixed32Rules.toObject(message.sfixed32, options);
                if (options.oneofs)
                    object.type = "sfixed32";
            }
            if (message.sfixed64 != null && message.hasOwnProperty("sfixed64")) {
                object.sfixed64 = $root.validate.SFixed64Rules.toObject(message.sfixed64, options);
                if (options.oneofs)
                    object.type = "sfixed64";
            }
            if (message.bool != null && message.hasOwnProperty("bool")) {
                object.bool = $root.validate.BoolRules.toObject(message.bool, options);
                if (options.oneofs)
                    object.type = "bool";
            }
            if (message.string != null && message.hasOwnProperty("string")) {
                object.string = $root.validate.StringRules.toObject(message.string, options);
                if (options.oneofs)
                    object.type = "string";
            }
            if (message.bytes != null && message.hasOwnProperty("bytes")) {
                object.bytes = $root.validate.BytesRules.toObject(message.bytes, options);
                if (options.oneofs)
                    object.type = "bytes";
            }
            if (message["enum"] != null && message.hasOwnProperty("enum")) {
                object["enum"] = $root.validate.EnumRules.toObject(message["enum"], options);
                if (options.oneofs)
                    object.type = "enum";
            }
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = $root.validate.MessageRules.toObject(message.message, options);
            if (message.repeated != null && message.hasOwnProperty("repeated")) {
                object.repeated = $root.validate.RepeatedRules.toObject(message.repeated, options);
                if (options.oneofs)
                    object.type = "repeated";
            }
            if (message.map != null && message.hasOwnProperty("map")) {
                object.map = $root.validate.MapRules.toObject(message.map, options);
                if (options.oneofs)
                    object.type = "map";
            }
            if (message.any != null && message.hasOwnProperty("any")) {
                object.any = $root.validate.AnyRules.toObject(message.any, options);
                if (options.oneofs)
                    object.type = "any";
            }
            if (message.duration != null && message.hasOwnProperty("duration")) {
                object.duration = $root.validate.DurationRules.toObject(message.duration, options);
                if (options.oneofs)
                    object.type = "duration";
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                object.timestamp = $root.validate.TimestampRules.toObject(message.timestamp, options);
                if (options.oneofs)
                    object.type = "timestamp";
            }
            return object;
        };

        /**
         * Converts this FieldRules to JSON.
         * @function toJSON
         * @memberof validate.FieldRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FieldRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FieldRules;
    })();

    validate.FloatRules = (function() {

        /**
         * Properties of a FloatRules.
         * @memberof validate
         * @interface IFloatRules
         * @property {number|null} ["const"] FloatRules const
         * @property {number|null} [lt] FloatRules lt
         * @property {number|null} [lte] FloatRules lte
         * @property {number|null} [gt] FloatRules gt
         * @property {number|null} [gte] FloatRules gte
         * @property {Array.<number>|null} ["in"] FloatRules in
         * @property {Array.<number>|null} [notIn] FloatRules notIn
         * @property {boolean|null} [ignoreEmpty] FloatRules ignoreEmpty
         */

        /**
         * Constructs a new FloatRules.
         * @memberof validate
         * @classdesc Represents a FloatRules.
         * @implements IFloatRules
         * @constructor
         * @param {validate.IFloatRules=} [properties] Properties to set
         */
        function FloatRules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FloatRules const.
         * @member {number} const
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype["const"] = 0;

        /**
         * FloatRules lt.
         * @member {number} lt
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype.lt = 0;

        /**
         * FloatRules lte.
         * @member {number} lte
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype.lte = 0;

        /**
         * FloatRules gt.
         * @member {number} gt
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype.gt = 0;

        /**
         * FloatRules gte.
         * @member {number} gte
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype.gte = 0;

        /**
         * FloatRules in.
         * @member {Array.<number>} in
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype["in"] = $util.emptyArray;

        /**
         * FloatRules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype.notIn = $util.emptyArray;

        /**
         * FloatRules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype.ignoreEmpty = false;

        /**
         * Verifies a FloatRules message.
         * @function verify
         * @memberof validate.FloatRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FloatRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] !== "number")
                    return "const: number expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (typeof message.lt !== "number")
                    return "lt: number expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (typeof message.lte !== "number")
                    return "lte: number expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (typeof message.gt !== "number")
                    return "gt: number expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (typeof message.gte !== "number")
                    return "gte: number expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (typeof message["in"][i] !== "number")
                        return "in: number[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (typeof message.notIn[i] !== "number")
                        return "notIn: number[] expected";
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates a FloatRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.FloatRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.FloatRules} FloatRules
         */
        FloatRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.FloatRules)
                return object;
            let message = new $root.validate.FloatRules();
            if (object["const"] != null)
                message["const"] = Number(object["const"]);
            if (object.lt != null)
                message.lt = Number(object.lt);
            if (object.lte != null)
                message.lte = Number(object.lte);
            if (object.gt != null)
                message.gt = Number(object.gt);
            if (object.gte != null)
                message.gte = Number(object.gte);
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.FloatRules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = Number(object["in"][i]);
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.FloatRules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = Number(object.notIn[i]);
            }
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from a FloatRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.FloatRules
         * @static
         * @param {validate.FloatRules} message FloatRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FloatRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.lt = 0;
                object.lte = 0;
                object.gt = 0;
                object.gte = 0;
                object.ignoreEmpty = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = options.json && !isFinite(message["const"]) ? String(message["const"]) : message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = options.json && !isFinite(message.lt) ? String(message.lt) : message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = options.json && !isFinite(message.lte) ? String(message.lte) : message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = options.json && !isFinite(message.gt) ? String(message.gt) : message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = options.json && !isFinite(message.gte) ? String(message.gte) : message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = options.json && !isFinite(message["in"][j]) ? String(message["in"][j]) : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = options.json && !isFinite(message.notIn[j]) ? String(message.notIn[j]) : message.notIn[j];
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this FloatRules to JSON.
         * @function toJSON
         * @memberof validate.FloatRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FloatRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FloatRules;
    })();

    validate.DoubleRules = (function() {

        /**
         * Properties of a DoubleRules.
         * @memberof validate
         * @interface IDoubleRules
         * @property {number|null} ["const"] DoubleRules const
         * @property {number|null} [lt] DoubleRules lt
         * @property {number|null} [lte] DoubleRules lte
         * @property {number|null} [gt] DoubleRules gt
         * @property {number|null} [gte] DoubleRules gte
         * @property {Array.<number>|null} ["in"] DoubleRules in
         * @property {Array.<number>|null} [notIn] DoubleRules notIn
         * @property {boolean|null} [ignoreEmpty] DoubleRules ignoreEmpty
         */

        /**
         * Constructs a new DoubleRules.
         * @memberof validate
         * @classdesc Represents a DoubleRules.
         * @implements IDoubleRules
         * @constructor
         * @param {validate.IDoubleRules=} [properties] Properties to set
         */
        function DoubleRules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DoubleRules const.
         * @member {number} const
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype["const"] = 0;

        /**
         * DoubleRules lt.
         * @member {number} lt
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype.lt = 0;

        /**
         * DoubleRules lte.
         * @member {number} lte
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype.lte = 0;

        /**
         * DoubleRules gt.
         * @member {number} gt
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype.gt = 0;

        /**
         * DoubleRules gte.
         * @member {number} gte
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype.gte = 0;

        /**
         * DoubleRules in.
         * @member {Array.<number>} in
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype["in"] = $util.emptyArray;

        /**
         * DoubleRules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype.notIn = $util.emptyArray;

        /**
         * DoubleRules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype.ignoreEmpty = false;

        /**
         * Verifies a DoubleRules message.
         * @function verify
         * @memberof validate.DoubleRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DoubleRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] !== "number")
                    return "const: number expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (typeof message.lt !== "number")
                    return "lt: number expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (typeof message.lte !== "number")
                    return "lte: number expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (typeof message.gt !== "number")
                    return "gt: number expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (typeof message.gte !== "number")
                    return "gte: number expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (typeof message["in"][i] !== "number")
                        return "in: number[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (typeof message.notIn[i] !== "number")
                        return "notIn: number[] expected";
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates a DoubleRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.DoubleRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.DoubleRules} DoubleRules
         */
        DoubleRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.DoubleRules)
                return object;
            let message = new $root.validate.DoubleRules();
            if (object["const"] != null)
                message["const"] = Number(object["const"]);
            if (object.lt != null)
                message.lt = Number(object.lt);
            if (object.lte != null)
                message.lte = Number(object.lte);
            if (object.gt != null)
                message.gt = Number(object.gt);
            if (object.gte != null)
                message.gte = Number(object.gte);
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.DoubleRules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = Number(object["in"][i]);
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.DoubleRules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = Number(object.notIn[i]);
            }
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from a DoubleRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.DoubleRules
         * @static
         * @param {validate.DoubleRules} message DoubleRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DoubleRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.lt = 0;
                object.lte = 0;
                object.gt = 0;
                object.gte = 0;
                object.ignoreEmpty = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = options.json && !isFinite(message["const"]) ? String(message["const"]) : message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = options.json && !isFinite(message.lt) ? String(message.lt) : message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = options.json && !isFinite(message.lte) ? String(message.lte) : message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = options.json && !isFinite(message.gt) ? String(message.gt) : message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = options.json && !isFinite(message.gte) ? String(message.gte) : message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = options.json && !isFinite(message["in"][j]) ? String(message["in"][j]) : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = options.json && !isFinite(message.notIn[j]) ? String(message.notIn[j]) : message.notIn[j];
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this DoubleRules to JSON.
         * @function toJSON
         * @memberof validate.DoubleRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DoubleRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DoubleRules;
    })();

    validate.Int32Rules = (function() {

        /**
         * Properties of an Int32Rules.
         * @memberof validate
         * @interface IInt32Rules
         * @property {number|null} ["const"] Int32Rules const
         * @property {number|null} [lt] Int32Rules lt
         * @property {number|null} [lte] Int32Rules lte
         * @property {number|null} [gt] Int32Rules gt
         * @property {number|null} [gte] Int32Rules gte
         * @property {Array.<number>|null} ["in"] Int32Rules in
         * @property {Array.<number>|null} [notIn] Int32Rules notIn
         * @property {boolean|null} [ignoreEmpty] Int32Rules ignoreEmpty
         */

        /**
         * Constructs a new Int32Rules.
         * @memberof validate
         * @classdesc Represents an Int32Rules.
         * @implements IInt32Rules
         * @constructor
         * @param {validate.IInt32Rules=} [properties] Properties to set
         */
        function Int32Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Int32Rules const.
         * @member {number} const
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype["const"] = 0;

        /**
         * Int32Rules lt.
         * @member {number} lt
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype.lt = 0;

        /**
         * Int32Rules lte.
         * @member {number} lte
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype.lte = 0;

        /**
         * Int32Rules gt.
         * @member {number} gt
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype.gt = 0;

        /**
         * Int32Rules gte.
         * @member {number} gte
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype.gte = 0;

        /**
         * Int32Rules in.
         * @member {Array.<number>} in
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype["in"] = $util.emptyArray;

        /**
         * Int32Rules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype.notIn = $util.emptyArray;

        /**
         * Int32Rules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype.ignoreEmpty = false;

        /**
         * Verifies an Int32Rules message.
         * @function verify
         * @memberof validate.Int32Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Int32Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]))
                    return "const: integer expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt))
                    return "lt: integer expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte))
                    return "lte: integer expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt))
                    return "gt: integer expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte))
                    return "gte: integer expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]))
                        return "in: integer[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]))
                        return "notIn: integer[] expected";
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates an Int32Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.Int32Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.Int32Rules} Int32Rules
         */
        Int32Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.Int32Rules)
                return object;
            let message = new $root.validate.Int32Rules();
            if (object["const"] != null)
                message["const"] = object["const"] | 0;
            if (object.lt != null)
                message.lt = object.lt | 0;
            if (object.lte != null)
                message.lte = object.lte | 0;
            if (object.gt != null)
                message.gt = object.gt | 0;
            if (object.gte != null)
                message.gte = object.gte | 0;
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.Int32Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = object["in"][i] | 0;
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.Int32Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = object.notIn[i] | 0;
            }
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from an Int32Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.Int32Rules
         * @static
         * @param {validate.Int32Rules} message Int32Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Int32Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.lt = 0;
                object.lte = 0;
                object.gt = 0;
                object.gte = 0;
                object.ignoreEmpty = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this Int32Rules to JSON.
         * @function toJSON
         * @memberof validate.Int32Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Int32Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Int32Rules;
    })();

    validate.Int64Rules = (function() {

        /**
         * Properties of an Int64Rules.
         * @memberof validate
         * @interface IInt64Rules
         * @property {number|Long|null} ["const"] Int64Rules const
         * @property {number|Long|null} [lt] Int64Rules lt
         * @property {number|Long|null} [lte] Int64Rules lte
         * @property {number|Long|null} [gt] Int64Rules gt
         * @property {number|Long|null} [gte] Int64Rules gte
         * @property {Array.<number|Long>|null} ["in"] Int64Rules in
         * @property {Array.<number|Long>|null} [notIn] Int64Rules notIn
         * @property {boolean|null} [ignoreEmpty] Int64Rules ignoreEmpty
         */

        /**
         * Constructs a new Int64Rules.
         * @memberof validate
         * @classdesc Represents an Int64Rules.
         * @implements IInt64Rules
         * @constructor
         * @param {validate.IInt64Rules=} [properties] Properties to set
         */
        function Int64Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Int64Rules const.
         * @member {number|Long} const
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype["const"] = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Int64Rules lt.
         * @member {number|Long} lt
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype.lt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Int64Rules lte.
         * @member {number|Long} lte
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype.lte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Int64Rules gt.
         * @member {number|Long} gt
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype.gt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Int64Rules gte.
         * @member {number|Long} gte
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype.gte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Int64Rules in.
         * @member {Array.<number|Long>} in
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype["in"] = $util.emptyArray;

        /**
         * Int64Rules notIn.
         * @member {Array.<number|Long>} notIn
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype.notIn = $util.emptyArray;

        /**
         * Int64Rules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype.ignoreEmpty = false;

        /**
         * Verifies an Int64Rules message.
         * @function verify
         * @memberof validate.Int64Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Int64Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]) && !(message["const"] && $util.isInteger(message["const"].low) && $util.isInteger(message["const"].high)))
                    return "const: integer|Long expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt) && !(message.lt && $util.isInteger(message.lt.low) && $util.isInteger(message.lt.high)))
                    return "lt: integer|Long expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte) && !(message.lte && $util.isInteger(message.lte.low) && $util.isInteger(message.lte.high)))
                    return "lte: integer|Long expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt) && !(message.gt && $util.isInteger(message.gt.low) && $util.isInteger(message.gt.high)))
                    return "gt: integer|Long expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte) && !(message.gte && $util.isInteger(message.gte.low) && $util.isInteger(message.gte.high)))
                    return "gte: integer|Long expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]) && !(message["in"][i] && $util.isInteger(message["in"][i].low) && $util.isInteger(message["in"][i].high)))
                        return "in: integer|Long[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]) && !(message.notIn[i] && $util.isInteger(message.notIn[i].low) && $util.isInteger(message.notIn[i].high)))
                        return "notIn: integer|Long[] expected";
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates an Int64Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.Int64Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.Int64Rules} Int64Rules
         */
        Int64Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.Int64Rules)
                return object;
            let message = new $root.validate.Int64Rules();
            if (object["const"] != null)
                if ($util.Long)
                    (message["const"] = $util.Long.fromValue(object["const"])).unsigned = false;
                else if (typeof object["const"] === "string")
                    message["const"] = parseInt(object["const"], 10);
                else if (typeof object["const"] === "number")
                    message["const"] = object["const"];
                else if (typeof object["const"] === "object")
                    message["const"] = new $util.LongBits(object["const"].low >>> 0, object["const"].high >>> 0).toNumber();
            if (object.lt != null)
                if ($util.Long)
                    (message.lt = $util.Long.fromValue(object.lt)).unsigned = false;
                else if (typeof object.lt === "string")
                    message.lt = parseInt(object.lt, 10);
                else if (typeof object.lt === "number")
                    message.lt = object.lt;
                else if (typeof object.lt === "object")
                    message.lt = new $util.LongBits(object.lt.low >>> 0, object.lt.high >>> 0).toNumber();
            if (object.lte != null)
                if ($util.Long)
                    (message.lte = $util.Long.fromValue(object.lte)).unsigned = false;
                else if (typeof object.lte === "string")
                    message.lte = parseInt(object.lte, 10);
                else if (typeof object.lte === "number")
                    message.lte = object.lte;
                else if (typeof object.lte === "object")
                    message.lte = new $util.LongBits(object.lte.low >>> 0, object.lte.high >>> 0).toNumber();
            if (object.gt != null)
                if ($util.Long)
                    (message.gt = $util.Long.fromValue(object.gt)).unsigned = false;
                else if (typeof object.gt === "string")
                    message.gt = parseInt(object.gt, 10);
                else if (typeof object.gt === "number")
                    message.gt = object.gt;
                else if (typeof object.gt === "object")
                    message.gt = new $util.LongBits(object.gt.low >>> 0, object.gt.high >>> 0).toNumber();
            if (object.gte != null)
                if ($util.Long)
                    (message.gte = $util.Long.fromValue(object.gte)).unsigned = false;
                else if (typeof object.gte === "string")
                    message.gte = parseInt(object.gte, 10);
                else if (typeof object.gte === "number")
                    message.gte = object.gte;
                else if (typeof object.gte === "object")
                    message.gte = new $util.LongBits(object.gte.low >>> 0, object.gte.high >>> 0).toNumber();
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.Int64Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    if ($util.Long)
                        (message["in"][i] = $util.Long.fromValue(object["in"][i])).unsigned = false;
                    else if (typeof object["in"][i] === "string")
                        message["in"][i] = parseInt(object["in"][i], 10);
                    else if (typeof object["in"][i] === "number")
                        message["in"][i] = object["in"][i];
                    else if (typeof object["in"][i] === "object")
                        message["in"][i] = new $util.LongBits(object["in"][i].low >>> 0, object["in"][i].high >>> 0).toNumber();
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.Int64Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    if ($util.Long)
                        (message.notIn[i] = $util.Long.fromValue(object.notIn[i])).unsigned = false;
                    else if (typeof object.notIn[i] === "string")
                        message.notIn[i] = parseInt(object.notIn[i], 10);
                    else if (typeof object.notIn[i] === "number")
                        message.notIn[i] = object.notIn[i];
                    else if (typeof object.notIn[i] === "object")
                        message.notIn[i] = new $util.LongBits(object.notIn[i].low >>> 0, object.notIn[i].high >>> 0).toNumber();
            }
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from an Int64Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.Int64Rules
         * @static
         * @param {validate.Int64Rules} message Int64Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Int64Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object["const"] = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object["const"] = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lte = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gte = options.longs === String ? "0" : 0;
                object.ignoreEmpty = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] === "number")
                    object["const"] = options.longs === String ? String(message["const"]) : message["const"];
                else
                    object["const"] = options.longs === String ? $util.Long.prototype.toString.call(message["const"]) : options.longs === Number ? new $util.LongBits(message["const"].low >>> 0, message["const"].high >>> 0).toNumber() : message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (typeof message.lt === "number")
                    object.lt = options.longs === String ? String(message.lt) : message.lt;
                else
                    object.lt = options.longs === String ? $util.Long.prototype.toString.call(message.lt) : options.longs === Number ? new $util.LongBits(message.lt.low >>> 0, message.lt.high >>> 0).toNumber() : message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (typeof message.lte === "number")
                    object.lte = options.longs === String ? String(message.lte) : message.lte;
                else
                    object.lte = options.longs === String ? $util.Long.prototype.toString.call(message.lte) : options.longs === Number ? new $util.LongBits(message.lte.low >>> 0, message.lte.high >>> 0).toNumber() : message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (typeof message.gt === "number")
                    object.gt = options.longs === String ? String(message.gt) : message.gt;
                else
                    object.gt = options.longs === String ? $util.Long.prototype.toString.call(message.gt) : options.longs === Number ? new $util.LongBits(message.gt.low >>> 0, message.gt.high >>> 0).toNumber() : message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (typeof message.gte === "number")
                    object.gte = options.longs === String ? String(message.gte) : message.gte;
                else
                    object.gte = options.longs === String ? $util.Long.prototype.toString.call(message.gte) : options.longs === Number ? new $util.LongBits(message.gte.low >>> 0, message.gte.high >>> 0).toNumber() : message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    if (typeof message["in"][j] === "number")
                        object["in"][j] = options.longs === String ? String(message["in"][j]) : message["in"][j];
                    else
                        object["in"][j] = options.longs === String ? $util.Long.prototype.toString.call(message["in"][j]) : options.longs === Number ? new $util.LongBits(message["in"][j].low >>> 0, message["in"][j].high >>> 0).toNumber() : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    if (typeof message.notIn[j] === "number")
                        object.notIn[j] = options.longs === String ? String(message.notIn[j]) : message.notIn[j];
                    else
                        object.notIn[j] = options.longs === String ? $util.Long.prototype.toString.call(message.notIn[j]) : options.longs === Number ? new $util.LongBits(message.notIn[j].low >>> 0, message.notIn[j].high >>> 0).toNumber() : message.notIn[j];
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this Int64Rules to JSON.
         * @function toJSON
         * @memberof validate.Int64Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Int64Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Int64Rules;
    })();

    validate.UInt32Rules = (function() {

        /**
         * Properties of a UInt32Rules.
         * @memberof validate
         * @interface IUInt32Rules
         * @property {number|null} ["const"] UInt32Rules const
         * @property {number|null} [lt] UInt32Rules lt
         * @property {number|null} [lte] UInt32Rules lte
         * @property {number|null} [gt] UInt32Rules gt
         * @property {number|null} [gte] UInt32Rules gte
         * @property {Array.<number>|null} ["in"] UInt32Rules in
         * @property {Array.<number>|null} [notIn] UInt32Rules notIn
         * @property {boolean|null} [ignoreEmpty] UInt32Rules ignoreEmpty
         */

        /**
         * Constructs a new UInt32Rules.
         * @memberof validate
         * @classdesc Represents a UInt32Rules.
         * @implements IUInt32Rules
         * @constructor
         * @param {validate.IUInt32Rules=} [properties] Properties to set
         */
        function UInt32Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UInt32Rules const.
         * @member {number} const
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype["const"] = 0;

        /**
         * UInt32Rules lt.
         * @member {number} lt
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype.lt = 0;

        /**
         * UInt32Rules lte.
         * @member {number} lte
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype.lte = 0;

        /**
         * UInt32Rules gt.
         * @member {number} gt
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype.gt = 0;

        /**
         * UInt32Rules gte.
         * @member {number} gte
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype.gte = 0;

        /**
         * UInt32Rules in.
         * @member {Array.<number>} in
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype["in"] = $util.emptyArray;

        /**
         * UInt32Rules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype.notIn = $util.emptyArray;

        /**
         * UInt32Rules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype.ignoreEmpty = false;

        /**
         * Verifies a UInt32Rules message.
         * @function verify
         * @memberof validate.UInt32Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UInt32Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]))
                    return "const: integer expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt))
                    return "lt: integer expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte))
                    return "lte: integer expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt))
                    return "gt: integer expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte))
                    return "gte: integer expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]))
                        return "in: integer[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]))
                        return "notIn: integer[] expected";
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates a UInt32Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.UInt32Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.UInt32Rules} UInt32Rules
         */
        UInt32Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.UInt32Rules)
                return object;
            let message = new $root.validate.UInt32Rules();
            if (object["const"] != null)
                message["const"] = object["const"] >>> 0;
            if (object.lt != null)
                message.lt = object.lt >>> 0;
            if (object.lte != null)
                message.lte = object.lte >>> 0;
            if (object.gt != null)
                message.gt = object.gt >>> 0;
            if (object.gte != null)
                message.gte = object.gte >>> 0;
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.UInt32Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = object["in"][i] >>> 0;
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.UInt32Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = object.notIn[i] >>> 0;
            }
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from a UInt32Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.UInt32Rules
         * @static
         * @param {validate.UInt32Rules} message UInt32Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UInt32Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.lt = 0;
                object.lte = 0;
                object.gt = 0;
                object.gte = 0;
                object.ignoreEmpty = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this UInt32Rules to JSON.
         * @function toJSON
         * @memberof validate.UInt32Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UInt32Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UInt32Rules;
    })();

    validate.UInt64Rules = (function() {

        /**
         * Properties of a UInt64Rules.
         * @memberof validate
         * @interface IUInt64Rules
         * @property {number|Long|null} ["const"] UInt64Rules const
         * @property {number|Long|null} [lt] UInt64Rules lt
         * @property {number|Long|null} [lte] UInt64Rules lte
         * @property {number|Long|null} [gt] UInt64Rules gt
         * @property {number|Long|null} [gte] UInt64Rules gte
         * @property {Array.<number|Long>|null} ["in"] UInt64Rules in
         * @property {Array.<number|Long>|null} [notIn] UInt64Rules notIn
         * @property {boolean|null} [ignoreEmpty] UInt64Rules ignoreEmpty
         */

        /**
         * Constructs a new UInt64Rules.
         * @memberof validate
         * @classdesc Represents a UInt64Rules.
         * @implements IUInt64Rules
         * @constructor
         * @param {validate.IUInt64Rules=} [properties] Properties to set
         */
        function UInt64Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UInt64Rules const.
         * @member {number|Long} const
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype["const"] = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UInt64Rules lt.
         * @member {number|Long} lt
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype.lt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UInt64Rules lte.
         * @member {number|Long} lte
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype.lte = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UInt64Rules gt.
         * @member {number|Long} gt
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype.gt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UInt64Rules gte.
         * @member {number|Long} gte
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype.gte = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UInt64Rules in.
         * @member {Array.<number|Long>} in
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype["in"] = $util.emptyArray;

        /**
         * UInt64Rules notIn.
         * @member {Array.<number|Long>} notIn
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype.notIn = $util.emptyArray;

        /**
         * UInt64Rules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype.ignoreEmpty = false;

        /**
         * Verifies a UInt64Rules message.
         * @function verify
         * @memberof validate.UInt64Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UInt64Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]) && !(message["const"] && $util.isInteger(message["const"].low) && $util.isInteger(message["const"].high)))
                    return "const: integer|Long expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt) && !(message.lt && $util.isInteger(message.lt.low) && $util.isInteger(message.lt.high)))
                    return "lt: integer|Long expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte) && !(message.lte && $util.isInteger(message.lte.low) && $util.isInteger(message.lte.high)))
                    return "lte: integer|Long expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt) && !(message.gt && $util.isInteger(message.gt.low) && $util.isInteger(message.gt.high)))
                    return "gt: integer|Long expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte) && !(message.gte && $util.isInteger(message.gte.low) && $util.isInteger(message.gte.high)))
                    return "gte: integer|Long expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]) && !(message["in"][i] && $util.isInteger(message["in"][i].low) && $util.isInteger(message["in"][i].high)))
                        return "in: integer|Long[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]) && !(message.notIn[i] && $util.isInteger(message.notIn[i].low) && $util.isInteger(message.notIn[i].high)))
                        return "notIn: integer|Long[] expected";
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates a UInt64Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.UInt64Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.UInt64Rules} UInt64Rules
         */
        UInt64Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.UInt64Rules)
                return object;
            let message = new $root.validate.UInt64Rules();
            if (object["const"] != null)
                if ($util.Long)
                    (message["const"] = $util.Long.fromValue(object["const"])).unsigned = true;
                else if (typeof object["const"] === "string")
                    message["const"] = parseInt(object["const"], 10);
                else if (typeof object["const"] === "number")
                    message["const"] = object["const"];
                else if (typeof object["const"] === "object")
                    message["const"] = new $util.LongBits(object["const"].low >>> 0, object["const"].high >>> 0).toNumber(true);
            if (object.lt != null)
                if ($util.Long)
                    (message.lt = $util.Long.fromValue(object.lt)).unsigned = true;
                else if (typeof object.lt === "string")
                    message.lt = parseInt(object.lt, 10);
                else if (typeof object.lt === "number")
                    message.lt = object.lt;
                else if (typeof object.lt === "object")
                    message.lt = new $util.LongBits(object.lt.low >>> 0, object.lt.high >>> 0).toNumber(true);
            if (object.lte != null)
                if ($util.Long)
                    (message.lte = $util.Long.fromValue(object.lte)).unsigned = true;
                else if (typeof object.lte === "string")
                    message.lte = parseInt(object.lte, 10);
                else if (typeof object.lte === "number")
                    message.lte = object.lte;
                else if (typeof object.lte === "object")
                    message.lte = new $util.LongBits(object.lte.low >>> 0, object.lte.high >>> 0).toNumber(true);
            if (object.gt != null)
                if ($util.Long)
                    (message.gt = $util.Long.fromValue(object.gt)).unsigned = true;
                else if (typeof object.gt === "string")
                    message.gt = parseInt(object.gt, 10);
                else if (typeof object.gt === "number")
                    message.gt = object.gt;
                else if (typeof object.gt === "object")
                    message.gt = new $util.LongBits(object.gt.low >>> 0, object.gt.high >>> 0).toNumber(true);
            if (object.gte != null)
                if ($util.Long)
                    (message.gte = $util.Long.fromValue(object.gte)).unsigned = true;
                else if (typeof object.gte === "string")
                    message.gte = parseInt(object.gte, 10);
                else if (typeof object.gte === "number")
                    message.gte = object.gte;
                else if (typeof object.gte === "object")
                    message.gte = new $util.LongBits(object.gte.low >>> 0, object.gte.high >>> 0).toNumber(true);
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.UInt64Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    if ($util.Long)
                        (message["in"][i] = $util.Long.fromValue(object["in"][i])).unsigned = true;
                    else if (typeof object["in"][i] === "string")
                        message["in"][i] = parseInt(object["in"][i], 10);
                    else if (typeof object["in"][i] === "number")
                        message["in"][i] = object["in"][i];
                    else if (typeof object["in"][i] === "object")
                        message["in"][i] = new $util.LongBits(object["in"][i].low >>> 0, object["in"][i].high >>> 0).toNumber(true);
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.UInt64Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    if ($util.Long)
                        (message.notIn[i] = $util.Long.fromValue(object.notIn[i])).unsigned = true;
                    else if (typeof object.notIn[i] === "string")
                        message.notIn[i] = parseInt(object.notIn[i], 10);
                    else if (typeof object.notIn[i] === "number")
                        message.notIn[i] = object.notIn[i];
                    else if (typeof object.notIn[i] === "object")
                        message.notIn[i] = new $util.LongBits(object.notIn[i].low >>> 0, object.notIn[i].high >>> 0).toNumber(true);
            }
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from a UInt64Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.UInt64Rules
         * @static
         * @param {validate.UInt64Rules} message UInt64Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UInt64Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object["const"] = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object["const"] = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.lt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.lte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lte = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.gt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.gte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gte = options.longs === String ? "0" : 0;
                object.ignoreEmpty = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] === "number")
                    object["const"] = options.longs === String ? String(message["const"]) : message["const"];
                else
                    object["const"] = options.longs === String ? $util.Long.prototype.toString.call(message["const"]) : options.longs === Number ? new $util.LongBits(message["const"].low >>> 0, message["const"].high >>> 0).toNumber(true) : message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (typeof message.lt === "number")
                    object.lt = options.longs === String ? String(message.lt) : message.lt;
                else
                    object.lt = options.longs === String ? $util.Long.prototype.toString.call(message.lt) : options.longs === Number ? new $util.LongBits(message.lt.low >>> 0, message.lt.high >>> 0).toNumber(true) : message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (typeof message.lte === "number")
                    object.lte = options.longs === String ? String(message.lte) : message.lte;
                else
                    object.lte = options.longs === String ? $util.Long.prototype.toString.call(message.lte) : options.longs === Number ? new $util.LongBits(message.lte.low >>> 0, message.lte.high >>> 0).toNumber(true) : message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (typeof message.gt === "number")
                    object.gt = options.longs === String ? String(message.gt) : message.gt;
                else
                    object.gt = options.longs === String ? $util.Long.prototype.toString.call(message.gt) : options.longs === Number ? new $util.LongBits(message.gt.low >>> 0, message.gt.high >>> 0).toNumber(true) : message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (typeof message.gte === "number")
                    object.gte = options.longs === String ? String(message.gte) : message.gte;
                else
                    object.gte = options.longs === String ? $util.Long.prototype.toString.call(message.gte) : options.longs === Number ? new $util.LongBits(message.gte.low >>> 0, message.gte.high >>> 0).toNumber(true) : message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    if (typeof message["in"][j] === "number")
                        object["in"][j] = options.longs === String ? String(message["in"][j]) : message["in"][j];
                    else
                        object["in"][j] = options.longs === String ? $util.Long.prototype.toString.call(message["in"][j]) : options.longs === Number ? new $util.LongBits(message["in"][j].low >>> 0, message["in"][j].high >>> 0).toNumber(true) : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    if (typeof message.notIn[j] === "number")
                        object.notIn[j] = options.longs === String ? String(message.notIn[j]) : message.notIn[j];
                    else
                        object.notIn[j] = options.longs === String ? $util.Long.prototype.toString.call(message.notIn[j]) : options.longs === Number ? new $util.LongBits(message.notIn[j].low >>> 0, message.notIn[j].high >>> 0).toNumber(true) : message.notIn[j];
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this UInt64Rules to JSON.
         * @function toJSON
         * @memberof validate.UInt64Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UInt64Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UInt64Rules;
    })();

    validate.SInt32Rules = (function() {

        /**
         * Properties of a SInt32Rules.
         * @memberof validate
         * @interface ISInt32Rules
         * @property {number|null} ["const"] SInt32Rules const
         * @property {number|null} [lt] SInt32Rules lt
         * @property {number|null} [lte] SInt32Rules lte
         * @property {number|null} [gt] SInt32Rules gt
         * @property {number|null} [gte] SInt32Rules gte
         * @property {Array.<number>|null} ["in"] SInt32Rules in
         * @property {Array.<number>|null} [notIn] SInt32Rules notIn
         * @property {boolean|null} [ignoreEmpty] SInt32Rules ignoreEmpty
         */

        /**
         * Constructs a new SInt32Rules.
         * @memberof validate
         * @classdesc Represents a SInt32Rules.
         * @implements ISInt32Rules
         * @constructor
         * @param {validate.ISInt32Rules=} [properties] Properties to set
         */
        function SInt32Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SInt32Rules const.
         * @member {number} const
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype["const"] = 0;

        /**
         * SInt32Rules lt.
         * @member {number} lt
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype.lt = 0;

        /**
         * SInt32Rules lte.
         * @member {number} lte
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype.lte = 0;

        /**
         * SInt32Rules gt.
         * @member {number} gt
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype.gt = 0;

        /**
         * SInt32Rules gte.
         * @member {number} gte
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype.gte = 0;

        /**
         * SInt32Rules in.
         * @member {Array.<number>} in
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype["in"] = $util.emptyArray;

        /**
         * SInt32Rules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype.notIn = $util.emptyArray;

        /**
         * SInt32Rules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype.ignoreEmpty = false;

        /**
         * Verifies a SInt32Rules message.
         * @function verify
         * @memberof validate.SInt32Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SInt32Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]))
                    return "const: integer expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt))
                    return "lt: integer expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte))
                    return "lte: integer expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt))
                    return "gt: integer expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte))
                    return "gte: integer expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]))
                        return "in: integer[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]))
                        return "notIn: integer[] expected";
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates a SInt32Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.SInt32Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.SInt32Rules} SInt32Rules
         */
        SInt32Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.SInt32Rules)
                return object;
            let message = new $root.validate.SInt32Rules();
            if (object["const"] != null)
                message["const"] = object["const"] | 0;
            if (object.lt != null)
                message.lt = object.lt | 0;
            if (object.lte != null)
                message.lte = object.lte | 0;
            if (object.gt != null)
                message.gt = object.gt | 0;
            if (object.gte != null)
                message.gte = object.gte | 0;
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.SInt32Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = object["in"][i] | 0;
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.SInt32Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = object.notIn[i] | 0;
            }
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from a SInt32Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.SInt32Rules
         * @static
         * @param {validate.SInt32Rules} message SInt32Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SInt32Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.lt = 0;
                object.lte = 0;
                object.gt = 0;
                object.gte = 0;
                object.ignoreEmpty = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this SInt32Rules to JSON.
         * @function toJSON
         * @memberof validate.SInt32Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SInt32Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SInt32Rules;
    })();

    validate.SInt64Rules = (function() {

        /**
         * Properties of a SInt64Rules.
         * @memberof validate
         * @interface ISInt64Rules
         * @property {number|Long|null} ["const"] SInt64Rules const
         * @property {number|Long|null} [lt] SInt64Rules lt
         * @property {number|Long|null} [lte] SInt64Rules lte
         * @property {number|Long|null} [gt] SInt64Rules gt
         * @property {number|Long|null} [gte] SInt64Rules gte
         * @property {Array.<number|Long>|null} ["in"] SInt64Rules in
         * @property {Array.<number|Long>|null} [notIn] SInt64Rules notIn
         * @property {boolean|null} [ignoreEmpty] SInt64Rules ignoreEmpty
         */

        /**
         * Constructs a new SInt64Rules.
         * @memberof validate
         * @classdesc Represents a SInt64Rules.
         * @implements ISInt64Rules
         * @constructor
         * @param {validate.ISInt64Rules=} [properties] Properties to set
         */
        function SInt64Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SInt64Rules const.
         * @member {number|Long} const
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype["const"] = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SInt64Rules lt.
         * @member {number|Long} lt
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype.lt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SInt64Rules lte.
         * @member {number|Long} lte
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype.lte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SInt64Rules gt.
         * @member {number|Long} gt
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype.gt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SInt64Rules gte.
         * @member {number|Long} gte
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype.gte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SInt64Rules in.
         * @member {Array.<number|Long>} in
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype["in"] = $util.emptyArray;

        /**
         * SInt64Rules notIn.
         * @member {Array.<number|Long>} notIn
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype.notIn = $util.emptyArray;

        /**
         * SInt64Rules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype.ignoreEmpty = false;

        /**
         * Verifies a SInt64Rules message.
         * @function verify
         * @memberof validate.SInt64Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SInt64Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]) && !(message["const"] && $util.isInteger(message["const"].low) && $util.isInteger(message["const"].high)))
                    return "const: integer|Long expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt) && !(message.lt && $util.isInteger(message.lt.low) && $util.isInteger(message.lt.high)))
                    return "lt: integer|Long expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte) && !(message.lte && $util.isInteger(message.lte.low) && $util.isInteger(message.lte.high)))
                    return "lte: integer|Long expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt) && !(message.gt && $util.isInteger(message.gt.low) && $util.isInteger(message.gt.high)))
                    return "gt: integer|Long expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte) && !(message.gte && $util.isInteger(message.gte.low) && $util.isInteger(message.gte.high)))
                    return "gte: integer|Long expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]) && !(message["in"][i] && $util.isInteger(message["in"][i].low) && $util.isInteger(message["in"][i].high)))
                        return "in: integer|Long[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]) && !(message.notIn[i] && $util.isInteger(message.notIn[i].low) && $util.isInteger(message.notIn[i].high)))
                        return "notIn: integer|Long[] expected";
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates a SInt64Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.SInt64Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.SInt64Rules} SInt64Rules
         */
        SInt64Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.SInt64Rules)
                return object;
            let message = new $root.validate.SInt64Rules();
            if (object["const"] != null)
                if ($util.Long)
                    (message["const"] = $util.Long.fromValue(object["const"])).unsigned = false;
                else if (typeof object["const"] === "string")
                    message["const"] = parseInt(object["const"], 10);
                else if (typeof object["const"] === "number")
                    message["const"] = object["const"];
                else if (typeof object["const"] === "object")
                    message["const"] = new $util.LongBits(object["const"].low >>> 0, object["const"].high >>> 0).toNumber();
            if (object.lt != null)
                if ($util.Long)
                    (message.lt = $util.Long.fromValue(object.lt)).unsigned = false;
                else if (typeof object.lt === "string")
                    message.lt = parseInt(object.lt, 10);
                else if (typeof object.lt === "number")
                    message.lt = object.lt;
                else if (typeof object.lt === "object")
                    message.lt = new $util.LongBits(object.lt.low >>> 0, object.lt.high >>> 0).toNumber();
            if (object.lte != null)
                if ($util.Long)
                    (message.lte = $util.Long.fromValue(object.lte)).unsigned = false;
                else if (typeof object.lte === "string")
                    message.lte = parseInt(object.lte, 10);
                else if (typeof object.lte === "number")
                    message.lte = object.lte;
                else if (typeof object.lte === "object")
                    message.lte = new $util.LongBits(object.lte.low >>> 0, object.lte.high >>> 0).toNumber();
            if (object.gt != null)
                if ($util.Long)
                    (message.gt = $util.Long.fromValue(object.gt)).unsigned = false;
                else if (typeof object.gt === "string")
                    message.gt = parseInt(object.gt, 10);
                else if (typeof object.gt === "number")
                    message.gt = object.gt;
                else if (typeof object.gt === "object")
                    message.gt = new $util.LongBits(object.gt.low >>> 0, object.gt.high >>> 0).toNumber();
            if (object.gte != null)
                if ($util.Long)
                    (message.gte = $util.Long.fromValue(object.gte)).unsigned = false;
                else if (typeof object.gte === "string")
                    message.gte = parseInt(object.gte, 10);
                else if (typeof object.gte === "number")
                    message.gte = object.gte;
                else if (typeof object.gte === "object")
                    message.gte = new $util.LongBits(object.gte.low >>> 0, object.gte.high >>> 0).toNumber();
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.SInt64Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    if ($util.Long)
                        (message["in"][i] = $util.Long.fromValue(object["in"][i])).unsigned = false;
                    else if (typeof object["in"][i] === "string")
                        message["in"][i] = parseInt(object["in"][i], 10);
                    else if (typeof object["in"][i] === "number")
                        message["in"][i] = object["in"][i];
                    else if (typeof object["in"][i] === "object")
                        message["in"][i] = new $util.LongBits(object["in"][i].low >>> 0, object["in"][i].high >>> 0).toNumber();
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.SInt64Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    if ($util.Long)
                        (message.notIn[i] = $util.Long.fromValue(object.notIn[i])).unsigned = false;
                    else if (typeof object.notIn[i] === "string")
                        message.notIn[i] = parseInt(object.notIn[i], 10);
                    else if (typeof object.notIn[i] === "number")
                        message.notIn[i] = object.notIn[i];
                    else if (typeof object.notIn[i] === "object")
                        message.notIn[i] = new $util.LongBits(object.notIn[i].low >>> 0, object.notIn[i].high >>> 0).toNumber();
            }
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from a SInt64Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.SInt64Rules
         * @static
         * @param {validate.SInt64Rules} message SInt64Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SInt64Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object["const"] = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object["const"] = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lte = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gte = options.longs === String ? "0" : 0;
                object.ignoreEmpty = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] === "number")
                    object["const"] = options.longs === String ? String(message["const"]) : message["const"];
                else
                    object["const"] = options.longs === String ? $util.Long.prototype.toString.call(message["const"]) : options.longs === Number ? new $util.LongBits(message["const"].low >>> 0, message["const"].high >>> 0).toNumber() : message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (typeof message.lt === "number")
                    object.lt = options.longs === String ? String(message.lt) : message.lt;
                else
                    object.lt = options.longs === String ? $util.Long.prototype.toString.call(message.lt) : options.longs === Number ? new $util.LongBits(message.lt.low >>> 0, message.lt.high >>> 0).toNumber() : message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (typeof message.lte === "number")
                    object.lte = options.longs === String ? String(message.lte) : message.lte;
                else
                    object.lte = options.longs === String ? $util.Long.prototype.toString.call(message.lte) : options.longs === Number ? new $util.LongBits(message.lte.low >>> 0, message.lte.high >>> 0).toNumber() : message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (typeof message.gt === "number")
                    object.gt = options.longs === String ? String(message.gt) : message.gt;
                else
                    object.gt = options.longs === String ? $util.Long.prototype.toString.call(message.gt) : options.longs === Number ? new $util.LongBits(message.gt.low >>> 0, message.gt.high >>> 0).toNumber() : message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (typeof message.gte === "number")
                    object.gte = options.longs === String ? String(message.gte) : message.gte;
                else
                    object.gte = options.longs === String ? $util.Long.prototype.toString.call(message.gte) : options.longs === Number ? new $util.LongBits(message.gte.low >>> 0, message.gte.high >>> 0).toNumber() : message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    if (typeof message["in"][j] === "number")
                        object["in"][j] = options.longs === String ? String(message["in"][j]) : message["in"][j];
                    else
                        object["in"][j] = options.longs === String ? $util.Long.prototype.toString.call(message["in"][j]) : options.longs === Number ? new $util.LongBits(message["in"][j].low >>> 0, message["in"][j].high >>> 0).toNumber() : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    if (typeof message.notIn[j] === "number")
                        object.notIn[j] = options.longs === String ? String(message.notIn[j]) : message.notIn[j];
                    else
                        object.notIn[j] = options.longs === String ? $util.Long.prototype.toString.call(message.notIn[j]) : options.longs === Number ? new $util.LongBits(message.notIn[j].low >>> 0, message.notIn[j].high >>> 0).toNumber() : message.notIn[j];
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this SInt64Rules to JSON.
         * @function toJSON
         * @memberof validate.SInt64Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SInt64Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SInt64Rules;
    })();

    validate.Fixed32Rules = (function() {

        /**
         * Properties of a Fixed32Rules.
         * @memberof validate
         * @interface IFixed32Rules
         * @property {number|null} ["const"] Fixed32Rules const
         * @property {number|null} [lt] Fixed32Rules lt
         * @property {number|null} [lte] Fixed32Rules lte
         * @property {number|null} [gt] Fixed32Rules gt
         * @property {number|null} [gte] Fixed32Rules gte
         * @property {Array.<number>|null} ["in"] Fixed32Rules in
         * @property {Array.<number>|null} [notIn] Fixed32Rules notIn
         * @property {boolean|null} [ignoreEmpty] Fixed32Rules ignoreEmpty
         */

        /**
         * Constructs a new Fixed32Rules.
         * @memberof validate
         * @classdesc Represents a Fixed32Rules.
         * @implements IFixed32Rules
         * @constructor
         * @param {validate.IFixed32Rules=} [properties] Properties to set
         */
        function Fixed32Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Fixed32Rules const.
         * @member {number} const
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype["const"] = 0;

        /**
         * Fixed32Rules lt.
         * @member {number} lt
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype.lt = 0;

        /**
         * Fixed32Rules lte.
         * @member {number} lte
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype.lte = 0;

        /**
         * Fixed32Rules gt.
         * @member {number} gt
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype.gt = 0;

        /**
         * Fixed32Rules gte.
         * @member {number} gte
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype.gte = 0;

        /**
         * Fixed32Rules in.
         * @member {Array.<number>} in
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype["in"] = $util.emptyArray;

        /**
         * Fixed32Rules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype.notIn = $util.emptyArray;

        /**
         * Fixed32Rules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype.ignoreEmpty = false;

        /**
         * Verifies a Fixed32Rules message.
         * @function verify
         * @memberof validate.Fixed32Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Fixed32Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]))
                    return "const: integer expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt))
                    return "lt: integer expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte))
                    return "lte: integer expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt))
                    return "gt: integer expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte))
                    return "gte: integer expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]))
                        return "in: integer[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]))
                        return "notIn: integer[] expected";
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates a Fixed32Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.Fixed32Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.Fixed32Rules} Fixed32Rules
         */
        Fixed32Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.Fixed32Rules)
                return object;
            let message = new $root.validate.Fixed32Rules();
            if (object["const"] != null)
                message["const"] = object["const"] >>> 0;
            if (object.lt != null)
                message.lt = object.lt >>> 0;
            if (object.lte != null)
                message.lte = object.lte >>> 0;
            if (object.gt != null)
                message.gt = object.gt >>> 0;
            if (object.gte != null)
                message.gte = object.gte >>> 0;
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.Fixed32Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = object["in"][i] >>> 0;
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.Fixed32Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = object.notIn[i] >>> 0;
            }
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from a Fixed32Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.Fixed32Rules
         * @static
         * @param {validate.Fixed32Rules} message Fixed32Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Fixed32Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.lt = 0;
                object.lte = 0;
                object.gt = 0;
                object.gte = 0;
                object.ignoreEmpty = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this Fixed32Rules to JSON.
         * @function toJSON
         * @memberof validate.Fixed32Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Fixed32Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Fixed32Rules;
    })();

    validate.Fixed64Rules = (function() {

        /**
         * Properties of a Fixed64Rules.
         * @memberof validate
         * @interface IFixed64Rules
         * @property {number|Long|null} ["const"] Fixed64Rules const
         * @property {number|Long|null} [lt] Fixed64Rules lt
         * @property {number|Long|null} [lte] Fixed64Rules lte
         * @property {number|Long|null} [gt] Fixed64Rules gt
         * @property {number|Long|null} [gte] Fixed64Rules gte
         * @property {Array.<number|Long>|null} ["in"] Fixed64Rules in
         * @property {Array.<number|Long>|null} [notIn] Fixed64Rules notIn
         * @property {boolean|null} [ignoreEmpty] Fixed64Rules ignoreEmpty
         */

        /**
         * Constructs a new Fixed64Rules.
         * @memberof validate
         * @classdesc Represents a Fixed64Rules.
         * @implements IFixed64Rules
         * @constructor
         * @param {validate.IFixed64Rules=} [properties] Properties to set
         */
        function Fixed64Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Fixed64Rules const.
         * @member {number|Long} const
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype["const"] = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fixed64Rules lt.
         * @member {number|Long} lt
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype.lt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fixed64Rules lte.
         * @member {number|Long} lte
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype.lte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fixed64Rules gt.
         * @member {number|Long} gt
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype.gt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fixed64Rules gte.
         * @member {number|Long} gte
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype.gte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fixed64Rules in.
         * @member {Array.<number|Long>} in
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype["in"] = $util.emptyArray;

        /**
         * Fixed64Rules notIn.
         * @member {Array.<number|Long>} notIn
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype.notIn = $util.emptyArray;

        /**
         * Fixed64Rules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype.ignoreEmpty = false;

        /**
         * Verifies a Fixed64Rules message.
         * @function verify
         * @memberof validate.Fixed64Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Fixed64Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]) && !(message["const"] && $util.isInteger(message["const"].low) && $util.isInteger(message["const"].high)))
                    return "const: integer|Long expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt) && !(message.lt && $util.isInteger(message.lt.low) && $util.isInteger(message.lt.high)))
                    return "lt: integer|Long expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte) && !(message.lte && $util.isInteger(message.lte.low) && $util.isInteger(message.lte.high)))
                    return "lte: integer|Long expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt) && !(message.gt && $util.isInteger(message.gt.low) && $util.isInteger(message.gt.high)))
                    return "gt: integer|Long expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte) && !(message.gte && $util.isInteger(message.gte.low) && $util.isInteger(message.gte.high)))
                    return "gte: integer|Long expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]) && !(message["in"][i] && $util.isInteger(message["in"][i].low) && $util.isInteger(message["in"][i].high)))
                        return "in: integer|Long[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]) && !(message.notIn[i] && $util.isInteger(message.notIn[i].low) && $util.isInteger(message.notIn[i].high)))
                        return "notIn: integer|Long[] expected";
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates a Fixed64Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.Fixed64Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.Fixed64Rules} Fixed64Rules
         */
        Fixed64Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.Fixed64Rules)
                return object;
            let message = new $root.validate.Fixed64Rules();
            if (object["const"] != null)
                if ($util.Long)
                    (message["const"] = $util.Long.fromValue(object["const"])).unsigned = false;
                else if (typeof object["const"] === "string")
                    message["const"] = parseInt(object["const"], 10);
                else if (typeof object["const"] === "number")
                    message["const"] = object["const"];
                else if (typeof object["const"] === "object")
                    message["const"] = new $util.LongBits(object["const"].low >>> 0, object["const"].high >>> 0).toNumber();
            if (object.lt != null)
                if ($util.Long)
                    (message.lt = $util.Long.fromValue(object.lt)).unsigned = false;
                else if (typeof object.lt === "string")
                    message.lt = parseInt(object.lt, 10);
                else if (typeof object.lt === "number")
                    message.lt = object.lt;
                else if (typeof object.lt === "object")
                    message.lt = new $util.LongBits(object.lt.low >>> 0, object.lt.high >>> 0).toNumber();
            if (object.lte != null)
                if ($util.Long)
                    (message.lte = $util.Long.fromValue(object.lte)).unsigned = false;
                else if (typeof object.lte === "string")
                    message.lte = parseInt(object.lte, 10);
                else if (typeof object.lte === "number")
                    message.lte = object.lte;
                else if (typeof object.lte === "object")
                    message.lte = new $util.LongBits(object.lte.low >>> 0, object.lte.high >>> 0).toNumber();
            if (object.gt != null)
                if ($util.Long)
                    (message.gt = $util.Long.fromValue(object.gt)).unsigned = false;
                else if (typeof object.gt === "string")
                    message.gt = parseInt(object.gt, 10);
                else if (typeof object.gt === "number")
                    message.gt = object.gt;
                else if (typeof object.gt === "object")
                    message.gt = new $util.LongBits(object.gt.low >>> 0, object.gt.high >>> 0).toNumber();
            if (object.gte != null)
                if ($util.Long)
                    (message.gte = $util.Long.fromValue(object.gte)).unsigned = false;
                else if (typeof object.gte === "string")
                    message.gte = parseInt(object.gte, 10);
                else if (typeof object.gte === "number")
                    message.gte = object.gte;
                else if (typeof object.gte === "object")
                    message.gte = new $util.LongBits(object.gte.low >>> 0, object.gte.high >>> 0).toNumber();
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.Fixed64Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    if ($util.Long)
                        (message["in"][i] = $util.Long.fromValue(object["in"][i])).unsigned = false;
                    else if (typeof object["in"][i] === "string")
                        message["in"][i] = parseInt(object["in"][i], 10);
                    else if (typeof object["in"][i] === "number")
                        message["in"][i] = object["in"][i];
                    else if (typeof object["in"][i] === "object")
                        message["in"][i] = new $util.LongBits(object["in"][i].low >>> 0, object["in"][i].high >>> 0).toNumber();
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.Fixed64Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    if ($util.Long)
                        (message.notIn[i] = $util.Long.fromValue(object.notIn[i])).unsigned = false;
                    else if (typeof object.notIn[i] === "string")
                        message.notIn[i] = parseInt(object.notIn[i], 10);
                    else if (typeof object.notIn[i] === "number")
                        message.notIn[i] = object.notIn[i];
                    else if (typeof object.notIn[i] === "object")
                        message.notIn[i] = new $util.LongBits(object.notIn[i].low >>> 0, object.notIn[i].high >>> 0).toNumber();
            }
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from a Fixed64Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.Fixed64Rules
         * @static
         * @param {validate.Fixed64Rules} message Fixed64Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Fixed64Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object["const"] = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object["const"] = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lte = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gte = options.longs === String ? "0" : 0;
                object.ignoreEmpty = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] === "number")
                    object["const"] = options.longs === String ? String(message["const"]) : message["const"];
                else
                    object["const"] = options.longs === String ? $util.Long.prototype.toString.call(message["const"]) : options.longs === Number ? new $util.LongBits(message["const"].low >>> 0, message["const"].high >>> 0).toNumber() : message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (typeof message.lt === "number")
                    object.lt = options.longs === String ? String(message.lt) : message.lt;
                else
                    object.lt = options.longs === String ? $util.Long.prototype.toString.call(message.lt) : options.longs === Number ? new $util.LongBits(message.lt.low >>> 0, message.lt.high >>> 0).toNumber() : message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (typeof message.lte === "number")
                    object.lte = options.longs === String ? String(message.lte) : message.lte;
                else
                    object.lte = options.longs === String ? $util.Long.prototype.toString.call(message.lte) : options.longs === Number ? new $util.LongBits(message.lte.low >>> 0, message.lte.high >>> 0).toNumber() : message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (typeof message.gt === "number")
                    object.gt = options.longs === String ? String(message.gt) : message.gt;
                else
                    object.gt = options.longs === String ? $util.Long.prototype.toString.call(message.gt) : options.longs === Number ? new $util.LongBits(message.gt.low >>> 0, message.gt.high >>> 0).toNumber() : message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (typeof message.gte === "number")
                    object.gte = options.longs === String ? String(message.gte) : message.gte;
                else
                    object.gte = options.longs === String ? $util.Long.prototype.toString.call(message.gte) : options.longs === Number ? new $util.LongBits(message.gte.low >>> 0, message.gte.high >>> 0).toNumber() : message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    if (typeof message["in"][j] === "number")
                        object["in"][j] = options.longs === String ? String(message["in"][j]) : message["in"][j];
                    else
                        object["in"][j] = options.longs === String ? $util.Long.prototype.toString.call(message["in"][j]) : options.longs === Number ? new $util.LongBits(message["in"][j].low >>> 0, message["in"][j].high >>> 0).toNumber() : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    if (typeof message.notIn[j] === "number")
                        object.notIn[j] = options.longs === String ? String(message.notIn[j]) : message.notIn[j];
                    else
                        object.notIn[j] = options.longs === String ? $util.Long.prototype.toString.call(message.notIn[j]) : options.longs === Number ? new $util.LongBits(message.notIn[j].low >>> 0, message.notIn[j].high >>> 0).toNumber() : message.notIn[j];
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this Fixed64Rules to JSON.
         * @function toJSON
         * @memberof validate.Fixed64Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Fixed64Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Fixed64Rules;
    })();

    validate.SFixed32Rules = (function() {

        /**
         * Properties of a SFixed32Rules.
         * @memberof validate
         * @interface ISFixed32Rules
         * @property {number|null} ["const"] SFixed32Rules const
         * @property {number|null} [lt] SFixed32Rules lt
         * @property {number|null} [lte] SFixed32Rules lte
         * @property {number|null} [gt] SFixed32Rules gt
         * @property {number|null} [gte] SFixed32Rules gte
         * @property {Array.<number>|null} ["in"] SFixed32Rules in
         * @property {Array.<number>|null} [notIn] SFixed32Rules notIn
         * @property {boolean|null} [ignoreEmpty] SFixed32Rules ignoreEmpty
         */

        /**
         * Constructs a new SFixed32Rules.
         * @memberof validate
         * @classdesc Represents a SFixed32Rules.
         * @implements ISFixed32Rules
         * @constructor
         * @param {validate.ISFixed32Rules=} [properties] Properties to set
         */
        function SFixed32Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SFixed32Rules const.
         * @member {number} const
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype["const"] = 0;

        /**
         * SFixed32Rules lt.
         * @member {number} lt
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype.lt = 0;

        /**
         * SFixed32Rules lte.
         * @member {number} lte
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype.lte = 0;

        /**
         * SFixed32Rules gt.
         * @member {number} gt
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype.gt = 0;

        /**
         * SFixed32Rules gte.
         * @member {number} gte
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype.gte = 0;

        /**
         * SFixed32Rules in.
         * @member {Array.<number>} in
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype["in"] = $util.emptyArray;

        /**
         * SFixed32Rules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype.notIn = $util.emptyArray;

        /**
         * SFixed32Rules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype.ignoreEmpty = false;

        /**
         * Verifies a SFixed32Rules message.
         * @function verify
         * @memberof validate.SFixed32Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SFixed32Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]))
                    return "const: integer expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt))
                    return "lt: integer expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte))
                    return "lte: integer expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt))
                    return "gt: integer expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte))
                    return "gte: integer expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]))
                        return "in: integer[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]))
                        return "notIn: integer[] expected";
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates a SFixed32Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.SFixed32Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.SFixed32Rules} SFixed32Rules
         */
        SFixed32Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.SFixed32Rules)
                return object;
            let message = new $root.validate.SFixed32Rules();
            if (object["const"] != null)
                message["const"] = object["const"] | 0;
            if (object.lt != null)
                message.lt = object.lt | 0;
            if (object.lte != null)
                message.lte = object.lte | 0;
            if (object.gt != null)
                message.gt = object.gt | 0;
            if (object.gte != null)
                message.gte = object.gte | 0;
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.SFixed32Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = object["in"][i] | 0;
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.SFixed32Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = object.notIn[i] | 0;
            }
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from a SFixed32Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.SFixed32Rules
         * @static
         * @param {validate.SFixed32Rules} message SFixed32Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SFixed32Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.lt = 0;
                object.lte = 0;
                object.gt = 0;
                object.gte = 0;
                object.ignoreEmpty = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this SFixed32Rules to JSON.
         * @function toJSON
         * @memberof validate.SFixed32Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SFixed32Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SFixed32Rules;
    })();

    validate.SFixed64Rules = (function() {

        /**
         * Properties of a SFixed64Rules.
         * @memberof validate
         * @interface ISFixed64Rules
         * @property {number|Long|null} ["const"] SFixed64Rules const
         * @property {number|Long|null} [lt] SFixed64Rules lt
         * @property {number|Long|null} [lte] SFixed64Rules lte
         * @property {number|Long|null} [gt] SFixed64Rules gt
         * @property {number|Long|null} [gte] SFixed64Rules gte
         * @property {Array.<number|Long>|null} ["in"] SFixed64Rules in
         * @property {Array.<number|Long>|null} [notIn] SFixed64Rules notIn
         * @property {boolean|null} [ignoreEmpty] SFixed64Rules ignoreEmpty
         */

        /**
         * Constructs a new SFixed64Rules.
         * @memberof validate
         * @classdesc Represents a SFixed64Rules.
         * @implements ISFixed64Rules
         * @constructor
         * @param {validate.ISFixed64Rules=} [properties] Properties to set
         */
        function SFixed64Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SFixed64Rules const.
         * @member {number|Long} const
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype["const"] = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SFixed64Rules lt.
         * @member {number|Long} lt
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype.lt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SFixed64Rules lte.
         * @member {number|Long} lte
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype.lte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SFixed64Rules gt.
         * @member {number|Long} gt
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype.gt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SFixed64Rules gte.
         * @member {number|Long} gte
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype.gte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SFixed64Rules in.
         * @member {Array.<number|Long>} in
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype["in"] = $util.emptyArray;

        /**
         * SFixed64Rules notIn.
         * @member {Array.<number|Long>} notIn
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype.notIn = $util.emptyArray;

        /**
         * SFixed64Rules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype.ignoreEmpty = false;

        /**
         * Verifies a SFixed64Rules message.
         * @function verify
         * @memberof validate.SFixed64Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SFixed64Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]) && !(message["const"] && $util.isInteger(message["const"].low) && $util.isInteger(message["const"].high)))
                    return "const: integer|Long expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt) && !(message.lt && $util.isInteger(message.lt.low) && $util.isInteger(message.lt.high)))
                    return "lt: integer|Long expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte) && !(message.lte && $util.isInteger(message.lte.low) && $util.isInteger(message.lte.high)))
                    return "lte: integer|Long expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt) && !(message.gt && $util.isInteger(message.gt.low) && $util.isInteger(message.gt.high)))
                    return "gt: integer|Long expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte) && !(message.gte && $util.isInteger(message.gte.low) && $util.isInteger(message.gte.high)))
                    return "gte: integer|Long expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]) && !(message["in"][i] && $util.isInteger(message["in"][i].low) && $util.isInteger(message["in"][i].high)))
                        return "in: integer|Long[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]) && !(message.notIn[i] && $util.isInteger(message.notIn[i].low) && $util.isInteger(message.notIn[i].high)))
                        return "notIn: integer|Long[] expected";
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates a SFixed64Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.SFixed64Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.SFixed64Rules} SFixed64Rules
         */
        SFixed64Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.SFixed64Rules)
                return object;
            let message = new $root.validate.SFixed64Rules();
            if (object["const"] != null)
                if ($util.Long)
                    (message["const"] = $util.Long.fromValue(object["const"])).unsigned = false;
                else if (typeof object["const"] === "string")
                    message["const"] = parseInt(object["const"], 10);
                else if (typeof object["const"] === "number")
                    message["const"] = object["const"];
                else if (typeof object["const"] === "object")
                    message["const"] = new $util.LongBits(object["const"].low >>> 0, object["const"].high >>> 0).toNumber();
            if (object.lt != null)
                if ($util.Long)
                    (message.lt = $util.Long.fromValue(object.lt)).unsigned = false;
                else if (typeof object.lt === "string")
                    message.lt = parseInt(object.lt, 10);
                else if (typeof object.lt === "number")
                    message.lt = object.lt;
                else if (typeof object.lt === "object")
                    message.lt = new $util.LongBits(object.lt.low >>> 0, object.lt.high >>> 0).toNumber();
            if (object.lte != null)
                if ($util.Long)
                    (message.lte = $util.Long.fromValue(object.lte)).unsigned = false;
                else if (typeof object.lte === "string")
                    message.lte = parseInt(object.lte, 10);
                else if (typeof object.lte === "number")
                    message.lte = object.lte;
                else if (typeof object.lte === "object")
                    message.lte = new $util.LongBits(object.lte.low >>> 0, object.lte.high >>> 0).toNumber();
            if (object.gt != null)
                if ($util.Long)
                    (message.gt = $util.Long.fromValue(object.gt)).unsigned = false;
                else if (typeof object.gt === "string")
                    message.gt = parseInt(object.gt, 10);
                else if (typeof object.gt === "number")
                    message.gt = object.gt;
                else if (typeof object.gt === "object")
                    message.gt = new $util.LongBits(object.gt.low >>> 0, object.gt.high >>> 0).toNumber();
            if (object.gte != null)
                if ($util.Long)
                    (message.gte = $util.Long.fromValue(object.gte)).unsigned = false;
                else if (typeof object.gte === "string")
                    message.gte = parseInt(object.gte, 10);
                else if (typeof object.gte === "number")
                    message.gte = object.gte;
                else if (typeof object.gte === "object")
                    message.gte = new $util.LongBits(object.gte.low >>> 0, object.gte.high >>> 0).toNumber();
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.SFixed64Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    if ($util.Long)
                        (message["in"][i] = $util.Long.fromValue(object["in"][i])).unsigned = false;
                    else if (typeof object["in"][i] === "string")
                        message["in"][i] = parseInt(object["in"][i], 10);
                    else if (typeof object["in"][i] === "number")
                        message["in"][i] = object["in"][i];
                    else if (typeof object["in"][i] === "object")
                        message["in"][i] = new $util.LongBits(object["in"][i].low >>> 0, object["in"][i].high >>> 0).toNumber();
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.SFixed64Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    if ($util.Long)
                        (message.notIn[i] = $util.Long.fromValue(object.notIn[i])).unsigned = false;
                    else if (typeof object.notIn[i] === "string")
                        message.notIn[i] = parseInt(object.notIn[i], 10);
                    else if (typeof object.notIn[i] === "number")
                        message.notIn[i] = object.notIn[i];
                    else if (typeof object.notIn[i] === "object")
                        message.notIn[i] = new $util.LongBits(object.notIn[i].low >>> 0, object.notIn[i].high >>> 0).toNumber();
            }
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from a SFixed64Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.SFixed64Rules
         * @static
         * @param {validate.SFixed64Rules} message SFixed64Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SFixed64Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object["const"] = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object["const"] = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lte = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gte = options.longs === String ? "0" : 0;
                object.ignoreEmpty = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] === "number")
                    object["const"] = options.longs === String ? String(message["const"]) : message["const"];
                else
                    object["const"] = options.longs === String ? $util.Long.prototype.toString.call(message["const"]) : options.longs === Number ? new $util.LongBits(message["const"].low >>> 0, message["const"].high >>> 0).toNumber() : message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (typeof message.lt === "number")
                    object.lt = options.longs === String ? String(message.lt) : message.lt;
                else
                    object.lt = options.longs === String ? $util.Long.prototype.toString.call(message.lt) : options.longs === Number ? new $util.LongBits(message.lt.low >>> 0, message.lt.high >>> 0).toNumber() : message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (typeof message.lte === "number")
                    object.lte = options.longs === String ? String(message.lte) : message.lte;
                else
                    object.lte = options.longs === String ? $util.Long.prototype.toString.call(message.lte) : options.longs === Number ? new $util.LongBits(message.lte.low >>> 0, message.lte.high >>> 0).toNumber() : message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (typeof message.gt === "number")
                    object.gt = options.longs === String ? String(message.gt) : message.gt;
                else
                    object.gt = options.longs === String ? $util.Long.prototype.toString.call(message.gt) : options.longs === Number ? new $util.LongBits(message.gt.low >>> 0, message.gt.high >>> 0).toNumber() : message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (typeof message.gte === "number")
                    object.gte = options.longs === String ? String(message.gte) : message.gte;
                else
                    object.gte = options.longs === String ? $util.Long.prototype.toString.call(message.gte) : options.longs === Number ? new $util.LongBits(message.gte.low >>> 0, message.gte.high >>> 0).toNumber() : message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    if (typeof message["in"][j] === "number")
                        object["in"][j] = options.longs === String ? String(message["in"][j]) : message["in"][j];
                    else
                        object["in"][j] = options.longs === String ? $util.Long.prototype.toString.call(message["in"][j]) : options.longs === Number ? new $util.LongBits(message["in"][j].low >>> 0, message["in"][j].high >>> 0).toNumber() : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    if (typeof message.notIn[j] === "number")
                        object.notIn[j] = options.longs === String ? String(message.notIn[j]) : message.notIn[j];
                    else
                        object.notIn[j] = options.longs === String ? $util.Long.prototype.toString.call(message.notIn[j]) : options.longs === Number ? new $util.LongBits(message.notIn[j].low >>> 0, message.notIn[j].high >>> 0).toNumber() : message.notIn[j];
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this SFixed64Rules to JSON.
         * @function toJSON
         * @memberof validate.SFixed64Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SFixed64Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SFixed64Rules;
    })();

    validate.BoolRules = (function() {

        /**
         * Properties of a BoolRules.
         * @memberof validate
         * @interface IBoolRules
         * @property {boolean|null} ["const"] BoolRules const
         */

        /**
         * Constructs a new BoolRules.
         * @memberof validate
         * @classdesc Represents a BoolRules.
         * @implements IBoolRules
         * @constructor
         * @param {validate.IBoolRules=} [properties] Properties to set
         */
        function BoolRules(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BoolRules const.
         * @member {boolean} const
         * @memberof validate.BoolRules
         * @instance
         */
        BoolRules.prototype["const"] = false;

        /**
         * Verifies a BoolRules message.
         * @function verify
         * @memberof validate.BoolRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BoolRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] !== "boolean")
                    return "const: boolean expected";
            return null;
        };

        /**
         * Creates a BoolRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.BoolRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.BoolRules} BoolRules
         */
        BoolRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.BoolRules)
                return object;
            let message = new $root.validate.BoolRules();
            if (object["const"] != null)
                message["const"] = Boolean(object["const"]);
            return message;
        };

        /**
         * Creates a plain object from a BoolRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.BoolRules
         * @static
         * @param {validate.BoolRules} message BoolRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BoolRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object["const"] = false;
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            return object;
        };

        /**
         * Converts this BoolRules to JSON.
         * @function toJSON
         * @memberof validate.BoolRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BoolRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BoolRules;
    })();

    validate.StringRules = (function() {

        /**
         * Properties of a StringRules.
         * @memberof validate
         * @interface IStringRules
         * @property {string|null} ["const"] StringRules const
         * @property {number|Long|null} [len] StringRules len
         * @property {number|Long|null} [minLen] StringRules minLen
         * @property {number|Long|null} [maxLen] StringRules maxLen
         * @property {number|Long|null} [lenBytes] StringRules lenBytes
         * @property {number|Long|null} [minBytes] StringRules minBytes
         * @property {number|Long|null} [maxBytes] StringRules maxBytes
         * @property {string|null} [pattern] StringRules pattern
         * @property {string|null} [prefix] StringRules prefix
         * @property {string|null} [suffix] StringRules suffix
         * @property {string|null} [contains] StringRules contains
         * @property {string|null} [notContains] StringRules notContains
         * @property {Array.<string>|null} ["in"] StringRules in
         * @property {Array.<string>|null} [notIn] StringRules notIn
         * @property {boolean|null} [email] StringRules email
         * @property {boolean|null} [hostname] StringRules hostname
         * @property {boolean|null} [ip] StringRules ip
         * @property {boolean|null} [ipv4] StringRules ipv4
         * @property {boolean|null} [ipv6] StringRules ipv6
         * @property {boolean|null} [uri] StringRules uri
         * @property {boolean|null} [uriRef] StringRules uriRef
         * @property {boolean|null} [address] StringRules address
         * @property {boolean|null} [uuid] StringRules uuid
         * @property {validate.KnownRegex|null} [wellKnownRegex] StringRules wellKnownRegex
         * @property {boolean|null} [strict] StringRules strict
         * @property {boolean|null} [ignoreEmpty] StringRules ignoreEmpty
         */

        /**
         * Constructs a new StringRules.
         * @memberof validate
         * @classdesc Represents a StringRules.
         * @implements IStringRules
         * @constructor
         * @param {validate.IStringRules=} [properties] Properties to set
         */
        function StringRules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StringRules const.
         * @member {string} const
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype["const"] = "";

        /**
         * StringRules len.
         * @member {number|Long} len
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.len = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StringRules minLen.
         * @member {number|Long} minLen
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.minLen = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StringRules maxLen.
         * @member {number|Long} maxLen
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.maxLen = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StringRules lenBytes.
         * @member {number|Long} lenBytes
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.lenBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StringRules minBytes.
         * @member {number|Long} minBytes
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.minBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StringRules maxBytes.
         * @member {number|Long} maxBytes
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.maxBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StringRules pattern.
         * @member {string} pattern
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.pattern = "";

        /**
         * StringRules prefix.
         * @member {string} prefix
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.prefix = "";

        /**
         * StringRules suffix.
         * @member {string} suffix
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.suffix = "";

        /**
         * StringRules contains.
         * @member {string} contains
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.contains = "";

        /**
         * StringRules notContains.
         * @member {string} notContains
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.notContains = "";

        /**
         * StringRules in.
         * @member {Array.<string>} in
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype["in"] = $util.emptyArray;

        /**
         * StringRules notIn.
         * @member {Array.<string>} notIn
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.notIn = $util.emptyArray;

        /**
         * StringRules email.
         * @member {boolean|null|undefined} email
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.email = null;

        /**
         * StringRules hostname.
         * @member {boolean|null|undefined} hostname
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.hostname = null;

        /**
         * StringRules ip.
         * @member {boolean|null|undefined} ip
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.ip = null;

        /**
         * StringRules ipv4.
         * @member {boolean|null|undefined} ipv4
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.ipv4 = null;

        /**
         * StringRules ipv6.
         * @member {boolean|null|undefined} ipv6
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.ipv6 = null;

        /**
         * StringRules uri.
         * @member {boolean|null|undefined} uri
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.uri = null;

        /**
         * StringRules uriRef.
         * @member {boolean|null|undefined} uriRef
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.uriRef = null;

        /**
         * StringRules address.
         * @member {boolean|null|undefined} address
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.address = null;

        /**
         * StringRules uuid.
         * @member {boolean|null|undefined} uuid
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.uuid = null;

        /**
         * StringRules wellKnownRegex.
         * @member {validate.KnownRegex|null|undefined} wellKnownRegex
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.wellKnownRegex = null;

        /**
         * StringRules strict.
         * @member {boolean} strict
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.strict = true;

        /**
         * StringRules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.ignoreEmpty = false;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * StringRules wellKnown.
         * @member {"email"|"hostname"|"ip"|"ipv4"|"ipv6"|"uri"|"uriRef"|"address"|"uuid"|"wellKnownRegex"|undefined} wellKnown
         * @memberof validate.StringRules
         * @instance
         */
        Object.defineProperty(StringRules.prototype, "wellKnown", {
            get: $util.oneOfGetter($oneOfFields = ["email", "hostname", "ip", "ipv4", "ipv6", "uri", "uriRef", "address", "uuid", "wellKnownRegex"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Verifies a StringRules message.
         * @function verify
         * @memberof validate.StringRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StringRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isString(message["const"]))
                    return "const: string expected";
            if (message.len != null && message.hasOwnProperty("len"))
                if (!$util.isInteger(message.len) && !(message.len && $util.isInteger(message.len.low) && $util.isInteger(message.len.high)))
                    return "len: integer|Long expected";
            if (message.minLen != null && message.hasOwnProperty("minLen"))
                if (!$util.isInteger(message.minLen) && !(message.minLen && $util.isInteger(message.minLen.low) && $util.isInteger(message.minLen.high)))
                    return "minLen: integer|Long expected";
            if (message.maxLen != null && message.hasOwnProperty("maxLen"))
                if (!$util.isInteger(message.maxLen) && !(message.maxLen && $util.isInteger(message.maxLen.low) && $util.isInteger(message.maxLen.high)))
                    return "maxLen: integer|Long expected";
            if (message.lenBytes != null && message.hasOwnProperty("lenBytes"))
                if (!$util.isInteger(message.lenBytes) && !(message.lenBytes && $util.isInteger(message.lenBytes.low) && $util.isInteger(message.lenBytes.high)))
                    return "lenBytes: integer|Long expected";
            if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                if (!$util.isInteger(message.minBytes) && !(message.minBytes && $util.isInteger(message.minBytes.low) && $util.isInteger(message.minBytes.high)))
                    return "minBytes: integer|Long expected";
            if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                if (!$util.isInteger(message.maxBytes) && !(message.maxBytes && $util.isInteger(message.maxBytes.low) && $util.isInteger(message.maxBytes.high)))
                    return "maxBytes: integer|Long expected";
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                if (!$util.isString(message.pattern))
                    return "pattern: string expected";
            if (message.prefix != null && message.hasOwnProperty("prefix"))
                if (!$util.isString(message.prefix))
                    return "prefix: string expected";
            if (message.suffix != null && message.hasOwnProperty("suffix"))
                if (!$util.isString(message.suffix))
                    return "suffix: string expected";
            if (message.contains != null && message.hasOwnProperty("contains"))
                if (!$util.isString(message.contains))
                    return "contains: string expected";
            if (message.notContains != null && message.hasOwnProperty("notContains"))
                if (!$util.isString(message.notContains))
                    return "notContains: string expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isString(message["in"][i]))
                        return "in: string[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isString(message.notIn[i]))
                        return "notIn: string[] expected";
            }
            if (message.email != null && message.hasOwnProperty("email")) {
                properties.wellKnown = 1;
                if (typeof message.email !== "boolean")
                    return "email: boolean expected";
            }
            if (message.hostname != null && message.hasOwnProperty("hostname")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.hostname !== "boolean")
                    return "hostname: boolean expected";
            }
            if (message.ip != null && message.hasOwnProperty("ip")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.ip !== "boolean")
                    return "ip: boolean expected";
            }
            if (message.ipv4 != null && message.hasOwnProperty("ipv4")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.ipv4 !== "boolean")
                    return "ipv4: boolean expected";
            }
            if (message.ipv6 != null && message.hasOwnProperty("ipv6")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.ipv6 !== "boolean")
                    return "ipv6: boolean expected";
            }
            if (message.uri != null && message.hasOwnProperty("uri")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.uri !== "boolean")
                    return "uri: boolean expected";
            }
            if (message.uriRef != null && message.hasOwnProperty("uriRef")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.uriRef !== "boolean")
                    return "uriRef: boolean expected";
            }
            if (message.address != null && message.hasOwnProperty("address")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.address !== "boolean")
                    return "address: boolean expected";
            }
            if (message.uuid != null && message.hasOwnProperty("uuid")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.uuid !== "boolean")
                    return "uuid: boolean expected";
            }
            if (message.wellKnownRegex != null && message.hasOwnProperty("wellKnownRegex")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                switch (message.wellKnownRegex) {
                default:
                    return "wellKnownRegex: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            }
            if (message.strict != null && message.hasOwnProperty("strict"))
                if (typeof message.strict !== "boolean")
                    return "strict: boolean expected";
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates a StringRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.StringRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.StringRules} StringRules
         */
        StringRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.StringRules)
                return object;
            let message = new $root.validate.StringRules();
            if (object["const"] != null)
                message["const"] = String(object["const"]);
            if (object.len != null)
                if ($util.Long)
                    (message.len = $util.Long.fromValue(object.len)).unsigned = true;
                else if (typeof object.len === "string")
                    message.len = parseInt(object.len, 10);
                else if (typeof object.len === "number")
                    message.len = object.len;
                else if (typeof object.len === "object")
                    message.len = new $util.LongBits(object.len.low >>> 0, object.len.high >>> 0).toNumber(true);
            if (object.minLen != null)
                if ($util.Long)
                    (message.minLen = $util.Long.fromValue(object.minLen)).unsigned = true;
                else if (typeof object.minLen === "string")
                    message.minLen = parseInt(object.minLen, 10);
                else if (typeof object.minLen === "number")
                    message.minLen = object.minLen;
                else if (typeof object.minLen === "object")
                    message.minLen = new $util.LongBits(object.minLen.low >>> 0, object.minLen.high >>> 0).toNumber(true);
            if (object.maxLen != null)
                if ($util.Long)
                    (message.maxLen = $util.Long.fromValue(object.maxLen)).unsigned = true;
                else if (typeof object.maxLen === "string")
                    message.maxLen = parseInt(object.maxLen, 10);
                else if (typeof object.maxLen === "number")
                    message.maxLen = object.maxLen;
                else if (typeof object.maxLen === "object")
                    message.maxLen = new $util.LongBits(object.maxLen.low >>> 0, object.maxLen.high >>> 0).toNumber(true);
            if (object.lenBytes != null)
                if ($util.Long)
                    (message.lenBytes = $util.Long.fromValue(object.lenBytes)).unsigned = true;
                else if (typeof object.lenBytes === "string")
                    message.lenBytes = parseInt(object.lenBytes, 10);
                else if (typeof object.lenBytes === "number")
                    message.lenBytes = object.lenBytes;
                else if (typeof object.lenBytes === "object")
                    message.lenBytes = new $util.LongBits(object.lenBytes.low >>> 0, object.lenBytes.high >>> 0).toNumber(true);
            if (object.minBytes != null)
                if ($util.Long)
                    (message.minBytes = $util.Long.fromValue(object.minBytes)).unsigned = true;
                else if (typeof object.minBytes === "string")
                    message.minBytes = parseInt(object.minBytes, 10);
                else if (typeof object.minBytes === "number")
                    message.minBytes = object.minBytes;
                else if (typeof object.minBytes === "object")
                    message.minBytes = new $util.LongBits(object.minBytes.low >>> 0, object.minBytes.high >>> 0).toNumber(true);
            if (object.maxBytes != null)
                if ($util.Long)
                    (message.maxBytes = $util.Long.fromValue(object.maxBytes)).unsigned = true;
                else if (typeof object.maxBytes === "string")
                    message.maxBytes = parseInt(object.maxBytes, 10);
                else if (typeof object.maxBytes === "number")
                    message.maxBytes = object.maxBytes;
                else if (typeof object.maxBytes === "object")
                    message.maxBytes = new $util.LongBits(object.maxBytes.low >>> 0, object.maxBytes.high >>> 0).toNumber(true);
            if (object.pattern != null)
                message.pattern = String(object.pattern);
            if (object.prefix != null)
                message.prefix = String(object.prefix);
            if (object.suffix != null)
                message.suffix = String(object.suffix);
            if (object.contains != null)
                message.contains = String(object.contains);
            if (object.notContains != null)
                message.notContains = String(object.notContains);
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.StringRules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = String(object["in"][i]);
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.StringRules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = String(object.notIn[i]);
            }
            if (object.email != null)
                message.email = Boolean(object.email);
            if (object.hostname != null)
                message.hostname = Boolean(object.hostname);
            if (object.ip != null)
                message.ip = Boolean(object.ip);
            if (object.ipv4 != null)
                message.ipv4 = Boolean(object.ipv4);
            if (object.ipv6 != null)
                message.ipv6 = Boolean(object.ipv6);
            if (object.uri != null)
                message.uri = Boolean(object.uri);
            if (object.uriRef != null)
                message.uriRef = Boolean(object.uriRef);
            if (object.address != null)
                message.address = Boolean(object.address);
            if (object.uuid != null)
                message.uuid = Boolean(object.uuid);
            switch (object.wellKnownRegex) {
            case "UNKNOWN":
            case 0:
                message.wellKnownRegex = 0;
                break;
            case "HTTP_HEADER_NAME":
            case 1:
                message.wellKnownRegex = 1;
                break;
            case "HTTP_HEADER_VALUE":
            case 2:
                message.wellKnownRegex = 2;
                break;
            }
            if (object.strict != null)
                message.strict = Boolean(object.strict);
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from a StringRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.StringRules
         * @static
         * @param {validate.StringRules} message StringRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StringRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.minLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minLen = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxLen = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.minBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minBytes = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxBytes = options.longs === String ? "0" : 0;
                object.pattern = "";
                object.prefix = "";
                object.suffix = "";
                object.contains = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.len = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.len = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.lenBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lenBytes = options.longs === String ? "0" : 0;
                object.notContains = "";
                object.strict = true;
                object.ignoreEmpty = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            if (message.minLen != null && message.hasOwnProperty("minLen"))
                if (typeof message.minLen === "number")
                    object.minLen = options.longs === String ? String(message.minLen) : message.minLen;
                else
                    object.minLen = options.longs === String ? $util.Long.prototype.toString.call(message.minLen) : options.longs === Number ? new $util.LongBits(message.minLen.low >>> 0, message.minLen.high >>> 0).toNumber(true) : message.minLen;
            if (message.maxLen != null && message.hasOwnProperty("maxLen"))
                if (typeof message.maxLen === "number")
                    object.maxLen = options.longs === String ? String(message.maxLen) : message.maxLen;
                else
                    object.maxLen = options.longs === String ? $util.Long.prototype.toString.call(message.maxLen) : options.longs === Number ? new $util.LongBits(message.maxLen.low >>> 0, message.maxLen.high >>> 0).toNumber(true) : message.maxLen;
            if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                if (typeof message.minBytes === "number")
                    object.minBytes = options.longs === String ? String(message.minBytes) : message.minBytes;
                else
                    object.minBytes = options.longs === String ? $util.Long.prototype.toString.call(message.minBytes) : options.longs === Number ? new $util.LongBits(message.minBytes.low >>> 0, message.minBytes.high >>> 0).toNumber(true) : message.minBytes;
            if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                if (typeof message.maxBytes === "number")
                    object.maxBytes = options.longs === String ? String(message.maxBytes) : message.maxBytes;
                else
                    object.maxBytes = options.longs === String ? $util.Long.prototype.toString.call(message.maxBytes) : options.longs === Number ? new $util.LongBits(message.maxBytes.low >>> 0, message.maxBytes.high >>> 0).toNumber(true) : message.maxBytes;
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                object.pattern = message.pattern;
            if (message.prefix != null && message.hasOwnProperty("prefix"))
                object.prefix = message.prefix;
            if (message.suffix != null && message.hasOwnProperty("suffix"))
                object.suffix = message.suffix;
            if (message.contains != null && message.hasOwnProperty("contains"))
                object.contains = message.contains;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            if (message.email != null && message.hasOwnProperty("email")) {
                object.email = message.email;
                if (options.oneofs)
                    object.wellKnown = "email";
            }
            if (message.hostname != null && message.hasOwnProperty("hostname")) {
                object.hostname = message.hostname;
                if (options.oneofs)
                    object.wellKnown = "hostname";
            }
            if (message.ip != null && message.hasOwnProperty("ip")) {
                object.ip = message.ip;
                if (options.oneofs)
                    object.wellKnown = "ip";
            }
            if (message.ipv4 != null && message.hasOwnProperty("ipv4")) {
                object.ipv4 = message.ipv4;
                if (options.oneofs)
                    object.wellKnown = "ipv4";
            }
            if (message.ipv6 != null && message.hasOwnProperty("ipv6")) {
                object.ipv6 = message.ipv6;
                if (options.oneofs)
                    object.wellKnown = "ipv6";
            }
            if (message.uri != null && message.hasOwnProperty("uri")) {
                object.uri = message.uri;
                if (options.oneofs)
                    object.wellKnown = "uri";
            }
            if (message.uriRef != null && message.hasOwnProperty("uriRef")) {
                object.uriRef = message.uriRef;
                if (options.oneofs)
                    object.wellKnown = "uriRef";
            }
            if (message.len != null && message.hasOwnProperty("len"))
                if (typeof message.len === "number")
                    object.len = options.longs === String ? String(message.len) : message.len;
                else
                    object.len = options.longs === String ? $util.Long.prototype.toString.call(message.len) : options.longs === Number ? new $util.LongBits(message.len.low >>> 0, message.len.high >>> 0).toNumber(true) : message.len;
            if (message.lenBytes != null && message.hasOwnProperty("lenBytes"))
                if (typeof message.lenBytes === "number")
                    object.lenBytes = options.longs === String ? String(message.lenBytes) : message.lenBytes;
                else
                    object.lenBytes = options.longs === String ? $util.Long.prototype.toString.call(message.lenBytes) : options.longs === Number ? new $util.LongBits(message.lenBytes.low >>> 0, message.lenBytes.high >>> 0).toNumber(true) : message.lenBytes;
            if (message.address != null && message.hasOwnProperty("address")) {
                object.address = message.address;
                if (options.oneofs)
                    object.wellKnown = "address";
            }
            if (message.uuid != null && message.hasOwnProperty("uuid")) {
                object.uuid = message.uuid;
                if (options.oneofs)
                    object.wellKnown = "uuid";
            }
            if (message.notContains != null && message.hasOwnProperty("notContains"))
                object.notContains = message.notContains;
            if (message.wellKnownRegex != null && message.hasOwnProperty("wellKnownRegex")) {
                object.wellKnownRegex = options.enums === String ? $root.validate.KnownRegex[message.wellKnownRegex] : message.wellKnownRegex;
                if (options.oneofs)
                    object.wellKnown = "wellKnownRegex";
            }
            if (message.strict != null && message.hasOwnProperty("strict"))
                object.strict = message.strict;
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this StringRules to JSON.
         * @function toJSON
         * @memberof validate.StringRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StringRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StringRules;
    })();

    /**
     * KnownRegex enum.
     * @name validate.KnownRegex
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} HTTP_HEADER_NAME=1 HTTP_HEADER_NAME value
     * @property {number} HTTP_HEADER_VALUE=2 HTTP_HEADER_VALUE value
     */
    validate.KnownRegex = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "HTTP_HEADER_NAME"] = 1;
        values[valuesById[2] = "HTTP_HEADER_VALUE"] = 2;
        return values;
    })();

    validate.BytesRules = (function() {

        /**
         * Properties of a BytesRules.
         * @memberof validate
         * @interface IBytesRules
         * @property {Uint8Array|null} ["const"] BytesRules const
         * @property {number|Long|null} [len] BytesRules len
         * @property {number|Long|null} [minLen] BytesRules minLen
         * @property {number|Long|null} [maxLen] BytesRules maxLen
         * @property {string|null} [pattern] BytesRules pattern
         * @property {Uint8Array|null} [prefix] BytesRules prefix
         * @property {Uint8Array|null} [suffix] BytesRules suffix
         * @property {Uint8Array|null} [contains] BytesRules contains
         * @property {Array.<Uint8Array>|null} ["in"] BytesRules in
         * @property {Array.<Uint8Array>|null} [notIn] BytesRules notIn
         * @property {boolean|null} [ip] BytesRules ip
         * @property {boolean|null} [ipv4] BytesRules ipv4
         * @property {boolean|null} [ipv6] BytesRules ipv6
         * @property {boolean|null} [ignoreEmpty] BytesRules ignoreEmpty
         */

        /**
         * Constructs a new BytesRules.
         * @memberof validate
         * @classdesc Represents a BytesRules.
         * @implements IBytesRules
         * @constructor
         * @param {validate.IBytesRules=} [properties] Properties to set
         */
        function BytesRules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BytesRules const.
         * @member {Uint8Array} const
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype["const"] = $util.newBuffer([]);

        /**
         * BytesRules len.
         * @member {number|Long} len
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.len = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * BytesRules minLen.
         * @member {number|Long} minLen
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.minLen = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * BytesRules maxLen.
         * @member {number|Long} maxLen
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.maxLen = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * BytesRules pattern.
         * @member {string} pattern
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.pattern = "";

        /**
         * BytesRules prefix.
         * @member {Uint8Array} prefix
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.prefix = $util.newBuffer([]);

        /**
         * BytesRules suffix.
         * @member {Uint8Array} suffix
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.suffix = $util.newBuffer([]);

        /**
         * BytesRules contains.
         * @member {Uint8Array} contains
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.contains = $util.newBuffer([]);

        /**
         * BytesRules in.
         * @member {Array.<Uint8Array>} in
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype["in"] = $util.emptyArray;

        /**
         * BytesRules notIn.
         * @member {Array.<Uint8Array>} notIn
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.notIn = $util.emptyArray;

        /**
         * BytesRules ip.
         * @member {boolean|null|undefined} ip
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.ip = null;

        /**
         * BytesRules ipv4.
         * @member {boolean|null|undefined} ipv4
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.ipv4 = null;

        /**
         * BytesRules ipv6.
         * @member {boolean|null|undefined} ipv6
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.ipv6 = null;

        /**
         * BytesRules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.ignoreEmpty = false;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * BytesRules wellKnown.
         * @member {"ip"|"ipv4"|"ipv6"|undefined} wellKnown
         * @memberof validate.BytesRules
         * @instance
         */
        Object.defineProperty(BytesRules.prototype, "wellKnown", {
            get: $util.oneOfGetter($oneOfFields = ["ip", "ipv4", "ipv6"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Verifies a BytesRules message.
         * @function verify
         * @memberof validate.BytesRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BytesRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!(message["const"] && typeof message["const"].length === "number" || $util.isString(message["const"])))
                    return "const: buffer expected";
            if (message.len != null && message.hasOwnProperty("len"))
                if (!$util.isInteger(message.len) && !(message.len && $util.isInteger(message.len.low) && $util.isInteger(message.len.high)))
                    return "len: integer|Long expected";
            if (message.minLen != null && message.hasOwnProperty("minLen"))
                if (!$util.isInteger(message.minLen) && !(message.minLen && $util.isInteger(message.minLen.low) && $util.isInteger(message.minLen.high)))
                    return "minLen: integer|Long expected";
            if (message.maxLen != null && message.hasOwnProperty("maxLen"))
                if (!$util.isInteger(message.maxLen) && !(message.maxLen && $util.isInteger(message.maxLen.low) && $util.isInteger(message.maxLen.high)))
                    return "maxLen: integer|Long expected";
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                if (!$util.isString(message.pattern))
                    return "pattern: string expected";
            if (message.prefix != null && message.hasOwnProperty("prefix"))
                if (!(message.prefix && typeof message.prefix.length === "number" || $util.isString(message.prefix)))
                    return "prefix: buffer expected";
            if (message.suffix != null && message.hasOwnProperty("suffix"))
                if (!(message.suffix && typeof message.suffix.length === "number" || $util.isString(message.suffix)))
                    return "suffix: buffer expected";
            if (message.contains != null && message.hasOwnProperty("contains"))
                if (!(message.contains && typeof message.contains.length === "number" || $util.isString(message.contains)))
                    return "contains: buffer expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!(message["in"][i] && typeof message["in"][i].length === "number" || $util.isString(message["in"][i])))
                        return "in: buffer[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!(message.notIn[i] && typeof message.notIn[i].length === "number" || $util.isString(message.notIn[i])))
                        return "notIn: buffer[] expected";
            }
            if (message.ip != null && message.hasOwnProperty("ip")) {
                properties.wellKnown = 1;
                if (typeof message.ip !== "boolean")
                    return "ip: boolean expected";
            }
            if (message.ipv4 != null && message.hasOwnProperty("ipv4")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.ipv4 !== "boolean")
                    return "ipv4: boolean expected";
            }
            if (message.ipv6 != null && message.hasOwnProperty("ipv6")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.ipv6 !== "boolean")
                    return "ipv6: boolean expected";
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates a BytesRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.BytesRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.BytesRules} BytesRules
         */
        BytesRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.BytesRules)
                return object;
            let message = new $root.validate.BytesRules();
            if (object["const"] != null)
                if (typeof object["const"] === "string")
                    $util.base64.decode(object["const"], message["const"] = $util.newBuffer($util.base64.length(object["const"])), 0);
                else if (object["const"].length)
                    message["const"] = object["const"];
            if (object.len != null)
                if ($util.Long)
                    (message.len = $util.Long.fromValue(object.len)).unsigned = true;
                else if (typeof object.len === "string")
                    message.len = parseInt(object.len, 10);
                else if (typeof object.len === "number")
                    message.len = object.len;
                else if (typeof object.len === "object")
                    message.len = new $util.LongBits(object.len.low >>> 0, object.len.high >>> 0).toNumber(true);
            if (object.minLen != null)
                if ($util.Long)
                    (message.minLen = $util.Long.fromValue(object.minLen)).unsigned = true;
                else if (typeof object.minLen === "string")
                    message.minLen = parseInt(object.minLen, 10);
                else if (typeof object.minLen === "number")
                    message.minLen = object.minLen;
                else if (typeof object.minLen === "object")
                    message.minLen = new $util.LongBits(object.minLen.low >>> 0, object.minLen.high >>> 0).toNumber(true);
            if (object.maxLen != null)
                if ($util.Long)
                    (message.maxLen = $util.Long.fromValue(object.maxLen)).unsigned = true;
                else if (typeof object.maxLen === "string")
                    message.maxLen = parseInt(object.maxLen, 10);
                else if (typeof object.maxLen === "number")
                    message.maxLen = object.maxLen;
                else if (typeof object.maxLen === "object")
                    message.maxLen = new $util.LongBits(object.maxLen.low >>> 0, object.maxLen.high >>> 0).toNumber(true);
            if (object.pattern != null)
                message.pattern = String(object.pattern);
            if (object.prefix != null)
                if (typeof object.prefix === "string")
                    $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);
                else if (object.prefix.length)
                    message.prefix = object.prefix;
            if (object.suffix != null)
                if (typeof object.suffix === "string")
                    $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);
                else if (object.suffix.length)
                    message.suffix = object.suffix;
            if (object.contains != null)
                if (typeof object.contains === "string")
                    $util.base64.decode(object.contains, message.contains = $util.newBuffer($util.base64.length(object.contains)), 0);
                else if (object.contains.length)
                    message.contains = object.contains;
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.BytesRules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    if (typeof object["in"][i] === "string")
                        $util.base64.decode(object["in"][i], message["in"][i] = $util.newBuffer($util.base64.length(object["in"][i])), 0);
                    else if (object["in"][i].length)
                        message["in"][i] = object["in"][i];
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.BytesRules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    if (typeof object.notIn[i] === "string")
                        $util.base64.decode(object.notIn[i], message.notIn[i] = $util.newBuffer($util.base64.length(object.notIn[i])), 0);
                    else if (object.notIn[i].length)
                        message.notIn[i] = object.notIn[i];
            }
            if (object.ip != null)
                message.ip = Boolean(object.ip);
            if (object.ipv4 != null)
                message.ipv4 = Boolean(object.ipv4);
            if (object.ipv6 != null)
                message.ipv6 = Boolean(object.ipv6);
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from a BytesRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.BytesRules
         * @static
         * @param {validate.BytesRules} message BytesRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BytesRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object["const"] = "";
                else {
                    object["const"] = [];
                    if (options.bytes !== Array)
                        object["const"] = $util.newBuffer(object["const"]);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.minLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minLen = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxLen = options.longs === String ? "0" : 0;
                object.pattern = "";
                if (options.bytes === String)
                    object.prefix = "";
                else {
                    object.prefix = [];
                    if (options.bytes !== Array)
                        object.prefix = $util.newBuffer(object.prefix);
                }
                if (options.bytes === String)
                    object.suffix = "";
                else {
                    object.suffix = [];
                    if (options.bytes !== Array)
                        object.suffix = $util.newBuffer(object.suffix);
                }
                if (options.bytes === String)
                    object.contains = "";
                else {
                    object.contains = [];
                    if (options.bytes !== Array)
                        object.contains = $util.newBuffer(object.contains);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.len = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.len = options.longs === String ? "0" : 0;
                object.ignoreEmpty = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = options.bytes === String ? $util.base64.encode(message["const"], 0, message["const"].length) : options.bytes === Array ? Array.prototype.slice.call(message["const"]) : message["const"];
            if (message.minLen != null && message.hasOwnProperty("minLen"))
                if (typeof message.minLen === "number")
                    object.minLen = options.longs === String ? String(message.minLen) : message.minLen;
                else
                    object.minLen = options.longs === String ? $util.Long.prototype.toString.call(message.minLen) : options.longs === Number ? new $util.LongBits(message.minLen.low >>> 0, message.minLen.high >>> 0).toNumber(true) : message.minLen;
            if (message.maxLen != null && message.hasOwnProperty("maxLen"))
                if (typeof message.maxLen === "number")
                    object.maxLen = options.longs === String ? String(message.maxLen) : message.maxLen;
                else
                    object.maxLen = options.longs === String ? $util.Long.prototype.toString.call(message.maxLen) : options.longs === Number ? new $util.LongBits(message.maxLen.low >>> 0, message.maxLen.high >>> 0).toNumber(true) : message.maxLen;
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                object.pattern = message.pattern;
            if (message.prefix != null && message.hasOwnProperty("prefix"))
                object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;
            if (message.suffix != null && message.hasOwnProperty("suffix"))
                object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;
            if (message.contains != null && message.hasOwnProperty("contains"))
                object.contains = options.bytes === String ? $util.base64.encode(message.contains, 0, message.contains.length) : options.bytes === Array ? Array.prototype.slice.call(message.contains) : message.contains;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = options.bytes === String ? $util.base64.encode(message["in"][j], 0, message["in"][j].length) : options.bytes === Array ? Array.prototype.slice.call(message["in"][j]) : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = options.bytes === String ? $util.base64.encode(message.notIn[j], 0, message.notIn[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.notIn[j]) : message.notIn[j];
            }
            if (message.ip != null && message.hasOwnProperty("ip")) {
                object.ip = message.ip;
                if (options.oneofs)
                    object.wellKnown = "ip";
            }
            if (message.ipv4 != null && message.hasOwnProperty("ipv4")) {
                object.ipv4 = message.ipv4;
                if (options.oneofs)
                    object.wellKnown = "ipv4";
            }
            if (message.ipv6 != null && message.hasOwnProperty("ipv6")) {
                object.ipv6 = message.ipv6;
                if (options.oneofs)
                    object.wellKnown = "ipv6";
            }
            if (message.len != null && message.hasOwnProperty("len"))
                if (typeof message.len === "number")
                    object.len = options.longs === String ? String(message.len) : message.len;
                else
                    object.len = options.longs === String ? $util.Long.prototype.toString.call(message.len) : options.longs === Number ? new $util.LongBits(message.len.low >>> 0, message.len.high >>> 0).toNumber(true) : message.len;
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this BytesRules to JSON.
         * @function toJSON
         * @memberof validate.BytesRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BytesRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BytesRules;
    })();

    validate.EnumRules = (function() {

        /**
         * Properties of an EnumRules.
         * @memberof validate
         * @interface IEnumRules
         * @property {number|null} ["const"] EnumRules const
         * @property {boolean|null} [definedOnly] EnumRules definedOnly
         * @property {Array.<number>|null} ["in"] EnumRules in
         * @property {Array.<number>|null} [notIn] EnumRules notIn
         */

        /**
         * Constructs a new EnumRules.
         * @memberof validate
         * @classdesc Represents an EnumRules.
         * @implements IEnumRules
         * @constructor
         * @param {validate.IEnumRules=} [properties] Properties to set
         */
        function EnumRules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnumRules const.
         * @member {number} const
         * @memberof validate.EnumRules
         * @instance
         */
        EnumRules.prototype["const"] = 0;

        /**
         * EnumRules definedOnly.
         * @member {boolean} definedOnly
         * @memberof validate.EnumRules
         * @instance
         */
        EnumRules.prototype.definedOnly = false;

        /**
         * EnumRules in.
         * @member {Array.<number>} in
         * @memberof validate.EnumRules
         * @instance
         */
        EnumRules.prototype["in"] = $util.emptyArray;

        /**
         * EnumRules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.EnumRules
         * @instance
         */
        EnumRules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies an EnumRules message.
         * @function verify
         * @memberof validate.EnumRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnumRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]))
                    return "const: integer expected";
            if (message.definedOnly != null && message.hasOwnProperty("definedOnly"))
                if (typeof message.definedOnly !== "boolean")
                    return "definedOnly: boolean expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]))
                        return "in: integer[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]))
                        return "notIn: integer[] expected";
            }
            return null;
        };

        /**
         * Creates an EnumRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.EnumRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.EnumRules} EnumRules
         */
        EnumRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.EnumRules)
                return object;
            let message = new $root.validate.EnumRules();
            if (object["const"] != null)
                message["const"] = object["const"] | 0;
            if (object.definedOnly != null)
                message.definedOnly = Boolean(object.definedOnly);
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.EnumRules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = object["in"][i] | 0;
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.EnumRules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = object.notIn[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from an EnumRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.EnumRules
         * @static
         * @param {validate.EnumRules} message EnumRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnumRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.definedOnly = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            if (message.definedOnly != null && message.hasOwnProperty("definedOnly"))
                object.definedOnly = message.definedOnly;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this EnumRules to JSON.
         * @function toJSON
         * @memberof validate.EnumRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnumRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnumRules;
    })();

    validate.MessageRules = (function() {

        /**
         * Properties of a MessageRules.
         * @memberof validate
         * @interface IMessageRules
         * @property {boolean|null} [skip] MessageRules skip
         * @property {boolean|null} [required] MessageRules required
         */

        /**
         * Constructs a new MessageRules.
         * @memberof validate
         * @classdesc Represents a MessageRules.
         * @implements IMessageRules
         * @constructor
         * @param {validate.IMessageRules=} [properties] Properties to set
         */
        function MessageRules(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageRules skip.
         * @member {boolean} skip
         * @memberof validate.MessageRules
         * @instance
         */
        MessageRules.prototype.skip = false;

        /**
         * MessageRules required.
         * @member {boolean} required
         * @memberof validate.MessageRules
         * @instance
         */
        MessageRules.prototype.required = false;

        /**
         * Verifies a MessageRules message.
         * @function verify
         * @memberof validate.MessageRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MessageRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.skip != null && message.hasOwnProperty("skip"))
                if (typeof message.skip !== "boolean")
                    return "skip: boolean expected";
            if (message.required != null && message.hasOwnProperty("required"))
                if (typeof message.required !== "boolean")
                    return "required: boolean expected";
            return null;
        };

        /**
         * Creates a MessageRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.MessageRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.MessageRules} MessageRules
         */
        MessageRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.MessageRules)
                return object;
            let message = new $root.validate.MessageRules();
            if (object.skip != null)
                message.skip = Boolean(object.skip);
            if (object.required != null)
                message.required = Boolean(object.required);
            return message;
        };

        /**
         * Creates a plain object from a MessageRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.MessageRules
         * @static
         * @param {validate.MessageRules} message MessageRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MessageRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.skip = false;
                object.required = false;
            }
            if (message.skip != null && message.hasOwnProperty("skip"))
                object.skip = message.skip;
            if (message.required != null && message.hasOwnProperty("required"))
                object.required = message.required;
            return object;
        };

        /**
         * Converts this MessageRules to JSON.
         * @function toJSON
         * @memberof validate.MessageRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MessageRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MessageRules;
    })();

    validate.RepeatedRules = (function() {

        /**
         * Properties of a RepeatedRules.
         * @memberof validate
         * @interface IRepeatedRules
         * @property {number|Long|null} [minItems] RepeatedRules minItems
         * @property {number|Long|null} [maxItems] RepeatedRules maxItems
         * @property {boolean|null} [unique] RepeatedRules unique
         * @property {validate.IFieldRules|null} [items] RepeatedRules items
         * @property {boolean|null} [ignoreEmpty] RepeatedRules ignoreEmpty
         */

        /**
         * Constructs a new RepeatedRules.
         * @memberof validate
         * @classdesc Represents a RepeatedRules.
         * @implements IRepeatedRules
         * @constructor
         * @param {validate.IRepeatedRules=} [properties] Properties to set
         */
        function RepeatedRules(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RepeatedRules minItems.
         * @member {number|Long} minItems
         * @memberof validate.RepeatedRules
         * @instance
         */
        RepeatedRules.prototype.minItems = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RepeatedRules maxItems.
         * @member {number|Long} maxItems
         * @memberof validate.RepeatedRules
         * @instance
         */
        RepeatedRules.prototype.maxItems = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RepeatedRules unique.
         * @member {boolean} unique
         * @memberof validate.RepeatedRules
         * @instance
         */
        RepeatedRules.prototype.unique = false;

        /**
         * RepeatedRules items.
         * @member {validate.IFieldRules|null|undefined} items
         * @memberof validate.RepeatedRules
         * @instance
         */
        RepeatedRules.prototype.items = null;

        /**
         * RepeatedRules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.RepeatedRules
         * @instance
         */
        RepeatedRules.prototype.ignoreEmpty = false;

        /**
         * Verifies a RepeatedRules message.
         * @function verify
         * @memberof validate.RepeatedRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RepeatedRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.minItems != null && message.hasOwnProperty("minItems"))
                if (!$util.isInteger(message.minItems) && !(message.minItems && $util.isInteger(message.minItems.low) && $util.isInteger(message.minItems.high)))
                    return "minItems: integer|Long expected";
            if (message.maxItems != null && message.hasOwnProperty("maxItems"))
                if (!$util.isInteger(message.maxItems) && !(message.maxItems && $util.isInteger(message.maxItems.low) && $util.isInteger(message.maxItems.high)))
                    return "maxItems: integer|Long expected";
            if (message.unique != null && message.hasOwnProperty("unique"))
                if (typeof message.unique !== "boolean")
                    return "unique: boolean expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                let error = $root.validate.FieldRules.verify(message.items);
                if (error)
                    return "items." + error;
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates a RepeatedRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.RepeatedRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.RepeatedRules} RepeatedRules
         */
        RepeatedRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.RepeatedRules)
                return object;
            let message = new $root.validate.RepeatedRules();
            if (object.minItems != null)
                if ($util.Long)
                    (message.minItems = $util.Long.fromValue(object.minItems)).unsigned = true;
                else if (typeof object.minItems === "string")
                    message.minItems = parseInt(object.minItems, 10);
                else if (typeof object.minItems === "number")
                    message.minItems = object.minItems;
                else if (typeof object.minItems === "object")
                    message.minItems = new $util.LongBits(object.minItems.low >>> 0, object.minItems.high >>> 0).toNumber(true);
            if (object.maxItems != null)
                if ($util.Long)
                    (message.maxItems = $util.Long.fromValue(object.maxItems)).unsigned = true;
                else if (typeof object.maxItems === "string")
                    message.maxItems = parseInt(object.maxItems, 10);
                else if (typeof object.maxItems === "number")
                    message.maxItems = object.maxItems;
                else if (typeof object.maxItems === "object")
                    message.maxItems = new $util.LongBits(object.maxItems.low >>> 0, object.maxItems.high >>> 0).toNumber(true);
            if (object.unique != null)
                message.unique = Boolean(object.unique);
            if (object.items != null) {
                if (typeof object.items !== "object")
                    throw TypeError(".validate.RepeatedRules.items: object expected");
                message.items = $root.validate.FieldRules.fromObject(object.items);
            }
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from a RepeatedRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.RepeatedRules
         * @static
         * @param {validate.RepeatedRules} message RepeatedRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RepeatedRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.minItems = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minItems = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxItems = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxItems = options.longs === String ? "0" : 0;
                object.unique = false;
                object.items = null;
                object.ignoreEmpty = false;
            }
            if (message.minItems != null && message.hasOwnProperty("minItems"))
                if (typeof message.minItems === "number")
                    object.minItems = options.longs === String ? String(message.minItems) : message.minItems;
                else
                    object.minItems = options.longs === String ? $util.Long.prototype.toString.call(message.minItems) : options.longs === Number ? new $util.LongBits(message.minItems.low >>> 0, message.minItems.high >>> 0).toNumber(true) : message.minItems;
            if (message.maxItems != null && message.hasOwnProperty("maxItems"))
                if (typeof message.maxItems === "number")
                    object.maxItems = options.longs === String ? String(message.maxItems) : message.maxItems;
                else
                    object.maxItems = options.longs === String ? $util.Long.prototype.toString.call(message.maxItems) : options.longs === Number ? new $util.LongBits(message.maxItems.low >>> 0, message.maxItems.high >>> 0).toNumber(true) : message.maxItems;
            if (message.unique != null && message.hasOwnProperty("unique"))
                object.unique = message.unique;
            if (message.items != null && message.hasOwnProperty("items"))
                object.items = $root.validate.FieldRules.toObject(message.items, options);
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this RepeatedRules to JSON.
         * @function toJSON
         * @memberof validate.RepeatedRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RepeatedRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RepeatedRules;
    })();

    validate.MapRules = (function() {

        /**
         * Properties of a MapRules.
         * @memberof validate
         * @interface IMapRules
         * @property {number|Long|null} [minPairs] MapRules minPairs
         * @property {number|Long|null} [maxPairs] MapRules maxPairs
         * @property {boolean|null} [noSparse] MapRules noSparse
         * @property {validate.IFieldRules|null} [keys] MapRules keys
         * @property {validate.IFieldRules|null} [values] MapRules values
         * @property {boolean|null} [ignoreEmpty] MapRules ignoreEmpty
         */

        /**
         * Constructs a new MapRules.
         * @memberof validate
         * @classdesc Represents a MapRules.
         * @implements IMapRules
         * @constructor
         * @param {validate.IMapRules=} [properties] Properties to set
         */
        function MapRules(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MapRules minPairs.
         * @member {number|Long} minPairs
         * @memberof validate.MapRules
         * @instance
         */
        MapRules.prototype.minPairs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MapRules maxPairs.
         * @member {number|Long} maxPairs
         * @memberof validate.MapRules
         * @instance
         */
        MapRules.prototype.maxPairs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MapRules noSparse.
         * @member {boolean} noSparse
         * @memberof validate.MapRules
         * @instance
         */
        MapRules.prototype.noSparse = false;

        /**
         * MapRules keys.
         * @member {validate.IFieldRules|null|undefined} keys
         * @memberof validate.MapRules
         * @instance
         */
        MapRules.prototype.keys = null;

        /**
         * MapRules values.
         * @member {validate.IFieldRules|null|undefined} values
         * @memberof validate.MapRules
         * @instance
         */
        MapRules.prototype.values = null;

        /**
         * MapRules ignoreEmpty.
         * @member {boolean} ignoreEmpty
         * @memberof validate.MapRules
         * @instance
         */
        MapRules.prototype.ignoreEmpty = false;

        /**
         * Verifies a MapRules message.
         * @function verify
         * @memberof validate.MapRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.minPairs != null && message.hasOwnProperty("minPairs"))
                if (!$util.isInteger(message.minPairs) && !(message.minPairs && $util.isInteger(message.minPairs.low) && $util.isInteger(message.minPairs.high)))
                    return "minPairs: integer|Long expected";
            if (message.maxPairs != null && message.hasOwnProperty("maxPairs"))
                if (!$util.isInteger(message.maxPairs) && !(message.maxPairs && $util.isInteger(message.maxPairs.low) && $util.isInteger(message.maxPairs.high)))
                    return "maxPairs: integer|Long expected";
            if (message.noSparse != null && message.hasOwnProperty("noSparse"))
                if (typeof message.noSparse !== "boolean")
                    return "noSparse: boolean expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                let error = $root.validate.FieldRules.verify(message.keys);
                if (error)
                    return "keys." + error;
            }
            if (message.values != null && message.hasOwnProperty("values")) {
                let error = $root.validate.FieldRules.verify(message.values);
                if (error)
                    return "values." + error;
            }
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                if (typeof message.ignoreEmpty !== "boolean")
                    return "ignoreEmpty: boolean expected";
            return null;
        };

        /**
         * Creates a MapRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.MapRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.MapRules} MapRules
         */
        MapRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.MapRules)
                return object;
            let message = new $root.validate.MapRules();
            if (object.minPairs != null)
                if ($util.Long)
                    (message.minPairs = $util.Long.fromValue(object.minPairs)).unsigned = true;
                else if (typeof object.minPairs === "string")
                    message.minPairs = parseInt(object.minPairs, 10);
                else if (typeof object.minPairs === "number")
                    message.minPairs = object.minPairs;
                else if (typeof object.minPairs === "object")
                    message.minPairs = new $util.LongBits(object.minPairs.low >>> 0, object.minPairs.high >>> 0).toNumber(true);
            if (object.maxPairs != null)
                if ($util.Long)
                    (message.maxPairs = $util.Long.fromValue(object.maxPairs)).unsigned = true;
                else if (typeof object.maxPairs === "string")
                    message.maxPairs = parseInt(object.maxPairs, 10);
                else if (typeof object.maxPairs === "number")
                    message.maxPairs = object.maxPairs;
                else if (typeof object.maxPairs === "object")
                    message.maxPairs = new $util.LongBits(object.maxPairs.low >>> 0, object.maxPairs.high >>> 0).toNumber(true);
            if (object.noSparse != null)
                message.noSparse = Boolean(object.noSparse);
            if (object.keys != null) {
                if (typeof object.keys !== "object")
                    throw TypeError(".validate.MapRules.keys: object expected");
                message.keys = $root.validate.FieldRules.fromObject(object.keys);
            }
            if (object.values != null) {
                if (typeof object.values !== "object")
                    throw TypeError(".validate.MapRules.values: object expected");
                message.values = $root.validate.FieldRules.fromObject(object.values);
            }
            if (object.ignoreEmpty != null)
                message.ignoreEmpty = Boolean(object.ignoreEmpty);
            return message;
        };

        /**
         * Creates a plain object from a MapRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.MapRules
         * @static
         * @param {validate.MapRules} message MapRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.minPairs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minPairs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxPairs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxPairs = options.longs === String ? "0" : 0;
                object.noSparse = false;
                object.keys = null;
                object.values = null;
                object.ignoreEmpty = false;
            }
            if (message.minPairs != null && message.hasOwnProperty("minPairs"))
                if (typeof message.minPairs === "number")
                    object.minPairs = options.longs === String ? String(message.minPairs) : message.minPairs;
                else
                    object.minPairs = options.longs === String ? $util.Long.prototype.toString.call(message.minPairs) : options.longs === Number ? new $util.LongBits(message.minPairs.low >>> 0, message.minPairs.high >>> 0).toNumber(true) : message.minPairs;
            if (message.maxPairs != null && message.hasOwnProperty("maxPairs"))
                if (typeof message.maxPairs === "number")
                    object.maxPairs = options.longs === String ? String(message.maxPairs) : message.maxPairs;
                else
                    object.maxPairs = options.longs === String ? $util.Long.prototype.toString.call(message.maxPairs) : options.longs === Number ? new $util.LongBits(message.maxPairs.low >>> 0, message.maxPairs.high >>> 0).toNumber(true) : message.maxPairs;
            if (message.noSparse != null && message.hasOwnProperty("noSparse"))
                object.noSparse = message.noSparse;
            if (message.keys != null && message.hasOwnProperty("keys"))
                object.keys = $root.validate.FieldRules.toObject(message.keys, options);
            if (message.values != null && message.hasOwnProperty("values"))
                object.values = $root.validate.FieldRules.toObject(message.values, options);
            if (message.ignoreEmpty != null && message.hasOwnProperty("ignoreEmpty"))
                object.ignoreEmpty = message.ignoreEmpty;
            return object;
        };

        /**
         * Converts this MapRules to JSON.
         * @function toJSON
         * @memberof validate.MapRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MapRules;
    })();

    validate.AnyRules = (function() {

        /**
         * Properties of an AnyRules.
         * @memberof validate
         * @interface IAnyRules
         * @property {boolean|null} [required] AnyRules required
         * @property {Array.<string>|null} ["in"] AnyRules in
         * @property {Array.<string>|null} [notIn] AnyRules notIn
         */

        /**
         * Constructs a new AnyRules.
         * @memberof validate
         * @classdesc Represents an AnyRules.
         * @implements IAnyRules
         * @constructor
         * @param {validate.IAnyRules=} [properties] Properties to set
         */
        function AnyRules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AnyRules required.
         * @member {boolean} required
         * @memberof validate.AnyRules
         * @instance
         */
        AnyRules.prototype.required = false;

        /**
         * AnyRules in.
         * @member {Array.<string>} in
         * @memberof validate.AnyRules
         * @instance
         */
        AnyRules.prototype["in"] = $util.emptyArray;

        /**
         * AnyRules notIn.
         * @member {Array.<string>} notIn
         * @memberof validate.AnyRules
         * @instance
         */
        AnyRules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies an AnyRules message.
         * @function verify
         * @memberof validate.AnyRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AnyRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.required != null && message.hasOwnProperty("required"))
                if (typeof message.required !== "boolean")
                    return "required: boolean expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isString(message["in"][i]))
                        return "in: string[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isString(message.notIn[i]))
                        return "notIn: string[] expected";
            }
            return null;
        };

        /**
         * Creates an AnyRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.AnyRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.AnyRules} AnyRules
         */
        AnyRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.AnyRules)
                return object;
            let message = new $root.validate.AnyRules();
            if (object.required != null)
                message.required = Boolean(object.required);
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.AnyRules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = String(object["in"][i]);
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.AnyRules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = String(object.notIn[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an AnyRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.AnyRules
         * @static
         * @param {validate.AnyRules} message AnyRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AnyRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults)
                object.required = false;
            if (message.required != null && message.hasOwnProperty("required"))
                object.required = message.required;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this AnyRules to JSON.
         * @function toJSON
         * @memberof validate.AnyRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AnyRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AnyRules;
    })();

    validate.DurationRules = (function() {

        /**
         * Properties of a DurationRules.
         * @memberof validate
         * @interface IDurationRules
         * @property {boolean|null} [required] DurationRules required
         * @property {google.protobuf.IDuration|null} ["const"] DurationRules const
         * @property {google.protobuf.IDuration|null} [lt] DurationRules lt
         * @property {google.protobuf.IDuration|null} [lte] DurationRules lte
         * @property {google.protobuf.IDuration|null} [gt] DurationRules gt
         * @property {google.protobuf.IDuration|null} [gte] DurationRules gte
         * @property {Array.<google.protobuf.IDuration>|null} ["in"] DurationRules in
         * @property {Array.<google.protobuf.IDuration>|null} [notIn] DurationRules notIn
         */

        /**
         * Constructs a new DurationRules.
         * @memberof validate
         * @classdesc Represents a DurationRules.
         * @implements IDurationRules
         * @constructor
         * @param {validate.IDurationRules=} [properties] Properties to set
         */
        function DurationRules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DurationRules required.
         * @member {boolean} required
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype.required = false;

        /**
         * DurationRules const.
         * @member {google.protobuf.IDuration|null|undefined} const
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype["const"] = null;

        /**
         * DurationRules lt.
         * @member {google.protobuf.IDuration|null|undefined} lt
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype.lt = null;

        /**
         * DurationRules lte.
         * @member {google.protobuf.IDuration|null|undefined} lte
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype.lte = null;

        /**
         * DurationRules gt.
         * @member {google.protobuf.IDuration|null|undefined} gt
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype.gt = null;

        /**
         * DurationRules gte.
         * @member {google.protobuf.IDuration|null|undefined} gte
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype.gte = null;

        /**
         * DurationRules in.
         * @member {Array.<google.protobuf.IDuration>} in
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype["in"] = $util.emptyArray;

        /**
         * DurationRules notIn.
         * @member {Array.<google.protobuf.IDuration>} notIn
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies a DurationRules message.
         * @function verify
         * @memberof validate.DurationRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DurationRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.required != null && message.hasOwnProperty("required"))
                if (typeof message.required !== "boolean")
                    return "required: boolean expected";
            if (message["const"] != null && message.hasOwnProperty("const")) {
                let error = $root.google.protobuf.Duration.verify(message["const"]);
                if (error)
                    return "const." + error;
            }
            if (message.lt != null && message.hasOwnProperty("lt")) {
                let error = $root.google.protobuf.Duration.verify(message.lt);
                if (error)
                    return "lt." + error;
            }
            if (message.lte != null && message.hasOwnProperty("lte")) {
                let error = $root.google.protobuf.Duration.verify(message.lte);
                if (error)
                    return "lte." + error;
            }
            if (message.gt != null && message.hasOwnProperty("gt")) {
                let error = $root.google.protobuf.Duration.verify(message.gt);
                if (error)
                    return "gt." + error;
            }
            if (message.gte != null && message.hasOwnProperty("gte")) {
                let error = $root.google.protobuf.Duration.verify(message.gte);
                if (error)
                    return "gte." + error;
            }
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i) {
                    let error = $root.google.protobuf.Duration.verify(message["in"][i]);
                    if (error)
                        return "in." + error;
                }
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i) {
                    let error = $root.google.protobuf.Duration.verify(message.notIn[i]);
                    if (error)
                        return "notIn." + error;
                }
            }
            return null;
        };

        /**
         * Creates a DurationRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.DurationRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.DurationRules} DurationRules
         */
        DurationRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.DurationRules)
                return object;
            let message = new $root.validate.DurationRules();
            if (object.required != null)
                message.required = Boolean(object.required);
            if (object["const"] != null) {
                if (typeof object["const"] !== "object")
                    throw TypeError(".validate.DurationRules.const: object expected");
                message["const"] = $root.google.protobuf.Duration.fromObject(object["const"]);
            }
            if (object.lt != null) {
                if (typeof object.lt !== "object")
                    throw TypeError(".validate.DurationRules.lt: object expected");
                message.lt = $root.google.protobuf.Duration.fromObject(object.lt);
            }
            if (object.lte != null) {
                if (typeof object.lte !== "object")
                    throw TypeError(".validate.DurationRules.lte: object expected");
                message.lte = $root.google.protobuf.Duration.fromObject(object.lte);
            }
            if (object.gt != null) {
                if (typeof object.gt !== "object")
                    throw TypeError(".validate.DurationRules.gt: object expected");
                message.gt = $root.google.protobuf.Duration.fromObject(object.gt);
            }
            if (object.gte != null) {
                if (typeof object.gte !== "object")
                    throw TypeError(".validate.DurationRules.gte: object expected");
                message.gte = $root.google.protobuf.Duration.fromObject(object.gte);
            }
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.DurationRules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i) {
                    if (typeof object["in"][i] !== "object")
                        throw TypeError(".validate.DurationRules.in: object expected");
                    message["in"][i] = $root.google.protobuf.Duration.fromObject(object["in"][i]);
                }
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.DurationRules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i) {
                    if (typeof object.notIn[i] !== "object")
                        throw TypeError(".validate.DurationRules.notIn: object expected");
                    message.notIn[i] = $root.google.protobuf.Duration.fromObject(object.notIn[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a DurationRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.DurationRules
         * @static
         * @param {validate.DurationRules} message DurationRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DurationRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object.required = false;
                object["const"] = null;
                object.lt = null;
                object.lte = null;
                object.gt = null;
                object.gte = null;
            }
            if (message.required != null && message.hasOwnProperty("required"))
                object.required = message.required;
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = $root.google.protobuf.Duration.toObject(message["const"], options);
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = $root.google.protobuf.Duration.toObject(message.lt, options);
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = $root.google.protobuf.Duration.toObject(message.lte, options);
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = $root.google.protobuf.Duration.toObject(message.gt, options);
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = $root.google.protobuf.Duration.toObject(message.gte, options);
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = $root.google.protobuf.Duration.toObject(message["in"][j], options);
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = $root.google.protobuf.Duration.toObject(message.notIn[j], options);
            }
            return object;
        };

        /**
         * Converts this DurationRules to JSON.
         * @function toJSON
         * @memberof validate.DurationRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DurationRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DurationRules;
    })();

    validate.TimestampRules = (function() {

        /**
         * Properties of a TimestampRules.
         * @memberof validate
         * @interface ITimestampRules
         * @property {boolean|null} [required] TimestampRules required
         * @property {google.protobuf.ITimestamp|null} ["const"] TimestampRules const
         * @property {google.protobuf.ITimestamp|null} [lt] TimestampRules lt
         * @property {google.protobuf.ITimestamp|null} [lte] TimestampRules lte
         * @property {google.protobuf.ITimestamp|null} [gt] TimestampRules gt
         * @property {google.protobuf.ITimestamp|null} [gte] TimestampRules gte
         * @property {boolean|null} [ltNow] TimestampRules ltNow
         * @property {boolean|null} [gtNow] TimestampRules gtNow
         * @property {google.protobuf.IDuration|null} [within] TimestampRules within
         */

        /**
         * Constructs a new TimestampRules.
         * @memberof validate
         * @classdesc Represents a TimestampRules.
         * @implements ITimestampRules
         * @constructor
         * @param {validate.ITimestampRules=} [properties] Properties to set
         */
        function TimestampRules(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TimestampRules required.
         * @member {boolean} required
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.required = false;

        /**
         * TimestampRules const.
         * @member {google.protobuf.ITimestamp|null|undefined} const
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype["const"] = null;

        /**
         * TimestampRules lt.
         * @member {google.protobuf.ITimestamp|null|undefined} lt
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.lt = null;

        /**
         * TimestampRules lte.
         * @member {google.protobuf.ITimestamp|null|undefined} lte
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.lte = null;

        /**
         * TimestampRules gt.
         * @member {google.protobuf.ITimestamp|null|undefined} gt
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.gt = null;

        /**
         * TimestampRules gte.
         * @member {google.protobuf.ITimestamp|null|undefined} gte
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.gte = null;

        /**
         * TimestampRules ltNow.
         * @member {boolean} ltNow
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.ltNow = false;

        /**
         * TimestampRules gtNow.
         * @member {boolean} gtNow
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.gtNow = false;

        /**
         * TimestampRules within.
         * @member {google.protobuf.IDuration|null|undefined} within
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.within = null;

        /**
         * Verifies a TimestampRules message.
         * @function verify
         * @memberof validate.TimestampRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TimestampRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.required != null && message.hasOwnProperty("required"))
                if (typeof message.required !== "boolean")
                    return "required: boolean expected";
            if (message["const"] != null && message.hasOwnProperty("const")) {
                let error = $root.google.protobuf.Timestamp.verify(message["const"]);
                if (error)
                    return "const." + error;
            }
            if (message.lt != null && message.hasOwnProperty("lt")) {
                let error = $root.google.protobuf.Timestamp.verify(message.lt);
                if (error)
                    return "lt." + error;
            }
            if (message.lte != null && message.hasOwnProperty("lte")) {
                let error = $root.google.protobuf.Timestamp.verify(message.lte);
                if (error)
                    return "lte." + error;
            }
            if (message.gt != null && message.hasOwnProperty("gt")) {
                let error = $root.google.protobuf.Timestamp.verify(message.gt);
                if (error)
                    return "gt." + error;
            }
            if (message.gte != null && message.hasOwnProperty("gte")) {
                let error = $root.google.protobuf.Timestamp.verify(message.gte);
                if (error)
                    return "gte." + error;
            }
            if (message.ltNow != null && message.hasOwnProperty("ltNow"))
                if (typeof message.ltNow !== "boolean")
                    return "ltNow: boolean expected";
            if (message.gtNow != null && message.hasOwnProperty("gtNow"))
                if (typeof message.gtNow !== "boolean")
                    return "gtNow: boolean expected";
            if (message.within != null && message.hasOwnProperty("within")) {
                let error = $root.google.protobuf.Duration.verify(message.within);
                if (error)
                    return "within." + error;
            }
            return null;
        };

        /**
         * Creates a TimestampRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.TimestampRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.TimestampRules} TimestampRules
         */
        TimestampRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.TimestampRules)
                return object;
            let message = new $root.validate.TimestampRules();
            if (object.required != null)
                message.required = Boolean(object.required);
            if (object["const"] != null) {
                if (typeof object["const"] !== "object")
                    throw TypeError(".validate.TimestampRules.const: object expected");
                message["const"] = $root.google.protobuf.Timestamp.fromObject(object["const"]);
            }
            if (object.lt != null) {
                if (typeof object.lt !== "object")
                    throw TypeError(".validate.TimestampRules.lt: object expected");
                message.lt = $root.google.protobuf.Timestamp.fromObject(object.lt);
            }
            if (object.lte != null) {
                if (typeof object.lte !== "object")
                    throw TypeError(".validate.TimestampRules.lte: object expected");
                message.lte = $root.google.protobuf.Timestamp.fromObject(object.lte);
            }
            if (object.gt != null) {
                if (typeof object.gt !== "object")
                    throw TypeError(".validate.TimestampRules.gt: object expected");
                message.gt = $root.google.protobuf.Timestamp.fromObject(object.gt);
            }
            if (object.gte != null) {
                if (typeof object.gte !== "object")
                    throw TypeError(".validate.TimestampRules.gte: object expected");
                message.gte = $root.google.protobuf.Timestamp.fromObject(object.gte);
            }
            if (object.ltNow != null)
                message.ltNow = Boolean(object.ltNow);
            if (object.gtNow != null)
                message.gtNow = Boolean(object.gtNow);
            if (object.within != null) {
                if (typeof object.within !== "object")
                    throw TypeError(".validate.TimestampRules.within: object expected");
                message.within = $root.google.protobuf.Duration.fromObject(object.within);
            }
            return message;
        };

        /**
         * Creates a plain object from a TimestampRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.TimestampRules
         * @static
         * @param {validate.TimestampRules} message TimestampRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TimestampRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.required = false;
                object["const"] = null;
                object.lt = null;
                object.lte = null;
                object.gt = null;
                object.gte = null;
                object.ltNow = false;
                object.gtNow = false;
                object.within = null;
            }
            if (message.required != null && message.hasOwnProperty("required"))
                object.required = message.required;
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = $root.google.protobuf.Timestamp.toObject(message["const"], options);
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = $root.google.protobuf.Timestamp.toObject(message.lt, options);
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = $root.google.protobuf.Timestamp.toObject(message.lte, options);
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = $root.google.protobuf.Timestamp.toObject(message.gt, options);
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = $root.google.protobuf.Timestamp.toObject(message.gte, options);
            if (message.ltNow != null && message.hasOwnProperty("ltNow"))
                object.ltNow = message.ltNow;
            if (message.gtNow != null && message.hasOwnProperty("gtNow"))
                object.gtNow = message.gtNow;
            if (message.within != null && message.hasOwnProperty("within"))
                object.within = $root.google.protobuf.Duration.toObject(message.within, options);
            return object;
        };

        /**
         * Converts this TimestampRules to JSON.
         * @function toJSON
         * @memberof validate.TimestampRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TimestampRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TimestampRules;
    })();

    return validate;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Verifies a FileDescriptorSet message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (let i = 0; i < message.file.length; ++i) {
                        let error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorSet)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorSet();
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                    message.file = [];
                    for (let i = 0; i < object.file.length; ++i) {
                        if (typeof object.file[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                        message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.file = [];
                if (message.file && message.file.length) {
                    object.file = [];
                    for (let j = 0; j < message.file.length; ++j)
                        object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                }
                return object;
            };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorSet;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * Verifies a FileDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (let i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                    if (!Array.isArray(message.publicDependency))
                        return "publicDependency: array expected";
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        if (!$util.isInteger(message.publicDependency[i]))
                            return "publicDependency: integer[] expected";
                }
                if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                    if (!Array.isArray(message.weakDependency))
                        return "weakDependency: array expected";
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        if (!$util.isInteger(message.weakDependency[i]))
                            return "weakDependency: integer[] expected";
                }
                if (message.messageType != null && message.hasOwnProperty("messageType")) {
                    if (!Array.isArray(message.messageType))
                        return "messageType: array expected";
                    for (let i = 0; i < message.messageType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                        if (error)
                            return "messageType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (let i = 0; i < message.service.length; ++i) {
                        let error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                    let error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                    if (error)
                        return "sourceCodeInfo." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                return null;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object["package"] != null)
                    message["package"] = String(object["package"]);
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                    message.dependency = [];
                    for (let i = 0; i < object.dependency.length; ++i)
                        message.dependency[i] = String(object.dependency[i]);
                }
                if (object.publicDependency) {
                    if (!Array.isArray(object.publicDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                    message.publicDependency = [];
                    for (let i = 0; i < object.publicDependency.length; ++i)
                        message.publicDependency[i] = object.publicDependency[i] | 0;
                }
                if (object.weakDependency) {
                    if (!Array.isArray(object.weakDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                    message.weakDependency = [];
                    for (let i = 0; i < object.weakDependency.length; ++i)
                        message.weakDependency[i] = object.weakDependency[i] | 0;
                }
                if (object.messageType) {
                    if (!Array.isArray(object.messageType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                    message.messageType = [];
                    for (let i = 0; i < object.messageType.length; ++i) {
                        if (typeof object.messageType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                        message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (let i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                    message.service = [];
                    for (let i = 0; i < object.service.length; ++i) {
                        if (typeof object.service[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                        message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                }
                if (object.sourceCodeInfo != null) {
                    if (typeof object.sourceCodeInfo !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                    message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                }
                if (object.syntax != null)
                    message.syntax = String(object.syntax);
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependency = [];
                    object.messageType = [];
                    object.enumType = [];
                    object.service = [];
                    object.extension = [];
                    object.publicDependency = [];
                    object.weakDependency = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object["package"] = "";
                    object.options = null;
                    object.sourceCodeInfo = null;
                    object.syntax = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message["package"] != null && message.hasOwnProperty("package"))
                    object["package"] = message["package"];
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (let j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = message.dependency[j];
                }
                if (message.messageType && message.messageType.length) {
                    object.messageType = [];
                    for (let j = 0; j < message.messageType.length; ++j)
                        object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (let j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.service && message.service.length) {
                    object.service = [];
                    for (let j = 0; j < message.service.length; ++j)
                        object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                if (message.publicDependency && message.publicDependency.length) {
                    object.publicDependency = [];
                    for (let j = 0; j < message.publicDependency.length; ++j)
                        object.publicDependency[j] = message.publicDependency[j];
                }
                if (message.weakDependency && message.weakDependency.length) {
                    object.weakDependency = [];
                    for (let j = 0; j < message.weakDependency.length; ++j)
                        object.weakDependency[j] = message.weakDependency[j];
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    object.syntax = message.syntax;
                return object;
            };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */

            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Verifies a DescriptorProto message.
             * @function verify
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (let i = 0; i < message.field.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                    if (!Array.isArray(message.nestedType))
                        return "nestedType: array expected";
                    for (let i = 0; i < message.nestedType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                        if (error)
                            return "nestedType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                    if (!Array.isArray(message.extensionRange))
                        return "extensionRange: array expected";
                    for (let i = 0; i < message.extensionRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                        if (error)
                            return "extensionRange." + error;
                    }
                }
                if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                    if (!Array.isArray(message.oneofDecl))
                        return "oneofDecl: array expected";
                    for (let i = 0; i < message.oneofDecl.length; ++i) {
                        let error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                        if (error)
                            return "oneofDecl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (let i = 0; i < message.reservedRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (let i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DescriptorProto)
                    return object;
                let message = new $root.google.protobuf.DescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.field) {
                    if (!Array.isArray(object.field))
                        throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                    message.field = [];
                    for (let i = 0; i < object.field.length; ++i) {
                        if (typeof object.field[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                        message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.nestedType) {
                    if (!Array.isArray(object.nestedType))
                        throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                    message.nestedType = [];
                    for (let i = 0; i < object.nestedType.length; ++i) {
                        if (typeof object.nestedType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                        message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (let i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.extensionRange) {
                    if (!Array.isArray(object.extensionRange))
                        throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                    message.extensionRange = [];
                    for (let i = 0; i < object.extensionRange.length; ++i) {
                        if (typeof object.extensionRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                        message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                    }
                }
                if (object.oneofDecl) {
                    if (!Array.isArray(object.oneofDecl))
                        throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                    message.oneofDecl = [];
                    for (let i = 0; i < object.oneofDecl.length; ++i) {
                        if (typeof object.oneofDecl[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                        message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (let i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (let i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.field = [];
                    object.nestedType = [];
                    object.enumType = [];
                    object.extensionRange = [];
                    object.extension = [];
                    object.oneofDecl = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.field && message.field.length) {
                    object.field = [];
                    for (let j = 0; j < message.field.length; ++j)
                        object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                }
                if (message.nestedType && message.nestedType.length) {
                    object.nestedType = [];
                    for (let j = 0; j < message.nestedType.length; ++j)
                        object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (let j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.extensionRange && message.extensionRange.length) {
                    object.extensionRange = [];
                    for (let j = 0; j < message.extensionRange.length; ++j)
                        object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                if (message.oneofDecl && message.oneofDecl.length) {
                    object.oneofDecl = [];
                    for (let j = 0; j < message.oneofDecl.length; ++j)
                        object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                }
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (let j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (let j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Converts this DescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.DescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 * @property {google.protobuf.IExtensionRangeOptions|null} [options] ExtensionRange options
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * ExtensionRange options.
                 * @member {google.protobuf.IExtensionRangeOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.options = null;

                /**
                 * Verifies an ExtensionRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        let error = $root.google.protobuf.ExtensionRangeOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.ExtensionRange.options: object expected");
                        message.options = $root.google.protobuf.ExtensionRangeOptions.fromObject(object.options);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                        object.options = null;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.ExtensionRangeOptions.toObject(message.options, options);
                    return object;
                };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtensionRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Verifies a ReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.ExtensionRangeOptions = (function() {

            /**
             * Properties of an ExtensionRangeOptions.
             * @memberof google.protobuf
             * @interface IExtensionRangeOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ExtensionRangeOptions uninterpretedOption
             */

            /**
             * Constructs a new ExtensionRangeOptions.
             * @memberof google.protobuf
             * @classdesc Represents an ExtensionRangeOptions.
             * @implements IExtensionRangeOptions
             * @constructor
             * @param {google.protobuf.IExtensionRangeOptions=} [properties] Properties to set
             */
            function ExtensionRangeOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExtensionRangeOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ExtensionRangeOptions
             * @instance
             */
            ExtensionRangeOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Verifies an ExtensionRangeOptions message.
             * @function verify
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExtensionRangeOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an ExtensionRangeOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ExtensionRangeOptions} ExtensionRangeOptions
             */
            ExtensionRangeOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ExtensionRangeOptions)
                    return object;
                let message = new $root.google.protobuf.ExtensionRangeOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ExtensionRangeOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ExtensionRangeOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an ExtensionRangeOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {google.protobuf.ExtensionRangeOptions} message ExtensionRangeOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExtensionRangeOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ExtensionRangeOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ExtensionRangeOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExtensionRangeOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExtensionRangeOptions;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             * @property {boolean|null} [proto3Optional] FieldDescriptorProto proto3Optional
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * FieldDescriptorProto proto3Optional.
             * @member {boolean} proto3Optional
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.proto3Optional = false;

            /**
             * Verifies a FieldDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    if (!$util.isString(message.typeName))
                        return "typeName: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    if (!$util.isString(message.defaultValue))
                        return "defaultValue: string expected";
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    if (!$util.isInteger(message.oneofIndex))
                        return "oneofIndex: integer expected";
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    if (!$util.isString(message.jsonName))
                        return "jsonName: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.proto3Optional != null && message.hasOwnProperty("proto3Optional"))
                    if (typeof message.proto3Optional !== "boolean")
                        return "proto3Optional: boolean expected";
                return null;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FieldDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                switch (object.label) {
                case "LABEL_OPTIONAL":
                case 1:
                    message.label = 1;
                    break;
                case "LABEL_REQUIRED":
                case 2:
                    message.label = 2;
                    break;
                case "LABEL_REPEATED":
                case 3:
                    message.label = 3;
                    break;
                }
                switch (object.type) {
                case "TYPE_DOUBLE":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_FLOAT":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_INT64":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_UINT64":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_INT32":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_FIXED64":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_FIXED32":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BOOL":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_STRING":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_GROUP":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_MESSAGE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BYTES":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_UINT32":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_ENUM":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SFIXED32":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_SFIXED64":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SINT32":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_SINT64":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.typeName != null)
                    message.typeName = String(object.typeName);
                if (object.extendee != null)
                    message.extendee = String(object.extendee);
                if (object.defaultValue != null)
                    message.defaultValue = String(object.defaultValue);
                if (object.oneofIndex != null)
                    message.oneofIndex = object.oneofIndex | 0;
                if (object.jsonName != null)
                    message.jsonName = String(object.jsonName);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                }
                if (object.proto3Optional != null)
                    message.proto3Optional = Boolean(object.proto3Optional);
                return message;
            };

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.extendee = "";
                    object.number = 0;
                    object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                    object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                    object.typeName = "";
                    object.defaultValue = "";
                    object.options = null;
                    object.oneofIndex = 0;
                    object.jsonName = "";
                    object.proto3Optional = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    object.extendee = message.extendee;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    object.typeName = message.typeName;
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    object.defaultValue = message.defaultValue;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    object.oneofIndex = message.oneofIndex;
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    object.jsonName = message.jsonName;
                if (message.proto3Optional != null && message.hasOwnProperty("proto3Optional"))
                    object.proto3Optional = message.proto3Optional;
                return object;
            };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {number}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {number}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Verifies an OneofDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.OneofDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             * @property {Array.<google.protobuf.EnumDescriptorProto.IEnumReservedRange>|null} [reservedRange] EnumDescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] EnumDescriptorProto reservedName
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * EnumDescriptorProto reservedRange.
             * @member {Array.<google.protobuf.EnumDescriptorProto.IEnumReservedRange>} reservedRange
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * EnumDescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Verifies an EnumDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (let i = 0; i < message.value.length; ++i) {
                        let error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (let i = 0; i < message.reservedRange.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.EnumReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (let i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                    message.value = [];
                    for (let i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                        message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (let i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.EnumDescriptorProto.EnumReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (let i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.value = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (let j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (let j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.EnumDescriptorProto.EnumReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (let j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            EnumDescriptorProto.EnumReservedRange = (function() {

                /**
                 * Properties of an EnumReservedRange.
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @interface IEnumReservedRange
                 * @property {number|null} [start] EnumReservedRange start
                 * @property {number|null} [end] EnumReservedRange end
                 */

                /**
                 * Constructs a new EnumReservedRange.
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @classdesc Represents an EnumReservedRange.
                 * @implements IEnumReservedRange
                 * @constructor
                 * @param {google.protobuf.EnumDescriptorProto.IEnumReservedRange=} [properties] Properties to set
                 */
                function EnumReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EnumReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @instance
                 */
                EnumReservedRange.prototype.start = 0;

                /**
                 * EnumReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @instance
                 */
                EnumReservedRange.prototype.end = 0;

                /**
                 * Verifies an EnumReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an EnumReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumDescriptorProto.EnumReservedRange} EnumReservedRange
                 */
                EnumReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumDescriptorProto.EnumReservedRange)
                        return object;
                    let message = new $root.google.protobuf.EnumDescriptorProto.EnumReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an EnumReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto.EnumReservedRange} message EnumReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this EnumReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return EnumReservedRange;
            })();

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumValueDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.number = 0;
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Verifies a ServiceDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (let i = 0; i < message.method.length; ++i) {
                        let error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.ServiceDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.method) {
                    if (!Array.isArray(object.method))
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                    message.method = [];
                    for (let i = 0; i < object.method.length; ++i) {
                        if (typeof object.method[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                        message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.method = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.method && message.method.length) {
                    object.method = [];
                    for (let j = 0; j < message.method.length; ++j)
                        object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Verifies a MethodDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    if (!$util.isString(message.inputType))
                        return "inputType: string expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    if (!$util.isString(message.outputType))
                        return "outputType: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    if (typeof message.clientStreaming !== "boolean")
                        return "clientStreaming: boolean expected";
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    if (typeof message.serverStreaming !== "boolean")
                        return "serverStreaming: boolean expected";
                return null;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.MethodDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.inputType != null)
                    message.inputType = String(object.inputType);
                if (object.outputType != null)
                    message.outputType = String(object.outputType);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                }
                if (object.clientStreaming != null)
                    message.clientStreaming = Boolean(object.clientStreaming);
                if (object.serverStreaming != null)
                    message.serverStreaming = Boolean(object.serverStreaming);
                return message;
            };

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.inputType = "";
                    object.outputType = "";
                    object.options = null;
                    object.clientStreaming = false;
                    object.serverStreaming = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    object.inputType = message.inputType;
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = message.outputType;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    object.clientStreaming = message.clientStreaming;
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    object.serverStreaming = message.serverStreaming;
                return object;
            };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [phpGenericServices] FileOptions phpGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {string|null} [swiftPrefix] FileOptions swiftPrefix
             * @property {string|null} [phpClassPrefix] FileOptions phpClassPrefix
             * @property {string|null} [phpNamespace] FileOptions phpNamespace
             * @property {string|null} [phpMetadataNamespace] FileOptions phpMetadataNamespace
             * @property {string|null} [rubyPackage] FileOptions rubyPackage
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */

            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions phpGenericServices.
             * @member {boolean} phpGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.phpGenericServices = false;

            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = true;

            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions swiftPrefix.
             * @member {string} swiftPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.swiftPrefix = "";

            /**
             * FileOptions phpClassPrefix.
             * @member {string} phpClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.phpClassPrefix = "";

            /**
             * FileOptions phpNamespace.
             * @member {string} phpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.phpNamespace = "";

            /**
             * FileOptions phpMetadataNamespace.
             * @member {string} phpMetadataNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.phpMetadataNamespace = "";

            /**
             * FileOptions rubyPackage.
             * @member {string} rubyPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.rubyPackage = "";

            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Verifies a FileOptions message.
             * @function verify
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    if (!$util.isString(message.javaPackage))
                        return "javaPackage: string expected";
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    if (!$util.isString(message.javaOuterClassname))
                        return "javaOuterClassname: string expected";
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    if (typeof message.javaMultipleFiles !== "boolean")
                        return "javaMultipleFiles: boolean expected";
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                        return "javaGenerateEqualsAndHash: boolean expected";
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    if (typeof message.javaStringCheckUtf8 !== "boolean")
                        return "javaStringCheckUtf8: boolean expected";
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    switch (message.optimizeFor) {
                    default:
                        return "optimizeFor: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    if (!$util.isString(message.goPackage))
                        return "goPackage: string expected";
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    if (typeof message.ccGenericServices !== "boolean")
                        return "ccGenericServices: boolean expected";
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    if (typeof message.javaGenericServices !== "boolean")
                        return "javaGenericServices: boolean expected";
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    if (typeof message.pyGenericServices !== "boolean")
                        return "pyGenericServices: boolean expected";
                if (message.phpGenericServices != null && message.hasOwnProperty("phpGenericServices"))
                    if (typeof message.phpGenericServices !== "boolean")
                        return "phpGenericServices: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    if (typeof message.ccEnableArenas !== "boolean")
                        return "ccEnableArenas: boolean expected";
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    if (!$util.isString(message.objcClassPrefix))
                        return "objcClassPrefix: string expected";
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    if (!$util.isString(message.csharpNamespace))
                        return "csharpNamespace: string expected";
                if (message.swiftPrefix != null && message.hasOwnProperty("swiftPrefix"))
                    if (!$util.isString(message.swiftPrefix))
                        return "swiftPrefix: string expected";
                if (message.phpClassPrefix != null && message.hasOwnProperty("phpClassPrefix"))
                    if (!$util.isString(message.phpClassPrefix))
                        return "phpClassPrefix: string expected";
                if (message.phpNamespace != null && message.hasOwnProperty("phpNamespace"))
                    if (!$util.isString(message.phpNamespace))
                        return "phpNamespace: string expected";
                if (message.phpMetadataNamespace != null && message.hasOwnProperty("phpMetadataNamespace"))
                    if (!$util.isString(message.phpMetadataNamespace))
                        return "phpMetadataNamespace: string expected";
                if (message.rubyPackage != null && message.hasOwnProperty("rubyPackage"))
                    if (!$util.isString(message.rubyPackage))
                        return "rubyPackage: string expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileOptions)
                    return object;
                let message = new $root.google.protobuf.FileOptions();
                if (object.javaPackage != null)
                    message.javaPackage = String(object.javaPackage);
                if (object.javaOuterClassname != null)
                    message.javaOuterClassname = String(object.javaOuterClassname);
                if (object.javaMultipleFiles != null)
                    message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                if (object.javaGenerateEqualsAndHash != null)
                    message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                if (object.javaStringCheckUtf8 != null)
                    message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                switch (object.optimizeFor) {
                case "SPEED":
                case 1:
                    message.optimizeFor = 1;
                    break;
                case "CODE_SIZE":
                case 2:
                    message.optimizeFor = 2;
                    break;
                case "LITE_RUNTIME":
                case 3:
                    message.optimizeFor = 3;
                    break;
                }
                if (object.goPackage != null)
                    message.goPackage = String(object.goPackage);
                if (object.ccGenericServices != null)
                    message.ccGenericServices = Boolean(object.ccGenericServices);
                if (object.javaGenericServices != null)
                    message.javaGenericServices = Boolean(object.javaGenericServices);
                if (object.pyGenericServices != null)
                    message.pyGenericServices = Boolean(object.pyGenericServices);
                if (object.phpGenericServices != null)
                    message.phpGenericServices = Boolean(object.phpGenericServices);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.ccEnableArenas != null)
                    message.ccEnableArenas = Boolean(object.ccEnableArenas);
                if (object.objcClassPrefix != null)
                    message.objcClassPrefix = String(object.objcClassPrefix);
                if (object.csharpNamespace != null)
                    message.csharpNamespace = String(object.csharpNamespace);
                if (object.swiftPrefix != null)
                    message.swiftPrefix = String(object.swiftPrefix);
                if (object.phpClassPrefix != null)
                    message.phpClassPrefix = String(object.phpClassPrefix);
                if (object.phpNamespace != null)
                    message.phpNamespace = String(object.phpNamespace);
                if (object.phpMetadataNamespace != null)
                    message.phpMetadataNamespace = String(object.phpMetadataNamespace);
                if (object.rubyPackage != null)
                    message.rubyPackage = String(object.rubyPackage);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.javaPackage = "";
                    object.javaOuterClassname = "";
                    object.optimizeFor = options.enums === String ? "SPEED" : 1;
                    object.javaMultipleFiles = false;
                    object.goPackage = "";
                    object.ccGenericServices = false;
                    object.javaGenericServices = false;
                    object.pyGenericServices = false;
                    object.javaGenerateEqualsAndHash = false;
                    object.deprecated = false;
                    object.javaStringCheckUtf8 = false;
                    object.ccEnableArenas = true;
                    object.objcClassPrefix = "";
                    object.csharpNamespace = "";
                    object.swiftPrefix = "";
                    object.phpClassPrefix = "";
                    object.phpNamespace = "";
                    object.phpGenericServices = false;
                    object.phpMetadataNamespace = "";
                    object.rubyPackage = "";
                }
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    object.javaPackage = message.javaPackage;
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    object.javaOuterClassname = message.javaOuterClassname;
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    object.javaMultipleFiles = message.javaMultipleFiles;
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    object.goPackage = message.goPackage;
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    object.ccGenericServices = message.ccGenericServices;
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    object.javaGenericServices = message.javaGenericServices;
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    object.pyGenericServices = message.pyGenericServices;
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    object.ccEnableArenas = message.ccEnableArenas;
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    object.objcClassPrefix = message.objcClassPrefix;
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    object.csharpNamespace = message.csharpNamespace;
                if (message.swiftPrefix != null && message.hasOwnProperty("swiftPrefix"))
                    object.swiftPrefix = message.swiftPrefix;
                if (message.phpClassPrefix != null && message.hasOwnProperty("phpClassPrefix"))
                    object.phpClassPrefix = message.phpClassPrefix;
                if (message.phpNamespace != null && message.hasOwnProperty("phpNamespace"))
                    object.phpNamespace = message.phpNamespace;
                if (message.phpGenericServices != null && message.hasOwnProperty("phpGenericServices"))
                    object.phpGenericServices = message.phpGenericServices;
                if (message.phpMetadataNamespace != null && message.hasOwnProperty("phpMetadataNamespace"))
                    object.phpMetadataNamespace = message.phpMetadataNamespace;
                if (message.rubyPackage != null && message.hasOwnProperty("rubyPackage"))
                    object.rubyPackage = message.rubyPackage;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FileOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {number}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             * @property {clutch.api.v1.IReference|null} [".clutch.api.v1.reference"] MessageOptions .clutch.api.v1.reference
             * @property {clutch.api.v1.IIdentifier|null} [".clutch.api.v1.id"] MessageOptions .clutch.api.v1.id
             * @property {boolean|null} [".clutch.api.v1.redacted"] MessageOptions .clutch.api.v1.redacted
             * @property {boolean|null} [".validate.disabled"] MessageOptions .validate.disabled
             * @property {boolean|null} [".validate.ignored"] MessageOptions .validate.ignored
             * @property {clutch.resolver.v1.ISchemaMetadata|null} [".clutch.resolver.v1.schema"] MessageOptions .clutch.resolver.v1.schema
             */

            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * MessageOptions .clutch.api.v1.reference.
             * @member {clutch.api.v1.IReference|null|undefined} .clutch.api.v1.reference
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".clutch.api.v1.reference"] = null;

            /**
             * MessageOptions .clutch.api.v1.id.
             * @member {clutch.api.v1.IIdentifier|null|undefined} .clutch.api.v1.id
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".clutch.api.v1.id"] = null;

            /**
             * MessageOptions .clutch.api.v1.redacted.
             * @member {boolean} .clutch.api.v1.redacted
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".clutch.api.v1.redacted"] = false;

            /**
             * MessageOptions .validate.disabled.
             * @member {boolean} .validate.disabled
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".validate.disabled"] = false;

            /**
             * MessageOptions .validate.ignored.
             * @member {boolean} .validate.ignored
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".validate.ignored"] = false;

            /**
             * MessageOptions .clutch.resolver.v1.schema.
             * @member {clutch.resolver.v1.ISchemaMetadata|null|undefined} .clutch.resolver.v1.schema
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".clutch.resolver.v1.schema"] = null;

            /**
             * Verifies a MessageOptions message.
             * @function verify
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    if (typeof message.messageSetWireFormat !== "boolean")
                        return "messageSetWireFormat: boolean expected";
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    if (typeof message.noStandardDescriptorAccessor !== "boolean")
                        return "noStandardDescriptorAccessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    if (typeof message.mapEntry !== "boolean")
                        return "mapEntry: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".clutch.api.v1.reference"] != null && message.hasOwnProperty(".clutch.api.v1.reference")) {
                    let error = $root.clutch.api.v1.Reference.verify(message[".clutch.api.v1.reference"]);
                    if (error)
                        return ".clutch.api.v1.reference." + error;
                }
                if (message[".clutch.api.v1.id"] != null && message.hasOwnProperty(".clutch.api.v1.id")) {
                    let error = $root.clutch.api.v1.Identifier.verify(message[".clutch.api.v1.id"]);
                    if (error)
                        return ".clutch.api.v1.id." + error;
                }
                if (message[".clutch.api.v1.redacted"] != null && message.hasOwnProperty(".clutch.api.v1.redacted"))
                    if (typeof message[".clutch.api.v1.redacted"] !== "boolean")
                        return ".clutch.api.v1.redacted: boolean expected";
                if (message[".validate.disabled"] != null && message.hasOwnProperty(".validate.disabled"))
                    if (typeof message[".validate.disabled"] !== "boolean")
                        return ".validate.disabled: boolean expected";
                if (message[".validate.ignored"] != null && message.hasOwnProperty(".validate.ignored"))
                    if (typeof message[".validate.ignored"] !== "boolean")
                        return ".validate.ignored: boolean expected";
                if (message[".clutch.resolver.v1.schema"] != null && message.hasOwnProperty(".clutch.resolver.v1.schema")) {
                    let error = $root.clutch.resolver.v1.SchemaMetadata.verify(message[".clutch.resolver.v1.schema"]);
                    if (error)
                        return ".clutch.resolver.v1.schema." + error;
                }
                return null;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MessageOptions)
                    return object;
                let message = new $root.google.protobuf.MessageOptions();
                if (object.messageSetWireFormat != null)
                    message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                if (object.noStandardDescriptorAccessor != null)
                    message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.mapEntry != null)
                    message.mapEntry = Boolean(object.mapEntry);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".clutch.api.v1.reference"] != null) {
                    if (typeof object[".clutch.api.v1.reference"] !== "object")
                        throw TypeError(".google.protobuf.MessageOptions..clutch.api.v1.reference: object expected");
                    message[".clutch.api.v1.reference"] = $root.clutch.api.v1.Reference.fromObject(object[".clutch.api.v1.reference"]);
                }
                if (object[".clutch.api.v1.id"] != null) {
                    if (typeof object[".clutch.api.v1.id"] !== "object")
                        throw TypeError(".google.protobuf.MessageOptions..clutch.api.v1.id: object expected");
                    message[".clutch.api.v1.id"] = $root.clutch.api.v1.Identifier.fromObject(object[".clutch.api.v1.id"]);
                }
                if (object[".clutch.api.v1.redacted"] != null)
                    message[".clutch.api.v1.redacted"] = Boolean(object[".clutch.api.v1.redacted"]);
                if (object[".validate.disabled"] != null)
                    message[".validate.disabled"] = Boolean(object[".validate.disabled"]);
                if (object[".validate.ignored"] != null)
                    message[".validate.ignored"] = Boolean(object[".validate.ignored"]);
                if (object[".clutch.resolver.v1.schema"] != null) {
                    if (typeof object[".clutch.resolver.v1.schema"] !== "object")
                        throw TypeError(".google.protobuf.MessageOptions..clutch.resolver.v1.schema: object expected");
                    message[".clutch.resolver.v1.schema"] = $root.clutch.resolver.v1.SchemaMetadata.fromObject(object[".clutch.resolver.v1.schema"]);
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.messageSetWireFormat = false;
                    object.noStandardDescriptorAccessor = false;
                    object.deprecated = false;
                    object.mapEntry = false;
                    object[".validate.disabled"] = false;
                    object[".validate.ignored"] = false;
                    object[".clutch.api.v1.reference"] = null;
                    object[".clutch.api.v1.id"] = null;
                    object[".clutch.api.v1.redacted"] = false;
                    object[".clutch.resolver.v1.schema"] = null;
                }
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    object.messageSetWireFormat = message.messageSetWireFormat;
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    object.mapEntry = message.mapEntry;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".validate.disabled"] != null && message.hasOwnProperty(".validate.disabled"))
                    object[".validate.disabled"] = message[".validate.disabled"];
                if (message[".validate.ignored"] != null && message.hasOwnProperty(".validate.ignored"))
                    object[".validate.ignored"] = message[".validate.ignored"];
                if (message[".clutch.api.v1.reference"] != null && message.hasOwnProperty(".clutch.api.v1.reference"))
                    object[".clutch.api.v1.reference"] = $root.clutch.api.v1.Reference.toObject(message[".clutch.api.v1.reference"], options);
                if (message[".clutch.api.v1.id"] != null && message.hasOwnProperty(".clutch.api.v1.id"))
                    object[".clutch.api.v1.id"] = $root.clutch.api.v1.Identifier.toObject(message[".clutch.api.v1.id"], options);
                if (message[".clutch.api.v1.redacted"] != null && message.hasOwnProperty(".clutch.api.v1.redacted"))
                    object[".clutch.api.v1.redacted"] = message[".clutch.api.v1.redacted"];
                if (message[".clutch.resolver.v1.schema"] != null && message.hasOwnProperty(".clutch.resolver.v1.schema"))
                    object[".clutch.resolver.v1.schema"] = $root.clutch.resolver.v1.SchemaMetadata.toObject(message[".clutch.resolver.v1.schema"], options);
                return object;
            };

            /**
             * Converts this MessageOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MessageOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             * @property {boolean|null} [".clutch.api.v1.log"] FieldOptions .clutch.api.v1.log
             * @property {validate.IFieldRules|null} [".validate.rules"] FieldOptions .validate.rules
             * @property {clutch.resolver.v1.IFieldMetadata|null} [".clutch.resolver.v1.schemaField"] FieldOptions .clutch.resolver.v1.schemaField
             */

            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * FieldOptions .clutch.api.v1.log.
             * @member {boolean} .clutch.api.v1.log
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".clutch.api.v1.log"] = false;

            /**
             * FieldOptions .validate.rules.
             * @member {validate.IFieldRules|null|undefined} .validate.rules
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".validate.rules"] = null;

            /**
             * FieldOptions .clutch.resolver.v1.schemaField.
             * @member {clutch.resolver.v1.IFieldMetadata|null|undefined} .clutch.resolver.v1.schemaField
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".clutch.resolver.v1.schemaField"] = null;

            /**
             * Verifies a FieldOptions message.
             * @function verify
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".clutch.api.v1.log"] != null && message.hasOwnProperty(".clutch.api.v1.log"))
                    if (typeof message[".clutch.api.v1.log"] !== "boolean")
                        return ".clutch.api.v1.log: boolean expected";
                if (message[".validate.rules"] != null && message.hasOwnProperty(".validate.rules")) {
                    let error = $root.validate.FieldRules.verify(message[".validate.rules"]);
                    if (error)
                        return ".validate.rules." + error;
                }
                if (message[".clutch.resolver.v1.schemaField"] != null && message.hasOwnProperty(".clutch.resolver.v1.schemaField")) {
                    let error = $root.clutch.resolver.v1.FieldMetadata.verify(message[".clutch.resolver.v1.schemaField"]);
                    if (error)
                        return ".clutch.resolver.v1.schemaField." + error;
                }
                return null;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldOptions)
                    return object;
                let message = new $root.google.protobuf.FieldOptions();
                switch (object.ctype) {
                case "STRING":
                case 0:
                    message.ctype = 0;
                    break;
                case "CORD":
                case 1:
                    message.ctype = 1;
                    break;
                case "STRING_PIECE":
                case 2:
                    message.ctype = 2;
                    break;
                }
                if (object.packed != null)
                    message.packed = Boolean(object.packed);
                switch (object.jstype) {
                case "JS_NORMAL":
                case 0:
                    message.jstype = 0;
                    break;
                case "JS_STRING":
                case 1:
                    message.jstype = 1;
                    break;
                case "JS_NUMBER":
                case 2:
                    message.jstype = 2;
                    break;
                }
                if (object.lazy != null)
                    message.lazy = Boolean(object.lazy);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.weak != null)
                    message.weak = Boolean(object.weak);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".clutch.api.v1.log"] != null)
                    message[".clutch.api.v1.log"] = Boolean(object[".clutch.api.v1.log"]);
                if (object[".validate.rules"] != null) {
                    if (typeof object[".validate.rules"] !== "object")
                        throw TypeError(".google.protobuf.FieldOptions..validate.rules: object expected");
                    message[".validate.rules"] = $root.validate.FieldRules.fromObject(object[".validate.rules"]);
                }
                if (object[".clutch.resolver.v1.schemaField"] != null) {
                    if (typeof object[".clutch.resolver.v1.schemaField"] !== "object")
                        throw TypeError(".google.protobuf.FieldOptions..clutch.resolver.v1.schemaField: object expected");
                    message[".clutch.resolver.v1.schemaField"] = $root.clutch.resolver.v1.FieldMetadata.fromObject(object[".clutch.resolver.v1.schemaField"]);
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.ctype = options.enums === String ? "STRING" : 0;
                    object.packed = false;
                    object.deprecated = false;
                    object.lazy = false;
                    object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                    object.weak = false;
                    object[".validate.rules"] = null;
                    object[".clutch.api.v1.log"] = false;
                    object[".clutch.resolver.v1.schemaField"] = null;
                }
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                if (message.packed != null && message.hasOwnProperty("packed"))
                    object.packed = message.packed;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    object.lazy = message.lazy;
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                if (message.weak != null && message.hasOwnProperty("weak"))
                    object.weak = message.weak;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".validate.rules"] != null && message.hasOwnProperty(".validate.rules"))
                    object[".validate.rules"] = $root.validate.FieldRules.toObject(message[".validate.rules"], options);
                if (message[".clutch.api.v1.log"] != null && message.hasOwnProperty(".clutch.api.v1.log"))
                    object[".clutch.api.v1.log"] = message[".clutch.api.v1.log"];
                if (message[".clutch.resolver.v1.schemaField"] != null && message.hasOwnProperty(".clutch.resolver.v1.schemaField"))
                    object[".clutch.resolver.v1.schemaField"] = $root.clutch.resolver.v1.FieldMetadata.toObject(message[".clutch.resolver.v1.schemaField"], options);
                return object;
            };

            /**
             * Converts this FieldOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {number}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {number}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             * @property {boolean|null} [".validate.required"] OneofOptions .validate.required
             */

            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * OneofOptions .validate.required.
             * @member {boolean} .validate.required
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype[".validate.required"] = false;

            /**
             * Verifies an OneofOptions message.
             * @function verify
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".validate.required"] != null && message.hasOwnProperty(".validate.required"))
                    if (typeof message[".validate.required"] !== "boolean")
                        return ".validate.required: boolean expected";
                return null;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofOptions)
                    return object;
                let message = new $root.google.protobuf.OneofOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".validate.required"] != null)
                    message[".validate.required"] = Boolean(object[".validate.required"]);
                return message;
            };

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object[".validate.required"] = false;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".validate.required"] != null && message.hasOwnProperty(".validate.required"))
                    object[".validate.required"] = message[".validate.required"];
                return object;
            };

            /**
             * Converts this OneofOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Verifies an EnumOptions message.
             * @function verify
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    if (typeof message.allowAlias !== "boolean")
                        return "allowAlias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumOptions)
                    return object;
                let message = new $root.google.protobuf.EnumOptions();
                if (object.allowAlias != null)
                    message.allowAlias = Boolean(object.allowAlias);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.allowAlias = false;
                    object.deprecated = false;
                }
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    object.allowAlias = message.allowAlias;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Verifies an EnumValueOptions message.
             * @function verify
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueOptions)
                    return object;
                let message = new $root.google.protobuf.EnumValueOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumValueOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */

            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Verifies a ServiceOptions message.
             * @function verify
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceOptions)
                    return object;
                let message = new $root.google.protobuf.ServiceOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ServiceOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {google.protobuf.MethodOptions.IdempotencyLevel|null} [idempotencyLevel] MethodOptions idempotencyLevel
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             * @property {clutch.api.v1.IAction|null} [".clutch.api.v1.action"] MethodOptions .clutch.api.v1.action
             * @property {boolean|null} [".clutch.api.v1.disableAudit"] MethodOptions .clutch.api.v1.disableAudit
             * @property {google.api.IHttpRule|null} [".google.api.http"] MethodOptions .google.api.http
             */

            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions idempotencyLevel.
             * @member {google.protobuf.MethodOptions.IdempotencyLevel} idempotencyLevel
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.idempotencyLevel = 0;

            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * MethodOptions .clutch.api.v1.action.
             * @member {clutch.api.v1.IAction|null|undefined} .clutch.api.v1.action
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype[".clutch.api.v1.action"] = null;

            /**
             * MethodOptions .clutch.api.v1.disableAudit.
             * @member {boolean} .clutch.api.v1.disableAudit
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype[".clutch.api.v1.disableAudit"] = false;

            /**
             * MethodOptions .google.api.http.
             * @member {google.api.IHttpRule|null|undefined} .google.api.http
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype[".google.api.http"] = null;

            /**
             * Verifies a MethodOptions message.
             * @function verify
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.idempotencyLevel != null && message.hasOwnProperty("idempotencyLevel"))
                    switch (message.idempotencyLevel) {
                    default:
                        return "idempotencyLevel: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".clutch.api.v1.action"] != null && message.hasOwnProperty(".clutch.api.v1.action")) {
                    let error = $root.clutch.api.v1.Action.verify(message[".clutch.api.v1.action"]);
                    if (error)
                        return ".clutch.api.v1.action." + error;
                }
                if (message[".clutch.api.v1.disableAudit"] != null && message.hasOwnProperty(".clutch.api.v1.disableAudit"))
                    if (typeof message[".clutch.api.v1.disableAudit"] !== "boolean")
                        return ".clutch.api.v1.disableAudit: boolean expected";
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http")) {
                    let error = $root.google.api.HttpRule.verify(message[".google.api.http"]);
                    if (error)
                        return ".google.api.http." + error;
                }
                return null;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodOptions)
                    return object;
                let message = new $root.google.protobuf.MethodOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                switch (object.idempotencyLevel) {
                case "IDEMPOTENCY_UNKNOWN":
                case 0:
                    message.idempotencyLevel = 0;
                    break;
                case "NO_SIDE_EFFECTS":
                case 1:
                    message.idempotencyLevel = 1;
                    break;
                case "IDEMPOTENT":
                case 2:
                    message.idempotencyLevel = 2;
                    break;
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".clutch.api.v1.action"] != null) {
                    if (typeof object[".clutch.api.v1.action"] !== "object")
                        throw TypeError(".google.protobuf.MethodOptions..clutch.api.v1.action: object expected");
                    message[".clutch.api.v1.action"] = $root.clutch.api.v1.Action.fromObject(object[".clutch.api.v1.action"]);
                }
                if (object[".clutch.api.v1.disableAudit"] != null)
                    message[".clutch.api.v1.disableAudit"] = Boolean(object[".clutch.api.v1.disableAudit"]);
                if (object[".google.api.http"] != null) {
                    if (typeof object[".google.api.http"] !== "object")
                        throw TypeError(".google.protobuf.MethodOptions..google.api.http: object expected");
                    message[".google.api.http"] = $root.google.api.HttpRule.fromObject(object[".google.api.http"]);
                }
                return message;
            };

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.deprecated = false;
                    object.idempotencyLevel = options.enums === String ? "IDEMPOTENCY_UNKNOWN" : 0;
                    object[".clutch.api.v1.action"] = null;
                    object[".clutch.api.v1.disableAudit"] = false;
                    object[".google.api.http"] = null;
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.idempotencyLevel != null && message.hasOwnProperty("idempotencyLevel"))
                    object.idempotencyLevel = options.enums === String ? $root.google.protobuf.MethodOptions.IdempotencyLevel[message.idempotencyLevel] : message.idempotencyLevel;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".clutch.api.v1.action"] != null && message.hasOwnProperty(".clutch.api.v1.action"))
                    object[".clutch.api.v1.action"] = $root.clutch.api.v1.Action.toObject(message[".clutch.api.v1.action"], options);
                if (message[".clutch.api.v1.disableAudit"] != null && message.hasOwnProperty(".clutch.api.v1.disableAudit"))
                    object[".clutch.api.v1.disableAudit"] = message[".clutch.api.v1.disableAudit"];
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                    object[".google.api.http"] = $root.google.api.HttpRule.toObject(message[".google.api.http"], options);
                return object;
            };

            /**
             * Converts this MethodOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * IdempotencyLevel enum.
             * @name google.protobuf.MethodOptions.IdempotencyLevel
             * @enum {number}
             * @property {number} IDEMPOTENCY_UNKNOWN=0 IDEMPOTENCY_UNKNOWN value
             * @property {number} NO_SIDE_EFFECTS=1 NO_SIDE_EFFECTS value
             * @property {number} IDEMPOTENT=2 IDEMPOTENT value
             */
            MethodOptions.IdempotencyLevel = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "IDEMPOTENCY_UNKNOWN"] = 0;
                values[valuesById[1] = "NO_SIDE_EFFECTS"] = 1;
                values[valuesById[2] = "IDEMPOTENT"] = 2;
                return values;
            })();

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */

            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @member {number|Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @member {number|Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Verifies an UninterpretedOption message.
             * @function verify
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (let i = 0; i < message.name.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    if (!$util.isString(message.identifierValue))
                        return "identifierValue: string expected";
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                        return "positiveIntValue: integer|Long expected";
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                        return "negativeIntValue: integer|Long expected";
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                        return "stringValue: buffer expected";
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    if (!$util.isString(message.aggregateValue))
                        return "aggregateValue: string expected";
                return null;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UninterpretedOption)
                    return object;
                let message = new $root.google.protobuf.UninterpretedOption();
                if (object.name) {
                    if (!Array.isArray(object.name))
                        throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                    message.name = [];
                    for (let i = 0; i < object.name.length; ++i) {
                        if (typeof object.name[i] !== "object")
                            throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                        message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                    }
                }
                if (object.identifierValue != null)
                    message.identifierValue = String(object.identifierValue);
                if (object.positiveIntValue != null)
                    if ($util.Long)
                        (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                    else if (typeof object.positiveIntValue === "string")
                        message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                    else if (typeof object.positiveIntValue === "number")
                        message.positiveIntValue = object.positiveIntValue;
                    else if (typeof object.positiveIntValue === "object")
                        message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                if (object.negativeIntValue != null)
                    if ($util.Long)
                        (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                    else if (typeof object.negativeIntValue === "string")
                        message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                    else if (typeof object.negativeIntValue === "number")
                        message.negativeIntValue = object.negativeIntValue;
                    else if (typeof object.negativeIntValue === "object")
                        message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                if (object.doubleValue != null)
                    message.doubleValue = Number(object.doubleValue);
                if (object.stringValue != null)
                    if (typeof object.stringValue === "string")
                        $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                    else if (object.stringValue.length)
                        message.stringValue = object.stringValue;
                if (object.aggregateValue != null)
                    message.aggregateValue = String(object.aggregateValue);
                return message;
            };

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.name = [];
                if (options.defaults) {
                    object.identifierValue = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.positiveIntValue = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.negativeIntValue = options.longs === String ? "0" : 0;
                    object.doubleValue = 0;
                    if (options.bytes === String)
                        object.stringValue = "";
                    else {
                        object.stringValue = [];
                        if (options.bytes !== Array)
                            object.stringValue = $util.newBuffer(object.stringValue);
                    }
                    object.aggregateValue = "";
                }
                if (message.name && message.name.length) {
                    object.name = [];
                    for (let j = 0; j < message.name.length; ++j)
                        object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    object.identifierValue = message.identifierValue;
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (typeof message.positiveIntValue === "number")
                        object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                    else
                        object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (typeof message.negativeIntValue === "number")
                        object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                    else
                        object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    object.aggregateValue = message.aggregateValue;
                return object;
            };

            /**
             * Converts this UninterpretedOption to JSON.
             * @function toJSON
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UninterpretedOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */

                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Verifies a NamePart message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.namePart))
                        return "namePart: string expected";
                    if (typeof message.isExtension !== "boolean")
                        return "isExtension: boolean expected";
                    return null;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                        return object;
                    let message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    if (object.namePart != null)
                        message.namePart = String(object.namePart);
                    if (object.isExtension != null)
                        message.isExtension = Boolean(object.isExtension);
                    return message;
                };

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.namePart = "";
                        object.isExtension = false;
                    }
                    if (message.namePart != null && message.hasOwnProperty("namePart"))
                        object.namePart = message.namePart;
                    if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                        object.isExtension = message.isExtension;
                    return object;
                };

                /**
                 * Converts this NamePart to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamePart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Verifies a SourceCodeInfo message.
             * @function verify
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (let i = 0; i < message.location.length; ++i) {
                        let error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.SourceCodeInfo)
                    return object;
                let message = new $root.google.protobuf.SourceCodeInfo();
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                    message.location = [];
                    for (let i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                        message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.location = [];
                if (message.location && message.location.length) {
                    object.location = [];
                    for (let j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                }
                return object;
            };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */

                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (let i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        if (!$util.isString(message.leadingComments))
                            return "leadingComments: string expected";
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        if (!$util.isString(message.trailingComments))
                            return "trailingComments: string expected";
                    if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                        if (!Array.isArray(message.leadingDetachedComments))
                            return "leadingDetachedComments: array expected";
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            if (!$util.isString(message.leadingDetachedComments[i]))
                                return "leadingDetachedComments: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                        return object;
                    let message = new $root.google.protobuf.SourceCodeInfo.Location();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.span) {
                        if (!Array.isArray(object.span))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                        message.span = [];
                        for (let i = 0; i < object.span.length; ++i)
                            message.span[i] = object.span[i] | 0;
                    }
                    if (object.leadingComments != null)
                        message.leadingComments = String(object.leadingComments);
                    if (object.trailingComments != null)
                        message.trailingComments = String(object.trailingComments);
                    if (object.leadingDetachedComments) {
                        if (!Array.isArray(object.leadingDetachedComments))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                        message.leadingDetachedComments = [];
                        for (let i = 0; i < object.leadingDetachedComments.length; ++i)
                            message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.path = [];
                        object.span = [];
                        object.leadingDetachedComments = [];
                    }
                    if (options.defaults) {
                        object.leadingComments = "";
                        object.trailingComments = "";
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.span && message.span.length) {
                        object.span = [];
                        for (let j = 0; j < message.span.length; ++j)
                            object.span[j] = message.span[j];
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        object.leadingComments = message.leadingComments;
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        object.trailingComments = message.trailingComments;
                    if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                        object.leadingDetachedComments = [];
                        for (let j = 0; j < message.leadingDetachedComments.length; ++j)
                            object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                    }
                    return object;
                };

                /**
                 * Converts this Location to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Verifies a GeneratedCodeInfo message.
             * @function verify
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (let i = 0; i < message.annotation.length; ++i) {
                        let error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                    return object;
                let message = new $root.google.protobuf.GeneratedCodeInfo();
                if (object.annotation) {
                    if (!Array.isArray(object.annotation))
                        throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                    message.annotation = [];
                    for (let i = 0; i < object.annotation.length; ++i) {
                        if (typeof object.annotation[i] !== "object")
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                        message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.annotation = [];
                if (message.annotation && message.annotation.length) {
                    object.annotation = [];
                    for (let j = 0; j < message.annotation.length; ++j)
                        object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                }
                return object;
            };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 */

                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;

                /**
                 * Verifies an Annotation message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        if (!$util.isString(message.sourceFile))
                            return "sourceFile: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                        return object;
                    let message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.sourceFile != null)
                        message.sourceFile = String(object.sourceFile);
                    if (object.begin != null)
                        message.begin = object.begin | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.sourceFile = "";
                        object.begin = 0;
                        object.end = 0;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        object.sourceFile = message.sourceFile;
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        object.begin = message.begin;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this Annotation to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Annotation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                let message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        protobuf.Duration = (function() {

            /**
             * Properties of a Duration.
             * @memberof google.protobuf
             * @interface IDuration
             * @property {number|Long|null} [seconds] Duration seconds
             * @property {number|null} [nanos] Duration nanos
             */

            /**
             * Constructs a new Duration.
             * @memberof google.protobuf
             * @classdesc Represents a Duration.
             * @implements IDuration
             * @constructor
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             */
            function Duration(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Duration seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Duration nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.nanos = 0;

            /**
             * Verifies a Duration message.
             * @function verify
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Duration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Duration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Duration} Duration
             */
            Duration.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Duration)
                    return object;
                let message = new $root.google.protobuf.Duration();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Duration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.Duration} message Duration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Duration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Duration to JSON.
             * @function toJSON
             * @memberof google.protobuf.Duration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Duration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Duration;
        })();

        protobuf.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @memberof google.protobuf
             * @interface ITimestamp
             * @property {number|Long|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */

            /**
             * Constructs a new Timestamp.
             * @memberof google.protobuf
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Verifies a Timestamp message.
             * @function verify
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp)
                    return object;
                let message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Timestamp to JSON.
             * @function toJSON
             * @memberof google.protobuf.Timestamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Timestamp;
        })();

        protobuf.Struct = (function() {

            /**
             * Properties of a Struct.
             * @memberof google.protobuf
             * @interface IStruct
             * @property {Object.<string,google.protobuf.IValue>|null} [fields] Struct fields
             */

            /**
             * Constructs a new Struct.
             * @memberof google.protobuf
             * @classdesc Represents a Struct.
             * @implements IStruct
             * @constructor
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             */
            function Struct(properties) {
                this.fields = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Struct fields.
             * @member {Object.<string,google.protobuf.IValue>} fields
             * @memberof google.protobuf.Struct
             * @instance
             */
            Struct.prototype.fields = $util.emptyObject;

            /**
             * Verifies a Struct message.
             * @function verify
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Struct.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!$util.isObject(message.fields))
                        return "fields: object expected";
                    let key = Object.keys(message.fields);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.google.protobuf.Value.verify(message.fields[key[i]]);
                        if (error)
                            return "fields." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Struct message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Struct} Struct
             */
            Struct.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Struct)
                    return object;
                let message = new $root.google.protobuf.Struct();
                if (object.fields) {
                    if (typeof object.fields !== "object")
                        throw TypeError(".google.protobuf.Struct.fields: object expected");
                    message.fields = {};
                    for (let keys = Object.keys(object.fields), i = 0; i < keys.length; ++i) {
                        if (typeof object.fields[keys[i]] !== "object")
                            throw TypeError(".google.protobuf.Struct.fields: object expected");
                        message.fields[keys[i]] = $root.google.protobuf.Value.fromObject(object.fields[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Struct message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.Struct} message Struct
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Struct.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.fields = {};
                let keys2;
                if (message.fields && (keys2 = Object.keys(message.fields)).length) {
                    object.fields = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.fields[keys2[j]] = $root.google.protobuf.Value.toObject(message.fields[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this Struct to JSON.
             * @function toJSON
             * @memberof google.protobuf.Struct
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Struct.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Struct;
        })();

        protobuf.Value = (function() {

            /**
             * Properties of a Value.
             * @memberof google.protobuf
             * @interface IValue
             * @property {google.protobuf.NullValue|null} [nullValue] Value nullValue
             * @property {number|null} [numberValue] Value numberValue
             * @property {string|null} [stringValue] Value stringValue
             * @property {boolean|null} [boolValue] Value boolValue
             * @property {google.protobuf.IStruct|null} [structValue] Value structValue
             * @property {google.protobuf.IListValue|null} [listValue] Value listValue
             */

            /**
             * Constructs a new Value.
             * @memberof google.protobuf
             * @classdesc Represents a Value.
             * @implements IValue
             * @constructor
             * @param {google.protobuf.IValue=} [properties] Properties to set
             */
            function Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Value nullValue.
             * @member {google.protobuf.NullValue|null|undefined} nullValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.nullValue = null;

            /**
             * Value numberValue.
             * @member {number|null|undefined} numberValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.numberValue = null;

            /**
             * Value stringValue.
             * @member {string|null|undefined} stringValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.stringValue = null;

            /**
             * Value boolValue.
             * @member {boolean|null|undefined} boolValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.boolValue = null;

            /**
             * Value structValue.
             * @member {google.protobuf.IStruct|null|undefined} structValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.structValue = null;

            /**
             * Value listValue.
             * @member {google.protobuf.IListValue|null|undefined} listValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.listValue = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Value kind.
             * @member {"nullValue"|"numberValue"|"stringValue"|"boolValue"|"structValue"|"listValue"|undefined} kind
             * @memberof google.protobuf.Value
             * @instance
             */
            Object.defineProperty(Value.prototype, "kind", {
                get: $util.oneOfGetter($oneOfFields = ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Verifies a Value message.
             * @function verify
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    properties.kind = 1;
                    switch (message.nullValue) {
                    default:
                        return "nullValue: enum value expected";
                    case 0:
                        break;
                    }
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.numberValue !== "number")
                        return "numberValue: number expected";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (!$util.isString(message.stringValue))
                        return "stringValue: string expected";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.boolValue !== "boolean")
                        return "boolValue: boolean expected";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        let error = $root.google.protobuf.Struct.verify(message.structValue);
                        if (error)
                            return "structValue." + error;
                    }
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        let error = $root.google.protobuf.ListValue.verify(message.listValue);
                        if (error)
                            return "listValue." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Value} Value
             */
            Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Value)
                    return object;
                let message = new $root.google.protobuf.Value();
                switch (object.nullValue) {
                case "NULL_VALUE":
                case 0:
                    message.nullValue = 0;
                    break;
                }
                if (object.numberValue != null)
                    message.numberValue = Number(object.numberValue);
                if (object.stringValue != null)
                    message.stringValue = String(object.stringValue);
                if (object.boolValue != null)
                    message.boolValue = Boolean(object.boolValue);
                if (object.structValue != null) {
                    if (typeof object.structValue !== "object")
                        throw TypeError(".google.protobuf.Value.structValue: object expected");
                    message.structValue = $root.google.protobuf.Struct.fromObject(object.structValue);
                }
                if (object.listValue != null) {
                    if (typeof object.listValue !== "object")
                        throw TypeError(".google.protobuf.Value.listValue: object expected");
                    message.listValue = $root.google.protobuf.ListValue.fromObject(object.listValue);
                }
                return message;
            };

            /**
             * Creates a plain object from a Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.Value} message Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;
                    if (options.oneofs)
                        object.kind = "nullValue";
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    object.numberValue = options.json && !isFinite(message.numberValue) ? String(message.numberValue) : message.numberValue;
                    if (options.oneofs)
                        object.kind = "numberValue";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    object.stringValue = message.stringValue;
                    if (options.oneofs)
                        object.kind = "stringValue";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    object.boolValue = message.boolValue;
                    if (options.oneofs)
                        object.kind = "boolValue";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    object.structValue = $root.google.protobuf.Struct.toObject(message.structValue, options);
                    if (options.oneofs)
                        object.kind = "structValue";
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    object.listValue = $root.google.protobuf.ListValue.toObject(message.listValue, options);
                    if (options.oneofs)
                        object.kind = "listValue";
                }
                return object;
            };

            /**
             * Converts this Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Value;
        })();

        /**
         * NullValue enum.
         * @name google.protobuf.NullValue
         * @enum {number}
         * @property {number} NULL_VALUE=0 NULL_VALUE value
         */
        protobuf.NullValue = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NULL_VALUE"] = 0;
            return values;
        })();

        protobuf.ListValue = (function() {

            /**
             * Properties of a ListValue.
             * @memberof google.protobuf
             * @interface IListValue
             * @property {Array.<google.protobuf.IValue>|null} [values] ListValue values
             */

            /**
             * Constructs a new ListValue.
             * @memberof google.protobuf
             * @classdesc Represents a ListValue.
             * @implements IListValue
             * @constructor
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             */
            function ListValue(properties) {
                this.values = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListValue values.
             * @member {Array.<google.protobuf.IValue>} values
             * @memberof google.protobuf.ListValue
             * @instance
             */
            ListValue.prototype.values = $util.emptyArray;

            /**
             * Verifies a ListValue message.
             * @function verify
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (let i = 0; i < message.values.length; ++i) {
                        let error = $root.google.protobuf.Value.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ListValue} ListValue
             */
            ListValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ListValue)
                    return object;
                let message = new $root.google.protobuf.ListValue();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".google.protobuf.ListValue.values: array expected");
                    message.values = [];
                    for (let i = 0; i < object.values.length; ++i) {
                        if (typeof object.values[i] !== "object")
                            throw TypeError(".google.protobuf.ListValue.values: object expected");
                        message.values[i] = $root.google.protobuf.Value.fromObject(object.values[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.ListValue} message ListValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (let j = 0; j < message.values.length; ++j)
                        object.values[j] = $root.google.protobuf.Value.toObject(message.values[j], options);
                }
                return object;
            };

            /**
             * Converts this ListValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.ListValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListValue;
        })();

        protobuf.DoubleValue = (function() {

            /**
             * Properties of a DoubleValue.
             * @memberof google.protobuf
             * @interface IDoubleValue
             * @property {number|null} [value] DoubleValue value
             */

            /**
             * Constructs a new DoubleValue.
             * @memberof google.protobuf
             * @classdesc Represents a DoubleValue.
             * @implements IDoubleValue
             * @constructor
             * @param {google.protobuf.IDoubleValue=} [properties] Properties to set
             */
            function DoubleValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DoubleValue value.
             * @member {number} value
             * @memberof google.protobuf.DoubleValue
             * @instance
             */
            DoubleValue.prototype.value = 0;

            /**
             * Verifies a DoubleValue message.
             * @function verify
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DoubleValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a DoubleValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DoubleValue} DoubleValue
             */
            DoubleValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DoubleValue)
                    return object;
                let message = new $root.google.protobuf.DoubleValue();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a DoubleValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.DoubleValue} message DoubleValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DoubleValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this DoubleValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.DoubleValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DoubleValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DoubleValue;
        })();

        protobuf.FloatValue = (function() {

            /**
             * Properties of a FloatValue.
             * @memberof google.protobuf
             * @interface IFloatValue
             * @property {number|null} [value] FloatValue value
             */

            /**
             * Constructs a new FloatValue.
             * @memberof google.protobuf
             * @classdesc Represents a FloatValue.
             * @implements IFloatValue
             * @constructor
             * @param {google.protobuf.IFloatValue=} [properties] Properties to set
             */
            function FloatValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FloatValue value.
             * @member {number} value
             * @memberof google.protobuf.FloatValue
             * @instance
             */
            FloatValue.prototype.value = 0;

            /**
             * Verifies a FloatValue message.
             * @function verify
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FloatValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a FloatValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FloatValue} FloatValue
             */
            FloatValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FloatValue)
                    return object;
                let message = new $root.google.protobuf.FloatValue();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a FloatValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.FloatValue} message FloatValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FloatValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this FloatValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.FloatValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FloatValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FloatValue;
        })();

        protobuf.Int64Value = (function() {

            /**
             * Properties of an Int64Value.
             * @memberof google.protobuf
             * @interface IInt64Value
             * @property {number|Long|null} [value] Int64Value value
             */

            /**
             * Constructs a new Int64Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int64Value.
             * @implements IInt64Value
             * @constructor
             * @param {google.protobuf.IInt64Value=} [properties] Properties to set
             */
            function Int64Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Int64Value value.
             * @member {number|Long} value
             * @memberof google.protobuf.Int64Value
             * @instance
             */
            Int64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Verifies an Int64Value message.
             * @function verify
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Int64Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates an Int64Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Int64Value} Int64Value
             */
            Int64Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Int64Value)
                    return object;
                let message = new $root.google.protobuf.Int64Value();
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an Int64Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.Int64Value} message Int64Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Int64Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                return object;
            };

            /**
             * Converts this Int64Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Int64Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Int64Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Int64Value;
        })();

        protobuf.UInt64Value = (function() {

            /**
             * Properties of a UInt64Value.
             * @memberof google.protobuf
             * @interface IUInt64Value
             * @property {number|Long|null} [value] UInt64Value value
             */

            /**
             * Constructs a new UInt64Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt64Value.
             * @implements IUInt64Value
             * @constructor
             * @param {google.protobuf.IUInt64Value=} [properties] Properties to set
             */
            function UInt64Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UInt64Value value.
             * @member {number|Long} value
             * @memberof google.protobuf.UInt64Value
             * @instance
             */
            UInt64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Verifies a UInt64Value message.
             * @function verify
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UInt64Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates a UInt64Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UInt64Value} UInt64Value
             */
            UInt64Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UInt64Value)
                    return object;
                let message = new $root.google.protobuf.UInt64Value();
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a UInt64Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.UInt64Value} message UInt64Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UInt64Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                return object;
            };

            /**
             * Converts this UInt64Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.UInt64Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UInt64Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UInt64Value;
        })();

        protobuf.Int32Value = (function() {

            /**
             * Properties of an Int32Value.
             * @memberof google.protobuf
             * @interface IInt32Value
             * @property {number|null} [value] Int32Value value
             */

            /**
             * Constructs a new Int32Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int32Value.
             * @implements IInt32Value
             * @constructor
             * @param {google.protobuf.IInt32Value=} [properties] Properties to set
             */
            function Int32Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Int32Value value.
             * @member {number} value
             * @memberof google.protobuf.Int32Value
             * @instance
             */
            Int32Value.prototype.value = 0;

            /**
             * Verifies an Int32Value message.
             * @function verify
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Int32Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates an Int32Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Int32Value} Int32Value
             */
            Int32Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Int32Value)
                    return object;
                let message = new $root.google.protobuf.Int32Value();
                if (object.value != null)
                    message.value = object.value | 0;
                return message;
            };

            /**
             * Creates a plain object from an Int32Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.Int32Value} message Int32Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Int32Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this Int32Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Int32Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Int32Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Int32Value;
        })();

        protobuf.UInt32Value = (function() {

            /**
             * Properties of a UInt32Value.
             * @memberof google.protobuf
             * @interface IUInt32Value
             * @property {number|null} [value] UInt32Value value
             */

            /**
             * Constructs a new UInt32Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt32Value.
             * @implements IUInt32Value
             * @constructor
             * @param {google.protobuf.IUInt32Value=} [properties] Properties to set
             */
            function UInt32Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UInt32Value value.
             * @member {number} value
             * @memberof google.protobuf.UInt32Value
             * @instance
             */
            UInt32Value.prototype.value = 0;

            /**
             * Verifies a UInt32Value message.
             * @function verify
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UInt32Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates a UInt32Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UInt32Value} UInt32Value
             */
            UInt32Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UInt32Value)
                    return object;
                let message = new $root.google.protobuf.UInt32Value();
                if (object.value != null)
                    message.value = object.value >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a UInt32Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.UInt32Value} message UInt32Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UInt32Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this UInt32Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.UInt32Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UInt32Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UInt32Value;
        })();

        protobuf.BoolValue = (function() {

            /**
             * Properties of a BoolValue.
             * @memberof google.protobuf
             * @interface IBoolValue
             * @property {boolean|null} [value] BoolValue value
             */

            /**
             * Constructs a new BoolValue.
             * @memberof google.protobuf
             * @classdesc Represents a BoolValue.
             * @implements IBoolValue
             * @constructor
             * @param {google.protobuf.IBoolValue=} [properties] Properties to set
             */
            function BoolValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BoolValue value.
             * @member {boolean} value
             * @memberof google.protobuf.BoolValue
             * @instance
             */
            BoolValue.prototype.value = false;

            /**
             * Verifies a BoolValue message.
             * @function verify
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BoolValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "boolean")
                        return "value: boolean expected";
                return null;
            };

            /**
             * Creates a BoolValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.BoolValue} BoolValue
             */
            BoolValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.BoolValue)
                    return object;
                let message = new $root.google.protobuf.BoolValue();
                if (object.value != null)
                    message.value = Boolean(object.value);
                return message;
            };

            /**
             * Creates a plain object from a BoolValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.BoolValue} message BoolValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BoolValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = false;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this BoolValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.BoolValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BoolValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BoolValue;
        })();

        protobuf.StringValue = (function() {

            /**
             * Properties of a StringValue.
             * @memberof google.protobuf
             * @interface IStringValue
             * @property {string|null} [value] StringValue value
             */

            /**
             * Constructs a new StringValue.
             * @memberof google.protobuf
             * @classdesc Represents a StringValue.
             * @implements IStringValue
             * @constructor
             * @param {google.protobuf.IStringValue=} [properties] Properties to set
             */
            function StringValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StringValue value.
             * @member {string} value
             * @memberof google.protobuf.StringValue
             * @instance
             */
            StringValue.prototype.value = "";

            /**
             * Verifies a StringValue message.
             * @function verify
             * @memberof google.protobuf.StringValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StringValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a StringValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.StringValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.StringValue} StringValue
             */
            StringValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.StringValue)
                    return object;
                let message = new $root.google.protobuf.StringValue();
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a StringValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.StringValue} message StringValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StringValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = "";
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this StringValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.StringValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StringValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StringValue;
        })();

        protobuf.BytesValue = (function() {

            /**
             * Properties of a BytesValue.
             * @memberof google.protobuf
             * @interface IBytesValue
             * @property {Uint8Array|null} [value] BytesValue value
             */

            /**
             * Constructs a new BytesValue.
             * @memberof google.protobuf
             * @classdesc Represents a BytesValue.
             * @implements IBytesValue
             * @constructor
             * @param {google.protobuf.IBytesValue=} [properties] Properties to set
             */
            function BytesValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BytesValue value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.BytesValue
             * @instance
             */
            BytesValue.prototype.value = $util.newBuffer([]);

            /**
             * Verifies a BytesValue message.
             * @function verify
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BytesValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a BytesValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.BytesValue} BytesValue
             */
            BytesValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.BytesValue)
                    return object;
                let message = new $root.google.protobuf.BytesValue();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a BytesValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.BytesValue} message BytesValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BytesValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this BytesValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.BytesValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BytesValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BytesValue;
        })();

        return protobuf;
    })();

    google.rpc = (function() {

        /**
         * Namespace rpc.
         * @memberof google
         * @namespace
         */
        const rpc = {};

        rpc.Status = (function() {

            /**
             * Properties of a Status.
             * @memberof google.rpc
             * @interface IStatus
             * @property {number|null} [code] Status code
             * @property {string|null} [message] Status message
             * @property {Array.<google.protobuf.IAny>|null} [details] Status details
             */

            /**
             * Constructs a new Status.
             * @memberof google.rpc
             * @classdesc Represents a Status.
             * @implements IStatus
             * @constructor
             * @param {google.rpc.IStatus=} [properties] Properties to set
             */
            function Status(properties) {
                this.details = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Status code.
             * @member {number} code
             * @memberof google.rpc.Status
             * @instance
             */
            Status.prototype.code = 0;

            /**
             * Status message.
             * @member {string} message
             * @memberof google.rpc.Status
             * @instance
             */
            Status.prototype.message = "";

            /**
             * Status details.
             * @member {Array.<google.protobuf.IAny>} details
             * @memberof google.rpc.Status
             * @instance
             */
            Status.prototype.details = $util.emptyArray;

            /**
             * Verifies a Status message.
             * @function verify
             * @memberof google.rpc.Status
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Status.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    if (!$util.isInteger(message.code))
                        return "code: integer expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.details != null && message.hasOwnProperty("details")) {
                    if (!Array.isArray(message.details))
                        return "details: array expected";
                    for (let i = 0; i < message.details.length; ++i) {
                        let error = $root.google.protobuf.Any.verify(message.details[i]);
                        if (error)
                            return "details." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Status message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.rpc.Status
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.rpc.Status} Status
             */
            Status.fromObject = function fromObject(object) {
                if (object instanceof $root.google.rpc.Status)
                    return object;
                let message = new $root.google.rpc.Status();
                if (object.code != null)
                    message.code = object.code | 0;
                if (object.message != null)
                    message.message = String(object.message);
                if (object.details) {
                    if (!Array.isArray(object.details))
                        throw TypeError(".google.rpc.Status.details: array expected");
                    message.details = [];
                    for (let i = 0; i < object.details.length; ++i) {
                        if (typeof object.details[i] !== "object")
                            throw TypeError(".google.rpc.Status.details: object expected");
                        message.details[i] = $root.google.protobuf.Any.fromObject(object.details[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Status message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.rpc.Status
             * @static
             * @param {google.rpc.Status} message Status
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Status.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.details = [];
                if (options.defaults) {
                    object.code = 0;
                    object.message = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = message.code;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.details && message.details.length) {
                    object.details = [];
                    for (let j = 0; j < message.details.length; ++j)
                        object.details[j] = $root.google.protobuf.Any.toObject(message.details[j], options);
                }
                return object;
            };

            /**
             * Converts this Status to JSON.
             * @function toJSON
             * @memberof google.rpc.Status
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Status.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Status;
        })();

        return rpc;
    })();

    google.api = (function() {

        /**
         * Namespace api.
         * @memberof google
         * @namespace
         */
        const api = {};

        api.Http = (function() {

            /**
             * Properties of a Http.
             * @memberof google.api
             * @interface IHttp
             * @property {Array.<google.api.IHttpRule>|null} [rules] Http rules
             * @property {boolean|null} [fullyDecodeReservedExpansion] Http fullyDecodeReservedExpansion
             */

            /**
             * Constructs a new Http.
             * @memberof google.api
             * @classdesc Represents a Http.
             * @implements IHttp
             * @constructor
             * @param {google.api.IHttp=} [properties] Properties to set
             */
            function Http(properties) {
                this.rules = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Http rules.
             * @member {Array.<google.api.IHttpRule>} rules
             * @memberof google.api.Http
             * @instance
             */
            Http.prototype.rules = $util.emptyArray;

            /**
             * Http fullyDecodeReservedExpansion.
             * @member {boolean} fullyDecodeReservedExpansion
             * @memberof google.api.Http
             * @instance
             */
            Http.prototype.fullyDecodeReservedExpansion = false;

            /**
             * Verifies a Http message.
             * @function verify
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Http.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rules != null && message.hasOwnProperty("rules")) {
                    if (!Array.isArray(message.rules))
                        return "rules: array expected";
                    for (let i = 0; i < message.rules.length; ++i) {
                        let error = $root.google.api.HttpRule.verify(message.rules[i]);
                        if (error)
                            return "rules." + error;
                    }
                }
                if (message.fullyDecodeReservedExpansion != null && message.hasOwnProperty("fullyDecodeReservedExpansion"))
                    if (typeof message.fullyDecodeReservedExpansion !== "boolean")
                        return "fullyDecodeReservedExpansion: boolean expected";
                return null;
            };

            /**
             * Creates a Http message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.Http} Http
             */
            Http.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.Http)
                    return object;
                let message = new $root.google.api.Http();
                if (object.rules) {
                    if (!Array.isArray(object.rules))
                        throw TypeError(".google.api.Http.rules: array expected");
                    message.rules = [];
                    for (let i = 0; i < object.rules.length; ++i) {
                        if (typeof object.rules[i] !== "object")
                            throw TypeError(".google.api.Http.rules: object expected");
                        message.rules[i] = $root.google.api.HttpRule.fromObject(object.rules[i]);
                    }
                }
                if (object.fullyDecodeReservedExpansion != null)
                    message.fullyDecodeReservedExpansion = Boolean(object.fullyDecodeReservedExpansion);
                return message;
            };

            /**
             * Creates a plain object from a Http message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.Http
             * @static
             * @param {google.api.Http} message Http
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Http.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.rules = [];
                if (options.defaults)
                    object.fullyDecodeReservedExpansion = false;
                if (message.rules && message.rules.length) {
                    object.rules = [];
                    for (let j = 0; j < message.rules.length; ++j)
                        object.rules[j] = $root.google.api.HttpRule.toObject(message.rules[j], options);
                }
                if (message.fullyDecodeReservedExpansion != null && message.hasOwnProperty("fullyDecodeReservedExpansion"))
                    object.fullyDecodeReservedExpansion = message.fullyDecodeReservedExpansion;
                return object;
            };

            /**
             * Converts this Http to JSON.
             * @function toJSON
             * @memberof google.api.Http
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Http.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Http;
        })();

        api.HttpRule = (function() {

            /**
             * Properties of a HttpRule.
             * @memberof google.api
             * @interface IHttpRule
             * @property {string|null} [selector] HttpRule selector
             * @property {string|null} [get] HttpRule get
             * @property {string|null} [put] HttpRule put
             * @property {string|null} [post] HttpRule post
             * @property {string|null} ["delete"] HttpRule delete
             * @property {string|null} [patch] HttpRule patch
             * @property {google.api.ICustomHttpPattern|null} [custom] HttpRule custom
             * @property {string|null} [body] HttpRule body
             * @property {string|null} [responseBody] HttpRule responseBody
             * @property {Array.<google.api.IHttpRule>|null} [additionalBindings] HttpRule additionalBindings
             */

            /**
             * Constructs a new HttpRule.
             * @memberof google.api
             * @classdesc Represents a HttpRule.
             * @implements IHttpRule
             * @constructor
             * @param {google.api.IHttpRule=} [properties] Properties to set
             */
            function HttpRule(properties) {
                this.additionalBindings = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HttpRule selector.
             * @member {string} selector
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.selector = "";

            /**
             * HttpRule get.
             * @member {string|null|undefined} get
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.get = null;

            /**
             * HttpRule put.
             * @member {string|null|undefined} put
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.put = null;

            /**
             * HttpRule post.
             * @member {string|null|undefined} post
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.post = null;

            /**
             * HttpRule delete.
             * @member {string|null|undefined} delete
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype["delete"] = null;

            /**
             * HttpRule patch.
             * @member {string|null|undefined} patch
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.patch = null;

            /**
             * HttpRule custom.
             * @member {google.api.ICustomHttpPattern|null|undefined} custom
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.custom = null;

            /**
             * HttpRule body.
             * @member {string} body
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.body = "";

            /**
             * HttpRule responseBody.
             * @member {string} responseBody
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.responseBody = "";

            /**
             * HttpRule additionalBindings.
             * @member {Array.<google.api.IHttpRule>} additionalBindings
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.additionalBindings = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * HttpRule pattern.
             * @member {"get"|"put"|"post"|"delete"|"patch"|"custom"|undefined} pattern
             * @memberof google.api.HttpRule
             * @instance
             */
            Object.defineProperty(HttpRule.prototype, "pattern", {
                get: $util.oneOfGetter($oneOfFields = ["get", "put", "post", "delete", "patch", "custom"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Verifies a HttpRule message.
             * @function verify
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HttpRule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.selector != null && message.hasOwnProperty("selector"))
                    if (!$util.isString(message.selector))
                        return "selector: string expected";
                if (message.get != null && message.hasOwnProperty("get")) {
                    properties.pattern = 1;
                    if (!$util.isString(message.get))
                        return "get: string expected";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.put))
                        return "put: string expected";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.post))
                        return "post: string expected";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message["delete"]))
                        return "delete: string expected";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.patch))
                        return "patch: string expected";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    {
                        let error = $root.google.api.CustomHttpPattern.verify(message.custom);
                        if (error)
                            return "custom." + error;
                    }
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!$util.isString(message.body))
                        return "body: string expected";
                if (message.responseBody != null && message.hasOwnProperty("responseBody"))
                    if (!$util.isString(message.responseBody))
                        return "responseBody: string expected";
                if (message.additionalBindings != null && message.hasOwnProperty("additionalBindings")) {
                    if (!Array.isArray(message.additionalBindings))
                        return "additionalBindings: array expected";
                    for (let i = 0; i < message.additionalBindings.length; ++i) {
                        let error = $root.google.api.HttpRule.verify(message.additionalBindings[i]);
                        if (error)
                            return "additionalBindings." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a HttpRule message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.HttpRule} HttpRule
             */
            HttpRule.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.HttpRule)
                    return object;
                let message = new $root.google.api.HttpRule();
                if (object.selector != null)
                    message.selector = String(object.selector);
                if (object.get != null)
                    message.get = String(object.get);
                if (object.put != null)
                    message.put = String(object.put);
                if (object.post != null)
                    message.post = String(object.post);
                if (object["delete"] != null)
                    message["delete"] = String(object["delete"]);
                if (object.patch != null)
                    message.patch = String(object.patch);
                if (object.custom != null) {
                    if (typeof object.custom !== "object")
                        throw TypeError(".google.api.HttpRule.custom: object expected");
                    message.custom = $root.google.api.CustomHttpPattern.fromObject(object.custom);
                }
                if (object.body != null)
                    message.body = String(object.body);
                if (object.responseBody != null)
                    message.responseBody = String(object.responseBody);
                if (object.additionalBindings) {
                    if (!Array.isArray(object.additionalBindings))
                        throw TypeError(".google.api.HttpRule.additionalBindings: array expected");
                    message.additionalBindings = [];
                    for (let i = 0; i < object.additionalBindings.length; ++i) {
                        if (typeof object.additionalBindings[i] !== "object")
                            throw TypeError(".google.api.HttpRule.additionalBindings: object expected");
                        message.additionalBindings[i] = $root.google.api.HttpRule.fromObject(object.additionalBindings[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a HttpRule message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.HttpRule} message HttpRule
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HttpRule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.additionalBindings = [];
                if (options.defaults) {
                    object.selector = "";
                    object.body = "";
                    object.responseBody = "";
                }
                if (message.selector != null && message.hasOwnProperty("selector"))
                    object.selector = message.selector;
                if (message.get != null && message.hasOwnProperty("get")) {
                    object.get = message.get;
                    if (options.oneofs)
                        object.pattern = "get";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    object.put = message.put;
                    if (options.oneofs)
                        object.pattern = "put";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    object.post = message.post;
                    if (options.oneofs)
                        object.pattern = "post";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    object["delete"] = message["delete"];
                    if (options.oneofs)
                        object.pattern = "delete";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    object.patch = message.patch;
                    if (options.oneofs)
                        object.pattern = "patch";
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = message.body;
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    object.custom = $root.google.api.CustomHttpPattern.toObject(message.custom, options);
                    if (options.oneofs)
                        object.pattern = "custom";
                }
                if (message.additionalBindings && message.additionalBindings.length) {
                    object.additionalBindings = [];
                    for (let j = 0; j < message.additionalBindings.length; ++j)
                        object.additionalBindings[j] = $root.google.api.HttpRule.toObject(message.additionalBindings[j], options);
                }
                if (message.responseBody != null && message.hasOwnProperty("responseBody"))
                    object.responseBody = message.responseBody;
                return object;
            };

            /**
             * Converts this HttpRule to JSON.
             * @function toJSON
             * @memberof google.api.HttpRule
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HttpRule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HttpRule;
        })();

        api.CustomHttpPattern = (function() {

            /**
             * Properties of a CustomHttpPattern.
             * @memberof google.api
             * @interface ICustomHttpPattern
             * @property {string|null} [kind] CustomHttpPattern kind
             * @property {string|null} [path] CustomHttpPattern path
             */

            /**
             * Constructs a new CustomHttpPattern.
             * @memberof google.api
             * @classdesc Represents a CustomHttpPattern.
             * @implements ICustomHttpPattern
             * @constructor
             * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
             */
            function CustomHttpPattern(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CustomHttpPattern kind.
             * @member {string} kind
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.kind = "";

            /**
             * CustomHttpPattern path.
             * @member {string} path
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.path = "";

            /**
             * Verifies a CustomHttpPattern message.
             * @function verify
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CustomHttpPattern.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a CustomHttpPattern message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             */
            CustomHttpPattern.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.CustomHttpPattern)
                    return object;
                let message = new $root.google.api.CustomHttpPattern();
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a CustomHttpPattern message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.CustomHttpPattern} message CustomHttpPattern
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomHttpPattern.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.kind = "";
                    object.path = "";
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this CustomHttpPattern to JSON.
             * @function toJSON
             * @memberof google.api.CustomHttpPattern
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CustomHttpPattern.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CustomHttpPattern;
        })();

        return api;
    })();

    return google;
})();

export { $root as default };
