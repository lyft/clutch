// Code generated by protobuf.js in compile-protos.sh. DO NOT EDIT.

/*eslint-disable block-scoped-var, id-length, no-control-regex, no-magic-numbers, no-prototype-builtins, no-redeclare, no-shadow, no-var, sort-vars*/
import * as $protobuf from "protobufjs/minimal";

// Common aliases
const $util = $protobuf.util;

// Exported root namespace
const $root = $protobuf.roots["default"] || ($protobuf.roots["default"] = {});

export const clutch = $root.clutch = (() => {

    /**
     * Namespace clutch.
     * @exports clutch
     * @namespace
     */
    const clutch = {};

    clutch.api = (function() {

        /**
         * Namespace api.
         * @memberof clutch
         * @namespace
         */
        const api = {};

        api.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.api
             * @namespace
             */
            const v1 = {};

            /**
             * ActionType enum.
             * @name clutch.api.v1.ActionType
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} CREATE=1 CREATE value
             * @property {number} READ=2 READ value
             * @property {number} UPDATE=3 UPDATE value
             * @property {number} DELETE=4 DELETE value
             */
            v1.ActionType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "CREATE"] = 1;
                values[valuesById[2] = "READ"] = 2;
                values[valuesById[3] = "UPDATE"] = 3;
                values[valuesById[4] = "DELETE"] = 4;
                return values;
            })();

            v1.Action = (function() {

                /**
                 * Properties of an Action.
                 * @memberof clutch.api.v1
                 * @interface IAction
                 * @property {clutch.api.v1.ActionType|null} [type] Action type
                 */

                /**
                 * Constructs a new Action.
                 * @memberof clutch.api.v1
                 * @classdesc Represents an Action.
                 * @implements IAction
                 * @constructor
                 * @param {clutch.api.v1.IAction=} [properties] Properties to set
                 */
                function Action(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Action type.
                 * @member {clutch.api.v1.ActionType} type
                 * @memberof clutch.api.v1.Action
                 * @instance
                 */
                Action.prototype.type = 0;

                /**
                 * Verifies an Action message.
                 * @function verify
                 * @memberof clutch.api.v1.Action
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Action.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates an Action message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.api.v1.Action
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.api.v1.Action} Action
                 */
                Action.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.api.v1.Action)
                        return object;
                    let message = new $root.clutch.api.v1.Action();
                    switch (object.type) {
                    case "UNSPECIFIED":
                    case 0:
                        message.type = 0;
                        break;
                    case "CREATE":
                    case 1:
                        message.type = 1;
                        break;
                    case "READ":
                    case 2:
                        message.type = 2;
                        break;
                    case "UPDATE":
                    case 3:
                        message.type = 3;
                        break;
                    case "DELETE":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Action message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.api.v1.Action
                 * @static
                 * @param {clutch.api.v1.Action} message Action
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Action.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.type = options.enums === String ? "UNSPECIFIED" : 0;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.clutch.api.v1.ActionType[message.type] : message.type;
                    return object;
                };

                /**
                 * Converts this Action to JSON.
                 * @function toJSON
                 * @memberof clutch.api.v1.Action
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Action.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Action;
            })();

            v1.Pattern = (function() {

                /**
                 * Properties of a Pattern.
                 * @memberof clutch.api.v1
                 * @interface IPattern
                 * @property {string|null} [typeUrl] Pattern typeUrl
                 * @property {string|null} [pattern] Pattern pattern
                 */

                /**
                 * Constructs a new Pattern.
                 * @memberof clutch.api.v1
                 * @classdesc Represents a Pattern.
                 * @implements IPattern
                 * @constructor
                 * @param {clutch.api.v1.IPattern=} [properties] Properties to set
                 */
                function Pattern(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Pattern typeUrl.
                 * @member {string} typeUrl
                 * @memberof clutch.api.v1.Pattern
                 * @instance
                 */
                Pattern.prototype.typeUrl = "";

                /**
                 * Pattern pattern.
                 * @member {string} pattern
                 * @memberof clutch.api.v1.Pattern
                 * @instance
                 */
                Pattern.prototype.pattern = "";

                /**
                 * Verifies a Pattern message.
                 * @function verify
                 * @memberof clutch.api.v1.Pattern
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Pattern.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        if (!$util.isString(message.typeUrl))
                            return "typeUrl: string expected";
                    if (message.pattern != null && message.hasOwnProperty("pattern"))
                        if (!$util.isString(message.pattern))
                            return "pattern: string expected";
                    return null;
                };

                /**
                 * Creates a Pattern message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.api.v1.Pattern
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.api.v1.Pattern} Pattern
                 */
                Pattern.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.api.v1.Pattern)
                        return object;
                    let message = new $root.clutch.api.v1.Pattern();
                    if (object.typeUrl != null)
                        message.typeUrl = String(object.typeUrl);
                    if (object.pattern != null)
                        message.pattern = String(object.pattern);
                    return message;
                };

                /**
                 * Creates a plain object from a Pattern message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.api.v1.Pattern
                 * @static
                 * @param {clutch.api.v1.Pattern} message Pattern
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Pattern.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.typeUrl = "";
                        object.pattern = "";
                    }
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        object.typeUrl = message.typeUrl;
                    if (message.pattern != null && message.hasOwnProperty("pattern"))
                        object.pattern = message.pattern;
                    return object;
                };

                /**
                 * Converts this Pattern to JSON.
                 * @function toJSON
                 * @memberof clutch.api.v1.Pattern
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Pattern.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Pattern;
            })();

            v1.Identifier = (function() {

                /**
                 * Properties of an Identifier.
                 * @memberof clutch.api.v1
                 * @interface IIdentifier
                 * @property {Array.<clutch.api.v1.IPattern>|null} [patterns] Identifier patterns
                 */

                /**
                 * Constructs a new Identifier.
                 * @memberof clutch.api.v1
                 * @classdesc Represents an Identifier.
                 * @implements IIdentifier
                 * @constructor
                 * @param {clutch.api.v1.IIdentifier=} [properties] Properties to set
                 */
                function Identifier(properties) {
                    this.patterns = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Identifier patterns.
                 * @member {Array.<clutch.api.v1.IPattern>} patterns
                 * @memberof clutch.api.v1.Identifier
                 * @instance
                 */
                Identifier.prototype.patterns = $util.emptyArray;

                /**
                 * Verifies an Identifier message.
                 * @function verify
                 * @memberof clutch.api.v1.Identifier
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Identifier.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.patterns != null && message.hasOwnProperty("patterns")) {
                        if (!Array.isArray(message.patterns))
                            return "patterns: array expected";
                        for (let i = 0; i < message.patterns.length; ++i) {
                            let error = $root.clutch.api.v1.Pattern.verify(message.patterns[i]);
                            if (error)
                                return "patterns." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Identifier message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.api.v1.Identifier
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.api.v1.Identifier} Identifier
                 */
                Identifier.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.api.v1.Identifier)
                        return object;
                    let message = new $root.clutch.api.v1.Identifier();
                    if (object.patterns) {
                        if (!Array.isArray(object.patterns))
                            throw TypeError(".clutch.api.v1.Identifier.patterns: array expected");
                        message.patterns = [];
                        for (let i = 0; i < object.patterns.length; ++i) {
                            if (typeof object.patterns[i] !== "object")
                                throw TypeError(".clutch.api.v1.Identifier.patterns: object expected");
                            message.patterns[i] = $root.clutch.api.v1.Pattern.fromObject(object.patterns[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Identifier message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.api.v1.Identifier
                 * @static
                 * @param {clutch.api.v1.Identifier} message Identifier
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Identifier.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.patterns = [];
                    if (message.patterns && message.patterns.length) {
                        object.patterns = [];
                        for (let j = 0; j < message.patterns.length; ++j)
                            object.patterns[j] = $root.clutch.api.v1.Pattern.toObject(message.patterns[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Identifier to JSON.
                 * @function toJSON
                 * @memberof clutch.api.v1.Identifier
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Identifier.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Identifier;
            })();

            v1.Reference = (function() {

                /**
                 * Properties of a Reference.
                 * @memberof clutch.api.v1
                 * @interface IReference
                 * @property {Array.<string>|null} [fields] Reference fields
                 */

                /**
                 * Constructs a new Reference.
                 * @memberof clutch.api.v1
                 * @classdesc Represents a Reference.
                 * @implements IReference
                 * @constructor
                 * @param {clutch.api.v1.IReference=} [properties] Properties to set
                 */
                function Reference(properties) {
                    this.fields = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Reference fields.
                 * @member {Array.<string>} fields
                 * @memberof clutch.api.v1.Reference
                 * @instance
                 */
                Reference.prototype.fields = $util.emptyArray;

                /**
                 * Verifies a Reference message.
                 * @function verify
                 * @memberof clutch.api.v1.Reference
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Reference.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.fields != null && message.hasOwnProperty("fields")) {
                        if (!Array.isArray(message.fields))
                            return "fields: array expected";
                        for (let i = 0; i < message.fields.length; ++i)
                            if (!$util.isString(message.fields[i]))
                                return "fields: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Reference message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.api.v1.Reference
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.api.v1.Reference} Reference
                 */
                Reference.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.api.v1.Reference)
                        return object;
                    let message = new $root.clutch.api.v1.Reference();
                    if (object.fields) {
                        if (!Array.isArray(object.fields))
                            throw TypeError(".clutch.api.v1.Reference.fields: array expected");
                        message.fields = [];
                        for (let i = 0; i < object.fields.length; ++i)
                            message.fields[i] = String(object.fields[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Reference message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.api.v1.Reference
                 * @static
                 * @param {clutch.api.v1.Reference} message Reference
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Reference.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.fields = [];
                    if (message.fields && message.fields.length) {
                        object.fields = [];
                        for (let j = 0; j < message.fields.length; ++j)
                            object.fields[j] = message.fields[j];
                    }
                    return object;
                };

                /**
                 * Converts this Reference to JSON.
                 * @function toJSON
                 * @memberof clutch.api.v1.Reference
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Reference.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Reference;
            })();

            return v1;
        })();

        return api;
    })();

    clutch.assets = (function() {

        /**
         * Namespace assets.
         * @memberof clutch
         * @namespace
         */
        const assets = {};

        assets.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.assets
             * @namespace
             */
            const v1 = {};

            v1.AssetsAPI = (function() {

                /**
                 * Constructs a new AssetsAPI service.
                 * @memberof clutch.assets.v1
                 * @classdesc Represents an AssetsAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function AssetsAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (AssetsAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AssetsAPI;

                /**
                 * Callback as used by {@link clutch.assets.v1.AssetsAPI#fetch}.
                 * @memberof clutch.assets.v1.AssetsAPI
                 * @typedef FetchCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.assets.v1.FetchResponse} [response] FetchResponse
                 */

                /**
                 * Calls Fetch.
                 * @function fetch
                 * @memberof clutch.assets.v1.AssetsAPI
                 * @instance
                 * @param {clutch.assets.v1.IFetchRequest} request FetchRequest message or plain object
                 * @param {clutch.assets.v1.AssetsAPI.FetchCallback} callback Node-style callback called with the error, if any, and FetchResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AssetsAPI.prototype.fetch = function fetch(request, callback) {
                    return this.rpcCall(fetch, $root.clutch.assets.v1.FetchRequest, $root.clutch.assets.v1.FetchResponse, request, callback);
                }, "name", { value: "Fetch" });

                /**
                 * Calls Fetch.
                 * @function fetch
                 * @memberof clutch.assets.v1.AssetsAPI
                 * @instance
                 * @param {clutch.assets.v1.IFetchRequest} request FetchRequest message or plain object
                 * @returns {Promise<clutch.assets.v1.FetchResponse>} Promise
                 * @variation 2
                 */

                return AssetsAPI;
            })();

            v1.FetchRequest = (function() {

                /**
                 * Properties of a FetchRequest.
                 * @memberof clutch.assets.v1
                 * @interface IFetchRequest
                 */

                /**
                 * Constructs a new FetchRequest.
                 * @memberof clutch.assets.v1
                 * @classdesc Represents a FetchRequest.
                 * @implements IFetchRequest
                 * @constructor
                 * @param {clutch.assets.v1.IFetchRequest=} [properties] Properties to set
                 */
                function FetchRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a FetchRequest message.
                 * @function verify
                 * @memberof clutch.assets.v1.FetchRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FetchRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a FetchRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.assets.v1.FetchRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.assets.v1.FetchRequest} FetchRequest
                 */
                FetchRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.assets.v1.FetchRequest)
                        return object;
                    return new $root.clutch.assets.v1.FetchRequest();
                };

                /**
                 * Creates a plain object from a FetchRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.assets.v1.FetchRequest
                 * @static
                 * @param {clutch.assets.v1.FetchRequest} message FetchRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FetchRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this FetchRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.assets.v1.FetchRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FetchRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FetchRequest;
            })();

            v1.FetchResponse = (function() {

                /**
                 * Properties of a FetchResponse.
                 * @memberof clutch.assets.v1
                 * @interface IFetchResponse
                 */

                /**
                 * Constructs a new FetchResponse.
                 * @memberof clutch.assets.v1
                 * @classdesc Represents a FetchResponse.
                 * @implements IFetchResponse
                 * @constructor
                 * @param {clutch.assets.v1.IFetchResponse=} [properties] Properties to set
                 */
                function FetchResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a FetchResponse message.
                 * @function verify
                 * @memberof clutch.assets.v1.FetchResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FetchResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a FetchResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.assets.v1.FetchResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.assets.v1.FetchResponse} FetchResponse
                 */
                FetchResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.assets.v1.FetchResponse)
                        return object;
                    return new $root.clutch.assets.v1.FetchResponse();
                };

                /**
                 * Creates a plain object from a FetchResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.assets.v1.FetchResponse
                 * @static
                 * @param {clutch.assets.v1.FetchResponse} message FetchResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FetchResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this FetchResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.assets.v1.FetchResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FetchResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FetchResponse;
            })();

            return v1;
        })();

        return assets;
    })();

    clutch.audit = (function() {

        /**
         * Namespace audit.
         * @memberof clutch
         * @namespace
         */
        const audit = {};

        audit.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.audit
             * @namespace
             */
            const v1 = {};

            v1.AuditAPI = (function() {

                /**
                 * Constructs a new AuditAPI service.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents an AuditAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function AuditAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (AuditAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AuditAPI;

                /**
                 * Callback as used by {@link clutch.audit.v1.AuditAPI#getEvents}.
                 * @memberof clutch.audit.v1.AuditAPI
                 * @typedef GetEventsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.audit.v1.GetEventsResponse} [response] GetEventsResponse
                 */

                /**
                 * Calls GetEvents.
                 * @function getEvents
                 * @memberof clutch.audit.v1.AuditAPI
                 * @instance
                 * @param {clutch.audit.v1.IGetEventsRequest} request GetEventsRequest message or plain object
                 * @param {clutch.audit.v1.AuditAPI.GetEventsCallback} callback Node-style callback called with the error, if any, and GetEventsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AuditAPI.prototype.getEvents = function getEvents(request, callback) {
                    return this.rpcCall(getEvents, $root.clutch.audit.v1.GetEventsRequest, $root.clutch.audit.v1.GetEventsResponse, request, callback);
                }, "name", { value: "GetEvents" });

                /**
                 * Calls GetEvents.
                 * @function getEvents
                 * @memberof clutch.audit.v1.AuditAPI
                 * @instance
                 * @param {clutch.audit.v1.IGetEventsRequest} request GetEventsRequest message or plain object
                 * @returns {Promise<clutch.audit.v1.GetEventsResponse>} Promise
                 * @variation 2
                 */

                return AuditAPI;
            })();

            v1.TimeRange = (function() {

                /**
                 * Properties of a TimeRange.
                 * @memberof clutch.audit.v1
                 * @interface ITimeRange
                 * @property {google.protobuf.ITimestamp|null} [startTime] TimeRange startTime
                 * @property {google.protobuf.ITimestamp|null} [endTime] TimeRange endTime
                 */

                /**
                 * Constructs a new TimeRange.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents a TimeRange.
                 * @implements ITimeRange
                 * @constructor
                 * @param {clutch.audit.v1.ITimeRange=} [properties] Properties to set
                 */
                function TimeRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * TimeRange startTime.
                 * @member {google.protobuf.ITimestamp|null|undefined} startTime
                 * @memberof clutch.audit.v1.TimeRange
                 * @instance
                 */
                TimeRange.prototype.startTime = null;

                /**
                 * TimeRange endTime.
                 * @member {google.protobuf.ITimestamp|null|undefined} endTime
                 * @memberof clutch.audit.v1.TimeRange
                 * @instance
                 */
                TimeRange.prototype.endTime = null;

                /**
                 * Verifies a TimeRange message.
                 * @function verify
                 * @memberof clutch.audit.v1.TimeRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                TimeRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.startTime != null && message.hasOwnProperty("startTime")) {
                        let error = $root.google.protobuf.Timestamp.verify(message.startTime);
                        if (error)
                            return "startTime." + error;
                    }
                    if (message.endTime != null && message.hasOwnProperty("endTime")) {
                        let error = $root.google.protobuf.Timestamp.verify(message.endTime);
                        if (error)
                            return "endTime." + error;
                    }
                    return null;
                };

                /**
                 * Creates a TimeRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.audit.v1.TimeRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.audit.v1.TimeRange} TimeRange
                 */
                TimeRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.audit.v1.TimeRange)
                        return object;
                    let message = new $root.clutch.audit.v1.TimeRange();
                    if (object.startTime != null) {
                        if (typeof object.startTime !== "object")
                            throw TypeError(".clutch.audit.v1.TimeRange.startTime: object expected");
                        message.startTime = $root.google.protobuf.Timestamp.fromObject(object.startTime);
                    }
                    if (object.endTime != null) {
                        if (typeof object.endTime !== "object")
                            throw TypeError(".clutch.audit.v1.TimeRange.endTime: object expected");
                        message.endTime = $root.google.protobuf.Timestamp.fromObject(object.endTime);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a TimeRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.audit.v1.TimeRange
                 * @static
                 * @param {clutch.audit.v1.TimeRange} message TimeRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                TimeRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.startTime = null;
                        object.endTime = null;
                    }
                    if (message.startTime != null && message.hasOwnProperty("startTime"))
                        object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
                    if (message.endTime != null && message.hasOwnProperty("endTime"))
                        object.endTime = $root.google.protobuf.Timestamp.toObject(message.endTime, options);
                    return object;
                };

                /**
                 * Converts this TimeRange to JSON.
                 * @function toJSON
                 * @memberof clutch.audit.v1.TimeRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                TimeRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return TimeRange;
            })();

            v1.GetEventsRequest = (function() {

                /**
                 * Properties of a GetEventsRequest.
                 * @memberof clutch.audit.v1
                 * @interface IGetEventsRequest
                 * @property {clutch.audit.v1.ITimeRange|null} [range] GetEventsRequest range
                 * @property {google.protobuf.IDuration|null} [since] GetEventsRequest since
                 */

                /**
                 * Constructs a new GetEventsRequest.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents a GetEventsRequest.
                 * @implements IGetEventsRequest
                 * @constructor
                 * @param {clutch.audit.v1.IGetEventsRequest=} [properties] Properties to set
                 */
                function GetEventsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetEventsRequest range.
                 * @member {clutch.audit.v1.ITimeRange|null|undefined} range
                 * @memberof clutch.audit.v1.GetEventsRequest
                 * @instance
                 */
                GetEventsRequest.prototype.range = null;

                /**
                 * GetEventsRequest since.
                 * @member {google.protobuf.IDuration|null|undefined} since
                 * @memberof clutch.audit.v1.GetEventsRequest
                 * @instance
                 */
                GetEventsRequest.prototype.since = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * GetEventsRequest window.
                 * @member {"range"|"since"|undefined} window
                 * @memberof clutch.audit.v1.GetEventsRequest
                 * @instance
                 */
                Object.defineProperty(GetEventsRequest.prototype, "window", {
                    get: $util.oneOfGetter($oneOfFields = ["range", "since"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies a GetEventsRequest message.
                 * @function verify
                 * @memberof clutch.audit.v1.GetEventsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetEventsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.range != null && message.hasOwnProperty("range")) {
                        properties.window = 1;
                        {
                            let error = $root.clutch.audit.v1.TimeRange.verify(message.range);
                            if (error)
                                return "range." + error;
                        }
                    }
                    if (message.since != null && message.hasOwnProperty("since")) {
                        if (properties.window === 1)
                            return "window: multiple values";
                        properties.window = 1;
                        {
                            let error = $root.google.protobuf.Duration.verify(message.since);
                            if (error)
                                return "since." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetEventsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.audit.v1.GetEventsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.audit.v1.GetEventsRequest} GetEventsRequest
                 */
                GetEventsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.audit.v1.GetEventsRequest)
                        return object;
                    let message = new $root.clutch.audit.v1.GetEventsRequest();
                    if (object.range != null) {
                        if (typeof object.range !== "object")
                            throw TypeError(".clutch.audit.v1.GetEventsRequest.range: object expected");
                        message.range = $root.clutch.audit.v1.TimeRange.fromObject(object.range);
                    }
                    if (object.since != null) {
                        if (typeof object.since !== "object")
                            throw TypeError(".clutch.audit.v1.GetEventsRequest.since: object expected");
                        message.since = $root.google.protobuf.Duration.fromObject(object.since);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetEventsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.audit.v1.GetEventsRequest
                 * @static
                 * @param {clutch.audit.v1.GetEventsRequest} message GetEventsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetEventsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (message.range != null && message.hasOwnProperty("range")) {
                        object.range = $root.clutch.audit.v1.TimeRange.toObject(message.range, options);
                        if (options.oneofs)
                            object.window = "range";
                    }
                    if (message.since != null && message.hasOwnProperty("since")) {
                        object.since = $root.google.protobuf.Duration.toObject(message.since, options);
                        if (options.oneofs)
                            object.window = "since";
                    }
                    return object;
                };

                /**
                 * Converts this GetEventsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.audit.v1.GetEventsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetEventsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetEventsRequest;
            })();

            v1.Resource = (function() {

                /**
                 * Properties of a Resource.
                 * @memberof clutch.audit.v1
                 * @interface IResource
                 * @property {string|null} [typeUrl] Resource typeUrl
                 * @property {string|null} [id] Resource id
                 */

                /**
                 * Constructs a new Resource.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents a Resource.
                 * @implements IResource
                 * @constructor
                 * @param {clutch.audit.v1.IResource=} [properties] Properties to set
                 */
                function Resource(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Resource typeUrl.
                 * @member {string} typeUrl
                 * @memberof clutch.audit.v1.Resource
                 * @instance
                 */
                Resource.prototype.typeUrl = "";

                /**
                 * Resource id.
                 * @member {string} id
                 * @memberof clutch.audit.v1.Resource
                 * @instance
                 */
                Resource.prototype.id = "";

                /**
                 * Verifies a Resource message.
                 * @function verify
                 * @memberof clutch.audit.v1.Resource
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Resource.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        if (!$util.isString(message.typeUrl))
                            return "typeUrl: string expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    return null;
                };

                /**
                 * Creates a Resource message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.audit.v1.Resource
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.audit.v1.Resource} Resource
                 */
                Resource.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.audit.v1.Resource)
                        return object;
                    let message = new $root.clutch.audit.v1.Resource();
                    if (object.typeUrl != null)
                        message.typeUrl = String(object.typeUrl);
                    if (object.id != null)
                        message.id = String(object.id);
                    return message;
                };

                /**
                 * Creates a plain object from a Resource message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.audit.v1.Resource
                 * @static
                 * @param {clutch.audit.v1.Resource} message Resource
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Resource.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.typeUrl = "";
                        object.id = "";
                    }
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        object.typeUrl = message.typeUrl;
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    return object;
                };

                /**
                 * Converts this Resource to JSON.
                 * @function toJSON
                 * @memberof clutch.audit.v1.Resource
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Resource.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Resource;
            })();

            v1.RequestEvent = (function() {

                /**
                 * Properties of a RequestEvent.
                 * @memberof clutch.audit.v1
                 * @interface IRequestEvent
                 * @property {string|null} [username] RequestEvent username
                 * @property {string|null} [serviceName] RequestEvent serviceName
                 * @property {string|null} [methodName] RequestEvent methodName
                 * @property {clutch.api.v1.ActionType|null} [type] RequestEvent type
                 * @property {google.rpc.IStatus|null} [status] RequestEvent status
                 * @property {Array.<clutch.audit.v1.IResource>|null} [resources] RequestEvent resources
                 */

                /**
                 * Constructs a new RequestEvent.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents a RequestEvent.
                 * @implements IRequestEvent
                 * @constructor
                 * @param {clutch.audit.v1.IRequestEvent=} [properties] Properties to set
                 */
                function RequestEvent(properties) {
                    this.resources = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RequestEvent username.
                 * @member {string} username
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 */
                RequestEvent.prototype.username = "";

                /**
                 * RequestEvent serviceName.
                 * @member {string} serviceName
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 */
                RequestEvent.prototype.serviceName = "";

                /**
                 * RequestEvent methodName.
                 * @member {string} methodName
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 */
                RequestEvent.prototype.methodName = "";

                /**
                 * RequestEvent type.
                 * @member {clutch.api.v1.ActionType} type
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 */
                RequestEvent.prototype.type = 0;

                /**
                 * RequestEvent status.
                 * @member {google.rpc.IStatus|null|undefined} status
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 */
                RequestEvent.prototype.status = null;

                /**
                 * RequestEvent resources.
                 * @member {Array.<clutch.audit.v1.IResource>} resources
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 */
                RequestEvent.prototype.resources = $util.emptyArray;

                /**
                 * Verifies a RequestEvent message.
                 * @function verify
                 * @memberof clutch.audit.v1.RequestEvent
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RequestEvent.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.username != null && message.hasOwnProperty("username"))
                        if (!$util.isString(message.username))
                            return "username: string expected";
                    if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                        if (!$util.isString(message.serviceName))
                            return "serviceName: string expected";
                    if (message.methodName != null && message.hasOwnProperty("methodName"))
                        if (!$util.isString(message.methodName))
                            return "methodName: string expected";
                    if (message.type != null && message.hasOwnProperty("type"))
                        switch (message.type) {
                        default:
                            return "type: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.status != null && message.hasOwnProperty("status")) {
                        let error = $root.google.rpc.Status.verify(message.status);
                        if (error)
                            return "status." + error;
                    }
                    if (message.resources != null && message.hasOwnProperty("resources")) {
                        if (!Array.isArray(message.resources))
                            return "resources: array expected";
                        for (let i = 0; i < message.resources.length; ++i) {
                            let error = $root.clutch.audit.v1.Resource.verify(message.resources[i]);
                            if (error)
                                return "resources." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a RequestEvent message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.audit.v1.RequestEvent
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.audit.v1.RequestEvent} RequestEvent
                 */
                RequestEvent.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.audit.v1.RequestEvent)
                        return object;
                    let message = new $root.clutch.audit.v1.RequestEvent();
                    if (object.username != null)
                        message.username = String(object.username);
                    if (object.serviceName != null)
                        message.serviceName = String(object.serviceName);
                    if (object.methodName != null)
                        message.methodName = String(object.methodName);
                    switch (object.type) {
                    case "UNSPECIFIED":
                    case 0:
                        message.type = 0;
                        break;
                    case "CREATE":
                    case 1:
                        message.type = 1;
                        break;
                    case "READ":
                    case 2:
                        message.type = 2;
                        break;
                    case "UPDATE":
                    case 3:
                        message.type = 3;
                        break;
                    case "DELETE":
                    case 4:
                        message.type = 4;
                        break;
                    }
                    if (object.status != null) {
                        if (typeof object.status !== "object")
                            throw TypeError(".clutch.audit.v1.RequestEvent.status: object expected");
                        message.status = $root.google.rpc.Status.fromObject(object.status);
                    }
                    if (object.resources) {
                        if (!Array.isArray(object.resources))
                            throw TypeError(".clutch.audit.v1.RequestEvent.resources: array expected");
                        message.resources = [];
                        for (let i = 0; i < object.resources.length; ++i) {
                            if (typeof object.resources[i] !== "object")
                                throw TypeError(".clutch.audit.v1.RequestEvent.resources: object expected");
                            message.resources[i] = $root.clutch.audit.v1.Resource.fromObject(object.resources[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RequestEvent message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.audit.v1.RequestEvent
                 * @static
                 * @param {clutch.audit.v1.RequestEvent} message RequestEvent
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RequestEvent.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.resources = [];
                    if (options.defaults) {
                        object.username = "";
                        object.serviceName = "";
                        object.methodName = "";
                        object.type = options.enums === String ? "UNSPECIFIED" : 0;
                        object.status = null;
                    }
                    if (message.username != null && message.hasOwnProperty("username"))
                        object.username = message.username;
                    if (message.serviceName != null && message.hasOwnProperty("serviceName"))
                        object.serviceName = message.serviceName;
                    if (message.methodName != null && message.hasOwnProperty("methodName"))
                        object.methodName = message.methodName;
                    if (message.type != null && message.hasOwnProperty("type"))
                        object.type = options.enums === String ? $root.clutch.api.v1.ActionType[message.type] : message.type;
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = $root.google.rpc.Status.toObject(message.status, options);
                    if (message.resources && message.resources.length) {
                        object.resources = [];
                        for (let j = 0; j < message.resources.length; ++j)
                            object.resources[j] = $root.clutch.audit.v1.Resource.toObject(message.resources[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this RequestEvent to JSON.
                 * @function toJSON
                 * @memberof clutch.audit.v1.RequestEvent
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RequestEvent.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RequestEvent;
            })();

            v1.Event = (function() {

                /**
                 * Properties of an Event.
                 * @memberof clutch.audit.v1
                 * @interface IEvent
                 * @property {google.protobuf.ITimestamp|null} [occurredAt] Event occurredAt
                 * @property {clutch.audit.v1.IRequestEvent|null} [event] Event event
                 */

                /**
                 * Constructs a new Event.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents an Event.
                 * @implements IEvent
                 * @constructor
                 * @param {clutch.audit.v1.IEvent=} [properties] Properties to set
                 */
                function Event(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Event occurredAt.
                 * @member {google.protobuf.ITimestamp|null|undefined} occurredAt
                 * @memberof clutch.audit.v1.Event
                 * @instance
                 */
                Event.prototype.occurredAt = null;

                /**
                 * Event event.
                 * @member {clutch.audit.v1.IRequestEvent|null|undefined} event
                 * @memberof clutch.audit.v1.Event
                 * @instance
                 */
                Event.prototype.event = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Event eventType.
                 * @member {"event"|undefined} eventType
                 * @memberof clutch.audit.v1.Event
                 * @instance
                 */
                Object.defineProperty(Event.prototype, "eventType", {
                    get: $util.oneOfGetter($oneOfFields = ["event"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies an Event message.
                 * @function verify
                 * @memberof clutch.audit.v1.Event
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Event.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt")) {
                        let error = $root.google.protobuf.Timestamp.verify(message.occurredAt);
                        if (error)
                            return "occurredAt." + error;
                    }
                    if (message.event != null && message.hasOwnProperty("event")) {
                        properties.eventType = 1;
                        {
                            let error = $root.clutch.audit.v1.RequestEvent.verify(message.event);
                            if (error)
                                return "event." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Event message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.audit.v1.Event
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.audit.v1.Event} Event
                 */
                Event.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.audit.v1.Event)
                        return object;
                    let message = new $root.clutch.audit.v1.Event();
                    if (object.occurredAt != null) {
                        if (typeof object.occurredAt !== "object")
                            throw TypeError(".clutch.audit.v1.Event.occurredAt: object expected");
                        message.occurredAt = $root.google.protobuf.Timestamp.fromObject(object.occurredAt);
                    }
                    if (object.event != null) {
                        if (typeof object.event !== "object")
                            throw TypeError(".clutch.audit.v1.Event.event: object expected");
                        message.event = $root.clutch.audit.v1.RequestEvent.fromObject(object.event);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Event message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.audit.v1.Event
                 * @static
                 * @param {clutch.audit.v1.Event} message Event
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Event.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.occurredAt = null;
                    if (message.occurredAt != null && message.hasOwnProperty("occurredAt"))
                        object.occurredAt = $root.google.protobuf.Timestamp.toObject(message.occurredAt, options);
                    if (message.event != null && message.hasOwnProperty("event")) {
                        object.event = $root.clutch.audit.v1.RequestEvent.toObject(message.event, options);
                        if (options.oneofs)
                            object.eventType = "event";
                    }
                    return object;
                };

                /**
                 * Converts this Event to JSON.
                 * @function toJSON
                 * @memberof clutch.audit.v1.Event
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Event.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Event;
            })();

            v1.GetEventsResponse = (function() {

                /**
                 * Properties of a GetEventsResponse.
                 * @memberof clutch.audit.v1
                 * @interface IGetEventsResponse
                 * @property {Array.<clutch.audit.v1.IEvent>|null} [events] GetEventsResponse events
                 */

                /**
                 * Constructs a new GetEventsResponse.
                 * @memberof clutch.audit.v1
                 * @classdesc Represents a GetEventsResponse.
                 * @implements IGetEventsResponse
                 * @constructor
                 * @param {clutch.audit.v1.IGetEventsResponse=} [properties] Properties to set
                 */
                function GetEventsResponse(properties) {
                    this.events = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetEventsResponse events.
                 * @member {Array.<clutch.audit.v1.IEvent>} events
                 * @memberof clutch.audit.v1.GetEventsResponse
                 * @instance
                 */
                GetEventsResponse.prototype.events = $util.emptyArray;

                /**
                 * Verifies a GetEventsResponse message.
                 * @function verify
                 * @memberof clutch.audit.v1.GetEventsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetEventsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.events != null && message.hasOwnProperty("events")) {
                        if (!Array.isArray(message.events))
                            return "events: array expected";
                        for (let i = 0; i < message.events.length; ++i) {
                            let error = $root.clutch.audit.v1.Event.verify(message.events[i]);
                            if (error)
                                return "events." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetEventsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.audit.v1.GetEventsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.audit.v1.GetEventsResponse} GetEventsResponse
                 */
                GetEventsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.audit.v1.GetEventsResponse)
                        return object;
                    let message = new $root.clutch.audit.v1.GetEventsResponse();
                    if (object.events) {
                        if (!Array.isArray(object.events))
                            throw TypeError(".clutch.audit.v1.GetEventsResponse.events: array expected");
                        message.events = [];
                        for (let i = 0; i < object.events.length; ++i) {
                            if (typeof object.events[i] !== "object")
                                throw TypeError(".clutch.audit.v1.GetEventsResponse.events: object expected");
                            message.events[i] = $root.clutch.audit.v1.Event.fromObject(object.events[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetEventsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.audit.v1.GetEventsResponse
                 * @static
                 * @param {clutch.audit.v1.GetEventsResponse} message GetEventsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetEventsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.events = [];
                    if (message.events && message.events.length) {
                        object.events = [];
                        for (let j = 0; j < message.events.length; ++j)
                            object.events[j] = $root.clutch.audit.v1.Event.toObject(message.events[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetEventsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.audit.v1.GetEventsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetEventsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetEventsResponse;
            })();

            return v1;
        })();

        return audit;
    })();

    clutch.authn = (function() {

        /**
         * Namespace authn.
         * @memberof clutch
         * @namespace
         */
        const authn = {};

        authn.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.authn
             * @namespace
             */
            const v1 = {};

            v1.AuthnAPI = (function() {

                /**
                 * Constructs a new AuthnAPI service.
                 * @memberof clutch.authn.v1
                 * @classdesc Represents an AuthnAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function AuthnAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (AuthnAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AuthnAPI;

                /**
                 * Callback as used by {@link clutch.authn.v1.AuthnAPI#login}.
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @typedef LoginCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.authn.v1.LoginResponse} [response] LoginResponse
                 */

                /**
                 * Calls Login.
                 * @function login
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @instance
                 * @param {clutch.authn.v1.ILoginRequest} request LoginRequest message or plain object
                 * @param {clutch.authn.v1.AuthnAPI.LoginCallback} callback Node-style callback called with the error, if any, and LoginResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AuthnAPI.prototype.login = function login(request, callback) {
                    return this.rpcCall(login, $root.clutch.authn.v1.LoginRequest, $root.clutch.authn.v1.LoginResponse, request, callback);
                }, "name", { value: "Login" });

                /**
                 * Calls Login.
                 * @function login
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @instance
                 * @param {clutch.authn.v1.ILoginRequest} request LoginRequest message or plain object
                 * @returns {Promise<clutch.authn.v1.LoginResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.authn.v1.AuthnAPI#callback}.
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @typedef CallbackCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.authn.v1.CallbackResponse} [response] CallbackResponse
                 */

                /**
                 * Calls Callback.
                 * @function callback
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @instance
                 * @param {clutch.authn.v1.ICallbackRequest} request CallbackRequest message or plain object
                 * @param {clutch.authn.v1.AuthnAPI.CallbackCallback} callback Node-style callback called with the error, if any, and CallbackResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AuthnAPI.prototype.callback = function callback(request, callback) {
                    return this.rpcCall(callback, $root.clutch.authn.v1.CallbackRequest, $root.clutch.authn.v1.CallbackResponse, request, callback);
                }, "name", { value: "Callback" });

                /**
                 * Calls Callback.
                 * @function callback
                 * @memberof clutch.authn.v1.AuthnAPI
                 * @instance
                 * @param {clutch.authn.v1.ICallbackRequest} request CallbackRequest message or plain object
                 * @returns {Promise<clutch.authn.v1.CallbackResponse>} Promise
                 * @variation 2
                 */

                return AuthnAPI;
            })();

            v1.LoginRequest = (function() {

                /**
                 * Properties of a LoginRequest.
                 * @memberof clutch.authn.v1
                 * @interface ILoginRequest
                 * @property {string|null} [redirectUrl] LoginRequest redirectUrl
                 */

                /**
                 * Constructs a new LoginRequest.
                 * @memberof clutch.authn.v1
                 * @classdesc Represents a LoginRequest.
                 * @implements ILoginRequest
                 * @constructor
                 * @param {clutch.authn.v1.ILoginRequest=} [properties] Properties to set
                 */
                function LoginRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LoginRequest redirectUrl.
                 * @member {string} redirectUrl
                 * @memberof clutch.authn.v1.LoginRequest
                 * @instance
                 */
                LoginRequest.prototype.redirectUrl = "";

                /**
                 * Verifies a LoginRequest message.
                 * @function verify
                 * @memberof clutch.authn.v1.LoginRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LoginRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.redirectUrl != null && message.hasOwnProperty("redirectUrl"))
                        if (!$util.isString(message.redirectUrl))
                            return "redirectUrl: string expected";
                    return null;
                };

                /**
                 * Creates a LoginRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authn.v1.LoginRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authn.v1.LoginRequest} LoginRequest
                 */
                LoginRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authn.v1.LoginRequest)
                        return object;
                    let message = new $root.clutch.authn.v1.LoginRequest();
                    if (object.redirectUrl != null)
                        message.redirectUrl = String(object.redirectUrl);
                    return message;
                };

                /**
                 * Creates a plain object from a LoginRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authn.v1.LoginRequest
                 * @static
                 * @param {clutch.authn.v1.LoginRequest} message LoginRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LoginRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.redirectUrl = "";
                    if (message.redirectUrl != null && message.hasOwnProperty("redirectUrl"))
                        object.redirectUrl = message.redirectUrl;
                    return object;
                };

                /**
                 * Converts this LoginRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.authn.v1.LoginRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LoginRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LoginRequest;
            })();

            v1.LoginResponse = (function() {

                /**
                 * Properties of a LoginResponse.
                 * @memberof clutch.authn.v1
                 * @interface ILoginResponse
                 * @property {string|null} [authUrl] LoginResponse authUrl
                 */

                /**
                 * Constructs a new LoginResponse.
                 * @memberof clutch.authn.v1
                 * @classdesc Represents a LoginResponse.
                 * @implements ILoginResponse
                 * @constructor
                 * @param {clutch.authn.v1.ILoginResponse=} [properties] Properties to set
                 */
                function LoginResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * LoginResponse authUrl.
                 * @member {string} authUrl
                 * @memberof clutch.authn.v1.LoginResponse
                 * @instance
                 */
                LoginResponse.prototype.authUrl = "";

                /**
                 * Verifies a LoginResponse message.
                 * @function verify
                 * @memberof clutch.authn.v1.LoginResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                LoginResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.authUrl != null && message.hasOwnProperty("authUrl"))
                        if (!$util.isString(message.authUrl))
                            return "authUrl: string expected";
                    return null;
                };

                /**
                 * Creates a LoginResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authn.v1.LoginResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authn.v1.LoginResponse} LoginResponse
                 */
                LoginResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authn.v1.LoginResponse)
                        return object;
                    let message = new $root.clutch.authn.v1.LoginResponse();
                    if (object.authUrl != null)
                        message.authUrl = String(object.authUrl);
                    return message;
                };

                /**
                 * Creates a plain object from a LoginResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authn.v1.LoginResponse
                 * @static
                 * @param {clutch.authn.v1.LoginResponse} message LoginResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                LoginResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.authUrl = "";
                    if (message.authUrl != null && message.hasOwnProperty("authUrl"))
                        object.authUrl = message.authUrl;
                    return object;
                };

                /**
                 * Converts this LoginResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.authn.v1.LoginResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                LoginResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return LoginResponse;
            })();

            v1.CallbackRequest = (function() {

                /**
                 * Properties of a CallbackRequest.
                 * @memberof clutch.authn.v1
                 * @interface ICallbackRequest
                 * @property {string|null} [code] CallbackRequest code
                 * @property {string|null} [state] CallbackRequest state
                 * @property {string|null} [error] CallbackRequest error
                 * @property {string|null} [errorDescription] CallbackRequest errorDescription
                 */

                /**
                 * Constructs a new CallbackRequest.
                 * @memberof clutch.authn.v1
                 * @classdesc Represents a CallbackRequest.
                 * @implements ICallbackRequest
                 * @constructor
                 * @param {clutch.authn.v1.ICallbackRequest=} [properties] Properties to set
                 */
                function CallbackRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CallbackRequest code.
                 * @member {string} code
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @instance
                 */
                CallbackRequest.prototype.code = "";

                /**
                 * CallbackRequest state.
                 * @member {string} state
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @instance
                 */
                CallbackRequest.prototype.state = "";

                /**
                 * CallbackRequest error.
                 * @member {string} error
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @instance
                 */
                CallbackRequest.prototype.error = "";

                /**
                 * CallbackRequest errorDescription.
                 * @member {string} errorDescription
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @instance
                 */
                CallbackRequest.prototype.errorDescription = "";

                /**
                 * Verifies a CallbackRequest message.
                 * @function verify
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CallbackRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.code != null && message.hasOwnProperty("code"))
                        if (!$util.isString(message.code))
                            return "code: string expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        if (!$util.isString(message.state))
                            return "state: string expected";
                    if (message.error != null && message.hasOwnProperty("error"))
                        if (!$util.isString(message.error))
                            return "error: string expected";
                    if (message.errorDescription != null && message.hasOwnProperty("errorDescription"))
                        if (!$util.isString(message.errorDescription))
                            return "errorDescription: string expected";
                    return null;
                };

                /**
                 * Creates a CallbackRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authn.v1.CallbackRequest} CallbackRequest
                 */
                CallbackRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authn.v1.CallbackRequest)
                        return object;
                    let message = new $root.clutch.authn.v1.CallbackRequest();
                    if (object.code != null)
                        message.code = String(object.code);
                    if (object.state != null)
                        message.state = String(object.state);
                    if (object.error != null)
                        message.error = String(object.error);
                    if (object.errorDescription != null)
                        message.errorDescription = String(object.errorDescription);
                    return message;
                };

                /**
                 * Creates a plain object from a CallbackRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @static
                 * @param {clutch.authn.v1.CallbackRequest} message CallbackRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CallbackRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.code = "";
                        object.state = "";
                        object.error = "";
                        object.errorDescription = "";
                    }
                    if (message.code != null && message.hasOwnProperty("code"))
                        object.code = message.code;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = message.state;
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = message.error;
                    if (message.errorDescription != null && message.hasOwnProperty("errorDescription"))
                        object.errorDescription = message.errorDescription;
                    return object;
                };

                /**
                 * Converts this CallbackRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.authn.v1.CallbackRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CallbackRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CallbackRequest;
            })();

            v1.CallbackResponse = (function() {

                /**
                 * Properties of a CallbackResponse.
                 * @memberof clutch.authn.v1
                 * @interface ICallbackResponse
                 * @property {string|null} [token] CallbackResponse token
                 */

                /**
                 * Constructs a new CallbackResponse.
                 * @memberof clutch.authn.v1
                 * @classdesc Represents a CallbackResponse.
                 * @implements ICallbackResponse
                 * @constructor
                 * @param {clutch.authn.v1.ICallbackResponse=} [properties] Properties to set
                 */
                function CallbackResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CallbackResponse token.
                 * @member {string} token
                 * @memberof clutch.authn.v1.CallbackResponse
                 * @instance
                 */
                CallbackResponse.prototype.token = "";

                /**
                 * Verifies a CallbackResponse message.
                 * @function verify
                 * @memberof clutch.authn.v1.CallbackResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CallbackResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.token != null && message.hasOwnProperty("token"))
                        if (!$util.isString(message.token))
                            return "token: string expected";
                    return null;
                };

                /**
                 * Creates a CallbackResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authn.v1.CallbackResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authn.v1.CallbackResponse} CallbackResponse
                 */
                CallbackResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authn.v1.CallbackResponse)
                        return object;
                    let message = new $root.clutch.authn.v1.CallbackResponse();
                    if (object.token != null)
                        message.token = String(object.token);
                    return message;
                };

                /**
                 * Creates a plain object from a CallbackResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authn.v1.CallbackResponse
                 * @static
                 * @param {clutch.authn.v1.CallbackResponse} message CallbackResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CallbackResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.token = "";
                    if (message.token != null && message.hasOwnProperty("token"))
                        object.token = message.token;
                    return object;
                };

                /**
                 * Converts this CallbackResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.authn.v1.CallbackResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CallbackResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CallbackResponse;
            })();

            return v1;
        })();

        return authn;
    })();

    clutch.authz = (function() {

        /**
         * Namespace authz.
         * @memberof clutch
         * @namespace
         */
        const authz = {};

        authz.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.authz
             * @namespace
             */
            const v1 = {};

            v1.AuthzAPI = (function() {

                /**
                 * Constructs a new AuthzAPI service.
                 * @memberof clutch.authz.v1
                 * @classdesc Represents an AuthzAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function AuthzAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (AuthzAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = AuthzAPI;

                /**
                 * Callback as used by {@link clutch.authz.v1.AuthzAPI#check}.
                 * @memberof clutch.authz.v1.AuthzAPI
                 * @typedef CheckCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.authz.v1.CheckResponse} [response] CheckResponse
                 */

                /**
                 * Calls Check.
                 * @function check
                 * @memberof clutch.authz.v1.AuthzAPI
                 * @instance
                 * @param {clutch.authz.v1.ICheckRequest} request CheckRequest message or plain object
                 * @param {clutch.authz.v1.AuthzAPI.CheckCallback} callback Node-style callback called with the error, if any, and CheckResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(AuthzAPI.prototype.check = function check(request, callback) {
                    return this.rpcCall(check, $root.clutch.authz.v1.CheckRequest, $root.clutch.authz.v1.CheckResponse, request, callback);
                }, "name", { value: "Check" });

                /**
                 * Calls Check.
                 * @function check
                 * @memberof clutch.authz.v1.AuthzAPI
                 * @instance
                 * @param {clutch.authz.v1.ICheckRequest} request CheckRequest message or plain object
                 * @returns {Promise<clutch.authz.v1.CheckResponse>} Promise
                 * @variation 2
                 */

                return AuthzAPI;
            })();

            v1.Subject = (function() {

                /**
                 * Properties of a Subject.
                 * @memberof clutch.authz.v1
                 * @interface ISubject
                 * @property {string|null} [user] Subject user
                 * @property {Array.<string>|null} [groups] Subject groups
                 */

                /**
                 * Constructs a new Subject.
                 * @memberof clutch.authz.v1
                 * @classdesc Represents a Subject.
                 * @implements ISubject
                 * @constructor
                 * @param {clutch.authz.v1.ISubject=} [properties] Properties to set
                 */
                function Subject(properties) {
                    this.groups = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Subject user.
                 * @member {string} user
                 * @memberof clutch.authz.v1.Subject
                 * @instance
                 */
                Subject.prototype.user = "";

                /**
                 * Subject groups.
                 * @member {Array.<string>} groups
                 * @memberof clutch.authz.v1.Subject
                 * @instance
                 */
                Subject.prototype.groups = $util.emptyArray;

                /**
                 * Verifies a Subject message.
                 * @function verify
                 * @memberof clutch.authz.v1.Subject
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Subject.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.user != null && message.hasOwnProperty("user"))
                        if (!$util.isString(message.user))
                            return "user: string expected";
                    if (message.groups != null && message.hasOwnProperty("groups")) {
                        if (!Array.isArray(message.groups))
                            return "groups: array expected";
                        for (let i = 0; i < message.groups.length; ++i)
                            if (!$util.isString(message.groups[i]))
                                return "groups: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Subject message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authz.v1.Subject
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authz.v1.Subject} Subject
                 */
                Subject.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authz.v1.Subject)
                        return object;
                    let message = new $root.clutch.authz.v1.Subject();
                    if (object.user != null)
                        message.user = String(object.user);
                    if (object.groups) {
                        if (!Array.isArray(object.groups))
                            throw TypeError(".clutch.authz.v1.Subject.groups: array expected");
                        message.groups = [];
                        for (let i = 0; i < object.groups.length; ++i)
                            message.groups[i] = String(object.groups[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Subject message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authz.v1.Subject
                 * @static
                 * @param {clutch.authz.v1.Subject} message Subject
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Subject.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.groups = [];
                    if (options.defaults)
                        object.user = "";
                    if (message.user != null && message.hasOwnProperty("user"))
                        object.user = message.user;
                    if (message.groups && message.groups.length) {
                        object.groups = [];
                        for (let j = 0; j < message.groups.length; ++j)
                            object.groups[j] = message.groups[j];
                    }
                    return object;
                };

                /**
                 * Converts this Subject to JSON.
                 * @function toJSON
                 * @memberof clutch.authz.v1.Subject
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Subject.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Subject;
            })();

            v1.CheckRequest = (function() {

                /**
                 * Properties of a CheckRequest.
                 * @memberof clutch.authz.v1
                 * @interface ICheckRequest
                 * @property {clutch.authz.v1.ISubject|null} [subject] CheckRequest subject
                 * @property {string|null} [method] CheckRequest method
                 * @property {clutch.api.v1.ActionType|null} [actionType] CheckRequest actionType
                 * @property {string|null} [resource] CheckRequest resource
                 */

                /**
                 * Constructs a new CheckRequest.
                 * @memberof clutch.authz.v1
                 * @classdesc Represents a CheckRequest.
                 * @implements ICheckRequest
                 * @constructor
                 * @param {clutch.authz.v1.ICheckRequest=} [properties] Properties to set
                 */
                function CheckRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CheckRequest subject.
                 * @member {clutch.authz.v1.ISubject|null|undefined} subject
                 * @memberof clutch.authz.v1.CheckRequest
                 * @instance
                 */
                CheckRequest.prototype.subject = null;

                /**
                 * CheckRequest method.
                 * @member {string} method
                 * @memberof clutch.authz.v1.CheckRequest
                 * @instance
                 */
                CheckRequest.prototype.method = "";

                /**
                 * CheckRequest actionType.
                 * @member {clutch.api.v1.ActionType} actionType
                 * @memberof clutch.authz.v1.CheckRequest
                 * @instance
                 */
                CheckRequest.prototype.actionType = 0;

                /**
                 * CheckRequest resource.
                 * @member {string} resource
                 * @memberof clutch.authz.v1.CheckRequest
                 * @instance
                 */
                CheckRequest.prototype.resource = "";

                /**
                 * Verifies a CheckRequest message.
                 * @function verify
                 * @memberof clutch.authz.v1.CheckRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CheckRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.subject != null && message.hasOwnProperty("subject")) {
                        let error = $root.clutch.authz.v1.Subject.verify(message.subject);
                        if (error)
                            return "subject." + error;
                    }
                    if (message.method != null && message.hasOwnProperty("method"))
                        if (!$util.isString(message.method))
                            return "method: string expected";
                    if (message.actionType != null && message.hasOwnProperty("actionType"))
                        switch (message.actionType) {
                        default:
                            return "actionType: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.resource != null && message.hasOwnProperty("resource"))
                        if (!$util.isString(message.resource))
                            return "resource: string expected";
                    return null;
                };

                /**
                 * Creates a CheckRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authz.v1.CheckRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authz.v1.CheckRequest} CheckRequest
                 */
                CheckRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authz.v1.CheckRequest)
                        return object;
                    let message = new $root.clutch.authz.v1.CheckRequest();
                    if (object.subject != null) {
                        if (typeof object.subject !== "object")
                            throw TypeError(".clutch.authz.v1.CheckRequest.subject: object expected");
                        message.subject = $root.clutch.authz.v1.Subject.fromObject(object.subject);
                    }
                    if (object.method != null)
                        message.method = String(object.method);
                    switch (object.actionType) {
                    case "UNSPECIFIED":
                    case 0:
                        message.actionType = 0;
                        break;
                    case "CREATE":
                    case 1:
                        message.actionType = 1;
                        break;
                    case "READ":
                    case 2:
                        message.actionType = 2;
                        break;
                    case "UPDATE":
                    case 3:
                        message.actionType = 3;
                        break;
                    case "DELETE":
                    case 4:
                        message.actionType = 4;
                        break;
                    }
                    if (object.resource != null)
                        message.resource = String(object.resource);
                    return message;
                };

                /**
                 * Creates a plain object from a CheckRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authz.v1.CheckRequest
                 * @static
                 * @param {clutch.authz.v1.CheckRequest} message CheckRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CheckRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.subject = null;
                        object.method = "";
                        object.actionType = options.enums === String ? "UNSPECIFIED" : 0;
                        object.resource = "";
                    }
                    if (message.subject != null && message.hasOwnProperty("subject"))
                        object.subject = $root.clutch.authz.v1.Subject.toObject(message.subject, options);
                    if (message.method != null && message.hasOwnProperty("method"))
                        object.method = message.method;
                    if (message.actionType != null && message.hasOwnProperty("actionType"))
                        object.actionType = options.enums === String ? $root.clutch.api.v1.ActionType[message.actionType] : message.actionType;
                    if (message.resource != null && message.hasOwnProperty("resource"))
                        object.resource = message.resource;
                    return object;
                };

                /**
                 * Converts this CheckRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.authz.v1.CheckRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CheckRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CheckRequest;
            })();

            /**
             * Decision enum.
             * @name clutch.authz.v1.Decision
             * @enum {number}
             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
             * @property {number} DENY=1 DENY value
             * @property {number} ALLOW=2 ALLOW value
             */
            v1.Decision = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "UNSPECIFIED"] = 0;
                values[valuesById[1] = "DENY"] = 1;
                values[valuesById[2] = "ALLOW"] = 2;
                return values;
            })();

            v1.CheckResponse = (function() {

                /**
                 * Properties of a CheckResponse.
                 * @memberof clutch.authz.v1
                 * @interface ICheckResponse
                 * @property {clutch.authz.v1.Decision|null} [decision] CheckResponse decision
                 */

                /**
                 * Constructs a new CheckResponse.
                 * @memberof clutch.authz.v1
                 * @classdesc Represents a CheckResponse.
                 * @implements ICheckResponse
                 * @constructor
                 * @param {clutch.authz.v1.ICheckResponse=} [properties] Properties to set
                 */
                function CheckResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CheckResponse decision.
                 * @member {clutch.authz.v1.Decision} decision
                 * @memberof clutch.authz.v1.CheckResponse
                 * @instance
                 */
                CheckResponse.prototype.decision = 0;

                /**
                 * Verifies a CheckResponse message.
                 * @function verify
                 * @memberof clutch.authz.v1.CheckResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CheckResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.decision != null && message.hasOwnProperty("decision"))
                        switch (message.decision) {
                        default:
                            return "decision: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                            break;
                        }
                    return null;
                };

                /**
                 * Creates a CheckResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.authz.v1.CheckResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.authz.v1.CheckResponse} CheckResponse
                 */
                CheckResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.authz.v1.CheckResponse)
                        return object;
                    let message = new $root.clutch.authz.v1.CheckResponse();
                    switch (object.decision) {
                    case "UNSPECIFIED":
                    case 0:
                        message.decision = 0;
                        break;
                    case "DENY":
                    case 1:
                        message.decision = 1;
                        break;
                    case "ALLOW":
                    case 2:
                        message.decision = 2;
                        break;
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CheckResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.authz.v1.CheckResponse
                 * @static
                 * @param {clutch.authz.v1.CheckResponse} message CheckResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CheckResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.decision = options.enums === String ? "UNSPECIFIED" : 0;
                    if (message.decision != null && message.hasOwnProperty("decision"))
                        object.decision = options.enums === String ? $root.clutch.authz.v1.Decision[message.decision] : message.decision;
                    return object;
                };

                /**
                 * Converts this CheckResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.authz.v1.CheckResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CheckResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CheckResponse;
            })();

            return v1;
        })();

        return authz;
    })();

    clutch.aws = (function() {

        /**
         * Namespace aws.
         * @memberof clutch
         * @namespace
         */
        const aws = {};

        aws.ec2 = (function() {

            /**
             * Namespace ec2.
             * @memberof clutch.aws
             * @namespace
             */
            const ec2 = {};

            ec2.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.aws.ec2
                 * @namespace
                 */
                const v1 = {};

                v1.EC2API = (function() {

                    /**
                     * Constructs a new EC2API service.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a EC2API
                     * @extends $protobuf.rpc.Service
                     * @constructor
                     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                     */
                    function EC2API(rpcImpl, requestDelimited, responseDelimited) {
                        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                    }

                    (EC2API.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = EC2API;

                    /**
                     * Callback as used by {@link clutch.aws.ec2.v1.EC2API#getInstance}.
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @typedef GetInstanceCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.aws.ec2.v1.GetInstanceResponse} [response] GetInstanceResponse
                     */

                    /**
                     * Calls GetInstance.
                     * @function getInstance
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @instance
                     * @param {clutch.aws.ec2.v1.IGetInstanceRequest} request GetInstanceRequest message or plain object
                     * @param {clutch.aws.ec2.v1.EC2API.GetInstanceCallback} callback Node-style callback called with the error, if any, and GetInstanceResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(EC2API.prototype.getInstance = function getInstance(request, callback) {
                        return this.rpcCall(getInstance, $root.clutch.aws.ec2.v1.GetInstanceRequest, $root.clutch.aws.ec2.v1.GetInstanceResponse, request, callback);
                    }, "name", { value: "GetInstance" });

                    /**
                     * Calls GetInstance.
                     * @function getInstance
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @instance
                     * @param {clutch.aws.ec2.v1.IGetInstanceRequest} request GetInstanceRequest message or plain object
                     * @returns {Promise<clutch.aws.ec2.v1.GetInstanceResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.aws.ec2.v1.EC2API#terminateInstance}.
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @typedef TerminateInstanceCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.aws.ec2.v1.TerminateInstanceResponse} [response] TerminateInstanceResponse
                     */

                    /**
                     * Calls TerminateInstance.
                     * @function terminateInstance
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @instance
                     * @param {clutch.aws.ec2.v1.ITerminateInstanceRequest} request TerminateInstanceRequest message or plain object
                     * @param {clutch.aws.ec2.v1.EC2API.TerminateInstanceCallback} callback Node-style callback called with the error, if any, and TerminateInstanceResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(EC2API.prototype.terminateInstance = function terminateInstance(request, callback) {
                        return this.rpcCall(terminateInstance, $root.clutch.aws.ec2.v1.TerminateInstanceRequest, $root.clutch.aws.ec2.v1.TerminateInstanceResponse, request, callback);
                    }, "name", { value: "TerminateInstance" });

                    /**
                     * Calls TerminateInstance.
                     * @function terminateInstance
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @instance
                     * @param {clutch.aws.ec2.v1.ITerminateInstanceRequest} request TerminateInstanceRequest message or plain object
                     * @returns {Promise<clutch.aws.ec2.v1.TerminateInstanceResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.aws.ec2.v1.EC2API#resizeAutoscalingGroup}.
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @typedef ResizeAutoscalingGroupCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse} [response] ResizeAutoscalingGroupResponse
                     */

                    /**
                     * Calls ResizeAutoscalingGroup.
                     * @function resizeAutoscalingGroup
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @instance
                     * @param {clutch.aws.ec2.v1.IResizeAutoscalingGroupRequest} request ResizeAutoscalingGroupRequest message or plain object
                     * @param {clutch.aws.ec2.v1.EC2API.ResizeAutoscalingGroupCallback} callback Node-style callback called with the error, if any, and ResizeAutoscalingGroupResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(EC2API.prototype.resizeAutoscalingGroup = function resizeAutoscalingGroup(request, callback) {
                        return this.rpcCall(resizeAutoscalingGroup, $root.clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest, $root.clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse, request, callback);
                    }, "name", { value: "ResizeAutoscalingGroup" });

                    /**
                     * Calls ResizeAutoscalingGroup.
                     * @function resizeAutoscalingGroup
                     * @memberof clutch.aws.ec2.v1.EC2API
                     * @instance
                     * @param {clutch.aws.ec2.v1.IResizeAutoscalingGroupRequest} request ResizeAutoscalingGroupRequest message or plain object
                     * @returns {Promise<clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse>} Promise
                     * @variation 2
                     */

                    return EC2API;
                })();

                v1.AutoscalingGroupSize = (function() {

                    /**
                     * Properties of an AutoscalingGroupSize.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IAutoscalingGroupSize
                     * @property {number|null} [min] AutoscalingGroupSize min
                     * @property {number|null} [max] AutoscalingGroupSize max
                     * @property {number|null} [desired] AutoscalingGroupSize desired
                     */

                    /**
                     * Constructs a new AutoscalingGroupSize.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents an AutoscalingGroupSize.
                     * @implements IAutoscalingGroupSize
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IAutoscalingGroupSize=} [properties] Properties to set
                     */
                    function AutoscalingGroupSize(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * AutoscalingGroupSize min.
                     * @member {number} min
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroupSize
                     * @instance
                     */
                    AutoscalingGroupSize.prototype.min = 0;

                    /**
                     * AutoscalingGroupSize max.
                     * @member {number} max
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroupSize
                     * @instance
                     */
                    AutoscalingGroupSize.prototype.max = 0;

                    /**
                     * AutoscalingGroupSize desired.
                     * @member {number} desired
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroupSize
                     * @instance
                     */
                    AutoscalingGroupSize.prototype.desired = 0;

                    /**
                     * Verifies an AutoscalingGroupSize message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroupSize
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AutoscalingGroupSize.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.min != null && message.hasOwnProperty("min"))
                            if (!$util.isInteger(message.min))
                                return "min: integer expected";
                        if (message.max != null && message.hasOwnProperty("max"))
                            if (!$util.isInteger(message.max))
                                return "max: integer expected";
                        if (message.desired != null && message.hasOwnProperty("desired"))
                            if (!$util.isInteger(message.desired))
                                return "desired: integer expected";
                        return null;
                    };

                    /**
                     * Creates an AutoscalingGroupSize message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroupSize
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.AutoscalingGroupSize} AutoscalingGroupSize
                     */
                    AutoscalingGroupSize.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.AutoscalingGroupSize)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.AutoscalingGroupSize();
                        if (object.min != null)
                            message.min = object.min >>> 0;
                        if (object.max != null)
                            message.max = object.max >>> 0;
                        if (object.desired != null)
                            message.desired = object.desired >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from an AutoscalingGroupSize message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroupSize
                     * @static
                     * @param {clutch.aws.ec2.v1.AutoscalingGroupSize} message AutoscalingGroupSize
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AutoscalingGroupSize.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.min = 0;
                            object.max = 0;
                            object.desired = 0;
                        }
                        if (message.min != null && message.hasOwnProperty("min"))
                            object.min = message.min;
                        if (message.max != null && message.hasOwnProperty("max"))
                            object.max = message.max;
                        if (message.desired != null && message.hasOwnProperty("desired"))
                            object.desired = message.desired;
                        return object;
                    };

                    /**
                     * Converts this AutoscalingGroupSize to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroupSize
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AutoscalingGroupSize.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return AutoscalingGroupSize;
                })();

                v1.ResizeAutoscalingGroupRequest = (function() {

                    /**
                     * Properties of a ResizeAutoscalingGroupRequest.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IResizeAutoscalingGroupRequest
                     * @property {string|null} [name] ResizeAutoscalingGroupRequest name
                     * @property {string|null} [region] ResizeAutoscalingGroupRequest region
                     * @property {clutch.aws.ec2.v1.IAutoscalingGroupSize|null} [size] ResizeAutoscalingGroupRequest size
                     */

                    /**
                     * Constructs a new ResizeAutoscalingGroupRequest.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a ResizeAutoscalingGroupRequest.
                     * @implements IResizeAutoscalingGroupRequest
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IResizeAutoscalingGroupRequest=} [properties] Properties to set
                     */
                    function ResizeAutoscalingGroupRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ResizeAutoscalingGroupRequest name.
                     * @member {string} name
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @instance
                     */
                    ResizeAutoscalingGroupRequest.prototype.name = "";

                    /**
                     * ResizeAutoscalingGroupRequest region.
                     * @member {string} region
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @instance
                     */
                    ResizeAutoscalingGroupRequest.prototype.region = "";

                    /**
                     * ResizeAutoscalingGroupRequest size.
                     * @member {clutch.aws.ec2.v1.IAutoscalingGroupSize|null|undefined} size
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @instance
                     */
                    ResizeAutoscalingGroupRequest.prototype.size = null;

                    /**
                     * Verifies a ResizeAutoscalingGroupRequest message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ResizeAutoscalingGroupRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.size != null && message.hasOwnProperty("size")) {
                            let error = $root.clutch.aws.ec2.v1.AutoscalingGroupSize.verify(message.size);
                            if (error)
                                return "size." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a ResizeAutoscalingGroupRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest} ResizeAutoscalingGroupRequest
                     */
                    ResizeAutoscalingGroupRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.size != null) {
                            if (typeof object.size !== "object")
                                throw TypeError(".clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest.size: object expected");
                            message.size = $root.clutch.aws.ec2.v1.AutoscalingGroupSize.fromObject(object.size);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a ResizeAutoscalingGroupRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @static
                     * @param {clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest} message ResizeAutoscalingGroupRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ResizeAutoscalingGroupRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.region = "";
                            object.size = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.size != null && message.hasOwnProperty("size"))
                            object.size = $root.clutch.aws.ec2.v1.AutoscalingGroupSize.toObject(message.size, options);
                        return object;
                    };

                    /**
                     * Converts this ResizeAutoscalingGroupRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ResizeAutoscalingGroupRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ResizeAutoscalingGroupRequest;
                })();

                v1.ResizeAutoscalingGroupResponse = (function() {

                    /**
                     * Properties of a ResizeAutoscalingGroupResponse.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IResizeAutoscalingGroupResponse
                     */

                    /**
                     * Constructs a new ResizeAutoscalingGroupResponse.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a ResizeAutoscalingGroupResponse.
                     * @implements IResizeAutoscalingGroupResponse
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IResizeAutoscalingGroupResponse=} [properties] Properties to set
                     */
                    function ResizeAutoscalingGroupResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Verifies a ResizeAutoscalingGroupResponse message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ResizeAutoscalingGroupResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a ResizeAutoscalingGroupResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse} ResizeAutoscalingGroupResponse
                     */
                    ResizeAutoscalingGroupResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse)
                            return object;
                        return new $root.clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse();
                    };

                    /**
                     * Creates a plain object from a ResizeAutoscalingGroupResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse
                     * @static
                     * @param {clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse} message ResizeAutoscalingGroupResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ResizeAutoscalingGroupResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this ResizeAutoscalingGroupResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.ResizeAutoscalingGroupResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ResizeAutoscalingGroupResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ResizeAutoscalingGroupResponse;
                })();

                v1.AutoscalingGroup = (function() {

                    /**
                     * Properties of an AutoscalingGroup.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IAutoscalingGroup
                     * @property {string|null} [name] AutoscalingGroup name
                     * @property {string|null} [region] AutoscalingGroup region
                     * @property {Array.<string>|null} [zones] AutoscalingGroup zones
                     * @property {clutch.aws.ec2.v1.IAutoscalingGroupSize|null} [size] AutoscalingGroup size
                     * @property {Array.<clutch.aws.ec2.v1.AutoscalingGroup.TerminationPolicy>|null} [terminationPolicies] AutoscalingGroup terminationPolicies
                     * @property {Array.<clutch.aws.ec2.v1.AutoscalingGroup.IInstance>|null} [instances] AutoscalingGroup instances
                     */

                    /**
                     * Constructs a new AutoscalingGroup.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents an AutoscalingGroup.
                     * @implements IAutoscalingGroup
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IAutoscalingGroup=} [properties] Properties to set
                     */
                    function AutoscalingGroup(properties) {
                        this.zones = [];
                        this.terminationPolicies = [];
                        this.instances = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * AutoscalingGroup name.
                     * @member {string} name
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     */
                    AutoscalingGroup.prototype.name = "";

                    /**
                     * AutoscalingGroup region.
                     * @member {string} region
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     */
                    AutoscalingGroup.prototype.region = "";

                    /**
                     * AutoscalingGroup zones.
                     * @member {Array.<string>} zones
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     */
                    AutoscalingGroup.prototype.zones = $util.emptyArray;

                    /**
                     * AutoscalingGroup size.
                     * @member {clutch.aws.ec2.v1.IAutoscalingGroupSize|null|undefined} size
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     */
                    AutoscalingGroup.prototype.size = null;

                    /**
                     * AutoscalingGroup terminationPolicies.
                     * @member {Array.<clutch.aws.ec2.v1.AutoscalingGroup.TerminationPolicy>} terminationPolicies
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     */
                    AutoscalingGroup.prototype.terminationPolicies = $util.emptyArray;

                    /**
                     * AutoscalingGroup instances.
                     * @member {Array.<clutch.aws.ec2.v1.AutoscalingGroup.IInstance>} instances
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     */
                    AutoscalingGroup.prototype.instances = $util.emptyArray;

                    /**
                     * Verifies an AutoscalingGroup message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AutoscalingGroup.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.zones != null && message.hasOwnProperty("zones")) {
                            if (!Array.isArray(message.zones))
                                return "zones: array expected";
                            for (let i = 0; i < message.zones.length; ++i)
                                if (!$util.isString(message.zones[i]))
                                    return "zones: string[] expected";
                        }
                        if (message.size != null && message.hasOwnProperty("size")) {
                            let error = $root.clutch.aws.ec2.v1.AutoscalingGroupSize.verify(message.size);
                            if (error)
                                return "size." + error;
                        }
                        if (message.terminationPolicies != null && message.hasOwnProperty("terminationPolicies")) {
                            if (!Array.isArray(message.terminationPolicies))
                                return "terminationPolicies: array expected";
                            for (let i = 0; i < message.terminationPolicies.length; ++i)
                                switch (message.terminationPolicies[i]) {
                                default:
                                    return "terminationPolicies: enum value[] expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                    break;
                                }
                        }
                        if (message.instances != null && message.hasOwnProperty("instances")) {
                            if (!Array.isArray(message.instances))
                                return "instances: array expected";
                            for (let i = 0; i < message.instances.length; ++i) {
                                let error = $root.clutch.aws.ec2.v1.AutoscalingGroup.Instance.verify(message.instances[i]);
                                if (error)
                                    return "instances." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates an AutoscalingGroup message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.AutoscalingGroup} AutoscalingGroup
                     */
                    AutoscalingGroup.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.AutoscalingGroup)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.AutoscalingGroup();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.zones) {
                            if (!Array.isArray(object.zones))
                                throw TypeError(".clutch.aws.ec2.v1.AutoscalingGroup.zones: array expected");
                            message.zones = [];
                            for (let i = 0; i < object.zones.length; ++i)
                                message.zones[i] = String(object.zones[i]);
                        }
                        if (object.size != null) {
                            if (typeof object.size !== "object")
                                throw TypeError(".clutch.aws.ec2.v1.AutoscalingGroup.size: object expected");
                            message.size = $root.clutch.aws.ec2.v1.AutoscalingGroupSize.fromObject(object.size);
                        }
                        if (object.terminationPolicies) {
                            if (!Array.isArray(object.terminationPolicies))
                                throw TypeError(".clutch.aws.ec2.v1.AutoscalingGroup.terminationPolicies: array expected");
                            message.terminationPolicies = [];
                            for (let i = 0; i < object.terminationPolicies.length; ++i)
                                switch (object.terminationPolicies[i]) {
                                default:
                                case "UNSPECIFIED":
                                case 0:
                                    message.terminationPolicies[i] = 0;
                                    break;
                                case "UNKNOWN":
                                case 1:
                                    message.terminationPolicies[i] = 1;
                                    break;
                                case "OLDEST_INSTANCE":
                                case 2:
                                    message.terminationPolicies[i] = 2;
                                    break;
                                case "NEWEST_INSTANCE":
                                case 3:
                                    message.terminationPolicies[i] = 3;
                                    break;
                                case "OLDEST_LAUNCH_CONFIGURATION":
                                case 4:
                                    message.terminationPolicies[i] = 4;
                                    break;
                                case "CLOSEST_TO_NEXT_HOUR":
                                case 5:
                                    message.terminationPolicies[i] = 5;
                                    break;
                                case "DEFAULT":
                                case 6:
                                    message.terminationPolicies[i] = 6;
                                    break;
                                case "OLDEST_LAUNCH_TEMPLATE":
                                case 7:
                                    message.terminationPolicies[i] = 7;
                                    break;
                                case "ALLOCATION_STRATEGY":
                                case 8:
                                    message.terminationPolicies[i] = 8;
                                    break;
                                }
                        }
                        if (object.instances) {
                            if (!Array.isArray(object.instances))
                                throw TypeError(".clutch.aws.ec2.v1.AutoscalingGroup.instances: array expected");
                            message.instances = [];
                            for (let i = 0; i < object.instances.length; ++i) {
                                if (typeof object.instances[i] !== "object")
                                    throw TypeError(".clutch.aws.ec2.v1.AutoscalingGroup.instances: object expected");
                                message.instances[i] = $root.clutch.aws.ec2.v1.AutoscalingGroup.Instance.fromObject(object.instances[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an AutoscalingGroup message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @static
                     * @param {clutch.aws.ec2.v1.AutoscalingGroup} message AutoscalingGroup
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AutoscalingGroup.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults) {
                            object.zones = [];
                            object.terminationPolicies = [];
                            object.instances = [];
                        }
                        if (options.defaults) {
                            object.name = "";
                            object.region = "";
                            object.size = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.zones && message.zones.length) {
                            object.zones = [];
                            for (let j = 0; j < message.zones.length; ++j)
                                object.zones[j] = message.zones[j];
                        }
                        if (message.size != null && message.hasOwnProperty("size"))
                            object.size = $root.clutch.aws.ec2.v1.AutoscalingGroupSize.toObject(message.size, options);
                        if (message.terminationPolicies && message.terminationPolicies.length) {
                            object.terminationPolicies = [];
                            for (let j = 0; j < message.terminationPolicies.length; ++j)
                                object.terminationPolicies[j] = options.enums === String ? $root.clutch.aws.ec2.v1.AutoscalingGroup.TerminationPolicy[message.terminationPolicies[j]] : message.terminationPolicies[j];
                        }
                        if (message.instances && message.instances.length) {
                            object.instances = [];
                            for (let j = 0; j < message.instances.length; ++j)
                                object.instances[j] = $root.clutch.aws.ec2.v1.AutoscalingGroup.Instance.toObject(message.instances[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this AutoscalingGroup to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AutoscalingGroup.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * TerminationPolicy enum.
                     * @name clutch.aws.ec2.v1.AutoscalingGroup.TerminationPolicy
                     * @enum {number}
                     * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                     * @property {number} UNKNOWN=1 UNKNOWN value
                     * @property {number} OLDEST_INSTANCE=2 OLDEST_INSTANCE value
                     * @property {number} NEWEST_INSTANCE=3 NEWEST_INSTANCE value
                     * @property {number} OLDEST_LAUNCH_CONFIGURATION=4 OLDEST_LAUNCH_CONFIGURATION value
                     * @property {number} CLOSEST_TO_NEXT_HOUR=5 CLOSEST_TO_NEXT_HOUR value
                     * @property {number} DEFAULT=6 DEFAULT value
                     * @property {number} OLDEST_LAUNCH_TEMPLATE=7 OLDEST_LAUNCH_TEMPLATE value
                     * @property {number} ALLOCATION_STRATEGY=8 ALLOCATION_STRATEGY value
                     */
                    AutoscalingGroup.TerminationPolicy = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNSPECIFIED"] = 0;
                        values[valuesById[1] = "UNKNOWN"] = 1;
                        values[valuesById[2] = "OLDEST_INSTANCE"] = 2;
                        values[valuesById[3] = "NEWEST_INSTANCE"] = 3;
                        values[valuesById[4] = "OLDEST_LAUNCH_CONFIGURATION"] = 4;
                        values[valuesById[5] = "CLOSEST_TO_NEXT_HOUR"] = 5;
                        values[valuesById[6] = "DEFAULT"] = 6;
                        values[valuesById[7] = "OLDEST_LAUNCH_TEMPLATE"] = 7;
                        values[valuesById[8] = "ALLOCATION_STRATEGY"] = 8;
                        return values;
                    })();

                    AutoscalingGroup.Instance = (function() {

                        /**
                         * Properties of an Instance.
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                         * @interface IInstance
                         * @property {string|null} [id] Instance id
                         * @property {string|null} [zone] Instance zone
                         * @property {string|null} [launchConfigurationName] Instance launchConfigurationName
                         * @property {boolean|null} [healthy] Instance healthy
                         * @property {clutch.aws.ec2.v1.AutoscalingGroup.Instance.LifecycleState|null} [lifecycleState] Instance lifecycleState
                         */

                        /**
                         * Constructs a new Instance.
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup
                         * @classdesc Represents an Instance.
                         * @implements IInstance
                         * @constructor
                         * @param {clutch.aws.ec2.v1.AutoscalingGroup.IInstance=} [properties] Properties to set
                         */
                        function Instance(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Instance id.
                         * @member {string} id
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @instance
                         */
                        Instance.prototype.id = "";

                        /**
                         * Instance zone.
                         * @member {string} zone
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @instance
                         */
                        Instance.prototype.zone = "";

                        /**
                         * Instance launchConfigurationName.
                         * @member {string} launchConfigurationName
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @instance
                         */
                        Instance.prototype.launchConfigurationName = "";

                        /**
                         * Instance healthy.
                         * @member {boolean} healthy
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @instance
                         */
                        Instance.prototype.healthy = false;

                        /**
                         * Instance lifecycleState.
                         * @member {clutch.aws.ec2.v1.AutoscalingGroup.Instance.LifecycleState} lifecycleState
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @instance
                         */
                        Instance.prototype.lifecycleState = 0;

                        /**
                         * Verifies an Instance message.
                         * @function verify
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Instance.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.id != null && message.hasOwnProperty("id"))
                                if (!$util.isString(message.id))
                                    return "id: string expected";
                            if (message.zone != null && message.hasOwnProperty("zone"))
                                if (!$util.isString(message.zone))
                                    return "zone: string expected";
                            if (message.launchConfigurationName != null && message.hasOwnProperty("launchConfigurationName"))
                                if (!$util.isString(message.launchConfigurationName))
                                    return "launchConfigurationName: string expected";
                            if (message.healthy != null && message.hasOwnProperty("healthy"))
                                if (typeof message.healthy !== "boolean")
                                    return "healthy: boolean expected";
                            if (message.lifecycleState != null && message.hasOwnProperty("lifecycleState"))
                                switch (message.lifecycleState) {
                                default:
                                    return "lifecycleState: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                case 4:
                                case 5:
                                case 6:
                                case 7:
                                case 8:
                                case 9:
                                case 10:
                                case 11:
                                case 12:
                                case 13:
                                case 14:
                                    break;
                                }
                            return null;
                        };

                        /**
                         * Creates an Instance message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.aws.ec2.v1.AutoscalingGroup.Instance} Instance
                         */
                        Instance.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.aws.ec2.v1.AutoscalingGroup.Instance)
                                return object;
                            let message = new $root.clutch.aws.ec2.v1.AutoscalingGroup.Instance();
                            if (object.id != null)
                                message.id = String(object.id);
                            if (object.zone != null)
                                message.zone = String(object.zone);
                            if (object.launchConfigurationName != null)
                                message.launchConfigurationName = String(object.launchConfigurationName);
                            if (object.healthy != null)
                                message.healthy = Boolean(object.healthy);
                            switch (object.lifecycleState) {
                            case "UNSPECIFIED":
                            case 0:
                                message.lifecycleState = 0;
                                break;
                            case "UNKNOWN":
                            case 1:
                                message.lifecycleState = 1;
                                break;
                            case "PENDING":
                            case 2:
                                message.lifecycleState = 2;
                                break;
                            case "PENDING_WAIT":
                            case 3:
                                message.lifecycleState = 3;
                                break;
                            case "PENDING_PROCEED":
                            case 4:
                                message.lifecycleState = 4;
                                break;
                            case "QUARANTINED":
                            case 5:
                                message.lifecycleState = 5;
                                break;
                            case "IN_SERVICE":
                            case 6:
                                message.lifecycleState = 6;
                                break;
                            case "TERMINATING":
                            case 7:
                                message.lifecycleState = 7;
                                break;
                            case "TERMINATING_WAIT":
                            case 8:
                                message.lifecycleState = 8;
                                break;
                            case "TERMINATING_PROCEED":
                            case 9:
                                message.lifecycleState = 9;
                                break;
                            case "TERMINATED":
                            case 10:
                                message.lifecycleState = 10;
                                break;
                            case "DETACHING":
                            case 11:
                                message.lifecycleState = 11;
                                break;
                            case "DETACHED":
                            case 12:
                                message.lifecycleState = 12;
                                break;
                            case "ENTERING_STANDBY":
                            case 13:
                                message.lifecycleState = 13;
                                break;
                            case "STANDBY":
                            case 14:
                                message.lifecycleState = 14;
                                break;
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an Instance message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @static
                         * @param {clutch.aws.ec2.v1.AutoscalingGroup.Instance} message Instance
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Instance.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.id = "";
                                object.zone = "";
                                object.launchConfigurationName = "";
                                object.healthy = false;
                                object.lifecycleState = options.enums === String ? "UNSPECIFIED" : 0;
                            }
                            if (message.id != null && message.hasOwnProperty("id"))
                                object.id = message.id;
                            if (message.zone != null && message.hasOwnProperty("zone"))
                                object.zone = message.zone;
                            if (message.launchConfigurationName != null && message.hasOwnProperty("launchConfigurationName"))
                                object.launchConfigurationName = message.launchConfigurationName;
                            if (message.healthy != null && message.hasOwnProperty("healthy"))
                                object.healthy = message.healthy;
                            if (message.lifecycleState != null && message.hasOwnProperty("lifecycleState"))
                                object.lifecycleState = options.enums === String ? $root.clutch.aws.ec2.v1.AutoscalingGroup.Instance.LifecycleState[message.lifecycleState] : message.lifecycleState;
                            return object;
                        };

                        /**
                         * Converts this Instance to JSON.
                         * @function toJSON
                         * @memberof clutch.aws.ec2.v1.AutoscalingGroup.Instance
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Instance.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * LifecycleState enum.
                         * @name clutch.aws.ec2.v1.AutoscalingGroup.Instance.LifecycleState
                         * @enum {number}
                         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                         * @property {number} UNKNOWN=1 UNKNOWN value
                         * @property {number} PENDING=2 PENDING value
                         * @property {number} PENDING_WAIT=3 PENDING_WAIT value
                         * @property {number} PENDING_PROCEED=4 PENDING_PROCEED value
                         * @property {number} QUARANTINED=5 QUARANTINED value
                         * @property {number} IN_SERVICE=6 IN_SERVICE value
                         * @property {number} TERMINATING=7 TERMINATING value
                         * @property {number} TERMINATING_WAIT=8 TERMINATING_WAIT value
                         * @property {number} TERMINATING_PROCEED=9 TERMINATING_PROCEED value
                         * @property {number} TERMINATED=10 TERMINATED value
                         * @property {number} DETACHING=11 DETACHING value
                         * @property {number} DETACHED=12 DETACHED value
                         * @property {number} ENTERING_STANDBY=13 ENTERING_STANDBY value
                         * @property {number} STANDBY=14 STANDBY value
                         */
                        Instance.LifecycleState = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "UNSPECIFIED"] = 0;
                            values[valuesById[1] = "UNKNOWN"] = 1;
                            values[valuesById[2] = "PENDING"] = 2;
                            values[valuesById[3] = "PENDING_WAIT"] = 3;
                            values[valuesById[4] = "PENDING_PROCEED"] = 4;
                            values[valuesById[5] = "QUARANTINED"] = 5;
                            values[valuesById[6] = "IN_SERVICE"] = 6;
                            values[valuesById[7] = "TERMINATING"] = 7;
                            values[valuesById[8] = "TERMINATING_WAIT"] = 8;
                            values[valuesById[9] = "TERMINATING_PROCEED"] = 9;
                            values[valuesById[10] = "TERMINATED"] = 10;
                            values[valuesById[11] = "DETACHING"] = 11;
                            values[valuesById[12] = "DETACHED"] = 12;
                            values[valuesById[13] = "ENTERING_STANDBY"] = 13;
                            values[valuesById[14] = "STANDBY"] = 14;
                            return values;
                        })();

                        return Instance;
                    })();

                    return AutoscalingGroup;
                })();

                v1.GetInstanceRequest = (function() {

                    /**
                     * Properties of a GetInstanceRequest.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IGetInstanceRequest
                     * @property {string|null} [instanceId] GetInstanceRequest instanceId
                     * @property {string|null} [region] GetInstanceRequest region
                     */

                    /**
                     * Constructs a new GetInstanceRequest.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a GetInstanceRequest.
                     * @implements IGetInstanceRequest
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IGetInstanceRequest=} [properties] Properties to set
                     */
                    function GetInstanceRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetInstanceRequest instanceId.
                     * @member {string} instanceId
                     * @memberof clutch.aws.ec2.v1.GetInstanceRequest
                     * @instance
                     */
                    GetInstanceRequest.prototype.instanceId = "";

                    /**
                     * GetInstanceRequest region.
                     * @member {string} region
                     * @memberof clutch.aws.ec2.v1.GetInstanceRequest
                     * @instance
                     */
                    GetInstanceRequest.prototype.region = "";

                    /**
                     * Verifies a GetInstanceRequest message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.GetInstanceRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetInstanceRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                            if (!$util.isString(message.instanceId))
                                return "instanceId: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        return null;
                    };

                    /**
                     * Creates a GetInstanceRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.GetInstanceRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.GetInstanceRequest} GetInstanceRequest
                     */
                    GetInstanceRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.GetInstanceRequest)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.GetInstanceRequest();
                        if (object.instanceId != null)
                            message.instanceId = String(object.instanceId);
                        if (object.region != null)
                            message.region = String(object.region);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetInstanceRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.GetInstanceRequest
                     * @static
                     * @param {clutch.aws.ec2.v1.GetInstanceRequest} message GetInstanceRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetInstanceRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.instanceId = "";
                            object.region = "";
                        }
                        if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                            object.instanceId = message.instanceId;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        return object;
                    };

                    /**
                     * Converts this GetInstanceRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.GetInstanceRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetInstanceRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetInstanceRequest;
                })();

                v1.GetInstanceResponse = (function() {

                    /**
                     * Properties of a GetInstanceResponse.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IGetInstanceResponse
                     * @property {clutch.aws.ec2.v1.IInstance|null} [instance] GetInstanceResponse instance
                     */

                    /**
                     * Constructs a new GetInstanceResponse.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a GetInstanceResponse.
                     * @implements IGetInstanceResponse
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IGetInstanceResponse=} [properties] Properties to set
                     */
                    function GetInstanceResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetInstanceResponse instance.
                     * @member {clutch.aws.ec2.v1.IInstance|null|undefined} instance
                     * @memberof clutch.aws.ec2.v1.GetInstanceResponse
                     * @instance
                     */
                    GetInstanceResponse.prototype.instance = null;

                    /**
                     * Verifies a GetInstanceResponse message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.GetInstanceResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetInstanceResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.instance != null && message.hasOwnProperty("instance")) {
                            let error = $root.clutch.aws.ec2.v1.Instance.verify(message.instance);
                            if (error)
                                return "instance." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a GetInstanceResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.GetInstanceResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.GetInstanceResponse} GetInstanceResponse
                     */
                    GetInstanceResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.GetInstanceResponse)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.GetInstanceResponse();
                        if (object.instance != null) {
                            if (typeof object.instance !== "object")
                                throw TypeError(".clutch.aws.ec2.v1.GetInstanceResponse.instance: object expected");
                            message.instance = $root.clutch.aws.ec2.v1.Instance.fromObject(object.instance);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetInstanceResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.GetInstanceResponse
                     * @static
                     * @param {clutch.aws.ec2.v1.GetInstanceResponse} message GetInstanceResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetInstanceResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.instance = null;
                        if (message.instance != null && message.hasOwnProperty("instance"))
                            object.instance = $root.clutch.aws.ec2.v1.Instance.toObject(message.instance, options);
                        return object;
                    };

                    /**
                     * Converts this GetInstanceResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.GetInstanceResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetInstanceResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetInstanceResponse;
                })();

                v1.TerminateInstanceRequest = (function() {

                    /**
                     * Properties of a TerminateInstanceRequest.
                     * @memberof clutch.aws.ec2.v1
                     * @interface ITerminateInstanceRequest
                     * @property {string|null} [instanceId] TerminateInstanceRequest instanceId
                     * @property {string|null} [region] TerminateInstanceRequest region
                     */

                    /**
                     * Constructs a new TerminateInstanceRequest.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a TerminateInstanceRequest.
                     * @implements ITerminateInstanceRequest
                     * @constructor
                     * @param {clutch.aws.ec2.v1.ITerminateInstanceRequest=} [properties] Properties to set
                     */
                    function TerminateInstanceRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TerminateInstanceRequest instanceId.
                     * @member {string} instanceId
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceRequest
                     * @instance
                     */
                    TerminateInstanceRequest.prototype.instanceId = "";

                    /**
                     * TerminateInstanceRequest region.
                     * @member {string} region
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceRequest
                     * @instance
                     */
                    TerminateInstanceRequest.prototype.region = "";

                    /**
                     * Verifies a TerminateInstanceRequest message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TerminateInstanceRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                            if (!$util.isString(message.instanceId))
                                return "instanceId: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        return null;
                    };

                    /**
                     * Creates a TerminateInstanceRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.TerminateInstanceRequest} TerminateInstanceRequest
                     */
                    TerminateInstanceRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.TerminateInstanceRequest)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.TerminateInstanceRequest();
                        if (object.instanceId != null)
                            message.instanceId = String(object.instanceId);
                        if (object.region != null)
                            message.region = String(object.region);
                        return message;
                    };

                    /**
                     * Creates a plain object from a TerminateInstanceRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceRequest
                     * @static
                     * @param {clutch.aws.ec2.v1.TerminateInstanceRequest} message TerminateInstanceRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TerminateInstanceRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.instanceId = "";
                            object.region = "";
                        }
                        if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                            object.instanceId = message.instanceId;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        return object;
                    };

                    /**
                     * Converts this TerminateInstanceRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TerminateInstanceRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return TerminateInstanceRequest;
                })();

                v1.TerminateInstanceResponse = (function() {

                    /**
                     * Properties of a TerminateInstanceResponse.
                     * @memberof clutch.aws.ec2.v1
                     * @interface ITerminateInstanceResponse
                     */

                    /**
                     * Constructs a new TerminateInstanceResponse.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents a TerminateInstanceResponse.
                     * @implements ITerminateInstanceResponse
                     * @constructor
                     * @param {clutch.aws.ec2.v1.ITerminateInstanceResponse=} [properties] Properties to set
                     */
                    function TerminateInstanceResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Verifies a TerminateInstanceResponse message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TerminateInstanceResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a TerminateInstanceResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.TerminateInstanceResponse} TerminateInstanceResponse
                     */
                    TerminateInstanceResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.TerminateInstanceResponse)
                            return object;
                        return new $root.clutch.aws.ec2.v1.TerminateInstanceResponse();
                    };

                    /**
                     * Creates a plain object from a TerminateInstanceResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceResponse
                     * @static
                     * @param {clutch.aws.ec2.v1.TerminateInstanceResponse} message TerminateInstanceResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TerminateInstanceResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this TerminateInstanceResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.TerminateInstanceResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TerminateInstanceResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return TerminateInstanceResponse;
                })();

                v1.Instance = (function() {

                    /**
                     * Properties of an Instance.
                     * @memberof clutch.aws.ec2.v1
                     * @interface IInstance
                     * @property {string|null} [instanceId] Instance instanceId
                     * @property {string|null} [region] Instance region
                     * @property {clutch.aws.ec2.v1.Instance.State|null} [state] Instance state
                     * @property {string|null} [instanceType] Instance instanceType
                     * @property {string|null} [publicIpAddress] Instance publicIpAddress
                     * @property {string|null} [privateIpAddress] Instance privateIpAddress
                     * @property {string|null} [availabilityZone] Instance availabilityZone
                     * @property {Object.<string,string>|null} [tags] Instance tags
                     */

                    /**
                     * Constructs a new Instance.
                     * @memberof clutch.aws.ec2.v1
                     * @classdesc Represents an Instance.
                     * @implements IInstance
                     * @constructor
                     * @param {clutch.aws.ec2.v1.IInstance=} [properties] Properties to set
                     */
                    function Instance(properties) {
                        this.tags = {};
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Instance instanceId.
                     * @member {string} instanceId
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.instanceId = "";

                    /**
                     * Instance region.
                     * @member {string} region
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.region = "";

                    /**
                     * Instance state.
                     * @member {clutch.aws.ec2.v1.Instance.State} state
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.state = 0;

                    /**
                     * Instance instanceType.
                     * @member {string} instanceType
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.instanceType = "";

                    /**
                     * Instance publicIpAddress.
                     * @member {string} publicIpAddress
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.publicIpAddress = "";

                    /**
                     * Instance privateIpAddress.
                     * @member {string} privateIpAddress
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.privateIpAddress = "";

                    /**
                     * Instance availabilityZone.
                     * @member {string} availabilityZone
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.availabilityZone = "";

                    /**
                     * Instance tags.
                     * @member {Object.<string,string>} tags
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     */
                    Instance.prototype.tags = $util.emptyObject;

                    /**
                     * Verifies an Instance message.
                     * @function verify
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Instance.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                            if (!$util.isString(message.instanceId))
                                return "instanceId: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.state != null && message.hasOwnProperty("state"))
                            switch (message.state) {
                            default:
                                return "state: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                            case 7:
                                break;
                            }
                        if (message.instanceType != null && message.hasOwnProperty("instanceType"))
                            if (!$util.isString(message.instanceType))
                                return "instanceType: string expected";
                        if (message.publicIpAddress != null && message.hasOwnProperty("publicIpAddress"))
                            if (!$util.isString(message.publicIpAddress))
                                return "publicIpAddress: string expected";
                        if (message.privateIpAddress != null && message.hasOwnProperty("privateIpAddress"))
                            if (!$util.isString(message.privateIpAddress))
                                return "privateIpAddress: string expected";
                        if (message.availabilityZone != null && message.hasOwnProperty("availabilityZone"))
                            if (!$util.isString(message.availabilityZone))
                                return "availabilityZone: string expected";
                        if (message.tags != null && message.hasOwnProperty("tags")) {
                            if (!$util.isObject(message.tags))
                                return "tags: object expected";
                            let key = Object.keys(message.tags);
                            for (let i = 0; i < key.length; ++i)
                                if (!$util.isString(message.tags[key[i]]))
                                    return "tags: string{k:string} expected";
                        }
                        return null;
                    };

                    /**
                     * Creates an Instance message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.ec2.v1.Instance} Instance
                     */
                    Instance.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.ec2.v1.Instance)
                            return object;
                        let message = new $root.clutch.aws.ec2.v1.Instance();
                        if (object.instanceId != null)
                            message.instanceId = String(object.instanceId);
                        if (object.region != null)
                            message.region = String(object.region);
                        switch (object.state) {
                        case "UNSPECIFIED":
                        case 0:
                            message.state = 0;
                            break;
                        case "UNKNOWN":
                        case 1:
                            message.state = 1;
                            break;
                        case "PENDING":
                        case 2:
                            message.state = 2;
                            break;
                        case "RUNNING":
                        case 3:
                            message.state = 3;
                            break;
                        case "STOPPING":
                        case 4:
                            message.state = 4;
                            break;
                        case "STOPPED":
                        case 5:
                            message.state = 5;
                            break;
                        case "SHUTTING_DOWN":
                        case 6:
                            message.state = 6;
                            break;
                        case "TERMINATED":
                        case 7:
                            message.state = 7;
                            break;
                        }
                        if (object.instanceType != null)
                            message.instanceType = String(object.instanceType);
                        if (object.publicIpAddress != null)
                            message.publicIpAddress = String(object.publicIpAddress);
                        if (object.privateIpAddress != null)
                            message.privateIpAddress = String(object.privateIpAddress);
                        if (object.availabilityZone != null)
                            message.availabilityZone = String(object.availabilityZone);
                        if (object.tags) {
                            if (typeof object.tags !== "object")
                                throw TypeError(".clutch.aws.ec2.v1.Instance.tags: object expected");
                            message.tags = {};
                            for (let keys = Object.keys(object.tags), i = 0; i < keys.length; ++i)
                                message.tags[keys[i]] = String(object.tags[keys[i]]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an Instance message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @static
                     * @param {clutch.aws.ec2.v1.Instance} message Instance
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Instance.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.objects || options.defaults)
                            object.tags = {};
                        if (options.defaults) {
                            object.instanceId = "";
                            object.region = "";
                            object.state = options.enums === String ? "UNSPECIFIED" : 0;
                            object.instanceType = "";
                            object.publicIpAddress = "";
                            object.privateIpAddress = "";
                            object.availabilityZone = "";
                        }
                        if (message.instanceId != null && message.hasOwnProperty("instanceId"))
                            object.instanceId = message.instanceId;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.state != null && message.hasOwnProperty("state"))
                            object.state = options.enums === String ? $root.clutch.aws.ec2.v1.Instance.State[message.state] : message.state;
                        if (message.instanceType != null && message.hasOwnProperty("instanceType"))
                            object.instanceType = message.instanceType;
                        if (message.publicIpAddress != null && message.hasOwnProperty("publicIpAddress"))
                            object.publicIpAddress = message.publicIpAddress;
                        if (message.privateIpAddress != null && message.hasOwnProperty("privateIpAddress"))
                            object.privateIpAddress = message.privateIpAddress;
                        if (message.availabilityZone != null && message.hasOwnProperty("availabilityZone"))
                            object.availabilityZone = message.availabilityZone;
                        let keys2;
                        if (message.tags && (keys2 = Object.keys(message.tags)).length) {
                            object.tags = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.tags[keys2[j]] = message.tags[keys2[j]];
                        }
                        return object;
                    };

                    /**
                     * Converts this Instance to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.ec2.v1.Instance
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Instance.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * State enum.
                     * @name clutch.aws.ec2.v1.Instance.State
                     * @enum {number}
                     * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                     * @property {number} UNKNOWN=1 UNKNOWN value
                     * @property {number} PENDING=2 PENDING value
                     * @property {number} RUNNING=3 RUNNING value
                     * @property {number} STOPPING=4 STOPPING value
                     * @property {number} STOPPED=5 STOPPED value
                     * @property {number} SHUTTING_DOWN=6 SHUTTING_DOWN value
                     * @property {number} TERMINATED=7 TERMINATED value
                     */
                    Instance.State = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNSPECIFIED"] = 0;
                        values[valuesById[1] = "UNKNOWN"] = 1;
                        values[valuesById[2] = "PENDING"] = 2;
                        values[valuesById[3] = "RUNNING"] = 3;
                        values[valuesById[4] = "STOPPING"] = 4;
                        values[valuesById[5] = "STOPPED"] = 5;
                        values[valuesById[6] = "SHUTTING_DOWN"] = 6;
                        values[valuesById[7] = "TERMINATED"] = 7;
                        return values;
                    })();

                    return Instance;
                })();

                return v1;
            })();

            return ec2;
        })();

        aws.kinesis = (function() {

            /**
             * Namespace kinesis.
             * @memberof clutch.aws
             * @namespace
             */
            const kinesis = {};

            kinesis.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.aws.kinesis
                 * @namespace
                 */
                const v1 = {};

                v1.KinesisAPI = (function() {

                    /**
                     * Constructs a new KinesisAPI service.
                     * @memberof clutch.aws.kinesis.v1
                     * @classdesc Represents a KinesisAPI
                     * @extends $protobuf.rpc.Service
                     * @constructor
                     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                     */
                    function KinesisAPI(rpcImpl, requestDelimited, responseDelimited) {
                        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                    }

                    (KinesisAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = KinesisAPI;

                    /**
                     * Callback as used by {@link clutch.aws.kinesis.v1.KinesisAPI#getStream}.
                     * @memberof clutch.aws.kinesis.v1.KinesisAPI
                     * @typedef GetStreamCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.aws.kinesis.v1.GetStreamResponse} [response] GetStreamResponse
                     */

                    /**
                     * Calls GetStream.
                     * @function getStream
                     * @memberof clutch.aws.kinesis.v1.KinesisAPI
                     * @instance
                     * @param {clutch.aws.kinesis.v1.IGetStreamRequest} request GetStreamRequest message or plain object
                     * @param {clutch.aws.kinesis.v1.KinesisAPI.GetStreamCallback} callback Node-style callback called with the error, if any, and GetStreamResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(KinesisAPI.prototype.getStream = function getStream(request, callback) {
                        return this.rpcCall(getStream, $root.clutch.aws.kinesis.v1.GetStreamRequest, $root.clutch.aws.kinesis.v1.GetStreamResponse, request, callback);
                    }, "name", { value: "GetStream" });

                    /**
                     * Calls GetStream.
                     * @function getStream
                     * @memberof clutch.aws.kinesis.v1.KinesisAPI
                     * @instance
                     * @param {clutch.aws.kinesis.v1.IGetStreamRequest} request GetStreamRequest message or plain object
                     * @returns {Promise<clutch.aws.kinesis.v1.GetStreamResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.aws.kinesis.v1.KinesisAPI#updateShardCount}.
                     * @memberof clutch.aws.kinesis.v1.KinesisAPI
                     * @typedef UpdateShardCountCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.aws.kinesis.v1.UpdateShardCountResponse} [response] UpdateShardCountResponse
                     */

                    /**
                     * Calls UpdateShardCount.
                     * @function updateShardCount
                     * @memberof clutch.aws.kinesis.v1.KinesisAPI
                     * @instance
                     * @param {clutch.aws.kinesis.v1.IUpdateShardCountRequest} request UpdateShardCountRequest message or plain object
                     * @param {clutch.aws.kinesis.v1.KinesisAPI.UpdateShardCountCallback} callback Node-style callback called with the error, if any, and UpdateShardCountResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(KinesisAPI.prototype.updateShardCount = function updateShardCount(request, callback) {
                        return this.rpcCall(updateShardCount, $root.clutch.aws.kinesis.v1.UpdateShardCountRequest, $root.clutch.aws.kinesis.v1.UpdateShardCountResponse, request, callback);
                    }, "name", { value: "UpdateShardCount" });

                    /**
                     * Calls UpdateShardCount.
                     * @function updateShardCount
                     * @memberof clutch.aws.kinesis.v1.KinesisAPI
                     * @instance
                     * @param {clutch.aws.kinesis.v1.IUpdateShardCountRequest} request UpdateShardCountRequest message or plain object
                     * @returns {Promise<clutch.aws.kinesis.v1.UpdateShardCountResponse>} Promise
                     * @variation 2
                     */

                    return KinesisAPI;
                })();

                v1.GetStreamRequest = (function() {

                    /**
                     * Properties of a GetStreamRequest.
                     * @memberof clutch.aws.kinesis.v1
                     * @interface IGetStreamRequest
                     * @property {string|null} [streamName] GetStreamRequest streamName
                     * @property {string|null} [region] GetStreamRequest region
                     */

                    /**
                     * Constructs a new GetStreamRequest.
                     * @memberof clutch.aws.kinesis.v1
                     * @classdesc Represents a GetStreamRequest.
                     * @implements IGetStreamRequest
                     * @constructor
                     * @param {clutch.aws.kinesis.v1.IGetStreamRequest=} [properties] Properties to set
                     */
                    function GetStreamRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetStreamRequest streamName.
                     * @member {string} streamName
                     * @memberof clutch.aws.kinesis.v1.GetStreamRequest
                     * @instance
                     */
                    GetStreamRequest.prototype.streamName = "";

                    /**
                     * GetStreamRequest region.
                     * @member {string} region
                     * @memberof clutch.aws.kinesis.v1.GetStreamRequest
                     * @instance
                     */
                    GetStreamRequest.prototype.region = "";

                    /**
                     * Verifies a GetStreamRequest message.
                     * @function verify
                     * @memberof clutch.aws.kinesis.v1.GetStreamRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetStreamRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.streamName != null && message.hasOwnProperty("streamName"))
                            if (!$util.isString(message.streamName))
                                return "streamName: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        return null;
                    };

                    /**
                     * Creates a GetStreamRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.kinesis.v1.GetStreamRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.kinesis.v1.GetStreamRequest} GetStreamRequest
                     */
                    GetStreamRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.kinesis.v1.GetStreamRequest)
                            return object;
                        let message = new $root.clutch.aws.kinesis.v1.GetStreamRequest();
                        if (object.streamName != null)
                            message.streamName = String(object.streamName);
                        if (object.region != null)
                            message.region = String(object.region);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetStreamRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.kinesis.v1.GetStreamRequest
                     * @static
                     * @param {clutch.aws.kinesis.v1.GetStreamRequest} message GetStreamRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetStreamRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.streamName = "";
                            object.region = "";
                        }
                        if (message.streamName != null && message.hasOwnProperty("streamName"))
                            object.streamName = message.streamName;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        return object;
                    };

                    /**
                     * Converts this GetStreamRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.kinesis.v1.GetStreamRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetStreamRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetStreamRequest;
                })();

                v1.GetStreamResponse = (function() {

                    /**
                     * Properties of a GetStreamResponse.
                     * @memberof clutch.aws.kinesis.v1
                     * @interface IGetStreamResponse
                     * @property {clutch.aws.kinesis.v1.IStream|null} [stream] GetStreamResponse stream
                     */

                    /**
                     * Constructs a new GetStreamResponse.
                     * @memberof clutch.aws.kinesis.v1
                     * @classdesc Represents a GetStreamResponse.
                     * @implements IGetStreamResponse
                     * @constructor
                     * @param {clutch.aws.kinesis.v1.IGetStreamResponse=} [properties] Properties to set
                     */
                    function GetStreamResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetStreamResponse stream.
                     * @member {clutch.aws.kinesis.v1.IStream|null|undefined} stream
                     * @memberof clutch.aws.kinesis.v1.GetStreamResponse
                     * @instance
                     */
                    GetStreamResponse.prototype.stream = null;

                    /**
                     * Verifies a GetStreamResponse message.
                     * @function verify
                     * @memberof clutch.aws.kinesis.v1.GetStreamResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetStreamResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.stream != null && message.hasOwnProperty("stream")) {
                            let error = $root.clutch.aws.kinesis.v1.Stream.verify(message.stream);
                            if (error)
                                return "stream." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a GetStreamResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.kinesis.v1.GetStreamResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.kinesis.v1.GetStreamResponse} GetStreamResponse
                     */
                    GetStreamResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.kinesis.v1.GetStreamResponse)
                            return object;
                        let message = new $root.clutch.aws.kinesis.v1.GetStreamResponse();
                        if (object.stream != null) {
                            if (typeof object.stream !== "object")
                                throw TypeError(".clutch.aws.kinesis.v1.GetStreamResponse.stream: object expected");
                            message.stream = $root.clutch.aws.kinesis.v1.Stream.fromObject(object.stream);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetStreamResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.kinesis.v1.GetStreamResponse
                     * @static
                     * @param {clutch.aws.kinesis.v1.GetStreamResponse} message GetStreamResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetStreamResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.stream = null;
                        if (message.stream != null && message.hasOwnProperty("stream"))
                            object.stream = $root.clutch.aws.kinesis.v1.Stream.toObject(message.stream, options);
                        return object;
                    };

                    /**
                     * Converts this GetStreamResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.kinesis.v1.GetStreamResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetStreamResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetStreamResponse;
                })();

                v1.UpdateShardCountRequest = (function() {

                    /**
                     * Properties of an UpdateShardCountRequest.
                     * @memberof clutch.aws.kinesis.v1
                     * @interface IUpdateShardCountRequest
                     * @property {string|null} [streamName] UpdateShardCountRequest streamName
                     * @property {string|null} [region] UpdateShardCountRequest region
                     * @property {number|null} [targetShardCount] UpdateShardCountRequest targetShardCount
                     */

                    /**
                     * Constructs a new UpdateShardCountRequest.
                     * @memberof clutch.aws.kinesis.v1
                     * @classdesc Represents an UpdateShardCountRequest.
                     * @implements IUpdateShardCountRequest
                     * @constructor
                     * @param {clutch.aws.kinesis.v1.IUpdateShardCountRequest=} [properties] Properties to set
                     */
                    function UpdateShardCountRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UpdateShardCountRequest streamName.
                     * @member {string} streamName
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @instance
                     */
                    UpdateShardCountRequest.prototype.streamName = "";

                    /**
                     * UpdateShardCountRequest region.
                     * @member {string} region
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @instance
                     */
                    UpdateShardCountRequest.prototype.region = "";

                    /**
                     * UpdateShardCountRequest targetShardCount.
                     * @member {number} targetShardCount
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @instance
                     */
                    UpdateShardCountRequest.prototype.targetShardCount = 0;

                    /**
                     * Verifies an UpdateShardCountRequest message.
                     * @function verify
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UpdateShardCountRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.streamName != null && message.hasOwnProperty("streamName"))
                            if (!$util.isString(message.streamName))
                                return "streamName: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.targetShardCount != null && message.hasOwnProperty("targetShardCount"))
                            if (!$util.isInteger(message.targetShardCount))
                                return "targetShardCount: integer expected";
                        return null;
                    };

                    /**
                     * Creates an UpdateShardCountRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.kinesis.v1.UpdateShardCountRequest} UpdateShardCountRequest
                     */
                    UpdateShardCountRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.kinesis.v1.UpdateShardCountRequest)
                            return object;
                        let message = new $root.clutch.aws.kinesis.v1.UpdateShardCountRequest();
                        if (object.streamName != null)
                            message.streamName = String(object.streamName);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.targetShardCount != null)
                            message.targetShardCount = object.targetShardCount >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from an UpdateShardCountRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @static
                     * @param {clutch.aws.kinesis.v1.UpdateShardCountRequest} message UpdateShardCountRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UpdateShardCountRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.streamName = "";
                            object.region = "";
                            object.targetShardCount = 0;
                        }
                        if (message.streamName != null && message.hasOwnProperty("streamName"))
                            object.streamName = message.streamName;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.targetShardCount != null && message.hasOwnProperty("targetShardCount"))
                            object.targetShardCount = message.targetShardCount;
                        return object;
                    };

                    /**
                     * Converts this UpdateShardCountRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UpdateShardCountRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UpdateShardCountRequest;
                })();

                v1.UpdateShardCountResponse = (function() {

                    /**
                     * Properties of an UpdateShardCountResponse.
                     * @memberof clutch.aws.kinesis.v1
                     * @interface IUpdateShardCountResponse
                     */

                    /**
                     * Constructs a new UpdateShardCountResponse.
                     * @memberof clutch.aws.kinesis.v1
                     * @classdesc Represents an UpdateShardCountResponse.
                     * @implements IUpdateShardCountResponse
                     * @constructor
                     * @param {clutch.aws.kinesis.v1.IUpdateShardCountResponse=} [properties] Properties to set
                     */
                    function UpdateShardCountResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Verifies an UpdateShardCountResponse message.
                     * @function verify
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UpdateShardCountResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates an UpdateShardCountResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.kinesis.v1.UpdateShardCountResponse} UpdateShardCountResponse
                     */
                    UpdateShardCountResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.kinesis.v1.UpdateShardCountResponse)
                            return object;
                        return new $root.clutch.aws.kinesis.v1.UpdateShardCountResponse();
                    };

                    /**
                     * Creates a plain object from an UpdateShardCountResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountResponse
                     * @static
                     * @param {clutch.aws.kinesis.v1.UpdateShardCountResponse} message UpdateShardCountResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UpdateShardCountResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this UpdateShardCountResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.kinesis.v1.UpdateShardCountResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UpdateShardCountResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UpdateShardCountResponse;
                })();

                v1.Stream = (function() {

                    /**
                     * Properties of a Stream.
                     * @memberof clutch.aws.kinesis.v1
                     * @interface IStream
                     * @property {string|null} [streamName] Stream streamName
                     * @property {string|null} [region] Stream region
                     * @property {number|null} [currentShardCount] Stream currentShardCount
                     */

                    /**
                     * Constructs a new Stream.
                     * @memberof clutch.aws.kinesis.v1
                     * @classdesc Represents a Stream.
                     * @implements IStream
                     * @constructor
                     * @param {clutch.aws.kinesis.v1.IStream=} [properties] Properties to set
                     */
                    function Stream(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Stream streamName.
                     * @member {string} streamName
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @instance
                     */
                    Stream.prototype.streamName = "";

                    /**
                     * Stream region.
                     * @member {string} region
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @instance
                     */
                    Stream.prototype.region = "";

                    /**
                     * Stream currentShardCount.
                     * @member {number} currentShardCount
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @instance
                     */
                    Stream.prototype.currentShardCount = 0;

                    /**
                     * Verifies a Stream message.
                     * @function verify
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Stream.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.streamName != null && message.hasOwnProperty("streamName"))
                            if (!$util.isString(message.streamName))
                                return "streamName: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        if (message.currentShardCount != null && message.hasOwnProperty("currentShardCount"))
                            if (!$util.isInteger(message.currentShardCount))
                                return "currentShardCount: integer expected";
                        return null;
                    };

                    /**
                     * Creates a Stream message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.aws.kinesis.v1.Stream} Stream
                     */
                    Stream.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.aws.kinesis.v1.Stream)
                            return object;
                        let message = new $root.clutch.aws.kinesis.v1.Stream();
                        if (object.streamName != null)
                            message.streamName = String(object.streamName);
                        if (object.region != null)
                            message.region = String(object.region);
                        if (object.currentShardCount != null)
                            message.currentShardCount = object.currentShardCount >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a Stream message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @static
                     * @param {clutch.aws.kinesis.v1.Stream} message Stream
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Stream.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.streamName = "";
                            object.region = "";
                            object.currentShardCount = 0;
                        }
                        if (message.streamName != null && message.hasOwnProperty("streamName"))
                            object.streamName = message.streamName;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        if (message.currentShardCount != null && message.hasOwnProperty("currentShardCount"))
                            object.currentShardCount = message.currentShardCount;
                        return object;
                    };

                    /**
                     * Converts this Stream to JSON.
                     * @function toJSON
                     * @memberof clutch.aws.kinesis.v1.Stream
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Stream.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Stream;
                })();

                return v1;
            })();

            return kinesis;
        })();

        return aws;
    })();

    clutch.chaos = (function() {

        /**
         * Namespace chaos.
         * @memberof clutch
         * @namespace
         */
        const chaos = {};

        chaos.experimentation = (function() {

            /**
             * Namespace experimentation.
             * @memberof clutch.chaos
             * @namespace
             */
            const experimentation = {};

            experimentation.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.chaos.experimentation
                 * @namespace
                 */
                const v1 = {};

                v1.Experiment = (function() {

                    /**
                     * Properties of an Experiment.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IExperiment
                     * @property {number|Long|null} [id] Experiment id
                     * @property {google.protobuf.IAny|null} [config] Experiment config
                     */

                    /**
                     * Constructs a new Experiment.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents an Experiment.
                     * @implements IExperiment
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IExperiment=} [properties] Properties to set
                     */
                    function Experiment(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Experiment id.
                     * @member {number|Long} id
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @instance
                     */
                    Experiment.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Experiment config.
                     * @member {google.protobuf.IAny|null|undefined} config
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @instance
                     */
                    Experiment.prototype.config = null;

                    /**
                     * Verifies an Experiment message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Experiment.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                                return "id: integer|Long expected";
                        if (message.config != null && message.hasOwnProperty("config")) {
                            let error = $root.google.protobuf.Any.verify(message.config);
                            if (error)
                                return "config." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an Experiment message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.Experiment} Experiment
                     */
                    Experiment.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.Experiment)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.Experiment();
                        if (object.id != null)
                            if ($util.Long)
                                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                            else if (typeof object.id === "string")
                                message.id = parseInt(object.id, 10);
                            else if (typeof object.id === "number")
                                message.id = object.id;
                            else if (typeof object.id === "object")
                                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
                        if (object.config != null) {
                            if (typeof object.config !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.Experiment.config: object expected");
                            message.config = $root.google.protobuf.Any.fromObject(object.config);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an Experiment message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @static
                     * @param {clutch.chaos.experimentation.v1.Experiment} message Experiment
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Experiment.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.id = options.longs === String ? "0" : 0;
                            object.config = null;
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (typeof message.id === "number")
                                object.id = options.longs === String ? String(message.id) : message.id;
                            else
                                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
                        if (message.config != null && message.hasOwnProperty("config"))
                            object.config = $root.google.protobuf.Any.toObject(message.config, options);
                        return object;
                    };

                    /**
                     * Converts this Experiment to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.Experiment
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Experiment.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Experiment;
                })();

                v1.CreateExperimentsRequest = (function() {

                    /**
                     * Properties of a CreateExperimentsRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface ICreateExperimentsRequest
                     * @property {Array.<clutch.chaos.experimentation.v1.IExperiment>|null} [experiments] CreateExperimentsRequest experiments
                     */

                    /**
                     * Constructs a new CreateExperimentsRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a CreateExperimentsRequest.
                     * @implements ICreateExperimentsRequest
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.ICreateExperimentsRequest=} [properties] Properties to set
                     */
                    function CreateExperimentsRequest(properties) {
                        this.experiments = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CreateExperimentsRequest experiments.
                     * @member {Array.<clutch.chaos.experimentation.v1.IExperiment>} experiments
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentsRequest
                     * @instance
                     */
                    CreateExperimentsRequest.prototype.experiments = $util.emptyArray;

                    /**
                     * Verifies a CreateExperimentsRequest message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentsRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateExperimentsRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.experiments != null && message.hasOwnProperty("experiments")) {
                            if (!Array.isArray(message.experiments))
                                return "experiments: array expected";
                            for (let i = 0; i < message.experiments.length; ++i) {
                                let error = $root.clutch.chaos.experimentation.v1.Experiment.verify(message.experiments[i]);
                                if (error)
                                    return "experiments." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a CreateExperimentsRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentsRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.CreateExperimentsRequest} CreateExperimentsRequest
                     */
                    CreateExperimentsRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.CreateExperimentsRequest)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.CreateExperimentsRequest();
                        if (object.experiments) {
                            if (!Array.isArray(object.experiments))
                                throw TypeError(".clutch.chaos.experimentation.v1.CreateExperimentsRequest.experiments: array expected");
                            message.experiments = [];
                            for (let i = 0; i < object.experiments.length; ++i) {
                                if (typeof object.experiments[i] !== "object")
                                    throw TypeError(".clutch.chaos.experimentation.v1.CreateExperimentsRequest.experiments: object expected");
                                message.experiments[i] = $root.clutch.chaos.experimentation.v1.Experiment.fromObject(object.experiments[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a CreateExperimentsRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentsRequest
                     * @static
                     * @param {clutch.chaos.experimentation.v1.CreateExperimentsRequest} message CreateExperimentsRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateExperimentsRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.experiments = [];
                        if (message.experiments && message.experiments.length) {
                            object.experiments = [];
                            for (let j = 0; j < message.experiments.length; ++j)
                                object.experiments[j] = $root.clutch.chaos.experimentation.v1.Experiment.toObject(message.experiments[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this CreateExperimentsRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentsRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateExperimentsRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CreateExperimentsRequest;
                })();

                v1.CreateExperimentsResponse = (function() {

                    /**
                     * Properties of a CreateExperimentsResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface ICreateExperimentsResponse
                     * @property {Array.<clutch.chaos.experimentation.v1.IExperiment>|null} [experiments] CreateExperimentsResponse experiments
                     */

                    /**
                     * Constructs a new CreateExperimentsResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a CreateExperimentsResponse.
                     * @implements ICreateExperimentsResponse
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.ICreateExperimentsResponse=} [properties] Properties to set
                     */
                    function CreateExperimentsResponse(properties) {
                        this.experiments = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CreateExperimentsResponse experiments.
                     * @member {Array.<clutch.chaos.experimentation.v1.IExperiment>} experiments
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentsResponse
                     * @instance
                     */
                    CreateExperimentsResponse.prototype.experiments = $util.emptyArray;

                    /**
                     * Verifies a CreateExperimentsResponse message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentsResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateExperimentsResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.experiments != null && message.hasOwnProperty("experiments")) {
                            if (!Array.isArray(message.experiments))
                                return "experiments: array expected";
                            for (let i = 0; i < message.experiments.length; ++i) {
                                let error = $root.clutch.chaos.experimentation.v1.Experiment.verify(message.experiments[i]);
                                if (error)
                                    return "experiments." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a CreateExperimentsResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentsResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.CreateExperimentsResponse} CreateExperimentsResponse
                     */
                    CreateExperimentsResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.CreateExperimentsResponse)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.CreateExperimentsResponse();
                        if (object.experiments) {
                            if (!Array.isArray(object.experiments))
                                throw TypeError(".clutch.chaos.experimentation.v1.CreateExperimentsResponse.experiments: array expected");
                            message.experiments = [];
                            for (let i = 0; i < object.experiments.length; ++i) {
                                if (typeof object.experiments[i] !== "object")
                                    throw TypeError(".clutch.chaos.experimentation.v1.CreateExperimentsResponse.experiments: object expected");
                                message.experiments[i] = $root.clutch.chaos.experimentation.v1.Experiment.fromObject(object.experiments[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a CreateExperimentsResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentsResponse
                     * @static
                     * @param {clutch.chaos.experimentation.v1.CreateExperimentsResponse} message CreateExperimentsResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateExperimentsResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.experiments = [];
                        if (message.experiments && message.experiments.length) {
                            object.experiments = [];
                            for (let j = 0; j < message.experiments.length; ++j)
                                object.experiments[j] = $root.clutch.chaos.experimentation.v1.Experiment.toObject(message.experiments[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this CreateExperimentsResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.CreateExperimentsResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateExperimentsResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CreateExperimentsResponse;
                })();

                v1.GetExperimentsRequest = (function() {

                    /**
                     * Properties of a GetExperimentsRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IGetExperimentsRequest
                     * @property {Array.<number|Long>|null} [ids] GetExperimentsRequest ids
                     */

                    /**
                     * Constructs a new GetExperimentsRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a GetExperimentsRequest.
                     * @implements IGetExperimentsRequest
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentsRequest=} [properties] Properties to set
                     */
                    function GetExperimentsRequest(properties) {
                        this.ids = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetExperimentsRequest ids.
                     * @member {Array.<number|Long>} ids
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsRequest
                     * @instance
                     */
                    GetExperimentsRequest.prototype.ids = $util.emptyArray;

                    /**
                     * Verifies a GetExperimentsRequest message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetExperimentsRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ids != null && message.hasOwnProperty("ids")) {
                            if (!Array.isArray(message.ids))
                                return "ids: array expected";
                            for (let i = 0; i < message.ids.length; ++i)
                                if (!$util.isInteger(message.ids[i]) && !(message.ids[i] && $util.isInteger(message.ids[i].low) && $util.isInteger(message.ids[i].high)))
                                    return "ids: integer|Long[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a GetExperimentsRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.GetExperimentsRequest} GetExperimentsRequest
                     */
                    GetExperimentsRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.GetExperimentsRequest)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.GetExperimentsRequest();
                        if (object.ids) {
                            if (!Array.isArray(object.ids))
                                throw TypeError(".clutch.chaos.experimentation.v1.GetExperimentsRequest.ids: array expected");
                            message.ids = [];
                            for (let i = 0; i < object.ids.length; ++i)
                                if ($util.Long)
                                    (message.ids[i] = $util.Long.fromValue(object.ids[i])).unsigned = true;
                                else if (typeof object.ids[i] === "string")
                                    message.ids[i] = parseInt(object.ids[i], 10);
                                else if (typeof object.ids[i] === "number")
                                    message.ids[i] = object.ids[i];
                                else if (typeof object.ids[i] === "object")
                                    message.ids[i] = new $util.LongBits(object.ids[i].low >>> 0, object.ids[i].high >>> 0).toNumber(true);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetExperimentsRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsRequest
                     * @static
                     * @param {clutch.chaos.experimentation.v1.GetExperimentsRequest} message GetExperimentsRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetExperimentsRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.ids = [];
                        if (message.ids && message.ids.length) {
                            object.ids = [];
                            for (let j = 0; j < message.ids.length; ++j)
                                if (typeof message.ids[j] === "number")
                                    object.ids[j] = options.longs === String ? String(message.ids[j]) : message.ids[j];
                                else
                                    object.ids[j] = options.longs === String ? $util.Long.prototype.toString.call(message.ids[j]) : options.longs === Number ? new $util.LongBits(message.ids[j].low >>> 0, message.ids[j].high >>> 0).toNumber(true) : message.ids[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this GetExperimentsRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetExperimentsRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetExperimentsRequest;
                })();

                v1.GetExperimentsResponse = (function() {

                    /**
                     * Properties of a GetExperimentsResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IGetExperimentsResponse
                     * @property {Array.<clutch.chaos.experimentation.v1.IExperiment>|null} [experiments] GetExperimentsResponse experiments
                     */

                    /**
                     * Constructs a new GetExperimentsResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a GetExperimentsResponse.
                     * @implements IGetExperimentsResponse
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentsResponse=} [properties] Properties to set
                     */
                    function GetExperimentsResponse(properties) {
                        this.experiments = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetExperimentsResponse experiments.
                     * @member {Array.<clutch.chaos.experimentation.v1.IExperiment>} experiments
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsResponse
                     * @instance
                     */
                    GetExperimentsResponse.prototype.experiments = $util.emptyArray;

                    /**
                     * Verifies a GetExperimentsResponse message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetExperimentsResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.experiments != null && message.hasOwnProperty("experiments")) {
                            if (!Array.isArray(message.experiments))
                                return "experiments: array expected";
                            for (let i = 0; i < message.experiments.length; ++i) {
                                let error = $root.clutch.chaos.experimentation.v1.Experiment.verify(message.experiments[i]);
                                if (error)
                                    return "experiments." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a GetExperimentsResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.GetExperimentsResponse} GetExperimentsResponse
                     */
                    GetExperimentsResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.GetExperimentsResponse)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.GetExperimentsResponse();
                        if (object.experiments) {
                            if (!Array.isArray(object.experiments))
                                throw TypeError(".clutch.chaos.experimentation.v1.GetExperimentsResponse.experiments: array expected");
                            message.experiments = [];
                            for (let i = 0; i < object.experiments.length; ++i) {
                                if (typeof object.experiments[i] !== "object")
                                    throw TypeError(".clutch.chaos.experimentation.v1.GetExperimentsResponse.experiments: object expected");
                                message.experiments[i] = $root.clutch.chaos.experimentation.v1.Experiment.fromObject(object.experiments[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetExperimentsResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsResponse
                     * @static
                     * @param {clutch.chaos.experimentation.v1.GetExperimentsResponse} message GetExperimentsResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetExperimentsResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.experiments = [];
                        if (message.experiments && message.experiments.length) {
                            object.experiments = [];
                            for (let j = 0; j < message.experiments.length; ++j)
                                object.experiments[j] = $root.clutch.chaos.experimentation.v1.Experiment.toObject(message.experiments[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this GetExperimentsResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentsResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetExperimentsResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetExperimentsResponse;
                })();

                v1.GetExperimentRunConfigPairDetailsRequest = (function() {

                    /**
                     * Properties of a GetExperimentRunConfigPairDetailsRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IGetExperimentRunConfigPairDetailsRequest
                     * @property {number|Long|null} [id] GetExperimentRunConfigPairDetailsRequest id
                     */

                    /**
                     * Constructs a new GetExperimentRunConfigPairDetailsRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a GetExperimentRunConfigPairDetailsRequest.
                     * @implements IGetExperimentRunConfigPairDetailsRequest
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentRunConfigPairDetailsRequest=} [properties] Properties to set
                     */
                    function GetExperimentRunConfigPairDetailsRequest(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetExperimentRunConfigPairDetailsRequest id.
                     * @member {number|Long} id
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsRequest
                     * @instance
                     */
                    GetExperimentRunConfigPairDetailsRequest.prototype.id = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Verifies a GetExperimentRunConfigPairDetailsRequest message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetExperimentRunConfigPairDetailsRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                                return "id: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a GetExperimentRunConfigPairDetailsRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsRequest} GetExperimentRunConfigPairDetailsRequest
                     */
                    GetExperimentRunConfigPairDetailsRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsRequest)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsRequest();
                        if (object.id != null)
                            if ($util.Long)
                                (message.id = $util.Long.fromValue(object.id)).unsigned = true;
                            else if (typeof object.id === "string")
                                message.id = parseInt(object.id, 10);
                            else if (typeof object.id === "number")
                                message.id = object.id;
                            else if (typeof object.id === "object")
                                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetExperimentRunConfigPairDetailsRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsRequest
                     * @static
                     * @param {clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsRequest} message GetExperimentRunConfigPairDetailsRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetExperimentRunConfigPairDetailsRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.id = options.longs === String ? "0" : 0;
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (typeof message.id === "number")
                                object.id = options.longs === String ? String(message.id) : message.id;
                            else
                                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber(true) : message.id;
                        return object;
                    };

                    /**
                     * Converts this GetExperimentRunConfigPairDetailsRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetExperimentRunConfigPairDetailsRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetExperimentRunConfigPairDetailsRequest;
                })();

                v1.GetExperimentRunConfigPairDetailsResponse = (function() {

                    /**
                     * Properties of a GetExperimentRunConfigPairDetailsResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IGetExperimentRunConfigPairDetailsResponse
                     * @property {clutch.chaos.experimentation.v1.IExperimentRunConfigPairDetails|null} [runConfigPairDetails] GetExperimentRunConfigPairDetailsResponse runConfigPairDetails
                     */

                    /**
                     * Constructs a new GetExperimentRunConfigPairDetailsResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a GetExperimentRunConfigPairDetailsResponse.
                     * @implements IGetExperimentRunConfigPairDetailsResponse
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentRunConfigPairDetailsResponse=} [properties] Properties to set
                     */
                    function GetExperimentRunConfigPairDetailsResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GetExperimentRunConfigPairDetailsResponse runConfigPairDetails.
                     * @member {clutch.chaos.experimentation.v1.IExperimentRunConfigPairDetails|null|undefined} runConfigPairDetails
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsResponse
                     * @instance
                     */
                    GetExperimentRunConfigPairDetailsResponse.prototype.runConfigPairDetails = null;

                    /**
                     * Verifies a GetExperimentRunConfigPairDetailsResponse message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GetExperimentRunConfigPairDetailsResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.runConfigPairDetails != null && message.hasOwnProperty("runConfigPairDetails")) {
                            let error = $root.clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails.verify(message.runConfigPairDetails);
                            if (error)
                                return "runConfigPairDetails." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a GetExperimentRunConfigPairDetailsResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsResponse} GetExperimentRunConfigPairDetailsResponse
                     */
                    GetExperimentRunConfigPairDetailsResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsResponse)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsResponse();
                        if (object.runConfigPairDetails != null) {
                            if (typeof object.runConfigPairDetails !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsResponse.runConfigPairDetails: object expected");
                            message.runConfigPairDetails = $root.clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails.fromObject(object.runConfigPairDetails);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GetExperimentRunConfigPairDetailsResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsResponse
                     * @static
                     * @param {clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsResponse} message GetExperimentRunConfigPairDetailsResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GetExperimentRunConfigPairDetailsResponse.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.runConfigPairDetails = null;
                        if (message.runConfigPairDetails != null && message.hasOwnProperty("runConfigPairDetails"))
                            object.runConfigPairDetails = $root.clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails.toObject(message.runConfigPairDetails, options);
                        return object;
                    };

                    /**
                     * Converts this GetExperimentRunConfigPairDetailsResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GetExperimentRunConfigPairDetailsResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GetExperimentRunConfigPairDetailsResponse;
                })();

                v1.StopExperimentsRequest = (function() {

                    /**
                     * Properties of a StopExperimentsRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IStopExperimentsRequest
                     * @property {Array.<number|Long>|null} [ids] StopExperimentsRequest ids
                     */

                    /**
                     * Constructs a new StopExperimentsRequest.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a StopExperimentsRequest.
                     * @implements IStopExperimentsRequest
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IStopExperimentsRequest=} [properties] Properties to set
                     */
                    function StopExperimentsRequest(properties) {
                        this.ids = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * StopExperimentsRequest ids.
                     * @member {Array.<number|Long>} ids
                     * @memberof clutch.chaos.experimentation.v1.StopExperimentsRequest
                     * @instance
                     */
                    StopExperimentsRequest.prototype.ids = $util.emptyArray;

                    /**
                     * Verifies a StopExperimentsRequest message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.StopExperimentsRequest
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    StopExperimentsRequest.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ids != null && message.hasOwnProperty("ids")) {
                            if (!Array.isArray(message.ids))
                                return "ids: array expected";
                            for (let i = 0; i < message.ids.length; ++i)
                                if (!$util.isInteger(message.ids[i]) && !(message.ids[i] && $util.isInteger(message.ids[i].low) && $util.isInteger(message.ids[i].high)))
                                    return "ids: integer|Long[] expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a StopExperimentsRequest message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.StopExperimentsRequest
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.StopExperimentsRequest} StopExperimentsRequest
                     */
                    StopExperimentsRequest.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.StopExperimentsRequest)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.StopExperimentsRequest();
                        if (object.ids) {
                            if (!Array.isArray(object.ids))
                                throw TypeError(".clutch.chaos.experimentation.v1.StopExperimentsRequest.ids: array expected");
                            message.ids = [];
                            for (let i = 0; i < object.ids.length; ++i)
                                if ($util.Long)
                                    (message.ids[i] = $util.Long.fromValue(object.ids[i])).unsigned = true;
                                else if (typeof object.ids[i] === "string")
                                    message.ids[i] = parseInt(object.ids[i], 10);
                                else if (typeof object.ids[i] === "number")
                                    message.ids[i] = object.ids[i];
                                else if (typeof object.ids[i] === "object")
                                    message.ids[i] = new $util.LongBits(object.ids[i].low >>> 0, object.ids[i].high >>> 0).toNumber(true);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a StopExperimentsRequest message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.StopExperimentsRequest
                     * @static
                     * @param {clutch.chaos.experimentation.v1.StopExperimentsRequest} message StopExperimentsRequest
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    StopExperimentsRequest.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.ids = [];
                        if (message.ids && message.ids.length) {
                            object.ids = [];
                            for (let j = 0; j < message.ids.length; ++j)
                                if (typeof message.ids[j] === "number")
                                    object.ids[j] = options.longs === String ? String(message.ids[j]) : message.ids[j];
                                else
                                    object.ids[j] = options.longs === String ? $util.Long.prototype.toString.call(message.ids[j]) : options.longs === Number ? new $util.LongBits(message.ids[j].low >>> 0, message.ids[j].high >>> 0).toNumber(true) : message.ids[j];
                        }
                        return object;
                    };

                    /**
                     * Converts this StopExperimentsRequest to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.StopExperimentsRequest
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    StopExperimentsRequest.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return StopExperimentsRequest;
                })();

                v1.StopExperimentsResponse = (function() {

                    /**
                     * Properties of a StopExperimentsResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IStopExperimentsResponse
                     */

                    /**
                     * Constructs a new StopExperimentsResponse.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a StopExperimentsResponse.
                     * @implements IStopExperimentsResponse
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IStopExperimentsResponse=} [properties] Properties to set
                     */
                    function StopExperimentsResponse(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Verifies a StopExperimentsResponse message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.StopExperimentsResponse
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    StopExperimentsResponse.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        return null;
                    };

                    /**
                     * Creates a StopExperimentsResponse message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.StopExperimentsResponse
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.StopExperimentsResponse} StopExperimentsResponse
                     */
                    StopExperimentsResponse.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.StopExperimentsResponse)
                            return object;
                        return new $root.clutch.chaos.experimentation.v1.StopExperimentsResponse();
                    };

                    /**
                     * Creates a plain object from a StopExperimentsResponse message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.StopExperimentsResponse
                     * @static
                     * @param {clutch.chaos.experimentation.v1.StopExperimentsResponse} message StopExperimentsResponse
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    StopExperimentsResponse.toObject = function toObject() {
                        return {};
                    };

                    /**
                     * Converts this StopExperimentsResponse to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.StopExperimentsResponse
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    StopExperimentsResponse.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return StopExperimentsResponse;
                })();

                v1.ExperimentsAPI = (function() {

                    /**
                     * Constructs a new ExperimentsAPI service.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents an ExperimentsAPI
                     * @extends $protobuf.rpc.Service
                     * @constructor
                     * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                     * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                     * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                     */
                    function ExperimentsAPI(rpcImpl, requestDelimited, responseDelimited) {
                        $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                    }

                    (ExperimentsAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ExperimentsAPI;

                    /**
                     * Callback as used by {@link clutch.chaos.experimentation.v1.ExperimentsAPI#createExperiments}.
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @typedef CreateExperimentsCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.chaos.experimentation.v1.CreateExperimentsResponse} [response] CreateExperimentsResponse
                     */

                    /**
                     * Calls CreateExperiments.
                     * @function createExperiments
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.ICreateExperimentsRequest} request CreateExperimentsRequest message or plain object
                     * @param {clutch.chaos.experimentation.v1.ExperimentsAPI.CreateExperimentsCallback} callback Node-style callback called with the error, if any, and CreateExperimentsResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(ExperimentsAPI.prototype.createExperiments = function createExperiments(request, callback) {
                        return this.rpcCall(createExperiments, $root.clutch.chaos.experimentation.v1.CreateExperimentsRequest, $root.clutch.chaos.experimentation.v1.CreateExperimentsResponse, request, callback);
                    }, "name", { value: "CreateExperiments" });

                    /**
                     * Calls CreateExperiments.
                     * @function createExperiments
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.ICreateExperimentsRequest} request CreateExperimentsRequest message or plain object
                     * @returns {Promise<clutch.chaos.experimentation.v1.CreateExperimentsResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.chaos.experimentation.v1.ExperimentsAPI#getExperiments}.
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @typedef GetExperimentsCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.chaos.experimentation.v1.GetExperimentsResponse} [response] GetExperimentsResponse
                     */

                    /**
                     * Calls GetExperiments.
                     * @function getExperiments
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentsRequest} request GetExperimentsRequest message or plain object
                     * @param {clutch.chaos.experimentation.v1.ExperimentsAPI.GetExperimentsCallback} callback Node-style callback called with the error, if any, and GetExperimentsResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(ExperimentsAPI.prototype.getExperiments = function getExperiments(request, callback) {
                        return this.rpcCall(getExperiments, $root.clutch.chaos.experimentation.v1.GetExperimentsRequest, $root.clutch.chaos.experimentation.v1.GetExperimentsResponse, request, callback);
                    }, "name", { value: "GetExperiments" });

                    /**
                     * Calls GetExperiments.
                     * @function getExperiments
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentsRequest} request GetExperimentsRequest message or plain object
                     * @returns {Promise<clutch.chaos.experimentation.v1.GetExperimentsResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.chaos.experimentation.v1.ExperimentsAPI#getExperimentRunConfigPairDetails}.
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @typedef GetExperimentRunConfigPairDetailsCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsResponse} [response] GetExperimentRunConfigPairDetailsResponse
                     */

                    /**
                     * Calls GetExperimentRunConfigPairDetails.
                     * @function getExperimentRunConfigPairDetails
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentRunConfigPairDetailsRequest} request GetExperimentRunConfigPairDetailsRequest message or plain object
                     * @param {clutch.chaos.experimentation.v1.ExperimentsAPI.GetExperimentRunConfigPairDetailsCallback} callback Node-style callback called with the error, if any, and GetExperimentRunConfigPairDetailsResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(ExperimentsAPI.prototype.getExperimentRunConfigPairDetails = function getExperimentRunConfigPairDetails(request, callback) {
                        return this.rpcCall(getExperimentRunConfigPairDetails, $root.clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsRequest, $root.clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsResponse, request, callback);
                    }, "name", { value: "GetExperimentRunConfigPairDetails" });

                    /**
                     * Calls GetExperimentRunConfigPairDetails.
                     * @function getExperimentRunConfigPairDetails
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.IGetExperimentRunConfigPairDetailsRequest} request GetExperimentRunConfigPairDetailsRequest message or plain object
                     * @returns {Promise<clutch.chaos.experimentation.v1.GetExperimentRunConfigPairDetailsResponse>} Promise
                     * @variation 2
                     */

                    /**
                     * Callback as used by {@link clutch.chaos.experimentation.v1.ExperimentsAPI#stopExperiments}.
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @typedef StopExperimentsCallback
                     * @type {function}
                     * @param {Error|null} error Error, if any
                     * @param {clutch.chaos.experimentation.v1.StopExperimentsResponse} [response] StopExperimentsResponse
                     */

                    /**
                     * Calls StopExperiments.
                     * @function stopExperiments
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.IStopExperimentsRequest} request StopExperimentsRequest message or plain object
                     * @param {clutch.chaos.experimentation.v1.ExperimentsAPI.StopExperimentsCallback} callback Node-style callback called with the error, if any, and StopExperimentsResponse
                     * @returns {undefined}
                     * @variation 1
                     */
                    Object.defineProperty(ExperimentsAPI.prototype.stopExperiments = function stopExperiments(request, callback) {
                        return this.rpcCall(stopExperiments, $root.clutch.chaos.experimentation.v1.StopExperimentsRequest, $root.clutch.chaos.experimentation.v1.StopExperimentsResponse, request, callback);
                    }, "name", { value: "StopExperiments" });

                    /**
                     * Calls StopExperiments.
                     * @function stopExperiments
                     * @memberof clutch.chaos.experimentation.v1.ExperimentsAPI
                     * @instance
                     * @param {clutch.chaos.experimentation.v1.IStopExperimentsRequest} request StopExperimentsRequest message or plain object
                     * @returns {Promise<clutch.chaos.experimentation.v1.StopExperimentsResponse>} Promise
                     * @variation 2
                     */

                    return ExperimentsAPI;
                })();

                v1.ExperimentRunConfigPairDetails = (function() {

                    /**
                     * Properties of an ExperimentRunConfigPairDetails.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IExperimentRunConfigPairDetails
                     * @property {number|Long|null} [runId] ExperimentRunConfigPairDetails runId
                     * @property {clutch.chaos.experimentation.v1.Status|null} [status] ExperimentRunConfigPairDetails status
                     * @property {clutch.chaos.experimentation.v1.IForm|null} [form] ExperimentRunConfigPairDetails form
                     * @property {google.protobuf.IAny|null} [config] ExperimentRunConfigPairDetails config
                     */

                    /**
                     * Constructs a new ExperimentRunConfigPairDetails.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents an ExperimentRunConfigPairDetails.
                     * @implements IExperimentRunConfigPairDetails
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IExperimentRunConfigPairDetails=} [properties] Properties to set
                     */
                    function ExperimentRunConfigPairDetails(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ExperimentRunConfigPairDetails runId.
                     * @member {number|Long} runId
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails
                     * @instance
                     */
                    ExperimentRunConfigPairDetails.prototype.runId = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * ExperimentRunConfigPairDetails status.
                     * @member {clutch.chaos.experimentation.v1.Status} status
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails
                     * @instance
                     */
                    ExperimentRunConfigPairDetails.prototype.status = 0;

                    /**
                     * ExperimentRunConfigPairDetails form.
                     * @member {clutch.chaos.experimentation.v1.IForm|null|undefined} form
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails
                     * @instance
                     */
                    ExperimentRunConfigPairDetails.prototype.form = null;

                    /**
                     * ExperimentRunConfigPairDetails config.
                     * @member {google.protobuf.IAny|null|undefined} config
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails
                     * @instance
                     */
                    ExperimentRunConfigPairDetails.prototype.config = null;

                    /**
                     * Verifies an ExperimentRunConfigPairDetails message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ExperimentRunConfigPairDetails.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.runId != null && message.hasOwnProperty("runId"))
                            if (!$util.isInteger(message.runId) && !(message.runId && $util.isInteger(message.runId.low) && $util.isInteger(message.runId.high)))
                                return "runId: integer|Long expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                                break;
                            }
                        if (message.form != null && message.hasOwnProperty("form")) {
                            let error = $root.clutch.chaos.experimentation.v1.Form.verify(message.form);
                            if (error)
                                return "form." + error;
                        }
                        if (message.config != null && message.hasOwnProperty("config")) {
                            let error = $root.google.protobuf.Any.verify(message.config);
                            if (error)
                                return "config." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an ExperimentRunConfigPairDetails message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails} ExperimentRunConfigPairDetails
                     */
                    ExperimentRunConfigPairDetails.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails();
                        if (object.runId != null)
                            if ($util.Long)
                                (message.runId = $util.Long.fromValue(object.runId)).unsigned = false;
                            else if (typeof object.runId === "string")
                                message.runId = parseInt(object.runId, 10);
                            else if (typeof object.runId === "number")
                                message.runId = object.runId;
                            else if (typeof object.runId === "object")
                                message.runId = new $util.LongBits(object.runId.low >>> 0, object.runId.high >>> 0).toNumber();
                        switch (object.status) {
                        case "UNKNOWN":
                        case 0:
                            message.status = 0;
                            break;
                        case "SCHEDULED":
                        case 1:
                            message.status = 1;
                            break;
                        case "RUNNING":
                        case 2:
                            message.status = 2;
                            break;
                        case "COMPLETED":
                        case 3:
                            message.status = 3;
                            break;
                        }
                        if (object.form != null) {
                            if (typeof object.form !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails.form: object expected");
                            message.form = $root.clutch.chaos.experimentation.v1.Form.fromObject(object.form);
                        }
                        if (object.config != null) {
                            if (typeof object.config !== "object")
                                throw TypeError(".clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails.config: object expected");
                            message.config = $root.google.protobuf.Any.fromObject(object.config);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an ExperimentRunConfigPairDetails message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails
                     * @static
                     * @param {clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails} message ExperimentRunConfigPairDetails
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ExperimentRunConfigPairDetails.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.runId = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.runId = options.longs === String ? "0" : 0;
                            object.status = options.enums === String ? "UNKNOWN" : 0;
                            object.form = null;
                            object.config = null;
                        }
                        if (message.runId != null && message.hasOwnProperty("runId"))
                            if (typeof message.runId === "number")
                                object.runId = options.longs === String ? String(message.runId) : message.runId;
                            else
                                object.runId = options.longs === String ? $util.Long.prototype.toString.call(message.runId) : options.longs === Number ? new $util.LongBits(message.runId.low >>> 0, message.runId.high >>> 0).toNumber() : message.runId;
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.clutch.chaos.experimentation.v1.Status[message.status] : message.status;
                        if (message.form != null && message.hasOwnProperty("form"))
                            object.form = $root.clutch.chaos.experimentation.v1.Form.toObject(message.form, options);
                        if (message.config != null && message.hasOwnProperty("config"))
                            object.config = $root.google.protobuf.Any.toObject(message.config, options);
                        return object;
                    };

                    /**
                     * Converts this ExperimentRunConfigPairDetails to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.ExperimentRunConfigPairDetails
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ExperimentRunConfigPairDetails.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ExperimentRunConfigPairDetails;
                })();

                /**
                 * Status enum.
                 * @name clutch.chaos.experimentation.v1.Status
                 * @enum {number}
                 * @property {number} UNKNOWN=0 UNKNOWN value
                 * @property {number} SCHEDULED=1 SCHEDULED value
                 * @property {number} RUNNING=2 RUNNING value
                 * @property {number} COMPLETED=3 COMPLETED value
                 */
                v1.Status = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNKNOWN"] = 0;
                    values[valuesById[1] = "SCHEDULED"] = 1;
                    values[valuesById[2] = "RUNNING"] = 2;
                    values[valuesById[3] = "COMPLETED"] = 3;
                    return values;
                })();

                v1.Form = (function() {

                    /**
                     * Properties of a Form.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IForm
                     * @property {Array.<clutch.chaos.experimentation.v1.ITextField>|null} [fields] Form fields
                     */

                    /**
                     * Constructs a new Form.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a Form.
                     * @implements IForm
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IForm=} [properties] Properties to set
                     */
                    function Form(properties) {
                        this.fields = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Form fields.
                     * @member {Array.<clutch.chaos.experimentation.v1.ITextField>} fields
                     * @memberof clutch.chaos.experimentation.v1.Form
                     * @instance
                     */
                    Form.prototype.fields = $util.emptyArray;

                    /**
                     * Verifies a Form message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.Form
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Form.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.fields != null && message.hasOwnProperty("fields")) {
                            if (!Array.isArray(message.fields))
                                return "fields: array expected";
                            for (let i = 0; i < message.fields.length; ++i) {
                                let error = $root.clutch.chaos.experimentation.v1.TextField.verify(message.fields[i]);
                                if (error)
                                    return "fields." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Form message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.Form
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.Form} Form
                     */
                    Form.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.Form)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.Form();
                        if (object.fields) {
                            if (!Array.isArray(object.fields))
                                throw TypeError(".clutch.chaos.experimentation.v1.Form.fields: array expected");
                            message.fields = [];
                            for (let i = 0; i < object.fields.length; ++i) {
                                if (typeof object.fields[i] !== "object")
                                    throw TypeError(".clutch.chaos.experimentation.v1.Form.fields: object expected");
                                message.fields[i] = $root.clutch.chaos.experimentation.v1.TextField.fromObject(object.fields[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Form message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.Form
                     * @static
                     * @param {clutch.chaos.experimentation.v1.Form} message Form
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Form.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.fields = [];
                        if (message.fields && message.fields.length) {
                            object.fields = [];
                            for (let j = 0; j < message.fields.length; ++j)
                                object.fields[j] = $root.clutch.chaos.experimentation.v1.TextField.toObject(message.fields[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Form to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.Form
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Form.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Form;
                })();

                v1.TextField = (function() {

                    /**
                     * Properties of a TextField.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface ITextField
                     * @property {string|null} [label] TextField label
                     * @property {string|null} [value] TextField value
                     */

                    /**
                     * Constructs a new TextField.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents a TextField.
                     * @implements ITextField
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.ITextField=} [properties] Properties to set
                     */
                    function TextField(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TextField label.
                     * @member {string} label
                     * @memberof clutch.chaos.experimentation.v1.TextField
                     * @instance
                     */
                    TextField.prototype.label = "";

                    /**
                     * TextField value.
                     * @member {string} value
                     * @memberof clutch.chaos.experimentation.v1.TextField
                     * @instance
                     */
                    TextField.prototype.value = "";

                    /**
                     * Verifies a TextField message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.TextField
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TextField.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.label != null && message.hasOwnProperty("label"))
                            if (!$util.isString(message.label))
                                return "label: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isString(message.value))
                                return "value: string expected";
                        return null;
                    };

                    /**
                     * Creates a TextField message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.TextField
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.TextField} TextField
                     */
                    TextField.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.TextField)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.TextField();
                        if (object.label != null)
                            message.label = String(object.label);
                        if (object.value != null)
                            message.value = String(object.value);
                        return message;
                    };

                    /**
                     * Creates a plain object from a TextField message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.TextField
                     * @static
                     * @param {clutch.chaos.experimentation.v1.TextField} message TextField
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TextField.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.label = "";
                            object.value = "";
                        }
                        if (message.label != null && message.hasOwnProperty("label"))
                            object.label = message.label;
                        if (message.value != null && message.hasOwnProperty("value"))
                            object.value = message.value;
                        return object;
                    };

                    /**
                     * Converts this TextField to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.TextField
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TextField.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return TextField;
                })();

                v1.ExperimentConfig = (function() {

                    /**
                     * Properties of an ExperimentConfig.
                     * @memberof clutch.chaos.experimentation.v1
                     * @interface IExperimentConfig
                     * @property {number|Long|null} [id] ExperimentConfig id
                     */

                    /**
                     * Constructs a new ExperimentConfig.
                     * @memberof clutch.chaos.experimentation.v1
                     * @classdesc Represents an ExperimentConfig.
                     * @implements IExperimentConfig
                     * @constructor
                     * @param {clutch.chaos.experimentation.v1.IExperimentConfig=} [properties] Properties to set
                     */
                    function ExperimentConfig(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ExperimentConfig id.
                     * @member {number|Long} id
                     * @memberof clutch.chaos.experimentation.v1.ExperimentConfig
                     * @instance
                     */
                    ExperimentConfig.prototype.id = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

                    /**
                     * Verifies an ExperimentConfig message.
                     * @function verify
                     * @memberof clutch.chaos.experimentation.v1.ExperimentConfig
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ExperimentConfig.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isInteger(message.id) && !(message.id && $util.isInteger(message.id.low) && $util.isInteger(message.id.high)))
                                return "id: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates an ExperimentConfig message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.experimentation.v1.ExperimentConfig
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.experimentation.v1.ExperimentConfig} ExperimentConfig
                     */
                    ExperimentConfig.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.experimentation.v1.ExperimentConfig)
                            return object;
                        let message = new $root.clutch.chaos.experimentation.v1.ExperimentConfig();
                        if (object.id != null)
                            if ($util.Long)
                                (message.id = $util.Long.fromValue(object.id)).unsigned = false;
                            else if (typeof object.id === "string")
                                message.id = parseInt(object.id, 10);
                            else if (typeof object.id === "number")
                                message.id = object.id;
                            else if (typeof object.id === "object")
                                message.id = new $util.LongBits(object.id.low >>> 0, object.id.high >>> 0).toNumber();
                        return message;
                    };

                    /**
                     * Creates a plain object from an ExperimentConfig message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.experimentation.v1.ExperimentConfig
                     * @static
                     * @param {clutch.chaos.experimentation.v1.ExperimentConfig} message ExperimentConfig
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ExperimentConfig.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, false);
                                object.id = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.id = options.longs === String ? "0" : 0;
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (typeof message.id === "number")
                                object.id = options.longs === String ? String(message.id) : message.id;
                            else
                                object.id = options.longs === String ? $util.Long.prototype.toString.call(message.id) : options.longs === Number ? new $util.LongBits(message.id.low >>> 0, message.id.high >>> 0).toNumber() : message.id;
                        return object;
                    };

                    /**
                     * Converts this ExperimentConfig to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.experimentation.v1.ExperimentConfig
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ExperimentConfig.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ExperimentConfig;
                })();

                return v1;
            })();

            return experimentation;
        })();

        chaos.serverexperimentation = (function() {

            /**
             * Namespace serverexperimentation.
             * @memberof clutch.chaos
             * @namespace
             */
            const serverexperimentation = {};

            serverexperimentation.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.chaos.serverexperimentation
                 * @namespace
                 */
                const v1 = {};

                v1.TestConfig = (function() {

                    /**
                     * Properties of a TestConfig.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface ITestConfig
                     * @property {clutch.chaos.serverexperimentation.v1.IClusterPairTarget|null} [clusterPair] TestConfig clusterPair
                     * @property {clutch.chaos.serverexperimentation.v1.IAbortFaultConfig|null} [abort] TestConfig abort
                     * @property {clutch.chaos.serverexperimentation.v1.ILatencyFaultConfig|null} [latency] TestConfig latency
                     */

                    /**
                     * Constructs a new TestConfig.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents a TestConfig.
                     * @implements ITestConfig
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.ITestConfig=} [properties] Properties to set
                     */
                    function TestConfig(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TestConfig clusterPair.
                     * @member {clutch.chaos.serverexperimentation.v1.IClusterPairTarget|null|undefined} clusterPair
                     * @memberof clutch.chaos.serverexperimentation.v1.TestConfig
                     * @instance
                     */
                    TestConfig.prototype.clusterPair = null;

                    /**
                     * TestConfig abort.
                     * @member {clutch.chaos.serverexperimentation.v1.IAbortFaultConfig|null|undefined} abort
                     * @memberof clutch.chaos.serverexperimentation.v1.TestConfig
                     * @instance
                     */
                    TestConfig.prototype.abort = null;

                    /**
                     * TestConfig latency.
                     * @member {clutch.chaos.serverexperimentation.v1.ILatencyFaultConfig|null|undefined} latency
                     * @memberof clutch.chaos.serverexperimentation.v1.TestConfig
                     * @instance
                     */
                    TestConfig.prototype.latency = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * TestConfig target.
                     * @member {"clusterPair"|undefined} target
                     * @memberof clutch.chaos.serverexperimentation.v1.TestConfig
                     * @instance
                     */
                    Object.defineProperty(TestConfig.prototype, "target", {
                        get: $util.oneOfGetter($oneOfFields = ["clusterPair"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * TestConfig fault.
                     * @member {"abort"|"latency"|undefined} fault
                     * @memberof clutch.chaos.serverexperimentation.v1.TestConfig
                     * @instance
                     */
                    Object.defineProperty(TestConfig.prototype, "fault", {
                        get: $util.oneOfGetter($oneOfFields = ["abort", "latency"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies a TestConfig message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.TestConfig
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TestConfig.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.clusterPair != null && message.hasOwnProperty("clusterPair")) {
                            properties.target = 1;
                            {
                                let error = $root.clutch.chaos.serverexperimentation.v1.ClusterPairTarget.verify(message.clusterPair);
                                if (error)
                                    return "clusterPair." + error;
                            }
                        }
                        if (message.abort != null && message.hasOwnProperty("abort")) {
                            properties.fault = 1;
                            {
                                let error = $root.clutch.chaos.serverexperimentation.v1.AbortFaultConfig.verify(message.abort);
                                if (error)
                                    return "abort." + error;
                            }
                        }
                        if (message.latency != null && message.hasOwnProperty("latency")) {
                            if (properties.fault === 1)
                                return "fault: multiple values";
                            properties.fault = 1;
                            {
                                let error = $root.clutch.chaos.serverexperimentation.v1.LatencyFaultConfig.verify(message.latency);
                                if (error)
                                    return "latency." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a TestConfig message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.TestConfig
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.TestConfig} TestConfig
                     */
                    TestConfig.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.TestConfig)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.TestConfig();
                        if (object.clusterPair != null) {
                            if (typeof object.clusterPair !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.TestConfig.clusterPair: object expected");
                            message.clusterPair = $root.clutch.chaos.serverexperimentation.v1.ClusterPairTarget.fromObject(object.clusterPair);
                        }
                        if (object.abort != null) {
                            if (typeof object.abort !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.TestConfig.abort: object expected");
                            message.abort = $root.clutch.chaos.serverexperimentation.v1.AbortFaultConfig.fromObject(object.abort);
                        }
                        if (object.latency != null) {
                            if (typeof object.latency !== "object")
                                throw TypeError(".clutch.chaos.serverexperimentation.v1.TestConfig.latency: object expected");
                            message.latency = $root.clutch.chaos.serverexperimentation.v1.LatencyFaultConfig.fromObject(object.latency);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a TestConfig message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.TestConfig
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.TestConfig} message TestConfig
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TestConfig.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (message.clusterPair != null && message.hasOwnProperty("clusterPair")) {
                            object.clusterPair = $root.clutch.chaos.serverexperimentation.v1.ClusterPairTarget.toObject(message.clusterPair, options);
                            if (options.oneofs)
                                object.target = "clusterPair";
                        }
                        if (message.abort != null && message.hasOwnProperty("abort")) {
                            object.abort = $root.clutch.chaos.serverexperimentation.v1.AbortFaultConfig.toObject(message.abort, options);
                            if (options.oneofs)
                                object.fault = "abort";
                        }
                        if (message.latency != null && message.hasOwnProperty("latency")) {
                            object.latency = $root.clutch.chaos.serverexperimentation.v1.LatencyFaultConfig.toObject(message.latency, options);
                            if (options.oneofs)
                                object.fault = "latency";
                        }
                        return object;
                    };

                    /**
                     * Converts this TestConfig to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.TestConfig
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TestConfig.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return TestConfig;
                })();

                v1.ClusterPairTarget = (function() {

                    /**
                     * Properties of a ClusterPairTarget.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface IClusterPairTarget
                     * @property {string|null} [downstreamCluster] ClusterPairTarget downstreamCluster
                     * @property {string|null} [upstreamCluster] ClusterPairTarget upstreamCluster
                     */

                    /**
                     * Constructs a new ClusterPairTarget.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents a ClusterPairTarget.
                     * @implements IClusterPairTarget
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.IClusterPairTarget=} [properties] Properties to set
                     */
                    function ClusterPairTarget(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * ClusterPairTarget downstreamCluster.
                     * @member {string} downstreamCluster
                     * @memberof clutch.chaos.serverexperimentation.v1.ClusterPairTarget
                     * @instance
                     */
                    ClusterPairTarget.prototype.downstreamCluster = "";

                    /**
                     * ClusterPairTarget upstreamCluster.
                     * @member {string} upstreamCluster
                     * @memberof clutch.chaos.serverexperimentation.v1.ClusterPairTarget
                     * @instance
                     */
                    ClusterPairTarget.prototype.upstreamCluster = "";

                    /**
                     * Verifies a ClusterPairTarget message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.ClusterPairTarget
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    ClusterPairTarget.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.downstreamCluster != null && message.hasOwnProperty("downstreamCluster"))
                            if (!$util.isString(message.downstreamCluster))
                                return "downstreamCluster: string expected";
                        if (message.upstreamCluster != null && message.hasOwnProperty("upstreamCluster"))
                            if (!$util.isString(message.upstreamCluster))
                                return "upstreamCluster: string expected";
                        return null;
                    };

                    /**
                     * Creates a ClusterPairTarget message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.ClusterPairTarget
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.ClusterPairTarget} ClusterPairTarget
                     */
                    ClusterPairTarget.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.ClusterPairTarget)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.ClusterPairTarget();
                        if (object.downstreamCluster != null)
                            message.downstreamCluster = String(object.downstreamCluster);
                        if (object.upstreamCluster != null)
                            message.upstreamCluster = String(object.upstreamCluster);
                        return message;
                    };

                    /**
                     * Creates a plain object from a ClusterPairTarget message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.ClusterPairTarget
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.ClusterPairTarget} message ClusterPairTarget
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    ClusterPairTarget.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.downstreamCluster = "";
                            object.upstreamCluster = "";
                        }
                        if (message.downstreamCluster != null && message.hasOwnProperty("downstreamCluster"))
                            object.downstreamCluster = message.downstreamCluster;
                        if (message.upstreamCluster != null && message.hasOwnProperty("upstreamCluster"))
                            object.upstreamCluster = message.upstreamCluster;
                        return object;
                    };

                    /**
                     * Converts this ClusterPairTarget to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.ClusterPairTarget
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    ClusterPairTarget.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return ClusterPairTarget;
                })();

                v1.AbortFaultConfig = (function() {

                    /**
                     * Properties of an AbortFaultConfig.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface IAbortFaultConfig
                     * @property {number|null} [percent] AbortFaultConfig percent
                     * @property {number|null} [httpStatus] AbortFaultConfig httpStatus
                     */

                    /**
                     * Constructs a new AbortFaultConfig.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents an AbortFaultConfig.
                     * @implements IAbortFaultConfig
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.IAbortFaultConfig=} [properties] Properties to set
                     */
                    function AbortFaultConfig(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * AbortFaultConfig percent.
                     * @member {number} percent
                     * @memberof clutch.chaos.serverexperimentation.v1.AbortFaultConfig
                     * @instance
                     */
                    AbortFaultConfig.prototype.percent = 0;

                    /**
                     * AbortFaultConfig httpStatus.
                     * @member {number} httpStatus
                     * @memberof clutch.chaos.serverexperimentation.v1.AbortFaultConfig
                     * @instance
                     */
                    AbortFaultConfig.prototype.httpStatus = 0;

                    /**
                     * Verifies an AbortFaultConfig message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.AbortFaultConfig
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AbortFaultConfig.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.percent != null && message.hasOwnProperty("percent"))
                            if (typeof message.percent !== "number")
                                return "percent: number expected";
                        if (message.httpStatus != null && message.hasOwnProperty("httpStatus"))
                            if (!$util.isInteger(message.httpStatus))
                                return "httpStatus: integer expected";
                        return null;
                    };

                    /**
                     * Creates an AbortFaultConfig message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.AbortFaultConfig
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.AbortFaultConfig} AbortFaultConfig
                     */
                    AbortFaultConfig.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.AbortFaultConfig)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.AbortFaultConfig();
                        if (object.percent != null)
                            message.percent = Number(object.percent);
                        if (object.httpStatus != null)
                            message.httpStatus = object.httpStatus | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from an AbortFaultConfig message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.AbortFaultConfig
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.AbortFaultConfig} message AbortFaultConfig
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AbortFaultConfig.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.percent = 0;
                            object.httpStatus = 0;
                        }
                        if (message.percent != null && message.hasOwnProperty("percent"))
                            object.percent = options.json && !isFinite(message.percent) ? String(message.percent) : message.percent;
                        if (message.httpStatus != null && message.hasOwnProperty("httpStatus"))
                            object.httpStatus = message.httpStatus;
                        return object;
                    };

                    /**
                     * Converts this AbortFaultConfig to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.AbortFaultConfig
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AbortFaultConfig.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return AbortFaultConfig;
                })();

                v1.LatencyFaultConfig = (function() {

                    /**
                     * Properties of a LatencyFaultConfig.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @interface ILatencyFaultConfig
                     * @property {number|null} [percent] LatencyFaultConfig percent
                     * @property {number|null} [durationMs] LatencyFaultConfig durationMs
                     */

                    /**
                     * Constructs a new LatencyFaultConfig.
                     * @memberof clutch.chaos.serverexperimentation.v1
                     * @classdesc Represents a LatencyFaultConfig.
                     * @implements ILatencyFaultConfig
                     * @constructor
                     * @param {clutch.chaos.serverexperimentation.v1.ILatencyFaultConfig=} [properties] Properties to set
                     */
                    function LatencyFaultConfig(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * LatencyFaultConfig percent.
                     * @member {number} percent
                     * @memberof clutch.chaos.serverexperimentation.v1.LatencyFaultConfig
                     * @instance
                     */
                    LatencyFaultConfig.prototype.percent = 0;

                    /**
                     * LatencyFaultConfig durationMs.
                     * @member {number} durationMs
                     * @memberof clutch.chaos.serverexperimentation.v1.LatencyFaultConfig
                     * @instance
                     */
                    LatencyFaultConfig.prototype.durationMs = 0;

                    /**
                     * Verifies a LatencyFaultConfig message.
                     * @function verify
                     * @memberof clutch.chaos.serverexperimentation.v1.LatencyFaultConfig
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    LatencyFaultConfig.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.percent != null && message.hasOwnProperty("percent"))
                            if (typeof message.percent !== "number")
                                return "percent: number expected";
                        if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                            if (!$util.isInteger(message.durationMs))
                                return "durationMs: integer expected";
                        return null;
                    };

                    /**
                     * Creates a LatencyFaultConfig message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.chaos.serverexperimentation.v1.LatencyFaultConfig
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.chaos.serverexperimentation.v1.LatencyFaultConfig} LatencyFaultConfig
                     */
                    LatencyFaultConfig.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.chaos.serverexperimentation.v1.LatencyFaultConfig)
                            return object;
                        let message = new $root.clutch.chaos.serverexperimentation.v1.LatencyFaultConfig();
                        if (object.percent != null)
                            message.percent = Number(object.percent);
                        if (object.durationMs != null)
                            message.durationMs = object.durationMs | 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a LatencyFaultConfig message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.chaos.serverexperimentation.v1.LatencyFaultConfig
                     * @static
                     * @param {clutch.chaos.serverexperimentation.v1.LatencyFaultConfig} message LatencyFaultConfig
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    LatencyFaultConfig.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.percent = 0;
                            object.durationMs = 0;
                        }
                        if (message.percent != null && message.hasOwnProperty("percent"))
                            object.percent = options.json && !isFinite(message.percent) ? String(message.percent) : message.percent;
                        if (message.durationMs != null && message.hasOwnProperty("durationMs"))
                            object.durationMs = message.durationMs;
                        return object;
                    };

                    /**
                     * Converts this LatencyFaultConfig to JSON.
                     * @function toJSON
                     * @memberof clutch.chaos.serverexperimentation.v1.LatencyFaultConfig
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    LatencyFaultConfig.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return LatencyFaultConfig;
                })();

                return v1;
            })();

            return serverexperimentation;
        })();

        return chaos;
    })();

    clutch.config = (function() {

        /**
         * Namespace config.
         * @memberof clutch
         * @namespace
         */
        const config = {};

        config.gateway = (function() {

            /**
             * Namespace gateway.
             * @memberof clutch.config
             * @namespace
             */
            const gateway = {};

            gateway.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.config.gateway
                 * @namespace
                 */
                const v1 = {};

                v1.Config = (function() {

                    /**
                     * Properties of a Config.
                     * @memberof clutch.config.gateway.v1
                     * @interface IConfig
                     * @property {clutch.config.gateway.v1.IGatewayOptions|null} [gateway] Config gateway
                     * @property {Array.<clutch.config.gateway.v1.IService>|null} [services] Config services
                     * @property {Array.<clutch.config.gateway.v1.IResolver>|null} [resolvers] Config resolvers
                     * @property {Array.<clutch.config.gateway.v1.IModule>|null} [modules] Config modules
                     */

                    /**
                     * Constructs a new Config.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Config.
                     * @implements IConfig
                     * @constructor
                     * @param {clutch.config.gateway.v1.IConfig=} [properties] Properties to set
                     */
                    function Config(properties) {
                        this.services = [];
                        this.resolvers = [];
                        this.modules = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Config gateway.
                     * @member {clutch.config.gateway.v1.IGatewayOptions|null|undefined} gateway
                     * @memberof clutch.config.gateway.v1.Config
                     * @instance
                     */
                    Config.prototype.gateway = null;

                    /**
                     * Config services.
                     * @member {Array.<clutch.config.gateway.v1.IService>} services
                     * @memberof clutch.config.gateway.v1.Config
                     * @instance
                     */
                    Config.prototype.services = $util.emptyArray;

                    /**
                     * Config resolvers.
                     * @member {Array.<clutch.config.gateway.v1.IResolver>} resolvers
                     * @memberof clutch.config.gateway.v1.Config
                     * @instance
                     */
                    Config.prototype.resolvers = $util.emptyArray;

                    /**
                     * Config modules.
                     * @member {Array.<clutch.config.gateway.v1.IModule>} modules
                     * @memberof clutch.config.gateway.v1.Config
                     * @instance
                     */
                    Config.prototype.modules = $util.emptyArray;

                    /**
                     * Verifies a Config message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Config
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Config.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.gateway != null && message.hasOwnProperty("gateway")) {
                            let error = $root.clutch.config.gateway.v1.GatewayOptions.verify(message.gateway);
                            if (error)
                                return "gateway." + error;
                        }
                        if (message.services != null && message.hasOwnProperty("services")) {
                            if (!Array.isArray(message.services))
                                return "services: array expected";
                            for (let i = 0; i < message.services.length; ++i) {
                                let error = $root.clutch.config.gateway.v1.Service.verify(message.services[i]);
                                if (error)
                                    return "services." + error;
                            }
                        }
                        if (message.resolvers != null && message.hasOwnProperty("resolvers")) {
                            if (!Array.isArray(message.resolvers))
                                return "resolvers: array expected";
                            for (let i = 0; i < message.resolvers.length; ++i) {
                                let error = $root.clutch.config.gateway.v1.Resolver.verify(message.resolvers[i]);
                                if (error)
                                    return "resolvers." + error;
                            }
                        }
                        if (message.modules != null && message.hasOwnProperty("modules")) {
                            if (!Array.isArray(message.modules))
                                return "modules: array expected";
                            for (let i = 0; i < message.modules.length; ++i) {
                                let error = $root.clutch.config.gateway.v1.Module.verify(message.modules[i]);
                                if (error)
                                    return "modules." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Config message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Config
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Config} Config
                     */
                    Config.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Config)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Config();
                        if (object.gateway != null) {
                            if (typeof object.gateway !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Config.gateway: object expected");
                            message.gateway = $root.clutch.config.gateway.v1.GatewayOptions.fromObject(object.gateway);
                        }
                        if (object.services) {
                            if (!Array.isArray(object.services))
                                throw TypeError(".clutch.config.gateway.v1.Config.services: array expected");
                            message.services = [];
                            for (let i = 0; i < object.services.length; ++i) {
                                if (typeof object.services[i] !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.Config.services: object expected");
                                message.services[i] = $root.clutch.config.gateway.v1.Service.fromObject(object.services[i]);
                            }
                        }
                        if (object.resolvers) {
                            if (!Array.isArray(object.resolvers))
                                throw TypeError(".clutch.config.gateway.v1.Config.resolvers: array expected");
                            message.resolvers = [];
                            for (let i = 0; i < object.resolvers.length; ++i) {
                                if (typeof object.resolvers[i] !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.Config.resolvers: object expected");
                                message.resolvers[i] = $root.clutch.config.gateway.v1.Resolver.fromObject(object.resolvers[i]);
                            }
                        }
                        if (object.modules) {
                            if (!Array.isArray(object.modules))
                                throw TypeError(".clutch.config.gateway.v1.Config.modules: array expected");
                            message.modules = [];
                            for (let i = 0; i < object.modules.length; ++i) {
                                if (typeof object.modules[i] !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.Config.modules: object expected");
                                message.modules[i] = $root.clutch.config.gateway.v1.Module.fromObject(object.modules[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Config message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Config
                     * @static
                     * @param {clutch.config.gateway.v1.Config} message Config
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Config.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults) {
                            object.services = [];
                            object.resolvers = [];
                            object.modules = [];
                        }
                        if (options.defaults)
                            object.gateway = null;
                        if (message.gateway != null && message.hasOwnProperty("gateway"))
                            object.gateway = $root.clutch.config.gateway.v1.GatewayOptions.toObject(message.gateway, options);
                        if (message.services && message.services.length) {
                            object.services = [];
                            for (let j = 0; j < message.services.length; ++j)
                                object.services[j] = $root.clutch.config.gateway.v1.Service.toObject(message.services[j], options);
                        }
                        if (message.resolvers && message.resolvers.length) {
                            object.resolvers = [];
                            for (let j = 0; j < message.resolvers.length; ++j)
                                object.resolvers[j] = $root.clutch.config.gateway.v1.Resolver.toObject(message.resolvers[j], options);
                        }
                        if (message.modules && message.modules.length) {
                            object.modules = [];
                            for (let j = 0; j < message.modules.length; ++j)
                                object.modules[j] = $root.clutch.config.gateway.v1.Module.toObject(message.modules[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Config to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Config
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Config.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Config;
                })();

                v1.TCPSocket = (function() {

                    /**
                     * Properties of a TCPSocket.
                     * @memberof clutch.config.gateway.v1
                     * @interface ITCPSocket
                     * @property {string|null} [address] TCPSocket address
                     * @property {number|null} [port] TCPSocket port
                     * @property {boolean|null} [secure] TCPSocket secure
                     */

                    /**
                     * Constructs a new TCPSocket.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a TCPSocket.
                     * @implements ITCPSocket
                     * @constructor
                     * @param {clutch.config.gateway.v1.ITCPSocket=} [properties] Properties to set
                     */
                    function TCPSocket(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * TCPSocket address.
                     * @member {string} address
                     * @memberof clutch.config.gateway.v1.TCPSocket
                     * @instance
                     */
                    TCPSocket.prototype.address = "";

                    /**
                     * TCPSocket port.
                     * @member {number} port
                     * @memberof clutch.config.gateway.v1.TCPSocket
                     * @instance
                     */
                    TCPSocket.prototype.port = 0;

                    /**
                     * TCPSocket secure.
                     * @member {boolean} secure
                     * @memberof clutch.config.gateway.v1.TCPSocket
                     * @instance
                     */
                    TCPSocket.prototype.secure = false;

                    /**
                     * Verifies a TCPSocket message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.TCPSocket
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    TCPSocket.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.address != null && message.hasOwnProperty("address"))
                            if (!$util.isString(message.address))
                                return "address: string expected";
                        if (message.port != null && message.hasOwnProperty("port"))
                            if (!$util.isInteger(message.port))
                                return "port: integer expected";
                        if (message.secure != null && message.hasOwnProperty("secure"))
                            if (typeof message.secure !== "boolean")
                                return "secure: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a TCPSocket message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.TCPSocket
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.TCPSocket} TCPSocket
                     */
                    TCPSocket.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.TCPSocket)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.TCPSocket();
                        if (object.address != null)
                            message.address = String(object.address);
                        if (object.port != null)
                            message.port = object.port >>> 0;
                        if (object.secure != null)
                            message.secure = Boolean(object.secure);
                        return message;
                    };

                    /**
                     * Creates a plain object from a TCPSocket message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.TCPSocket
                     * @static
                     * @param {clutch.config.gateway.v1.TCPSocket} message TCPSocket
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    TCPSocket.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.address = "";
                            object.port = 0;
                            object.secure = false;
                        }
                        if (message.address != null && message.hasOwnProperty("address"))
                            object.address = message.address;
                        if (message.port != null && message.hasOwnProperty("port"))
                            object.port = message.port;
                        if (message.secure != null && message.hasOwnProperty("secure"))
                            object.secure = message.secure;
                        return object;
                    };

                    /**
                     * Converts this TCPSocket to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.TCPSocket
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    TCPSocket.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return TCPSocket;
                })();

                v1.Listener = (function() {

                    /**
                     * Properties of a Listener.
                     * @memberof clutch.config.gateway.v1
                     * @interface IListener
                     * @property {clutch.config.gateway.v1.ITCPSocket|null} [tcp] Listener tcp
                     */

                    /**
                     * Constructs a new Listener.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Listener.
                     * @implements IListener
                     * @constructor
                     * @param {clutch.config.gateway.v1.IListener=} [properties] Properties to set
                     */
                    function Listener(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Listener tcp.
                     * @member {clutch.config.gateway.v1.ITCPSocket|null|undefined} tcp
                     * @memberof clutch.config.gateway.v1.Listener
                     * @instance
                     */
                    Listener.prototype.tcp = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Listener socket.
                     * @member {"tcp"|undefined} socket
                     * @memberof clutch.config.gateway.v1.Listener
                     * @instance
                     */
                    Object.defineProperty(Listener.prototype, "socket", {
                        get: $util.oneOfGetter($oneOfFields = ["tcp"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies a Listener message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Listener
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Listener.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.tcp != null && message.hasOwnProperty("tcp")) {
                            properties.socket = 1;
                            {
                                let error = $root.clutch.config.gateway.v1.TCPSocket.verify(message.tcp);
                                if (error)
                                    return "tcp." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Listener message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Listener
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Listener} Listener
                     */
                    Listener.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Listener)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Listener();
                        if (object.tcp != null) {
                            if (typeof object.tcp !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Listener.tcp: object expected");
                            message.tcp = $root.clutch.config.gateway.v1.TCPSocket.fromObject(object.tcp);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Listener message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Listener
                     * @static
                     * @param {clutch.config.gateway.v1.Listener} message Listener
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Listener.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (message.tcp != null && message.hasOwnProperty("tcp")) {
                            object.tcp = $root.clutch.config.gateway.v1.TCPSocket.toObject(message.tcp, options);
                            if (options.oneofs)
                                object.socket = "tcp";
                        }
                        return object;
                    };

                    /**
                     * Converts this Listener to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Listener
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Listener.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Listener;
                })();

                v1.Stats = (function() {

                    /**
                     * Properties of a Stats.
                     * @memberof clutch.config.gateway.v1
                     * @interface IStats
                     * @property {google.protobuf.IDuration|null} [flushInterval] Stats flushInterval
                     * @property {clutch.config.gateway.v1.Stats.ILogReporter|null} [logReporter] Stats logReporter
                     * @property {clutch.config.gateway.v1.Stats.IStatsdReporter|null} [statsdReporter] Stats statsdReporter
                     */

                    /**
                     * Constructs a new Stats.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Stats.
                     * @implements IStats
                     * @constructor
                     * @param {clutch.config.gateway.v1.IStats=} [properties] Properties to set
                     */
                    function Stats(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Stats flushInterval.
                     * @member {google.protobuf.IDuration|null|undefined} flushInterval
                     * @memberof clutch.config.gateway.v1.Stats
                     * @instance
                     */
                    Stats.prototype.flushInterval = null;

                    /**
                     * Stats logReporter.
                     * @member {clutch.config.gateway.v1.Stats.ILogReporter|null|undefined} logReporter
                     * @memberof clutch.config.gateway.v1.Stats
                     * @instance
                     */
                    Stats.prototype.logReporter = null;

                    /**
                     * Stats statsdReporter.
                     * @member {clutch.config.gateway.v1.Stats.IStatsdReporter|null|undefined} statsdReporter
                     * @memberof clutch.config.gateway.v1.Stats
                     * @instance
                     */
                    Stats.prototype.statsdReporter = null;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Stats reporter.
                     * @member {"logReporter"|"statsdReporter"|undefined} reporter
                     * @memberof clutch.config.gateway.v1.Stats
                     * @instance
                     */
                    Object.defineProperty(Stats.prototype, "reporter", {
                        get: $util.oneOfGetter($oneOfFields = ["logReporter", "statsdReporter"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies a Stats message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Stats
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Stats.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.flushInterval != null && message.hasOwnProperty("flushInterval")) {
                            let error = $root.google.protobuf.Duration.verify(message.flushInterval);
                            if (error)
                                return "flushInterval." + error;
                        }
                        if (message.logReporter != null && message.hasOwnProperty("logReporter")) {
                            properties.reporter = 1;
                            {
                                let error = $root.clutch.config.gateway.v1.Stats.LogReporter.verify(message.logReporter);
                                if (error)
                                    return "logReporter." + error;
                            }
                        }
                        if (message.statsdReporter != null && message.hasOwnProperty("statsdReporter")) {
                            if (properties.reporter === 1)
                                return "reporter: multiple values";
                            properties.reporter = 1;
                            {
                                let error = $root.clutch.config.gateway.v1.Stats.StatsdReporter.verify(message.statsdReporter);
                                if (error)
                                    return "statsdReporter." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Stats message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Stats
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Stats} Stats
                     */
                    Stats.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Stats)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Stats();
                        if (object.flushInterval != null) {
                            if (typeof object.flushInterval !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Stats.flushInterval: object expected");
                            message.flushInterval = $root.google.protobuf.Duration.fromObject(object.flushInterval);
                        }
                        if (object.logReporter != null) {
                            if (typeof object.logReporter !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Stats.logReporter: object expected");
                            message.logReporter = $root.clutch.config.gateway.v1.Stats.LogReporter.fromObject(object.logReporter);
                        }
                        if (object.statsdReporter != null) {
                            if (typeof object.statsdReporter !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Stats.statsdReporter: object expected");
                            message.statsdReporter = $root.clutch.config.gateway.v1.Stats.StatsdReporter.fromObject(object.statsdReporter);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Stats message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Stats
                     * @static
                     * @param {clutch.config.gateway.v1.Stats} message Stats
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Stats.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.flushInterval = null;
                        if (message.flushInterval != null && message.hasOwnProperty("flushInterval"))
                            object.flushInterval = $root.google.protobuf.Duration.toObject(message.flushInterval, options);
                        if (message.logReporter != null && message.hasOwnProperty("logReporter")) {
                            object.logReporter = $root.clutch.config.gateway.v1.Stats.LogReporter.toObject(message.logReporter, options);
                            if (options.oneofs)
                                object.reporter = "logReporter";
                        }
                        if (message.statsdReporter != null && message.hasOwnProperty("statsdReporter")) {
                            object.statsdReporter = $root.clutch.config.gateway.v1.Stats.StatsdReporter.toObject(message.statsdReporter, options);
                            if (options.oneofs)
                                object.reporter = "statsdReporter";
                        }
                        return object;
                    };

                    /**
                     * Converts this Stats to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Stats
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Stats.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Stats.LogReporter = (function() {

                        /**
                         * Properties of a LogReporter.
                         * @memberof clutch.config.gateway.v1.Stats
                         * @interface ILogReporter
                         */

                        /**
                         * Constructs a new LogReporter.
                         * @memberof clutch.config.gateway.v1.Stats
                         * @classdesc Represents a LogReporter.
                         * @implements ILogReporter
                         * @constructor
                         * @param {clutch.config.gateway.v1.Stats.ILogReporter=} [properties] Properties to set
                         */
                        function LogReporter(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Verifies a LogReporter message.
                         * @function verify
                         * @memberof clutch.config.gateway.v1.Stats.LogReporter
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        LogReporter.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            return null;
                        };

                        /**
                         * Creates a LogReporter message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.gateway.v1.Stats.LogReporter
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.gateway.v1.Stats.LogReporter} LogReporter
                         */
                        LogReporter.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.gateway.v1.Stats.LogReporter)
                                return object;
                            return new $root.clutch.config.gateway.v1.Stats.LogReporter();
                        };

                        /**
                         * Creates a plain object from a LogReporter message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.gateway.v1.Stats.LogReporter
                         * @static
                         * @param {clutch.config.gateway.v1.Stats.LogReporter} message LogReporter
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        LogReporter.toObject = function toObject() {
                            return {};
                        };

                        /**
                         * Converts this LogReporter to JSON.
                         * @function toJSON
                         * @memberof clutch.config.gateway.v1.Stats.LogReporter
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        LogReporter.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return LogReporter;
                    })();

                    Stats.StatsdReporter = (function() {

                        /**
                         * Properties of a StatsdReporter.
                         * @memberof clutch.config.gateway.v1.Stats
                         * @interface IStatsdReporter
                         * @property {string|null} [address] StatsdReporter address
                         * @property {clutch.config.gateway.v1.Stats.StatsdReporter.IPointTags|null} [pointTags] StatsdReporter pointTags
                         */

                        /**
                         * Constructs a new StatsdReporter.
                         * @memberof clutch.config.gateway.v1.Stats
                         * @classdesc Represents a StatsdReporter.
                         * @implements IStatsdReporter
                         * @constructor
                         * @param {clutch.config.gateway.v1.Stats.IStatsdReporter=} [properties] Properties to set
                         */
                        function StatsdReporter(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * StatsdReporter address.
                         * @member {string} address
                         * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                         * @instance
                         */
                        StatsdReporter.prototype.address = "";

                        /**
                         * StatsdReporter pointTags.
                         * @member {clutch.config.gateway.v1.Stats.StatsdReporter.IPointTags|null|undefined} pointTags
                         * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                         * @instance
                         */
                        StatsdReporter.prototype.pointTags = null;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * StatsdReporter tagMode.
                         * @member {"pointTags"|undefined} tagMode
                         * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                         * @instance
                         */
                        Object.defineProperty(StatsdReporter.prototype, "tagMode", {
                            get: $util.oneOfGetter($oneOfFields = ["pointTags"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Verifies a StatsdReporter message.
                         * @function verify
                         * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        StatsdReporter.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.address != null && message.hasOwnProperty("address"))
                                if (!$util.isString(message.address))
                                    return "address: string expected";
                            if (message.pointTags != null && message.hasOwnProperty("pointTags")) {
                                properties.tagMode = 1;
                                {
                                    let error = $root.clutch.config.gateway.v1.Stats.StatsdReporter.PointTags.verify(message.pointTags);
                                    if (error)
                                        return "pointTags." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a StatsdReporter message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.gateway.v1.Stats.StatsdReporter} StatsdReporter
                         */
                        StatsdReporter.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.gateway.v1.Stats.StatsdReporter)
                                return object;
                            let message = new $root.clutch.config.gateway.v1.Stats.StatsdReporter();
                            if (object.address != null)
                                message.address = String(object.address);
                            if (object.pointTags != null) {
                                if (typeof object.pointTags !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.Stats.StatsdReporter.pointTags: object expected");
                                message.pointTags = $root.clutch.config.gateway.v1.Stats.StatsdReporter.PointTags.fromObject(object.pointTags);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a StatsdReporter message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                         * @static
                         * @param {clutch.config.gateway.v1.Stats.StatsdReporter} message StatsdReporter
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        StatsdReporter.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.address = "";
                            if (message.address != null && message.hasOwnProperty("address"))
                                object.address = message.address;
                            if (message.pointTags != null && message.hasOwnProperty("pointTags")) {
                                object.pointTags = $root.clutch.config.gateway.v1.Stats.StatsdReporter.PointTags.toObject(message.pointTags, options);
                                if (options.oneofs)
                                    object.tagMode = "pointTags";
                            }
                            return object;
                        };

                        /**
                         * Converts this StatsdReporter to JSON.
                         * @function toJSON
                         * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        StatsdReporter.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        StatsdReporter.PointTags = (function() {

                            /**
                             * Properties of a PointTags.
                             * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                             * @interface IPointTags
                             * @property {string|null} [separator] PointTags separator
                             */

                            /**
                             * Constructs a new PointTags.
                             * @memberof clutch.config.gateway.v1.Stats.StatsdReporter
                             * @classdesc Represents a PointTags.
                             * @implements IPointTags
                             * @constructor
                             * @param {clutch.config.gateway.v1.Stats.StatsdReporter.IPointTags=} [properties] Properties to set
                             */
                            function PointTags(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * PointTags separator.
                             * @member {string} separator
                             * @memberof clutch.config.gateway.v1.Stats.StatsdReporter.PointTags
                             * @instance
                             */
                            PointTags.prototype.separator = "";

                            /**
                             * Verifies a PointTags message.
                             * @function verify
                             * @memberof clutch.config.gateway.v1.Stats.StatsdReporter.PointTags
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            PointTags.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.separator != null && message.hasOwnProperty("separator"))
                                    if (!$util.isString(message.separator))
                                        return "separator: string expected";
                                return null;
                            };

                            /**
                             * Creates a PointTags message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof clutch.config.gateway.v1.Stats.StatsdReporter.PointTags
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {clutch.config.gateway.v1.Stats.StatsdReporter.PointTags} PointTags
                             */
                            PointTags.fromObject = function fromObject(object) {
                                if (object instanceof $root.clutch.config.gateway.v1.Stats.StatsdReporter.PointTags)
                                    return object;
                                let message = new $root.clutch.config.gateway.v1.Stats.StatsdReporter.PointTags();
                                if (object.separator != null)
                                    message.separator = String(object.separator);
                                return message;
                            };

                            /**
                             * Creates a plain object from a PointTags message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof clutch.config.gateway.v1.Stats.StatsdReporter.PointTags
                             * @static
                             * @param {clutch.config.gateway.v1.Stats.StatsdReporter.PointTags} message PointTags
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            PointTags.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults)
                                    object.separator = "";
                                if (message.separator != null && message.hasOwnProperty("separator"))
                                    object.separator = message.separator;
                                return object;
                            };

                            /**
                             * Converts this PointTags to JSON.
                             * @function toJSON
                             * @memberof clutch.config.gateway.v1.Stats.StatsdReporter.PointTags
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            PointTags.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return PointTags;
                        })();

                        return StatsdReporter;
                    })();

                    return Stats;
                })();

                v1.Timeouts = (function() {

                    /**
                     * Properties of a Timeouts.
                     * @memberof clutch.config.gateway.v1
                     * @interface ITimeouts
                     * @property {google.protobuf.IDuration|null} ["default"] Timeouts default
                     * @property {Array.<clutch.config.gateway.v1.Timeouts.IEntry>|null} [overrides] Timeouts overrides
                     */

                    /**
                     * Constructs a new Timeouts.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Timeouts.
                     * @implements ITimeouts
                     * @constructor
                     * @param {clutch.config.gateway.v1.ITimeouts=} [properties] Properties to set
                     */
                    function Timeouts(properties) {
                        this.overrides = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Timeouts default.
                     * @member {google.protobuf.IDuration|null|undefined} default
                     * @memberof clutch.config.gateway.v1.Timeouts
                     * @instance
                     */
                    Timeouts.prototype["default"] = null;

                    /**
                     * Timeouts overrides.
                     * @member {Array.<clutch.config.gateway.v1.Timeouts.IEntry>} overrides
                     * @memberof clutch.config.gateway.v1.Timeouts
                     * @instance
                     */
                    Timeouts.prototype.overrides = $util.emptyArray;

                    /**
                     * Verifies a Timeouts message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Timeouts
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Timeouts.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message["default"] != null && message.hasOwnProperty("default")) {
                            let error = $root.google.protobuf.Duration.verify(message["default"]);
                            if (error)
                                return "default." + error;
                        }
                        if (message.overrides != null && message.hasOwnProperty("overrides")) {
                            if (!Array.isArray(message.overrides))
                                return "overrides: array expected";
                            for (let i = 0; i < message.overrides.length; ++i) {
                                let error = $root.clutch.config.gateway.v1.Timeouts.Entry.verify(message.overrides[i]);
                                if (error)
                                    return "overrides." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a Timeouts message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Timeouts
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Timeouts} Timeouts
                     */
                    Timeouts.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Timeouts)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Timeouts();
                        if (object["default"] != null) {
                            if (typeof object["default"] !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Timeouts.default: object expected");
                            message["default"] = $root.google.protobuf.Duration.fromObject(object["default"]);
                        }
                        if (object.overrides) {
                            if (!Array.isArray(object.overrides))
                                throw TypeError(".clutch.config.gateway.v1.Timeouts.overrides: array expected");
                            message.overrides = [];
                            for (let i = 0; i < object.overrides.length; ++i) {
                                if (typeof object.overrides[i] !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.Timeouts.overrides: object expected");
                                message.overrides[i] = $root.clutch.config.gateway.v1.Timeouts.Entry.fromObject(object.overrides[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Timeouts message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Timeouts
                     * @static
                     * @param {clutch.config.gateway.v1.Timeouts} message Timeouts
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Timeouts.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.overrides = [];
                        if (options.defaults)
                            object["default"] = null;
                        if (message["default"] != null && message.hasOwnProperty("default"))
                            object["default"] = $root.google.protobuf.Duration.toObject(message["default"], options);
                        if (message.overrides && message.overrides.length) {
                            object.overrides = [];
                            for (let j = 0; j < message.overrides.length; ++j)
                                object.overrides[j] = $root.clutch.config.gateway.v1.Timeouts.Entry.toObject(message.overrides[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this Timeouts to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Timeouts
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Timeouts.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    Timeouts.Entry = (function() {

                        /**
                         * Properties of an Entry.
                         * @memberof clutch.config.gateway.v1.Timeouts
                         * @interface IEntry
                         * @property {string|null} [service] Entry service
                         * @property {string|null} [method] Entry method
                         * @property {google.protobuf.IDuration|null} [timeout] Entry timeout
                         */

                        /**
                         * Constructs a new Entry.
                         * @memberof clutch.config.gateway.v1.Timeouts
                         * @classdesc Represents an Entry.
                         * @implements IEntry
                         * @constructor
                         * @param {clutch.config.gateway.v1.Timeouts.IEntry=} [properties] Properties to set
                         */
                        function Entry(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Entry service.
                         * @member {string} service
                         * @memberof clutch.config.gateway.v1.Timeouts.Entry
                         * @instance
                         */
                        Entry.prototype.service = "";

                        /**
                         * Entry method.
                         * @member {string} method
                         * @memberof clutch.config.gateway.v1.Timeouts.Entry
                         * @instance
                         */
                        Entry.prototype.method = "";

                        /**
                         * Entry timeout.
                         * @member {google.protobuf.IDuration|null|undefined} timeout
                         * @memberof clutch.config.gateway.v1.Timeouts.Entry
                         * @instance
                         */
                        Entry.prototype.timeout = null;

                        /**
                         * Verifies an Entry message.
                         * @function verify
                         * @memberof clutch.config.gateway.v1.Timeouts.Entry
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Entry.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.service != null && message.hasOwnProperty("service"))
                                if (!$util.isString(message.service))
                                    return "service: string expected";
                            if (message.method != null && message.hasOwnProperty("method"))
                                if (!$util.isString(message.method))
                                    return "method: string expected";
                            if (message.timeout != null && message.hasOwnProperty("timeout")) {
                                let error = $root.google.protobuf.Duration.verify(message.timeout);
                                if (error)
                                    return "timeout." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates an Entry message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.gateway.v1.Timeouts.Entry
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.gateway.v1.Timeouts.Entry} Entry
                         */
                        Entry.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.gateway.v1.Timeouts.Entry)
                                return object;
                            let message = new $root.clutch.config.gateway.v1.Timeouts.Entry();
                            if (object.service != null)
                                message.service = String(object.service);
                            if (object.method != null)
                                message.method = String(object.method);
                            if (object.timeout != null) {
                                if (typeof object.timeout !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.Timeouts.Entry.timeout: object expected");
                                message.timeout = $root.google.protobuf.Duration.fromObject(object.timeout);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from an Entry message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.gateway.v1.Timeouts.Entry
                         * @static
                         * @param {clutch.config.gateway.v1.Timeouts.Entry} message Entry
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Entry.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.service = "";
                                object.method = "";
                                object.timeout = null;
                            }
                            if (message.service != null && message.hasOwnProperty("service"))
                                object.service = message.service;
                            if (message.method != null && message.hasOwnProperty("method"))
                                object.method = message.method;
                            if (message.timeout != null && message.hasOwnProperty("timeout"))
                                object.timeout = $root.google.protobuf.Duration.toObject(message.timeout, options);
                            return object;
                        };

                        /**
                         * Converts this Entry to JSON.
                         * @function toJSON
                         * @memberof clutch.config.gateway.v1.Timeouts.Entry
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Entry.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Entry;
                    })();

                    return Timeouts;
                })();

                v1.GatewayOptions = (function() {

                    /**
                     * Properties of a GatewayOptions.
                     * @memberof clutch.config.gateway.v1
                     * @interface IGatewayOptions
                     * @property {clutch.config.gateway.v1.IListener|null} [listener] GatewayOptions listener
                     * @property {clutch.config.gateway.v1.IListener|null} [jsonGrpcLoopbackListener] GatewayOptions jsonGrpcLoopbackListener
                     * @property {clutch.config.gateway.v1.ILogger|null} [logger] GatewayOptions logger
                     * @property {clutch.config.gateway.v1.IStats|null} [stats] GatewayOptions stats
                     * @property {clutch.config.gateway.v1.ITimeouts|null} [timeouts] GatewayOptions timeouts
                     * @property {Array.<clutch.config.gateway.v1.IMiddleware>|null} [middleware] GatewayOptions middleware
                     */

                    /**
                     * Constructs a new GatewayOptions.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a GatewayOptions.
                     * @implements IGatewayOptions
                     * @constructor
                     * @param {clutch.config.gateway.v1.IGatewayOptions=} [properties] Properties to set
                     */
                    function GatewayOptions(properties) {
                        this.middleware = [];
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * GatewayOptions listener.
                     * @member {clutch.config.gateway.v1.IListener|null|undefined} listener
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.listener = null;

                    /**
                     * GatewayOptions jsonGrpcLoopbackListener.
                     * @member {clutch.config.gateway.v1.IListener|null|undefined} jsonGrpcLoopbackListener
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.jsonGrpcLoopbackListener = null;

                    /**
                     * GatewayOptions logger.
                     * @member {clutch.config.gateway.v1.ILogger|null|undefined} logger
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.logger = null;

                    /**
                     * GatewayOptions stats.
                     * @member {clutch.config.gateway.v1.IStats|null|undefined} stats
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.stats = null;

                    /**
                     * GatewayOptions timeouts.
                     * @member {clutch.config.gateway.v1.ITimeouts|null|undefined} timeouts
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.timeouts = null;

                    /**
                     * GatewayOptions middleware.
                     * @member {Array.<clutch.config.gateway.v1.IMiddleware>} middleware
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     */
                    GatewayOptions.prototype.middleware = $util.emptyArray;

                    /**
                     * Verifies a GatewayOptions message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    GatewayOptions.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.listener != null && message.hasOwnProperty("listener")) {
                            let error = $root.clutch.config.gateway.v1.Listener.verify(message.listener);
                            if (error)
                                return "listener." + error;
                        }
                        if (message.jsonGrpcLoopbackListener != null && message.hasOwnProperty("jsonGrpcLoopbackListener")) {
                            let error = $root.clutch.config.gateway.v1.Listener.verify(message.jsonGrpcLoopbackListener);
                            if (error)
                                return "jsonGrpcLoopbackListener." + error;
                        }
                        if (message.logger != null && message.hasOwnProperty("logger")) {
                            let error = $root.clutch.config.gateway.v1.Logger.verify(message.logger);
                            if (error)
                                return "logger." + error;
                        }
                        if (message.stats != null && message.hasOwnProperty("stats")) {
                            let error = $root.clutch.config.gateway.v1.Stats.verify(message.stats);
                            if (error)
                                return "stats." + error;
                        }
                        if (message.timeouts != null && message.hasOwnProperty("timeouts")) {
                            let error = $root.clutch.config.gateway.v1.Timeouts.verify(message.timeouts);
                            if (error)
                                return "timeouts." + error;
                        }
                        if (message.middleware != null && message.hasOwnProperty("middleware")) {
                            if (!Array.isArray(message.middleware))
                                return "middleware: array expected";
                            for (let i = 0; i < message.middleware.length; ++i) {
                                let error = $root.clutch.config.gateway.v1.Middleware.verify(message.middleware[i]);
                                if (error)
                                    return "middleware." + error;
                            }
                        }
                        return null;
                    };

                    /**
                     * Creates a GatewayOptions message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.GatewayOptions} GatewayOptions
                     */
                    GatewayOptions.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.GatewayOptions)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.GatewayOptions();
                        if (object.listener != null) {
                            if (typeof object.listener !== "object")
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.listener: object expected");
                            message.listener = $root.clutch.config.gateway.v1.Listener.fromObject(object.listener);
                        }
                        if (object.jsonGrpcLoopbackListener != null) {
                            if (typeof object.jsonGrpcLoopbackListener !== "object")
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.jsonGrpcLoopbackListener: object expected");
                            message.jsonGrpcLoopbackListener = $root.clutch.config.gateway.v1.Listener.fromObject(object.jsonGrpcLoopbackListener);
                        }
                        if (object.logger != null) {
                            if (typeof object.logger !== "object")
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.logger: object expected");
                            message.logger = $root.clutch.config.gateway.v1.Logger.fromObject(object.logger);
                        }
                        if (object.stats != null) {
                            if (typeof object.stats !== "object")
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.stats: object expected");
                            message.stats = $root.clutch.config.gateway.v1.Stats.fromObject(object.stats);
                        }
                        if (object.timeouts != null) {
                            if (typeof object.timeouts !== "object")
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.timeouts: object expected");
                            message.timeouts = $root.clutch.config.gateway.v1.Timeouts.fromObject(object.timeouts);
                        }
                        if (object.middleware) {
                            if (!Array.isArray(object.middleware))
                                throw TypeError(".clutch.config.gateway.v1.GatewayOptions.middleware: array expected");
                            message.middleware = [];
                            for (let i = 0; i < object.middleware.length; ++i) {
                                if (typeof object.middleware[i] !== "object")
                                    throw TypeError(".clutch.config.gateway.v1.GatewayOptions.middleware: object expected");
                                message.middleware[i] = $root.clutch.config.gateway.v1.Middleware.fromObject(object.middleware[i]);
                            }
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a GatewayOptions message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @static
                     * @param {clutch.config.gateway.v1.GatewayOptions} message GatewayOptions
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    GatewayOptions.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.arrays || options.defaults)
                            object.middleware = [];
                        if (options.defaults) {
                            object.listener = null;
                            object.jsonGrpcLoopbackListener = null;
                            object.logger = null;
                            object.stats = null;
                            object.timeouts = null;
                        }
                        if (message.listener != null && message.hasOwnProperty("listener"))
                            object.listener = $root.clutch.config.gateway.v1.Listener.toObject(message.listener, options);
                        if (message.jsonGrpcLoopbackListener != null && message.hasOwnProperty("jsonGrpcLoopbackListener"))
                            object.jsonGrpcLoopbackListener = $root.clutch.config.gateway.v1.Listener.toObject(message.jsonGrpcLoopbackListener, options);
                        if (message.logger != null && message.hasOwnProperty("logger"))
                            object.logger = $root.clutch.config.gateway.v1.Logger.toObject(message.logger, options);
                        if (message.stats != null && message.hasOwnProperty("stats"))
                            object.stats = $root.clutch.config.gateway.v1.Stats.toObject(message.stats, options);
                        if (message.timeouts != null && message.hasOwnProperty("timeouts"))
                            object.timeouts = $root.clutch.config.gateway.v1.Timeouts.toObject(message.timeouts, options);
                        if (message.middleware && message.middleware.length) {
                            object.middleware = [];
                            for (let j = 0; j < message.middleware.length; ++j)
                                object.middleware[j] = $root.clutch.config.gateway.v1.Middleware.toObject(message.middleware[j], options);
                        }
                        return object;
                    };

                    /**
                     * Converts this GatewayOptions to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.GatewayOptions
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    GatewayOptions.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return GatewayOptions;
                })();

                v1.Logger = (function() {

                    /**
                     * Properties of a Logger.
                     * @memberof clutch.config.gateway.v1
                     * @interface ILogger
                     * @property {clutch.config.gateway.v1.Logger.Level|null} [level] Logger level
                     * @property {boolean|null} [pretty] Logger pretty
                     */

                    /**
                     * Constructs a new Logger.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Logger.
                     * @implements ILogger
                     * @constructor
                     * @param {clutch.config.gateway.v1.ILogger=} [properties] Properties to set
                     */
                    function Logger(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Logger level.
                     * @member {clutch.config.gateway.v1.Logger.Level} level
                     * @memberof clutch.config.gateway.v1.Logger
                     * @instance
                     */
                    Logger.prototype.level = 0;

                    /**
                     * Logger pretty.
                     * @member {boolean} pretty
                     * @memberof clutch.config.gateway.v1.Logger
                     * @instance
                     */
                    Logger.prototype.pretty = false;

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Logger format.
                     * @member {"pretty"|undefined} format
                     * @memberof clutch.config.gateway.v1.Logger
                     * @instance
                     */
                    Object.defineProperty(Logger.prototype, "format", {
                        get: $util.oneOfGetter($oneOfFields = ["pretty"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies a Logger message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Logger
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Logger.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.level != null && message.hasOwnProperty("level"))
                            switch (message.level) {
                            default:
                                return "level: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                            case 5:
                            case 6:
                                break;
                            }
                        if (message.pretty != null && message.hasOwnProperty("pretty")) {
                            properties.format = 1;
                            if (typeof message.pretty !== "boolean")
                                return "pretty: boolean expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Logger message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Logger
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Logger} Logger
                     */
                    Logger.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Logger)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Logger();
                        switch (object.level) {
                        case "UNSPECIFIED":
                        case 0:
                            message.level = 0;
                            break;
                        case "DEBUG":
                        case 1:
                            message.level = 1;
                            break;
                        case "INFO":
                        case 2:
                            message.level = 2;
                            break;
                        case "WARN":
                        case 3:
                            message.level = 3;
                            break;
                        case "ERROR":
                        case 4:
                            message.level = 4;
                            break;
                        case "PANIC":
                        case 5:
                            message.level = 5;
                            break;
                        case "FATAL":
                        case 6:
                            message.level = 6;
                            break;
                        }
                        if (object.pretty != null)
                            message.pretty = Boolean(object.pretty);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Logger message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Logger
                     * @static
                     * @param {clutch.config.gateway.v1.Logger} message Logger
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Logger.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.level = options.enums === String ? "UNSPECIFIED" : 0;
                        if (message.level != null && message.hasOwnProperty("level"))
                            object.level = options.enums === String ? $root.clutch.config.gateway.v1.Logger.Level[message.level] : message.level;
                        if (message.pretty != null && message.hasOwnProperty("pretty")) {
                            object.pretty = message.pretty;
                            if (options.oneofs)
                                object.format = "pretty";
                        }
                        return object;
                    };

                    /**
                     * Converts this Logger to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Logger
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Logger.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Level enum.
                     * @name clutch.config.gateway.v1.Logger.Level
                     * @enum {number}
                     * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                     * @property {number} DEBUG=1 DEBUG value
                     * @property {number} INFO=2 INFO value
                     * @property {number} WARN=3 WARN value
                     * @property {number} ERROR=4 ERROR value
                     * @property {number} PANIC=5 PANIC value
                     * @property {number} FATAL=6 FATAL value
                     */
                    Logger.Level = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNSPECIFIED"] = 0;
                        values[valuesById[1] = "DEBUG"] = 1;
                        values[valuesById[2] = "INFO"] = 2;
                        values[valuesById[3] = "WARN"] = 3;
                        values[valuesById[4] = "ERROR"] = 4;
                        values[valuesById[5] = "PANIC"] = 5;
                        values[valuesById[6] = "FATAL"] = 6;
                        return values;
                    })();

                    return Logger;
                })();

                v1.Middleware = (function() {

                    /**
                     * Properties of a Middleware.
                     * @memberof clutch.config.gateway.v1
                     * @interface IMiddleware
                     * @property {string|null} [name] Middleware name
                     * @property {google.protobuf.IAny|null} [typedConfig] Middleware typedConfig
                     */

                    /**
                     * Constructs a new Middleware.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Middleware.
                     * @implements IMiddleware
                     * @constructor
                     * @param {clutch.config.gateway.v1.IMiddleware=} [properties] Properties to set
                     */
                    function Middleware(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Middleware name.
                     * @member {string} name
                     * @memberof clutch.config.gateway.v1.Middleware
                     * @instance
                     */
                    Middleware.prototype.name = "";

                    /**
                     * Middleware typedConfig.
                     * @member {google.protobuf.IAny|null|undefined} typedConfig
                     * @memberof clutch.config.gateway.v1.Middleware
                     * @instance
                     */
                    Middleware.prototype.typedConfig = null;

                    /**
                     * Verifies a Middleware message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Middleware
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Middleware.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig")) {
                            let error = $root.google.protobuf.Any.verify(message.typedConfig);
                            if (error)
                                return "typedConfig." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Middleware message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Middleware
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Middleware} Middleware
                     */
                    Middleware.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Middleware)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Middleware();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.typedConfig != null) {
                            if (typeof object.typedConfig !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Middleware.typedConfig: object expected");
                            message.typedConfig = $root.google.protobuf.Any.fromObject(object.typedConfig);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Middleware message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Middleware
                     * @static
                     * @param {clutch.config.gateway.v1.Middleware} message Middleware
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Middleware.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.typedConfig = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig"))
                            object.typedConfig = $root.google.protobuf.Any.toObject(message.typedConfig, options);
                        return object;
                    };

                    /**
                     * Converts this Middleware to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Middleware
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Middleware.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Middleware;
                })();

                v1.Service = (function() {

                    /**
                     * Properties of a Service.
                     * @memberof clutch.config.gateway.v1
                     * @interface IService
                     * @property {string|null} [name] Service name
                     * @property {google.protobuf.IAny|null} [typedConfig] Service typedConfig
                     */

                    /**
                     * Constructs a new Service.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Service.
                     * @implements IService
                     * @constructor
                     * @param {clutch.config.gateway.v1.IService=} [properties] Properties to set
                     */
                    function Service(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Service name.
                     * @member {string} name
                     * @memberof clutch.config.gateway.v1.Service
                     * @instance
                     */
                    Service.prototype.name = "";

                    /**
                     * Service typedConfig.
                     * @member {google.protobuf.IAny|null|undefined} typedConfig
                     * @memberof clutch.config.gateway.v1.Service
                     * @instance
                     */
                    Service.prototype.typedConfig = null;

                    /**
                     * Verifies a Service message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Service
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Service.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig")) {
                            let error = $root.google.protobuf.Any.verify(message.typedConfig);
                            if (error)
                                return "typedConfig." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Service message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Service
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Service} Service
                     */
                    Service.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Service)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Service();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.typedConfig != null) {
                            if (typeof object.typedConfig !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Service.typedConfig: object expected");
                            message.typedConfig = $root.google.protobuf.Any.fromObject(object.typedConfig);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Service message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Service
                     * @static
                     * @param {clutch.config.gateway.v1.Service} message Service
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Service.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.typedConfig = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig"))
                            object.typedConfig = $root.google.protobuf.Any.toObject(message.typedConfig, options);
                        return object;
                    };

                    /**
                     * Converts this Service to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Service
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Service.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Service;
                })();

                v1.Resolver = (function() {

                    /**
                     * Properties of a Resolver.
                     * @memberof clutch.config.gateway.v1
                     * @interface IResolver
                     * @property {string|null} [name] Resolver name
                     * @property {google.protobuf.IAny|null} [typedConfig] Resolver typedConfig
                     */

                    /**
                     * Constructs a new Resolver.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Resolver.
                     * @implements IResolver
                     * @constructor
                     * @param {clutch.config.gateway.v1.IResolver=} [properties] Properties to set
                     */
                    function Resolver(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Resolver name.
                     * @member {string} name
                     * @memberof clutch.config.gateway.v1.Resolver
                     * @instance
                     */
                    Resolver.prototype.name = "";

                    /**
                     * Resolver typedConfig.
                     * @member {google.protobuf.IAny|null|undefined} typedConfig
                     * @memberof clutch.config.gateway.v1.Resolver
                     * @instance
                     */
                    Resolver.prototype.typedConfig = null;

                    /**
                     * Verifies a Resolver message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Resolver
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Resolver.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig")) {
                            let error = $root.google.protobuf.Any.verify(message.typedConfig);
                            if (error)
                                return "typedConfig." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Resolver message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Resolver
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Resolver} Resolver
                     */
                    Resolver.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Resolver)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Resolver();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.typedConfig != null) {
                            if (typeof object.typedConfig !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Resolver.typedConfig: object expected");
                            message.typedConfig = $root.google.protobuf.Any.fromObject(object.typedConfig);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Resolver message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Resolver
                     * @static
                     * @param {clutch.config.gateway.v1.Resolver} message Resolver
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Resolver.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.typedConfig = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig"))
                            object.typedConfig = $root.google.protobuf.Any.toObject(message.typedConfig, options);
                        return object;
                    };

                    /**
                     * Converts this Resolver to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Resolver
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Resolver.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Resolver;
                })();

                v1.Module = (function() {

                    /**
                     * Properties of a Module.
                     * @memberof clutch.config.gateway.v1
                     * @interface IModule
                     * @property {string|null} [name] Module name
                     * @property {google.protobuf.IAny|null} [typedConfig] Module typedConfig
                     */

                    /**
                     * Constructs a new Module.
                     * @memberof clutch.config.gateway.v1
                     * @classdesc Represents a Module.
                     * @implements IModule
                     * @constructor
                     * @param {clutch.config.gateway.v1.IModule=} [properties] Properties to set
                     */
                    function Module(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Module name.
                     * @member {string} name
                     * @memberof clutch.config.gateway.v1.Module
                     * @instance
                     */
                    Module.prototype.name = "";

                    /**
                     * Module typedConfig.
                     * @member {google.protobuf.IAny|null|undefined} typedConfig
                     * @memberof clutch.config.gateway.v1.Module
                     * @instance
                     */
                    Module.prototype.typedConfig = null;

                    /**
                     * Verifies a Module message.
                     * @function verify
                     * @memberof clutch.config.gateway.v1.Module
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Module.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig")) {
                            let error = $root.google.protobuf.Any.verify(message.typedConfig);
                            if (error)
                                return "typedConfig." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a Module message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.config.gateway.v1.Module
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.config.gateway.v1.Module} Module
                     */
                    Module.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.config.gateway.v1.Module)
                            return object;
                        let message = new $root.clutch.config.gateway.v1.Module();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.typedConfig != null) {
                            if (typeof object.typedConfig !== "object")
                                throw TypeError(".clutch.config.gateway.v1.Module.typedConfig: object expected");
                            message.typedConfig = $root.google.protobuf.Any.fromObject(object.typedConfig);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Module message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.config.gateway.v1.Module
                     * @static
                     * @param {clutch.config.gateway.v1.Module} message Module
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Module.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.typedConfig = null;
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.typedConfig != null && message.hasOwnProperty("typedConfig"))
                            object.typedConfig = $root.google.protobuf.Any.toObject(message.typedConfig, options);
                        return object;
                    };

                    /**
                     * Converts this Module to JSON.
                     * @function toJSON
                     * @memberof clutch.config.gateway.v1.Module
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Module.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Module;
                })();

                return v1;
            })();

            return gateway;
        })();

        config.module = (function() {

            /**
             * Namespace module.
             * @memberof clutch.config
             * @namespace
             */
            const module = {};

            module.chaos = (function() {

                /**
                 * Namespace chaos.
                 * @memberof clutch.config.module
                 * @namespace
                 */
                const chaos = {};

                chaos.experimentation = (function() {

                    /**
                     * Namespace experimentation.
                     * @memberof clutch.config.module.chaos
                     * @namespace
                     */
                    const experimentation = {};

                    experimentation.rtds = (function() {

                        /**
                         * Namespace rtds.
                         * @memberof clutch.config.module.chaos.experimentation
                         * @namespace
                         */
                        const rtds = {};

                        rtds.v1 = (function() {

                            /**
                             * Namespace v1.
                             * @memberof clutch.config.module.chaos.experimentation.rtds
                             * @namespace
                             */
                            const v1 = {};

                            v1.Config = (function() {

                                /**
                                 * Properties of a Config.
                                 * @memberof clutch.config.module.chaos.experimentation.rtds.v1
                                 * @interface IConfig
                                 * @property {string|null} [rtdsLayerName] Config rtdsLayerName
                                 * @property {google.protobuf.IDuration|null} [cacheRefreshInterval] Config cacheRefreshInterval
                                 */

                                /**
                                 * Constructs a new Config.
                                 * @memberof clutch.config.module.chaos.experimentation.rtds.v1
                                 * @classdesc Represents a Config.
                                 * @implements IConfig
                                 * @constructor
                                 * @param {clutch.config.module.chaos.experimentation.rtds.v1.IConfig=} [properties] Properties to set
                                 */
                                function Config(properties) {
                                    if (properties)
                                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                            if (properties[keys[i]] != null)
                                                this[keys[i]] = properties[keys[i]];
                                }

                                /**
                                 * Config rtdsLayerName.
                                 * @member {string} rtdsLayerName
                                 * @memberof clutch.config.module.chaos.experimentation.rtds.v1.Config
                                 * @instance
                                 */
                                Config.prototype.rtdsLayerName = "";

                                /**
                                 * Config cacheRefreshInterval.
                                 * @member {google.protobuf.IDuration|null|undefined} cacheRefreshInterval
                                 * @memberof clutch.config.module.chaos.experimentation.rtds.v1.Config
                                 * @instance
                                 */
                                Config.prototype.cacheRefreshInterval = null;

                                /**
                                 * Verifies a Config message.
                                 * @function verify
                                 * @memberof clutch.config.module.chaos.experimentation.rtds.v1.Config
                                 * @static
                                 * @param {Object.<string,*>} message Plain object to verify
                                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                                 */
                                Config.verify = function verify(message) {
                                    if (typeof message !== "object" || message === null)
                                        return "object expected";
                                    if (message.rtdsLayerName != null && message.hasOwnProperty("rtdsLayerName"))
                                        if (!$util.isString(message.rtdsLayerName))
                                            return "rtdsLayerName: string expected";
                                    if (message.cacheRefreshInterval != null && message.hasOwnProperty("cacheRefreshInterval")) {
                                        let error = $root.google.protobuf.Duration.verify(message.cacheRefreshInterval);
                                        if (error)
                                            return "cacheRefreshInterval." + error;
                                    }
                                    return null;
                                };

                                /**
                                 * Creates a Config message from a plain object. Also converts values to their respective internal types.
                                 * @function fromObject
                                 * @memberof clutch.config.module.chaos.experimentation.rtds.v1.Config
                                 * @static
                                 * @param {Object.<string,*>} object Plain object
                                 * @returns {clutch.config.module.chaos.experimentation.rtds.v1.Config} Config
                                 */
                                Config.fromObject = function fromObject(object) {
                                    if (object instanceof $root.clutch.config.module.chaos.experimentation.rtds.v1.Config)
                                        return object;
                                    let message = new $root.clutch.config.module.chaos.experimentation.rtds.v1.Config();
                                    if (object.rtdsLayerName != null)
                                        message.rtdsLayerName = String(object.rtdsLayerName);
                                    if (object.cacheRefreshInterval != null) {
                                        if (typeof object.cacheRefreshInterval !== "object")
                                            throw TypeError(".clutch.config.module.chaos.experimentation.rtds.v1.Config.cacheRefreshInterval: object expected");
                                        message.cacheRefreshInterval = $root.google.protobuf.Duration.fromObject(object.cacheRefreshInterval);
                                    }
                                    return message;
                                };

                                /**
                                 * Creates a plain object from a Config message. Also converts values to other types if specified.
                                 * @function toObject
                                 * @memberof clutch.config.module.chaos.experimentation.rtds.v1.Config
                                 * @static
                                 * @param {clutch.config.module.chaos.experimentation.rtds.v1.Config} message Config
                                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                                 * @returns {Object.<string,*>} Plain object
                                 */
                                Config.toObject = function toObject(message, options) {
                                    if (!options)
                                        options = {};
                                    let object = {};
                                    if (options.defaults) {
                                        object.rtdsLayerName = "";
                                        object.cacheRefreshInterval = null;
                                    }
                                    if (message.rtdsLayerName != null && message.hasOwnProperty("rtdsLayerName"))
                                        object.rtdsLayerName = message.rtdsLayerName;
                                    if (message.cacheRefreshInterval != null && message.hasOwnProperty("cacheRefreshInterval"))
                                        object.cacheRefreshInterval = $root.google.protobuf.Duration.toObject(message.cacheRefreshInterval, options);
                                    return object;
                                };

                                /**
                                 * Converts this Config to JSON.
                                 * @function toJSON
                                 * @memberof clutch.config.module.chaos.experimentation.rtds.v1.Config
                                 * @instance
                                 * @returns {Object.<string,*>} JSON object
                                 */
                                Config.prototype.toJSON = function toJSON() {
                                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                                };

                                return Config;
                            })();

                            return v1;
                        })();

                        return rtds;
                    })();

                    return experimentation;
                })();

                return chaos;
            })();

            return module;
        })();

        config.service = (function() {

            /**
             * Namespace service.
             * @memberof clutch.config
             * @namespace
             */
            const service = {};

            service.auditsink = (function() {

                /**
                 * Namespace auditsink.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const auditsink = {};

                auditsink.slack = (function() {

                    /**
                     * Namespace slack.
                     * @memberof clutch.config.service.auditsink
                     * @namespace
                     */
                    const slack = {};

                    slack.v1 = (function() {

                        /**
                         * Namespace v1.
                         * @memberof clutch.config.service.auditsink.slack
                         * @namespace
                         */
                        const v1 = {};

                        v1.SlackConfig = (function() {

                            /**
                             * Properties of a SlackConfig.
                             * @memberof clutch.config.service.auditsink.slack.v1
                             * @interface ISlackConfig
                             * @property {string|null} [token] SlackConfig token
                             * @property {string|null} [channel] SlackConfig channel
                             * @property {clutch.config.service.audit.v1.IFilter|null} [filter] SlackConfig filter
                             */

                            /**
                             * Constructs a new SlackConfig.
                             * @memberof clutch.config.service.auditsink.slack.v1
                             * @classdesc Represents a SlackConfig.
                             * @implements ISlackConfig
                             * @constructor
                             * @param {clutch.config.service.auditsink.slack.v1.ISlackConfig=} [properties] Properties to set
                             */
                            function SlackConfig(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * SlackConfig token.
                             * @member {string} token
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @instance
                             */
                            SlackConfig.prototype.token = "";

                            /**
                             * SlackConfig channel.
                             * @member {string} channel
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @instance
                             */
                            SlackConfig.prototype.channel = "";

                            /**
                             * SlackConfig filter.
                             * @member {clutch.config.service.audit.v1.IFilter|null|undefined} filter
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @instance
                             */
                            SlackConfig.prototype.filter = null;

                            /**
                             * Verifies a SlackConfig message.
                             * @function verify
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            SlackConfig.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.token != null && message.hasOwnProperty("token"))
                                    if (!$util.isString(message.token))
                                        return "token: string expected";
                                if (message.channel != null && message.hasOwnProperty("channel"))
                                    if (!$util.isString(message.channel))
                                        return "channel: string expected";
                                if (message.filter != null && message.hasOwnProperty("filter")) {
                                    let error = $root.clutch.config.service.audit.v1.Filter.verify(message.filter);
                                    if (error)
                                        return "filter." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a SlackConfig message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {clutch.config.service.auditsink.slack.v1.SlackConfig} SlackConfig
                             */
                            SlackConfig.fromObject = function fromObject(object) {
                                if (object instanceof $root.clutch.config.service.auditsink.slack.v1.SlackConfig)
                                    return object;
                                let message = new $root.clutch.config.service.auditsink.slack.v1.SlackConfig();
                                if (object.token != null)
                                    message.token = String(object.token);
                                if (object.channel != null)
                                    message.channel = String(object.channel);
                                if (object.filter != null) {
                                    if (typeof object.filter !== "object")
                                        throw TypeError(".clutch.config.service.auditsink.slack.v1.SlackConfig.filter: object expected");
                                    message.filter = $root.clutch.config.service.audit.v1.Filter.fromObject(object.filter);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a SlackConfig message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @static
                             * @param {clutch.config.service.auditsink.slack.v1.SlackConfig} message SlackConfig
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            SlackConfig.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.token = "";
                                    object.channel = "";
                                    object.filter = null;
                                }
                                if (message.token != null && message.hasOwnProperty("token"))
                                    object.token = message.token;
                                if (message.channel != null && message.hasOwnProperty("channel"))
                                    object.channel = message.channel;
                                if (message.filter != null && message.hasOwnProperty("filter"))
                                    object.filter = $root.clutch.config.service.audit.v1.Filter.toObject(message.filter, options);
                                return object;
                            };

                            /**
                             * Converts this SlackConfig to JSON.
                             * @function toJSON
                             * @memberof clutch.config.service.auditsink.slack.v1.SlackConfig
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            SlackConfig.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return SlackConfig;
                        })();

                        return v1;
                    })();

                    return slack;
                })();

                return auditsink;
            })();

            service.audit = (function() {

                /**
                 * Namespace audit.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const audit = {};

                audit.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.audit
                     * @namespace
                     */
                    const v1 = {};

                    v1.EventFilter = (function() {

                        /**
                         * Properties of an EventFilter.
                         * @memberof clutch.config.service.audit.v1
                         * @interface IEventFilter
                         * @property {clutch.config.service.audit.v1.EventFilter.FilterType|null} [field] EventFilter field
                         * @property {string|null} [text] EventFilter text
                         */

                        /**
                         * Constructs a new EventFilter.
                         * @memberof clutch.config.service.audit.v1
                         * @classdesc Represents an EventFilter.
                         * @implements IEventFilter
                         * @constructor
                         * @param {clutch.config.service.audit.v1.IEventFilter=} [properties] Properties to set
                         */
                        function EventFilter(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * EventFilter field.
                         * @member {clutch.config.service.audit.v1.EventFilter.FilterType} field
                         * @memberof clutch.config.service.audit.v1.EventFilter
                         * @instance
                         */
                        EventFilter.prototype.field = 0;

                        /**
                         * EventFilter text.
                         * @member {string} text
                         * @memberof clutch.config.service.audit.v1.EventFilter
                         * @instance
                         */
                        EventFilter.prototype.text = "";

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * EventFilter value.
                         * @member {"text"|undefined} value
                         * @memberof clutch.config.service.audit.v1.EventFilter
                         * @instance
                         */
                        Object.defineProperty(EventFilter.prototype, "value", {
                            get: $util.oneOfGetter($oneOfFields = ["text"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Verifies an EventFilter message.
                         * @function verify
                         * @memberof clutch.config.service.audit.v1.EventFilter
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        EventFilter.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.field != null && message.hasOwnProperty("field"))
                                switch (message.field) {
                                default:
                                    return "field: enum value expected";
                                case 0:
                                case 1:
                                case 2:
                                case 3:
                                    break;
                                }
                            if (message.text != null && message.hasOwnProperty("text")) {
                                properties.value = 1;
                                if (!$util.isString(message.text))
                                    return "text: string expected";
                            }
                            return null;
                        };

                        /**
                         * Creates an EventFilter message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.audit.v1.EventFilter
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.audit.v1.EventFilter} EventFilter
                         */
                        EventFilter.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.audit.v1.EventFilter)
                                return object;
                            let message = new $root.clutch.config.service.audit.v1.EventFilter();
                            switch (object.field) {
                            case "UNSPECIFIED":
                            case 0:
                                message.field = 0;
                                break;
                            case "SERVICE":
                            case 1:
                                message.field = 1;
                                break;
                            case "METHOD":
                            case 2:
                                message.field = 2;
                                break;
                            case "TYPE":
                            case 3:
                                message.field = 3;
                                break;
                            }
                            if (object.text != null)
                                message.text = String(object.text);
                            return message;
                        };

                        /**
                         * Creates a plain object from an EventFilter message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.audit.v1.EventFilter
                         * @static
                         * @param {clutch.config.service.audit.v1.EventFilter} message EventFilter
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        EventFilter.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.field = options.enums === String ? "UNSPECIFIED" : 0;
                            if (message.field != null && message.hasOwnProperty("field"))
                                object.field = options.enums === String ? $root.clutch.config.service.audit.v1.EventFilter.FilterType[message.field] : message.field;
                            if (message.text != null && message.hasOwnProperty("text")) {
                                object.text = message.text;
                                if (options.oneofs)
                                    object.value = "text";
                            }
                            return object;
                        };

                        /**
                         * Converts this EventFilter to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.audit.v1.EventFilter
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        EventFilter.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        /**
                         * FilterType enum.
                         * @name clutch.config.service.audit.v1.EventFilter.FilterType
                         * @enum {number}
                         * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                         * @property {number} SERVICE=1 SERVICE value
                         * @property {number} METHOD=2 METHOD value
                         * @property {number} TYPE=3 TYPE value
                         */
                        EventFilter.FilterType = (function() {
                            const valuesById = {}, values = Object.create(valuesById);
                            values[valuesById[0] = "UNSPECIFIED"] = 0;
                            values[valuesById[1] = "SERVICE"] = 1;
                            values[valuesById[2] = "METHOD"] = 2;
                            values[valuesById[3] = "TYPE"] = 3;
                            return values;
                        })();

                        return EventFilter;
                    })();

                    v1.Filter = (function() {

                        /**
                         * Properties of a Filter.
                         * @memberof clutch.config.service.audit.v1
                         * @interface IFilter
                         * @property {boolean|null} [denylist] Filter denylist
                         * @property {Array.<clutch.config.service.audit.v1.IEventFilter>|null} [rules] Filter rules
                         */

                        /**
                         * Constructs a new Filter.
                         * @memberof clutch.config.service.audit.v1
                         * @classdesc Represents a Filter.
                         * @implements IFilter
                         * @constructor
                         * @param {clutch.config.service.audit.v1.IFilter=} [properties] Properties to set
                         */
                        function Filter(properties) {
                            this.rules = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Filter denylist.
                         * @member {boolean} denylist
                         * @memberof clutch.config.service.audit.v1.Filter
                         * @instance
                         */
                        Filter.prototype.denylist = false;

                        /**
                         * Filter rules.
                         * @member {Array.<clutch.config.service.audit.v1.IEventFilter>} rules
                         * @memberof clutch.config.service.audit.v1.Filter
                         * @instance
                         */
                        Filter.prototype.rules = $util.emptyArray;

                        /**
                         * Verifies a Filter message.
                         * @function verify
                         * @memberof clutch.config.service.audit.v1.Filter
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Filter.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.denylist != null && message.hasOwnProperty("denylist"))
                                if (typeof message.denylist !== "boolean")
                                    return "denylist: boolean expected";
                            if (message.rules != null && message.hasOwnProperty("rules")) {
                                if (!Array.isArray(message.rules))
                                    return "rules: array expected";
                                for (let i = 0; i < message.rules.length; ++i) {
                                    let error = $root.clutch.config.service.audit.v1.EventFilter.verify(message.rules[i]);
                                    if (error)
                                        return "rules." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Filter message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.audit.v1.Filter
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.audit.v1.Filter} Filter
                         */
                        Filter.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.audit.v1.Filter)
                                return object;
                            let message = new $root.clutch.config.service.audit.v1.Filter();
                            if (object.denylist != null)
                                message.denylist = Boolean(object.denylist);
                            if (object.rules) {
                                if (!Array.isArray(object.rules))
                                    throw TypeError(".clutch.config.service.audit.v1.Filter.rules: array expected");
                                message.rules = [];
                                for (let i = 0; i < object.rules.length; ++i) {
                                    if (typeof object.rules[i] !== "object")
                                        throw TypeError(".clutch.config.service.audit.v1.Filter.rules: object expected");
                                    message.rules[i] = $root.clutch.config.service.audit.v1.EventFilter.fromObject(object.rules[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Filter message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.audit.v1.Filter
                         * @static
                         * @param {clutch.config.service.audit.v1.Filter} message Filter
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Filter.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.rules = [];
                            if (options.defaults)
                                object.denylist = false;
                            if (message.denylist != null && message.hasOwnProperty("denylist"))
                                object.denylist = message.denylist;
                            if (message.rules && message.rules.length) {
                                object.rules = [];
                                for (let j = 0; j < message.rules.length; ++j)
                                    object.rules[j] = $root.clutch.config.service.audit.v1.EventFilter.toObject(message.rules[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Filter to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.audit.v1.Filter
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Filter.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Filter;
                    })();

                    v1.SinkConfig = (function() {

                        /**
                         * Properties of a SinkConfig.
                         * @memberof clutch.config.service.audit.v1
                         * @interface ISinkConfig
                         * @property {clutch.config.service.audit.v1.IFilter|null} [filter] SinkConfig filter
                         */

                        /**
                         * Constructs a new SinkConfig.
                         * @memberof clutch.config.service.audit.v1
                         * @classdesc Represents a SinkConfig.
                         * @implements ISinkConfig
                         * @constructor
                         * @param {clutch.config.service.audit.v1.ISinkConfig=} [properties] Properties to set
                         */
                        function SinkConfig(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * SinkConfig filter.
                         * @member {clutch.config.service.audit.v1.IFilter|null|undefined} filter
                         * @memberof clutch.config.service.audit.v1.SinkConfig
                         * @instance
                         */
                        SinkConfig.prototype.filter = null;

                        /**
                         * Verifies a SinkConfig message.
                         * @function verify
                         * @memberof clutch.config.service.audit.v1.SinkConfig
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        SinkConfig.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.filter != null && message.hasOwnProperty("filter")) {
                                let error = $root.clutch.config.service.audit.v1.Filter.verify(message.filter);
                                if (error)
                                    return "filter." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a SinkConfig message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.audit.v1.SinkConfig
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.audit.v1.SinkConfig} SinkConfig
                         */
                        SinkConfig.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.audit.v1.SinkConfig)
                                return object;
                            let message = new $root.clutch.config.service.audit.v1.SinkConfig();
                            if (object.filter != null) {
                                if (typeof object.filter !== "object")
                                    throw TypeError(".clutch.config.service.audit.v1.SinkConfig.filter: object expected");
                                message.filter = $root.clutch.config.service.audit.v1.Filter.fromObject(object.filter);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a SinkConfig message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.audit.v1.SinkConfig
                         * @static
                         * @param {clutch.config.service.audit.v1.SinkConfig} message SinkConfig
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        SinkConfig.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.filter = null;
                            if (message.filter != null && message.hasOwnProperty("filter"))
                                object.filter = $root.clutch.config.service.audit.v1.Filter.toObject(message.filter, options);
                            return object;
                        };

                        /**
                         * Converts this SinkConfig to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.audit.v1.SinkConfig
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        SinkConfig.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return SinkConfig;
                    })();

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.audit.v1
                         * @interface IConfig
                         * @property {string|null} [dbProvider] Config dbProvider
                         * @property {clutch.config.service.audit.v1.IFilter|null} [filter] Config filter
                         * @property {Array.<string>|null} [sinks] Config sinks
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.audit.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.audit.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            this.sinks = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config dbProvider.
                         * @member {string} dbProvider
                         * @memberof clutch.config.service.audit.v1.Config
                         * @instance
                         */
                        Config.prototype.dbProvider = "";

                        /**
                         * Config filter.
                         * @member {clutch.config.service.audit.v1.IFilter|null|undefined} filter
                         * @memberof clutch.config.service.audit.v1.Config
                         * @instance
                         */
                        Config.prototype.filter = null;

                        /**
                         * Config sinks.
                         * @member {Array.<string>} sinks
                         * @memberof clutch.config.service.audit.v1.Config
                         * @instance
                         */
                        Config.prototype.sinks = $util.emptyArray;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.audit.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.dbProvider != null && message.hasOwnProperty("dbProvider"))
                                if (!$util.isString(message.dbProvider))
                                    return "dbProvider: string expected";
                            if (message.filter != null && message.hasOwnProperty("filter")) {
                                let error = $root.clutch.config.service.audit.v1.Filter.verify(message.filter);
                                if (error)
                                    return "filter." + error;
                            }
                            if (message.sinks != null && message.hasOwnProperty("sinks")) {
                                if (!Array.isArray(message.sinks))
                                    return "sinks: array expected";
                                for (let i = 0; i < message.sinks.length; ++i)
                                    if (!$util.isString(message.sinks[i]))
                                        return "sinks: string[] expected";
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.audit.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.audit.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.audit.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.audit.v1.Config();
                            if (object.dbProvider != null)
                                message.dbProvider = String(object.dbProvider);
                            if (object.filter != null) {
                                if (typeof object.filter !== "object")
                                    throw TypeError(".clutch.config.service.audit.v1.Config.filter: object expected");
                                message.filter = $root.clutch.config.service.audit.v1.Filter.fromObject(object.filter);
                            }
                            if (object.sinks) {
                                if (!Array.isArray(object.sinks))
                                    throw TypeError(".clutch.config.service.audit.v1.Config.sinks: array expected");
                                message.sinks = [];
                                for (let i = 0; i < object.sinks.length; ++i)
                                    message.sinks[i] = String(object.sinks[i]);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.audit.v1.Config
                         * @static
                         * @param {clutch.config.service.audit.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.sinks = [];
                            if (options.defaults) {
                                object.dbProvider = "";
                                object.filter = null;
                            }
                            if (message.dbProvider != null && message.hasOwnProperty("dbProvider"))
                                object.dbProvider = message.dbProvider;
                            if (message.filter != null && message.hasOwnProperty("filter"))
                                object.filter = $root.clutch.config.service.audit.v1.Filter.toObject(message.filter, options);
                            if (message.sinks && message.sinks.length) {
                                object.sinks = [];
                                for (let j = 0; j < message.sinks.length; ++j)
                                    object.sinks[j] = message.sinks[j];
                            }
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.audit.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return audit;
            })();

            service.authn = (function() {

                /**
                 * Namespace authn.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const authn = {};

                authn.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.authn
                     * @namespace
                     */
                    const v1 = {};

                    v1.OIDC = (function() {

                        /**
                         * Properties of a OIDC.
                         * @memberof clutch.config.service.authn.v1
                         * @interface IOIDC
                         * @property {string|null} [issuer] OIDC issuer
                         * @property {string|null} [clientId] OIDC clientId
                         * @property {string|null} [clientSecret] OIDC clientSecret
                         * @property {string|null} [redirectUrl] OIDC redirectUrl
                         */

                        /**
                         * Constructs a new OIDC.
                         * @memberof clutch.config.service.authn.v1
                         * @classdesc Represents a OIDC.
                         * @implements IOIDC
                         * @constructor
                         * @param {clutch.config.service.authn.v1.IOIDC=} [properties] Properties to set
                         */
                        function OIDC(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * OIDC issuer.
                         * @member {string} issuer
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @instance
                         */
                        OIDC.prototype.issuer = "";

                        /**
                         * OIDC clientId.
                         * @member {string} clientId
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @instance
                         */
                        OIDC.prototype.clientId = "";

                        /**
                         * OIDC clientSecret.
                         * @member {string} clientSecret
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @instance
                         */
                        OIDC.prototype.clientSecret = "";

                        /**
                         * OIDC redirectUrl.
                         * @member {string} redirectUrl
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @instance
                         */
                        OIDC.prototype.redirectUrl = "";

                        /**
                         * Verifies a OIDC message.
                         * @function verify
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        OIDC.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.issuer != null && message.hasOwnProperty("issuer"))
                                if (!$util.isString(message.issuer))
                                    return "issuer: string expected";
                            if (message.clientId != null && message.hasOwnProperty("clientId"))
                                if (!$util.isString(message.clientId))
                                    return "clientId: string expected";
                            if (message.clientSecret != null && message.hasOwnProperty("clientSecret"))
                                if (!$util.isString(message.clientSecret))
                                    return "clientSecret: string expected";
                            if (message.redirectUrl != null && message.hasOwnProperty("redirectUrl"))
                                if (!$util.isString(message.redirectUrl))
                                    return "redirectUrl: string expected";
                            return null;
                        };

                        /**
                         * Creates a OIDC message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authn.v1.OIDC} OIDC
                         */
                        OIDC.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authn.v1.OIDC)
                                return object;
                            let message = new $root.clutch.config.service.authn.v1.OIDC();
                            if (object.issuer != null)
                                message.issuer = String(object.issuer);
                            if (object.clientId != null)
                                message.clientId = String(object.clientId);
                            if (object.clientSecret != null)
                                message.clientSecret = String(object.clientSecret);
                            if (object.redirectUrl != null)
                                message.redirectUrl = String(object.redirectUrl);
                            return message;
                        };

                        /**
                         * Creates a plain object from a OIDC message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @static
                         * @param {clutch.config.service.authn.v1.OIDC} message OIDC
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        OIDC.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.issuer = "";
                                object.clientId = "";
                                object.clientSecret = "";
                                object.redirectUrl = "";
                            }
                            if (message.issuer != null && message.hasOwnProperty("issuer"))
                                object.issuer = message.issuer;
                            if (message.clientId != null && message.hasOwnProperty("clientId"))
                                object.clientId = message.clientId;
                            if (message.clientSecret != null && message.hasOwnProperty("clientSecret"))
                                object.clientSecret = message.clientSecret;
                            if (message.redirectUrl != null && message.hasOwnProperty("redirectUrl"))
                                object.redirectUrl = message.redirectUrl;
                            return object;
                        };

                        /**
                         * Converts this OIDC to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authn.v1.OIDC
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        OIDC.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return OIDC;
                    })();

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.authn.v1
                         * @interface IConfig
                         * @property {string|null} [sessionSecret] Config sessionSecret
                         * @property {clutch.config.service.authn.v1.IOIDC|null} [oidc] Config oidc
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.authn.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.authn.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config sessionSecret.
                         * @member {string} sessionSecret
                         * @memberof clutch.config.service.authn.v1.Config
                         * @instance
                         */
                        Config.prototype.sessionSecret = "";

                        /**
                         * Config oidc.
                         * @member {clutch.config.service.authn.v1.IOIDC|null|undefined} oidc
                         * @memberof clutch.config.service.authn.v1.Config
                         * @instance
                         */
                        Config.prototype.oidc = null;

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * Config type.
                         * @member {"oidc"|undefined} type
                         * @memberof clutch.config.service.authn.v1.Config
                         * @instance
                         */
                        Object.defineProperty(Config.prototype, "type", {
                            get: $util.oneOfGetter($oneOfFields = ["oidc"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.authn.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.sessionSecret != null && message.hasOwnProperty("sessionSecret"))
                                if (!$util.isString(message.sessionSecret))
                                    return "sessionSecret: string expected";
                            if (message.oidc != null && message.hasOwnProperty("oidc")) {
                                properties.type = 1;
                                {
                                    let error = $root.clutch.config.service.authn.v1.OIDC.verify(message.oidc);
                                    if (error)
                                        return "oidc." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authn.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authn.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authn.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.authn.v1.Config();
                            if (object.sessionSecret != null)
                                message.sessionSecret = String(object.sessionSecret);
                            if (object.oidc != null) {
                                if (typeof object.oidc !== "object")
                                    throw TypeError(".clutch.config.service.authn.v1.Config.oidc: object expected");
                                message.oidc = $root.clutch.config.service.authn.v1.OIDC.fromObject(object.oidc);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authn.v1.Config
                         * @static
                         * @param {clutch.config.service.authn.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults)
                                object.sessionSecret = "";
                            if (message.sessionSecret != null && message.hasOwnProperty("sessionSecret"))
                                object.sessionSecret = message.sessionSecret;
                            if (message.oidc != null && message.hasOwnProperty("oidc")) {
                                object.oidc = $root.clutch.config.service.authn.v1.OIDC.toObject(message.oidc, options);
                                if (options.oneofs)
                                    object.type = "oidc";
                            }
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authn.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return authn;
            })();

            service.authz = (function() {

                /**
                 * Namespace authz.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const authz = {};

                authz.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.authz
                     * @namespace
                     */
                    const v1 = {};

                    v1.Principal = (function() {

                        /**
                         * Properties of a Principal.
                         * @memberof clutch.config.service.authz.v1
                         * @interface IPrincipal
                         * @property {string|null} [user] Principal user
                         * @property {string|null} [group] Principal group
                         */

                        /**
                         * Constructs a new Principal.
                         * @memberof clutch.config.service.authz.v1
                         * @classdesc Represents a Principal.
                         * @implements IPrincipal
                         * @constructor
                         * @param {clutch.config.service.authz.v1.IPrincipal=} [properties] Properties to set
                         */
                        function Principal(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Principal user.
                         * @member {string} user
                         * @memberof clutch.config.service.authz.v1.Principal
                         * @instance
                         */
                        Principal.prototype.user = "";

                        /**
                         * Principal group.
                         * @member {string} group
                         * @memberof clutch.config.service.authz.v1.Principal
                         * @instance
                         */
                        Principal.prototype.group = "";

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * Principal type.
                         * @member {"user"|"group"|undefined} type
                         * @memberof clutch.config.service.authz.v1.Principal
                         * @instance
                         */
                        Object.defineProperty(Principal.prototype, "type", {
                            get: $util.oneOfGetter($oneOfFields = ["user", "group"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Verifies a Principal message.
                         * @function verify
                         * @memberof clutch.config.service.authz.v1.Principal
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Principal.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.user != null && message.hasOwnProperty("user")) {
                                properties.type = 1;
                                if (!$util.isString(message.user))
                                    return "user: string expected";
                            }
                            if (message.group != null && message.hasOwnProperty("group")) {
                                if (properties.type === 1)
                                    return "type: multiple values";
                                properties.type = 1;
                                if (!$util.isString(message.group))
                                    return "group: string expected";
                            }
                            return null;
                        };

                        /**
                         * Creates a Principal message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authz.v1.Principal
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authz.v1.Principal} Principal
                         */
                        Principal.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authz.v1.Principal)
                                return object;
                            let message = new $root.clutch.config.service.authz.v1.Principal();
                            if (object.user != null)
                                message.user = String(object.user);
                            if (object.group != null)
                                message.group = String(object.group);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Principal message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authz.v1.Principal
                         * @static
                         * @param {clutch.config.service.authz.v1.Principal} message Principal
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Principal.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (message.user != null && message.hasOwnProperty("user")) {
                                object.user = message.user;
                                if (options.oneofs)
                                    object.type = "user";
                            }
                            if (message.group != null && message.hasOwnProperty("group")) {
                                object.group = message.group;
                                if (options.oneofs)
                                    object.type = "group";
                            }
                            return object;
                        };

                        /**
                         * Converts this Principal to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authz.v1.Principal
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Principal.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Principal;
                    })();

                    v1.RoleBinding = (function() {

                        /**
                         * Properties of a RoleBinding.
                         * @memberof clutch.config.service.authz.v1
                         * @interface IRoleBinding
                         * @property {Array.<string>|null} [to] RoleBinding to
                         * @property {Array.<clutch.config.service.authz.v1.IPrincipal>|null} [principals] RoleBinding principals
                         */

                        /**
                         * Constructs a new RoleBinding.
                         * @memberof clutch.config.service.authz.v1
                         * @classdesc Represents a RoleBinding.
                         * @implements IRoleBinding
                         * @constructor
                         * @param {clutch.config.service.authz.v1.IRoleBinding=} [properties] Properties to set
                         */
                        function RoleBinding(properties) {
                            this.to = [];
                            this.principals = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * RoleBinding to.
                         * @member {Array.<string>} to
                         * @memberof clutch.config.service.authz.v1.RoleBinding
                         * @instance
                         */
                        RoleBinding.prototype.to = $util.emptyArray;

                        /**
                         * RoleBinding principals.
                         * @member {Array.<clutch.config.service.authz.v1.IPrincipal>} principals
                         * @memberof clutch.config.service.authz.v1.RoleBinding
                         * @instance
                         */
                        RoleBinding.prototype.principals = $util.emptyArray;

                        /**
                         * Verifies a RoleBinding message.
                         * @function verify
                         * @memberof clutch.config.service.authz.v1.RoleBinding
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        RoleBinding.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.to != null && message.hasOwnProperty("to")) {
                                if (!Array.isArray(message.to))
                                    return "to: array expected";
                                for (let i = 0; i < message.to.length; ++i)
                                    if (!$util.isString(message.to[i]))
                                        return "to: string[] expected";
                            }
                            if (message.principals != null && message.hasOwnProperty("principals")) {
                                if (!Array.isArray(message.principals))
                                    return "principals: array expected";
                                for (let i = 0; i < message.principals.length; ++i) {
                                    let error = $root.clutch.config.service.authz.v1.Principal.verify(message.principals[i]);
                                    if (error)
                                        return "principals." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a RoleBinding message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authz.v1.RoleBinding
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authz.v1.RoleBinding} RoleBinding
                         */
                        RoleBinding.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authz.v1.RoleBinding)
                                return object;
                            let message = new $root.clutch.config.service.authz.v1.RoleBinding();
                            if (object.to) {
                                if (!Array.isArray(object.to))
                                    throw TypeError(".clutch.config.service.authz.v1.RoleBinding.to: array expected");
                                message.to = [];
                                for (let i = 0; i < object.to.length; ++i)
                                    message.to[i] = String(object.to[i]);
                            }
                            if (object.principals) {
                                if (!Array.isArray(object.principals))
                                    throw TypeError(".clutch.config.service.authz.v1.RoleBinding.principals: array expected");
                                message.principals = [];
                                for (let i = 0; i < object.principals.length; ++i) {
                                    if (typeof object.principals[i] !== "object")
                                        throw TypeError(".clutch.config.service.authz.v1.RoleBinding.principals: object expected");
                                    message.principals[i] = $root.clutch.config.service.authz.v1.Principal.fromObject(object.principals[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a RoleBinding message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authz.v1.RoleBinding
                         * @static
                         * @param {clutch.config.service.authz.v1.RoleBinding} message RoleBinding
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        RoleBinding.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.to = [];
                                object.principals = [];
                            }
                            if (message.to && message.to.length) {
                                object.to = [];
                                for (let j = 0; j < message.to.length; ++j)
                                    object.to[j] = message.to[j];
                            }
                            if (message.principals && message.principals.length) {
                                object.principals = [];
                                for (let j = 0; j < message.principals.length; ++j)
                                    object.principals[j] = $root.clutch.config.service.authz.v1.Principal.toObject(message.principals[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this RoleBinding to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authz.v1.RoleBinding
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        RoleBinding.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return RoleBinding;
                    })();

                    v1.Policy = (function() {

                        /**
                         * Properties of a Policy.
                         * @memberof clutch.config.service.authz.v1
                         * @interface IPolicy
                         * @property {string|null} [policyName] Policy policyName
                         * @property {Array.<clutch.api.v1.ActionType>|null} [actionTypes] Policy actionTypes
                         * @property {string|null} [method] Policy method
                         * @property {Array.<string>|null} [resources] Policy resources
                         */

                        /**
                         * Constructs a new Policy.
                         * @memberof clutch.config.service.authz.v1
                         * @classdesc Represents a Policy.
                         * @implements IPolicy
                         * @constructor
                         * @param {clutch.config.service.authz.v1.IPolicy=} [properties] Properties to set
                         */
                        function Policy(properties) {
                            this.actionTypes = [];
                            this.resources = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Policy policyName.
                         * @member {string} policyName
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @instance
                         */
                        Policy.prototype.policyName = "";

                        /**
                         * Policy actionTypes.
                         * @member {Array.<clutch.api.v1.ActionType>} actionTypes
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @instance
                         */
                        Policy.prototype.actionTypes = $util.emptyArray;

                        /**
                         * Policy method.
                         * @member {string} method
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @instance
                         */
                        Policy.prototype.method = "";

                        /**
                         * Policy resources.
                         * @member {Array.<string>} resources
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @instance
                         */
                        Policy.prototype.resources = $util.emptyArray;

                        /**
                         * Verifies a Policy message.
                         * @function verify
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Policy.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.policyName != null && message.hasOwnProperty("policyName"))
                                if (!$util.isString(message.policyName))
                                    return "policyName: string expected";
                            if (message.actionTypes != null && message.hasOwnProperty("actionTypes")) {
                                if (!Array.isArray(message.actionTypes))
                                    return "actionTypes: array expected";
                                for (let i = 0; i < message.actionTypes.length; ++i)
                                    switch (message.actionTypes[i]) {
                                    default:
                                        return "actionTypes: enum value[] expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                    case 4:
                                        break;
                                    }
                            }
                            if (message.method != null && message.hasOwnProperty("method"))
                                if (!$util.isString(message.method))
                                    return "method: string expected";
                            if (message.resources != null && message.hasOwnProperty("resources")) {
                                if (!Array.isArray(message.resources))
                                    return "resources: array expected";
                                for (let i = 0; i < message.resources.length; ++i)
                                    if (!$util.isString(message.resources[i]))
                                        return "resources: string[] expected";
                            }
                            return null;
                        };

                        /**
                         * Creates a Policy message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authz.v1.Policy} Policy
                         */
                        Policy.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authz.v1.Policy)
                                return object;
                            let message = new $root.clutch.config.service.authz.v1.Policy();
                            if (object.policyName != null)
                                message.policyName = String(object.policyName);
                            if (object.actionTypes) {
                                if (!Array.isArray(object.actionTypes))
                                    throw TypeError(".clutch.config.service.authz.v1.Policy.actionTypes: array expected");
                                message.actionTypes = [];
                                for (let i = 0; i < object.actionTypes.length; ++i)
                                    switch (object.actionTypes[i]) {
                                    default:
                                    case "UNSPECIFIED":
                                    case 0:
                                        message.actionTypes[i] = 0;
                                        break;
                                    case "CREATE":
                                    case 1:
                                        message.actionTypes[i] = 1;
                                        break;
                                    case "READ":
                                    case 2:
                                        message.actionTypes[i] = 2;
                                        break;
                                    case "UPDATE":
                                    case 3:
                                        message.actionTypes[i] = 3;
                                        break;
                                    case "DELETE":
                                    case 4:
                                        message.actionTypes[i] = 4;
                                        break;
                                    }
                            }
                            if (object.method != null)
                                message.method = String(object.method);
                            if (object.resources) {
                                if (!Array.isArray(object.resources))
                                    throw TypeError(".clutch.config.service.authz.v1.Policy.resources: array expected");
                                message.resources = [];
                                for (let i = 0; i < object.resources.length; ++i)
                                    message.resources[i] = String(object.resources[i]);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Policy message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @static
                         * @param {clutch.config.service.authz.v1.Policy} message Policy
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Policy.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.actionTypes = [];
                                object.resources = [];
                            }
                            if (options.defaults) {
                                object.policyName = "";
                                object.method = "";
                            }
                            if (message.policyName != null && message.hasOwnProperty("policyName"))
                                object.policyName = message.policyName;
                            if (message.actionTypes && message.actionTypes.length) {
                                object.actionTypes = [];
                                for (let j = 0; j < message.actionTypes.length; ++j)
                                    object.actionTypes[j] = options.enums === String ? $root.clutch.api.v1.ActionType[message.actionTypes[j]] : message.actionTypes[j];
                            }
                            if (message.method != null && message.hasOwnProperty("method"))
                                object.method = message.method;
                            if (message.resources && message.resources.length) {
                                object.resources = [];
                                for (let j = 0; j < message.resources.length; ++j)
                                    object.resources[j] = message.resources[j];
                            }
                            return object;
                        };

                        /**
                         * Converts this Policy to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authz.v1.Policy
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Policy.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Policy;
                    })();

                    v1.Role = (function() {

                        /**
                         * Properties of a Role.
                         * @memberof clutch.config.service.authz.v1
                         * @interface IRole
                         * @property {string|null} [roleName] Role roleName
                         * @property {Array.<clutch.config.service.authz.v1.IPolicy>|null} [policies] Role policies
                         */

                        /**
                         * Constructs a new Role.
                         * @memberof clutch.config.service.authz.v1
                         * @classdesc Represents a Role.
                         * @implements IRole
                         * @constructor
                         * @param {clutch.config.service.authz.v1.IRole=} [properties] Properties to set
                         */
                        function Role(properties) {
                            this.policies = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Role roleName.
                         * @member {string} roleName
                         * @memberof clutch.config.service.authz.v1.Role
                         * @instance
                         */
                        Role.prototype.roleName = "";

                        /**
                         * Role policies.
                         * @member {Array.<clutch.config.service.authz.v1.IPolicy>} policies
                         * @memberof clutch.config.service.authz.v1.Role
                         * @instance
                         */
                        Role.prototype.policies = $util.emptyArray;

                        /**
                         * Verifies a Role message.
                         * @function verify
                         * @memberof clutch.config.service.authz.v1.Role
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Role.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.roleName != null && message.hasOwnProperty("roleName"))
                                if (!$util.isString(message.roleName))
                                    return "roleName: string expected";
                            if (message.policies != null && message.hasOwnProperty("policies")) {
                                if (!Array.isArray(message.policies))
                                    return "policies: array expected";
                                for (let i = 0; i < message.policies.length; ++i) {
                                    let error = $root.clutch.config.service.authz.v1.Policy.verify(message.policies[i]);
                                    if (error)
                                        return "policies." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Role message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authz.v1.Role
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authz.v1.Role} Role
                         */
                        Role.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authz.v1.Role)
                                return object;
                            let message = new $root.clutch.config.service.authz.v1.Role();
                            if (object.roleName != null)
                                message.roleName = String(object.roleName);
                            if (object.policies) {
                                if (!Array.isArray(object.policies))
                                    throw TypeError(".clutch.config.service.authz.v1.Role.policies: array expected");
                                message.policies = [];
                                for (let i = 0; i < object.policies.length; ++i) {
                                    if (typeof object.policies[i] !== "object")
                                        throw TypeError(".clutch.config.service.authz.v1.Role.policies: object expected");
                                    message.policies[i] = $root.clutch.config.service.authz.v1.Policy.fromObject(object.policies[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Role message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authz.v1.Role
                         * @static
                         * @param {clutch.config.service.authz.v1.Role} message Role
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Role.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.policies = [];
                            if (options.defaults)
                                object.roleName = "";
                            if (message.roleName != null && message.hasOwnProperty("roleName"))
                                object.roleName = message.roleName;
                            if (message.policies && message.policies.length) {
                                object.policies = [];
                                for (let j = 0; j < message.policies.length; ++j)
                                    object.policies[j] = $root.clutch.config.service.authz.v1.Policy.toObject(message.policies[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Role to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authz.v1.Role
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Role.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Role;
                    })();

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.authz.v1
                         * @interface IConfig
                         * @property {Array.<clutch.config.service.authz.v1.IRoleBinding>|null} [roleBindings] Config roleBindings
                         * @property {Array.<clutch.config.service.authz.v1.IRole>|null} [roles] Config roles
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.authz.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.authz.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            this.roleBindings = [];
                            this.roles = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config roleBindings.
                         * @member {Array.<clutch.config.service.authz.v1.IRoleBinding>} roleBindings
                         * @memberof clutch.config.service.authz.v1.Config
                         * @instance
                         */
                        Config.prototype.roleBindings = $util.emptyArray;

                        /**
                         * Config roles.
                         * @member {Array.<clutch.config.service.authz.v1.IRole>} roles
                         * @memberof clutch.config.service.authz.v1.Config
                         * @instance
                         */
                        Config.prototype.roles = $util.emptyArray;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.authz.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.roleBindings != null && message.hasOwnProperty("roleBindings")) {
                                if (!Array.isArray(message.roleBindings))
                                    return "roleBindings: array expected";
                                for (let i = 0; i < message.roleBindings.length; ++i) {
                                    let error = $root.clutch.config.service.authz.v1.RoleBinding.verify(message.roleBindings[i]);
                                    if (error)
                                        return "roleBindings." + error;
                                }
                            }
                            if (message.roles != null && message.hasOwnProperty("roles")) {
                                if (!Array.isArray(message.roles))
                                    return "roles: array expected";
                                for (let i = 0; i < message.roles.length; ++i) {
                                    let error = $root.clutch.config.service.authz.v1.Role.verify(message.roles[i]);
                                    if (error)
                                        return "roles." + error;
                                }
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.authz.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.authz.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.authz.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.authz.v1.Config();
                            if (object.roleBindings) {
                                if (!Array.isArray(object.roleBindings))
                                    throw TypeError(".clutch.config.service.authz.v1.Config.roleBindings: array expected");
                                message.roleBindings = [];
                                for (let i = 0; i < object.roleBindings.length; ++i) {
                                    if (typeof object.roleBindings[i] !== "object")
                                        throw TypeError(".clutch.config.service.authz.v1.Config.roleBindings: object expected");
                                    message.roleBindings[i] = $root.clutch.config.service.authz.v1.RoleBinding.fromObject(object.roleBindings[i]);
                                }
                            }
                            if (object.roles) {
                                if (!Array.isArray(object.roles))
                                    throw TypeError(".clutch.config.service.authz.v1.Config.roles: array expected");
                                message.roles = [];
                                for (let i = 0; i < object.roles.length; ++i) {
                                    if (typeof object.roles[i] !== "object")
                                        throw TypeError(".clutch.config.service.authz.v1.Config.roles: object expected");
                                    message.roles[i] = $root.clutch.config.service.authz.v1.Role.fromObject(object.roles[i]);
                                }
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.authz.v1.Config
                         * @static
                         * @param {clutch.config.service.authz.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults) {
                                object.roleBindings = [];
                                object.roles = [];
                            }
                            if (message.roleBindings && message.roleBindings.length) {
                                object.roleBindings = [];
                                for (let j = 0; j < message.roleBindings.length; ++j)
                                    object.roleBindings[j] = $root.clutch.config.service.authz.v1.RoleBinding.toObject(message.roleBindings[j], options);
                            }
                            if (message.roles && message.roles.length) {
                                object.roles = [];
                                for (let j = 0; j < message.roles.length; ++j)
                                    object.roles[j] = $root.clutch.config.service.authz.v1.Role.toObject(message.roles[j], options);
                            }
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.authz.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return authz;
            })();

            service.aws = (function() {

                /**
                 * Namespace aws.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const aws = {};

                aws.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.aws
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.aws.v1
                         * @interface IConfig
                         * @property {Array.<string>|null} [regions] Config regions
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.aws.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.aws.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            this.regions = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config regions.
                         * @member {Array.<string>} regions
                         * @memberof clutch.config.service.aws.v1.Config
                         * @instance
                         */
                        Config.prototype.regions = $util.emptyArray;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.aws.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.regions != null && message.hasOwnProperty("regions")) {
                                if (!Array.isArray(message.regions))
                                    return "regions: array expected";
                                for (let i = 0; i < message.regions.length; ++i)
                                    if (!$util.isString(message.regions[i]))
                                        return "regions: string[] expected";
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.aws.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.aws.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.aws.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.aws.v1.Config();
                            if (object.regions) {
                                if (!Array.isArray(object.regions))
                                    throw TypeError(".clutch.config.service.aws.v1.Config.regions: array expected");
                                message.regions = [];
                                for (let i = 0; i < object.regions.length; ++i)
                                    message.regions[i] = String(object.regions[i]);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.aws.v1.Config
                         * @static
                         * @param {clutch.config.service.aws.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.regions = [];
                            if (message.regions && message.regions.length) {
                                object.regions = [];
                                for (let j = 0; j < message.regions.length; ++j)
                                    object.regions[j] = message.regions[j];
                            }
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.aws.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return aws;
            })();

            service.db = (function() {

                /**
                 * Namespace db.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const db = {};

                db.postgres = (function() {

                    /**
                     * Namespace postgres.
                     * @memberof clutch.config.service.db
                     * @namespace
                     */
                    const postgres = {};

                    postgres.v1 = (function() {

                        /**
                         * Namespace v1.
                         * @memberof clutch.config.service.db.postgres
                         * @namespace
                         */
                        const v1 = {};

                        v1.Connection = (function() {

                            /**
                             * Properties of a Connection.
                             * @memberof clutch.config.service.db.postgres.v1
                             * @interface IConnection
                             * @property {string|null} [host] Connection host
                             * @property {number|null} [port] Connection port
                             * @property {string|null} [user] Connection user
                             * @property {string|null} [dbname] Connection dbname
                             * @property {clutch.config.service.db.postgres.v1.Connection.SSLMode|null} [sslMode] Connection sslMode
                             * @property {string|null} [password] Connection password
                             */

                            /**
                             * Constructs a new Connection.
                             * @memberof clutch.config.service.db.postgres.v1
                             * @classdesc Represents a Connection.
                             * @implements IConnection
                             * @constructor
                             * @param {clutch.config.service.db.postgres.v1.IConnection=} [properties] Properties to set
                             */
                            function Connection(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Connection host.
                             * @member {string} host
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             */
                            Connection.prototype.host = "";

                            /**
                             * Connection port.
                             * @member {number} port
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             */
                            Connection.prototype.port = 0;

                            /**
                             * Connection user.
                             * @member {string} user
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             */
                            Connection.prototype.user = "";

                            /**
                             * Connection dbname.
                             * @member {string} dbname
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             */
                            Connection.prototype.dbname = "";

                            /**
                             * Connection sslMode.
                             * @member {clutch.config.service.db.postgres.v1.Connection.SSLMode} sslMode
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             */
                            Connection.prototype.sslMode = 0;

                            /**
                             * Connection password.
                             * @member {string} password
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             */
                            Connection.prototype.password = "";

                            // OneOf field names bound to virtual getters and setters
                            let $oneOfFields;

                            /**
                             * Connection authn.
                             * @member {"password"|undefined} authn
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             */
                            Object.defineProperty(Connection.prototype, "authn", {
                                get: $util.oneOfGetter($oneOfFields = ["password"]),
                                set: $util.oneOfSetter($oneOfFields)
                            });

                            /**
                             * Verifies a Connection message.
                             * @function verify
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Connection.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                let properties = {};
                                if (message.host != null && message.hasOwnProperty("host"))
                                    if (!$util.isString(message.host))
                                        return "host: string expected";
                                if (message.port != null && message.hasOwnProperty("port"))
                                    if (!$util.isInteger(message.port))
                                        return "port: integer expected";
                                if (message.user != null && message.hasOwnProperty("user"))
                                    if (!$util.isString(message.user))
                                        return "user: string expected";
                                if (message.dbname != null && message.hasOwnProperty("dbname"))
                                    if (!$util.isString(message.dbname))
                                        return "dbname: string expected";
                                if (message.sslMode != null && message.hasOwnProperty("sslMode"))
                                    switch (message.sslMode) {
                                    default:
                                        return "sslMode: enum value expected";
                                    case 0:
                                    case 1:
                                    case 2:
                                    case 3:
                                    case 4:
                                    case 5:
                                    case 6:
                                        break;
                                    }
                                if (message.password != null && message.hasOwnProperty("password")) {
                                    properties.authn = 1;
                                    if (!$util.isString(message.password))
                                        return "password: string expected";
                                }
                                return null;
                            };

                            /**
                             * Creates a Connection message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {clutch.config.service.db.postgres.v1.Connection} Connection
                             */
                            Connection.fromObject = function fromObject(object) {
                                if (object instanceof $root.clutch.config.service.db.postgres.v1.Connection)
                                    return object;
                                let message = new $root.clutch.config.service.db.postgres.v1.Connection();
                                if (object.host != null)
                                    message.host = String(object.host);
                                if (object.port != null)
                                    message.port = object.port >>> 0;
                                if (object.user != null)
                                    message.user = String(object.user);
                                if (object.dbname != null)
                                    message.dbname = String(object.dbname);
                                switch (object.sslMode) {
                                case "UNSPECIFIED":
                                case 0:
                                    message.sslMode = 0;
                                    break;
                                case "DISABLE":
                                case 1:
                                    message.sslMode = 1;
                                    break;
                                case "ALLOW":
                                case 2:
                                    message.sslMode = 2;
                                    break;
                                case "PREFER":
                                case 3:
                                    message.sslMode = 3;
                                    break;
                                case "REQUIRE":
                                case 4:
                                    message.sslMode = 4;
                                    break;
                                case "VERIFY_CA":
                                case 5:
                                    message.sslMode = 5;
                                    break;
                                case "VERIFY_FULL":
                                case 6:
                                    message.sslMode = 6;
                                    break;
                                }
                                if (object.password != null)
                                    message.password = String(object.password);
                                return message;
                            };

                            /**
                             * Creates a plain object from a Connection message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @static
                             * @param {clutch.config.service.db.postgres.v1.Connection} message Connection
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Connection.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults) {
                                    object.host = "";
                                    object.port = 0;
                                    object.user = "";
                                    object.dbname = "";
                                    object.sslMode = options.enums === String ? "UNSPECIFIED" : 0;
                                }
                                if (message.host != null && message.hasOwnProperty("host"))
                                    object.host = message.host;
                                if (message.port != null && message.hasOwnProperty("port"))
                                    object.port = message.port;
                                if (message.user != null && message.hasOwnProperty("user"))
                                    object.user = message.user;
                                if (message.dbname != null && message.hasOwnProperty("dbname"))
                                    object.dbname = message.dbname;
                                if (message.sslMode != null && message.hasOwnProperty("sslMode"))
                                    object.sslMode = options.enums === String ? $root.clutch.config.service.db.postgres.v1.Connection.SSLMode[message.sslMode] : message.sslMode;
                                if (message.password != null && message.hasOwnProperty("password")) {
                                    object.password = message.password;
                                    if (options.oneofs)
                                        object.authn = "password";
                                }
                                return object;
                            };

                            /**
                             * Converts this Connection to JSON.
                             * @function toJSON
                             * @memberof clutch.config.service.db.postgres.v1.Connection
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Connection.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            /**
                             * SSLMode enum.
                             * @name clutch.config.service.db.postgres.v1.Connection.SSLMode
                             * @enum {number}
                             * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                             * @property {number} DISABLE=1 DISABLE value
                             * @property {number} ALLOW=2 ALLOW value
                             * @property {number} PREFER=3 PREFER value
                             * @property {number} REQUIRE=4 REQUIRE value
                             * @property {number} VERIFY_CA=5 VERIFY_CA value
                             * @property {number} VERIFY_FULL=6 VERIFY_FULL value
                             */
                            Connection.SSLMode = (function() {
                                const valuesById = {}, values = Object.create(valuesById);
                                values[valuesById[0] = "UNSPECIFIED"] = 0;
                                values[valuesById[1] = "DISABLE"] = 1;
                                values[valuesById[2] = "ALLOW"] = 2;
                                values[valuesById[3] = "PREFER"] = 3;
                                values[valuesById[4] = "REQUIRE"] = 4;
                                values[valuesById[5] = "VERIFY_CA"] = 5;
                                values[valuesById[6] = "VERIFY_FULL"] = 6;
                                return values;
                            })();

                            return Connection;
                        })();

                        v1.Config = (function() {

                            /**
                             * Properties of a Config.
                             * @memberof clutch.config.service.db.postgres.v1
                             * @interface IConfig
                             * @property {clutch.config.service.db.postgres.v1.IConnection|null} [connection] Config connection
                             */

                            /**
                             * Constructs a new Config.
                             * @memberof clutch.config.service.db.postgres.v1
                             * @classdesc Represents a Config.
                             * @implements IConfig
                             * @constructor
                             * @param {clutch.config.service.db.postgres.v1.IConfig=} [properties] Properties to set
                             */
                            function Config(properties) {
                                if (properties)
                                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                        if (properties[keys[i]] != null)
                                            this[keys[i]] = properties[keys[i]];
                            }

                            /**
                             * Config connection.
                             * @member {clutch.config.service.db.postgres.v1.IConnection|null|undefined} connection
                             * @memberof clutch.config.service.db.postgres.v1.Config
                             * @instance
                             */
                            Config.prototype.connection = null;

                            /**
                             * Verifies a Config message.
                             * @function verify
                             * @memberof clutch.config.service.db.postgres.v1.Config
                             * @static
                             * @param {Object.<string,*>} message Plain object to verify
                             * @returns {string|null} `null` if valid, otherwise the reason why it is not
                             */
                            Config.verify = function verify(message) {
                                if (typeof message !== "object" || message === null)
                                    return "object expected";
                                if (message.connection != null && message.hasOwnProperty("connection")) {
                                    let error = $root.clutch.config.service.db.postgres.v1.Connection.verify(message.connection);
                                    if (error)
                                        return "connection." + error;
                                }
                                return null;
                            };

                            /**
                             * Creates a Config message from a plain object. Also converts values to their respective internal types.
                             * @function fromObject
                             * @memberof clutch.config.service.db.postgres.v1.Config
                             * @static
                             * @param {Object.<string,*>} object Plain object
                             * @returns {clutch.config.service.db.postgres.v1.Config} Config
                             */
                            Config.fromObject = function fromObject(object) {
                                if (object instanceof $root.clutch.config.service.db.postgres.v1.Config)
                                    return object;
                                let message = new $root.clutch.config.service.db.postgres.v1.Config();
                                if (object.connection != null) {
                                    if (typeof object.connection !== "object")
                                        throw TypeError(".clutch.config.service.db.postgres.v1.Config.connection: object expected");
                                    message.connection = $root.clutch.config.service.db.postgres.v1.Connection.fromObject(object.connection);
                                }
                                return message;
                            };

                            /**
                             * Creates a plain object from a Config message. Also converts values to other types if specified.
                             * @function toObject
                             * @memberof clutch.config.service.db.postgres.v1.Config
                             * @static
                             * @param {clutch.config.service.db.postgres.v1.Config} message Config
                             * @param {$protobuf.IConversionOptions} [options] Conversion options
                             * @returns {Object.<string,*>} Plain object
                             */
                            Config.toObject = function toObject(message, options) {
                                if (!options)
                                    options = {};
                                let object = {};
                                if (options.defaults)
                                    object.connection = null;
                                if (message.connection != null && message.hasOwnProperty("connection"))
                                    object.connection = $root.clutch.config.service.db.postgres.v1.Connection.toObject(message.connection, options);
                                return object;
                            };

                            /**
                             * Converts this Config to JSON.
                             * @function toJSON
                             * @memberof clutch.config.service.db.postgres.v1.Config
                             * @instance
                             * @returns {Object.<string,*>} JSON object
                             */
                            Config.prototype.toJSON = function toJSON() {
                                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                            };

                            return Config;
                        })();

                        return v1;
                    })();

                    return postgres;
                })();

                return db;
            })();

            service.envoyadmin = (function() {

                /**
                 * Namespace envoyadmin.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const envoyadmin = {};

                envoyadmin.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.envoyadmin
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.envoyadmin.v1
                         * @interface IConfig
                         * @property {boolean|null} [secure] Config secure
                         * @property {number|null} [defaultRemotePort] Config defaultRemotePort
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.envoyadmin.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.envoyadmin.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config secure.
                         * @member {boolean} secure
                         * @memberof clutch.config.service.envoyadmin.v1.Config
                         * @instance
                         */
                        Config.prototype.secure = false;

                        /**
                         * Config defaultRemotePort.
                         * @member {number} defaultRemotePort
                         * @memberof clutch.config.service.envoyadmin.v1.Config
                         * @instance
                         */
                        Config.prototype.defaultRemotePort = 0;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.envoyadmin.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.secure != null && message.hasOwnProperty("secure"))
                                if (typeof message.secure !== "boolean")
                                    return "secure: boolean expected";
                            if (message.defaultRemotePort != null && message.hasOwnProperty("defaultRemotePort"))
                                if (!$util.isInteger(message.defaultRemotePort))
                                    return "defaultRemotePort: integer expected";
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.envoyadmin.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.envoyadmin.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.envoyadmin.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.envoyadmin.v1.Config();
                            if (object.secure != null)
                                message.secure = Boolean(object.secure);
                            if (object.defaultRemotePort != null)
                                message.defaultRemotePort = object.defaultRemotePort >>> 0;
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.envoyadmin.v1.Config
                         * @static
                         * @param {clutch.config.service.envoyadmin.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.secure = false;
                                object.defaultRemotePort = 0;
                            }
                            if (message.secure != null && message.hasOwnProperty("secure"))
                                object.secure = message.secure;
                            if (message.defaultRemotePort != null && message.hasOwnProperty("defaultRemotePort"))
                                object.defaultRemotePort = message.defaultRemotePort;
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.envoyadmin.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return envoyadmin;
            })();

            service.github = (function() {

                /**
                 * Namespace github.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const github = {};

                github.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.github
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.github.v1
                         * @interface IConfig
                         * @property {string|null} [accessToken] Config accessToken
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.github.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.github.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config accessToken.
                         * @member {string} accessToken
                         * @memberof clutch.config.service.github.v1.Config
                         * @instance
                         */
                        Config.prototype.accessToken = "";

                        // OneOf field names bound to virtual getters and setters
                        let $oneOfFields;

                        /**
                         * Config auth.
                         * @member {"accessToken"|undefined} auth
                         * @memberof clutch.config.service.github.v1.Config
                         * @instance
                         */
                        Object.defineProperty(Config.prototype, "auth", {
                            get: $util.oneOfGetter($oneOfFields = ["accessToken"]),
                            set: $util.oneOfSetter($oneOfFields)
                        });

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.github.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            let properties = {};
                            if (message.accessToken != null && message.hasOwnProperty("accessToken")) {
                                properties.auth = 1;
                                if (!$util.isString(message.accessToken))
                                    return "accessToken: string expected";
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.github.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.github.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.github.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.github.v1.Config();
                            if (object.accessToken != null)
                                message.accessToken = String(object.accessToken);
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.github.v1.Config
                         * @static
                         * @param {clutch.config.service.github.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (message.accessToken != null && message.hasOwnProperty("accessToken")) {
                                object.accessToken = message.accessToken;
                                if (options.oneofs)
                                    object.auth = "accessToken";
                            }
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.github.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    return v1;
                })();

                return github;
            })();

            service.k8s = (function() {

                /**
                 * Namespace k8s.
                 * @memberof clutch.config.service
                 * @namespace
                 */
                const k8s = {};

                k8s.v1 = (function() {

                    /**
                     * Namespace v1.
                     * @memberof clutch.config.service.k8s
                     * @namespace
                     */
                    const v1 = {};

                    v1.Config = (function() {

                        /**
                         * Properties of a Config.
                         * @memberof clutch.config.service.k8s.v1
                         * @interface IConfig
                         * @property {Array.<string>|null} [kubeconfigs] Config kubeconfigs
                         * @property {clutch.config.service.k8s.v1.IRestClientConfig|null} [restClientConfig] Config restClientConfig
                         */

                        /**
                         * Constructs a new Config.
                         * @memberof clutch.config.service.k8s.v1
                         * @classdesc Represents a Config.
                         * @implements IConfig
                         * @constructor
                         * @param {clutch.config.service.k8s.v1.IConfig=} [properties] Properties to set
                         */
                        function Config(properties) {
                            this.kubeconfigs = [];
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * Config kubeconfigs.
                         * @member {Array.<string>} kubeconfigs
                         * @memberof clutch.config.service.k8s.v1.Config
                         * @instance
                         */
                        Config.prototype.kubeconfigs = $util.emptyArray;

                        /**
                         * Config restClientConfig.
                         * @member {clutch.config.service.k8s.v1.IRestClientConfig|null|undefined} restClientConfig
                         * @memberof clutch.config.service.k8s.v1.Config
                         * @instance
                         */
                        Config.prototype.restClientConfig = null;

                        /**
                         * Verifies a Config message.
                         * @function verify
                         * @memberof clutch.config.service.k8s.v1.Config
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        Config.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.kubeconfigs != null && message.hasOwnProperty("kubeconfigs")) {
                                if (!Array.isArray(message.kubeconfigs))
                                    return "kubeconfigs: array expected";
                                for (let i = 0; i < message.kubeconfigs.length; ++i)
                                    if (!$util.isString(message.kubeconfigs[i]))
                                        return "kubeconfigs: string[] expected";
                            }
                            if (message.restClientConfig != null && message.hasOwnProperty("restClientConfig")) {
                                let error = $root.clutch.config.service.k8s.v1.RestClientConfig.verify(message.restClientConfig);
                                if (error)
                                    return "restClientConfig." + error;
                            }
                            return null;
                        };

                        /**
                         * Creates a Config message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.k8s.v1.Config
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.k8s.v1.Config} Config
                         */
                        Config.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.k8s.v1.Config)
                                return object;
                            let message = new $root.clutch.config.service.k8s.v1.Config();
                            if (object.kubeconfigs) {
                                if (!Array.isArray(object.kubeconfigs))
                                    throw TypeError(".clutch.config.service.k8s.v1.Config.kubeconfigs: array expected");
                                message.kubeconfigs = [];
                                for (let i = 0; i < object.kubeconfigs.length; ++i)
                                    message.kubeconfigs[i] = String(object.kubeconfigs[i]);
                            }
                            if (object.restClientConfig != null) {
                                if (typeof object.restClientConfig !== "object")
                                    throw TypeError(".clutch.config.service.k8s.v1.Config.restClientConfig: object expected");
                                message.restClientConfig = $root.clutch.config.service.k8s.v1.RestClientConfig.fromObject(object.restClientConfig);
                            }
                            return message;
                        };

                        /**
                         * Creates a plain object from a Config message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.k8s.v1.Config
                         * @static
                         * @param {clutch.config.service.k8s.v1.Config} message Config
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        Config.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.arrays || options.defaults)
                                object.kubeconfigs = [];
                            if (options.defaults)
                                object.restClientConfig = null;
                            if (message.kubeconfigs && message.kubeconfigs.length) {
                                object.kubeconfigs = [];
                                for (let j = 0; j < message.kubeconfigs.length; ++j)
                                    object.kubeconfigs[j] = message.kubeconfigs[j];
                            }
                            if (message.restClientConfig != null && message.hasOwnProperty("restClientConfig"))
                                object.restClientConfig = $root.clutch.config.service.k8s.v1.RestClientConfig.toObject(message.restClientConfig, options);
                            return object;
                        };

                        /**
                         * Converts this Config to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.k8s.v1.Config
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        Config.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return Config;
                    })();

                    v1.RestClientConfig = (function() {

                        /**
                         * Properties of a RestClientConfig.
                         * @memberof clutch.config.service.k8s.v1
                         * @interface IRestClientConfig
                         * @property {google.protobuf.IDuration|null} [timeout] RestClientConfig timeout
                         * @property {number|null} [qps] RestClientConfig qps
                         * @property {number|null} [burst] RestClientConfig burst
                         */

                        /**
                         * Constructs a new RestClientConfig.
                         * @memberof clutch.config.service.k8s.v1
                         * @classdesc Represents a RestClientConfig.
                         * @implements IRestClientConfig
                         * @constructor
                         * @param {clutch.config.service.k8s.v1.IRestClientConfig=} [properties] Properties to set
                         */
                        function RestClientConfig(properties) {
                            if (properties)
                                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                    if (properties[keys[i]] != null)
                                        this[keys[i]] = properties[keys[i]];
                        }

                        /**
                         * RestClientConfig timeout.
                         * @member {google.protobuf.IDuration|null|undefined} timeout
                         * @memberof clutch.config.service.k8s.v1.RestClientConfig
                         * @instance
                         */
                        RestClientConfig.prototype.timeout = null;

                        /**
                         * RestClientConfig qps.
                         * @member {number} qps
                         * @memberof clutch.config.service.k8s.v1.RestClientConfig
                         * @instance
                         */
                        RestClientConfig.prototype.qps = 0;

                        /**
                         * RestClientConfig burst.
                         * @member {number} burst
                         * @memberof clutch.config.service.k8s.v1.RestClientConfig
                         * @instance
                         */
                        RestClientConfig.prototype.burst = 0;

                        /**
                         * Verifies a RestClientConfig message.
                         * @function verify
                         * @memberof clutch.config.service.k8s.v1.RestClientConfig
                         * @static
                         * @param {Object.<string,*>} message Plain object to verify
                         * @returns {string|null} `null` if valid, otherwise the reason why it is not
                         */
                        RestClientConfig.verify = function verify(message) {
                            if (typeof message !== "object" || message === null)
                                return "object expected";
                            if (message.timeout != null && message.hasOwnProperty("timeout")) {
                                let error = $root.google.protobuf.Duration.verify(message.timeout);
                                if (error)
                                    return "timeout." + error;
                            }
                            if (message.qps != null && message.hasOwnProperty("qps"))
                                if (typeof message.qps !== "number")
                                    return "qps: number expected";
                            if (message.burst != null && message.hasOwnProperty("burst"))
                                if (!$util.isInteger(message.burst))
                                    return "burst: integer expected";
                            return null;
                        };

                        /**
                         * Creates a RestClientConfig message from a plain object. Also converts values to their respective internal types.
                         * @function fromObject
                         * @memberof clutch.config.service.k8s.v1.RestClientConfig
                         * @static
                         * @param {Object.<string,*>} object Plain object
                         * @returns {clutch.config.service.k8s.v1.RestClientConfig} RestClientConfig
                         */
                        RestClientConfig.fromObject = function fromObject(object) {
                            if (object instanceof $root.clutch.config.service.k8s.v1.RestClientConfig)
                                return object;
                            let message = new $root.clutch.config.service.k8s.v1.RestClientConfig();
                            if (object.timeout != null) {
                                if (typeof object.timeout !== "object")
                                    throw TypeError(".clutch.config.service.k8s.v1.RestClientConfig.timeout: object expected");
                                message.timeout = $root.google.protobuf.Duration.fromObject(object.timeout);
                            }
                            if (object.qps != null)
                                message.qps = Number(object.qps);
                            if (object.burst != null)
                                message.burst = object.burst >>> 0;
                            return message;
                        };

                        /**
                         * Creates a plain object from a RestClientConfig message. Also converts values to other types if specified.
                         * @function toObject
                         * @memberof clutch.config.service.k8s.v1.RestClientConfig
                         * @static
                         * @param {clutch.config.service.k8s.v1.RestClientConfig} message RestClientConfig
                         * @param {$protobuf.IConversionOptions} [options] Conversion options
                         * @returns {Object.<string,*>} Plain object
                         */
                        RestClientConfig.toObject = function toObject(message, options) {
                            if (!options)
                                options = {};
                            let object = {};
                            if (options.defaults) {
                                object.timeout = null;
                                object.qps = 0;
                                object.burst = 0;
                            }
                            if (message.timeout != null && message.hasOwnProperty("timeout"))
                                object.timeout = $root.google.protobuf.Duration.toObject(message.timeout, options);
                            if (message.qps != null && message.hasOwnProperty("qps"))
                                object.qps = options.json && !isFinite(message.qps) ? String(message.qps) : message.qps;
                            if (message.burst != null && message.hasOwnProperty("burst"))
                                object.burst = message.burst;
                            return object;
                        };

                        /**
                         * Converts this RestClientConfig to JSON.
                         * @function toJSON
                         * @memberof clutch.config.service.k8s.v1.RestClientConfig
                         * @instance
                         * @returns {Object.<string,*>} JSON object
                         */
                        RestClientConfig.prototype.toJSON = function toJSON() {
                            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                        };

                        return RestClientConfig;
                    })();

                    return v1;
                })();

                return k8s;
            })();

            return service;
        })();

        return config;
    })();

    clutch.envoytriage = (function() {

        /**
         * Namespace envoytriage.
         * @memberof clutch
         * @namespace
         */
        const envoytriage = {};

        envoytriage.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.envoytriage
             * @namespace
             */
            const v1 = {};

            v1.EnvoyTriageAPI = (function() {

                /**
                 * Constructs a new EnvoyTriageAPI service.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents an EnvoyTriageAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function EnvoyTriageAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (EnvoyTriageAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = EnvoyTriageAPI;

                /**
                 * Callback as used by {@link clutch.envoytriage.v1.EnvoyTriageAPI#read}.
                 * @memberof clutch.envoytriage.v1.EnvoyTriageAPI
                 * @typedef ReadCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.envoytriage.v1.ReadResponse} [response] ReadResponse
                 */

                /**
                 * Calls Read.
                 * @function read
                 * @memberof clutch.envoytriage.v1.EnvoyTriageAPI
                 * @instance
                 * @param {clutch.envoytriage.v1.IReadRequest} request ReadRequest message or plain object
                 * @param {clutch.envoytriage.v1.EnvoyTriageAPI.ReadCallback} callback Node-style callback called with the error, if any, and ReadResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(EnvoyTriageAPI.prototype.read = function read(request, callback) {
                    return this.rpcCall(read, $root.clutch.envoytriage.v1.ReadRequest, $root.clutch.envoytriage.v1.ReadResponse, request, callback);
                }, "name", { value: "Read" });

                /**
                 * Calls Read.
                 * @function read
                 * @memberof clutch.envoytriage.v1.EnvoyTriageAPI
                 * @instance
                 * @param {clutch.envoytriage.v1.IReadRequest} request ReadRequest message or plain object
                 * @returns {Promise<clutch.envoytriage.v1.ReadResponse>} Promise
                 * @variation 2
                 */

                return EnvoyTriageAPI;
            })();

            v1.ReadRequest = (function() {

                /**
                 * Properties of a ReadRequest.
                 * @memberof clutch.envoytriage.v1
                 * @interface IReadRequest
                 * @property {Array.<clutch.envoytriage.v1.IReadOperation>|null} [operations] ReadRequest operations
                 */

                /**
                 * Constructs a new ReadRequest.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a ReadRequest.
                 * @implements IReadRequest
                 * @constructor
                 * @param {clutch.envoytriage.v1.IReadRequest=} [properties] Properties to set
                 */
                function ReadRequest(properties) {
                    this.operations = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReadRequest operations.
                 * @member {Array.<clutch.envoytriage.v1.IReadOperation>} operations
                 * @memberof clutch.envoytriage.v1.ReadRequest
                 * @instance
                 */
                ReadRequest.prototype.operations = $util.emptyArray;

                /**
                 * Verifies a ReadRequest message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.ReadRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReadRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.operations != null && message.hasOwnProperty("operations")) {
                        if (!Array.isArray(message.operations))
                            return "operations: array expected";
                        for (let i = 0; i < message.operations.length; ++i) {
                            let error = $root.clutch.envoytriage.v1.ReadOperation.verify(message.operations[i]);
                            if (error)
                                return "operations." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ReadRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.ReadRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.ReadRequest} ReadRequest
                 */
                ReadRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.ReadRequest)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.ReadRequest();
                    if (object.operations) {
                        if (!Array.isArray(object.operations))
                            throw TypeError(".clutch.envoytriage.v1.ReadRequest.operations: array expected");
                        message.operations = [];
                        for (let i = 0; i < object.operations.length; ++i) {
                            if (typeof object.operations[i] !== "object")
                                throw TypeError(".clutch.envoytriage.v1.ReadRequest.operations: object expected");
                            message.operations[i] = $root.clutch.envoytriage.v1.ReadOperation.fromObject(object.operations[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ReadRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.ReadRequest
                 * @static
                 * @param {clutch.envoytriage.v1.ReadRequest} message ReadRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReadRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.operations = [];
                    if (message.operations && message.operations.length) {
                        object.operations = [];
                        for (let j = 0; j < message.operations.length; ++j)
                            object.operations[j] = $root.clutch.envoytriage.v1.ReadOperation.toObject(message.operations[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ReadRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.ReadRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReadRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReadRequest;
            })();

            v1.ReadOperation = (function() {

                /**
                 * Properties of a ReadOperation.
                 * @memberof clutch.envoytriage.v1
                 * @interface IReadOperation
                 * @property {clutch.envoytriage.v1.IAddress|null} [address] ReadOperation address
                 * @property {clutch.envoytriage.v1.ReadOperation.IInclude|null} [include] ReadOperation include
                 */

                /**
                 * Constructs a new ReadOperation.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a ReadOperation.
                 * @implements IReadOperation
                 * @constructor
                 * @param {clutch.envoytriage.v1.IReadOperation=} [properties] Properties to set
                 */
                function ReadOperation(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReadOperation address.
                 * @member {clutch.envoytriage.v1.IAddress|null|undefined} address
                 * @memberof clutch.envoytriage.v1.ReadOperation
                 * @instance
                 */
                ReadOperation.prototype.address = null;

                /**
                 * ReadOperation include.
                 * @member {clutch.envoytriage.v1.ReadOperation.IInclude|null|undefined} include
                 * @memberof clutch.envoytriage.v1.ReadOperation
                 * @instance
                 */
                ReadOperation.prototype.include = null;

                /**
                 * Verifies a ReadOperation message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.ReadOperation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReadOperation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.address != null && message.hasOwnProperty("address")) {
                        let error = $root.clutch.envoytriage.v1.Address.verify(message.address);
                        if (error)
                            return "address." + error;
                    }
                    if (message.include != null && message.hasOwnProperty("include")) {
                        let error = $root.clutch.envoytriage.v1.ReadOperation.Include.verify(message.include);
                        if (error)
                            return "include." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ReadOperation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.ReadOperation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.ReadOperation} ReadOperation
                 */
                ReadOperation.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.ReadOperation)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.ReadOperation();
                    if (object.address != null) {
                        if (typeof object.address !== "object")
                            throw TypeError(".clutch.envoytriage.v1.ReadOperation.address: object expected");
                        message.address = $root.clutch.envoytriage.v1.Address.fromObject(object.address);
                    }
                    if (object.include != null) {
                        if (typeof object.include !== "object")
                            throw TypeError(".clutch.envoytriage.v1.ReadOperation.include: object expected");
                        message.include = $root.clutch.envoytriage.v1.ReadOperation.Include.fromObject(object.include);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ReadOperation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.ReadOperation
                 * @static
                 * @param {clutch.envoytriage.v1.ReadOperation} message ReadOperation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReadOperation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.address = null;
                        object.include = null;
                    }
                    if (message.address != null && message.hasOwnProperty("address"))
                        object.address = $root.clutch.envoytriage.v1.Address.toObject(message.address, options);
                    if (message.include != null && message.hasOwnProperty("include"))
                        object.include = $root.clutch.envoytriage.v1.ReadOperation.Include.toObject(message.include, options);
                    return object;
                };

                /**
                 * Converts this ReadOperation to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.ReadOperation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReadOperation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                ReadOperation.Include = (function() {

                    /**
                     * Properties of an Include.
                     * @memberof clutch.envoytriage.v1.ReadOperation
                     * @interface IInclude
                     * @property {boolean|null} [clusters] Include clusters
                     * @property {boolean|null} [configDump] Include configDump
                     * @property {boolean|null} [listeners] Include listeners
                     * @property {boolean|null} [runtime] Include runtime
                     * @property {boolean|null} [stats] Include stats
                     * @property {boolean|null} [serverInfo] Include serverInfo
                     */

                    /**
                     * Constructs a new Include.
                     * @memberof clutch.envoytriage.v1.ReadOperation
                     * @classdesc Represents an Include.
                     * @implements IInclude
                     * @constructor
                     * @param {clutch.envoytriage.v1.ReadOperation.IInclude=} [properties] Properties to set
                     */
                    function Include(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Include clusters.
                     * @member {boolean} clusters
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @instance
                     */
                    Include.prototype.clusters = false;

                    /**
                     * Include configDump.
                     * @member {boolean} configDump
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @instance
                     */
                    Include.prototype.configDump = false;

                    /**
                     * Include listeners.
                     * @member {boolean} listeners
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @instance
                     */
                    Include.prototype.listeners = false;

                    /**
                     * Include runtime.
                     * @member {boolean} runtime
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @instance
                     */
                    Include.prototype.runtime = false;

                    /**
                     * Include stats.
                     * @member {boolean} stats
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @instance
                     */
                    Include.prototype.stats = false;

                    /**
                     * Include serverInfo.
                     * @member {boolean} serverInfo
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @instance
                     */
                    Include.prototype.serverInfo = false;

                    /**
                     * Verifies an Include message.
                     * @function verify
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Include.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.clusters != null && message.hasOwnProperty("clusters"))
                            if (typeof message.clusters !== "boolean")
                                return "clusters: boolean expected";
                        if (message.configDump != null && message.hasOwnProperty("configDump"))
                            if (typeof message.configDump !== "boolean")
                                return "configDump: boolean expected";
                        if (message.listeners != null && message.hasOwnProperty("listeners"))
                            if (typeof message.listeners !== "boolean")
                                return "listeners: boolean expected";
                        if (message.runtime != null && message.hasOwnProperty("runtime"))
                            if (typeof message.runtime !== "boolean")
                                return "runtime: boolean expected";
                        if (message.stats != null && message.hasOwnProperty("stats"))
                            if (typeof message.stats !== "boolean")
                                return "stats: boolean expected";
                        if (message.serverInfo != null && message.hasOwnProperty("serverInfo"))
                            if (typeof message.serverInfo !== "boolean")
                                return "serverInfo: boolean expected";
                        return null;
                    };

                    /**
                     * Creates an Include message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.envoytriage.v1.ReadOperation.Include} Include
                     */
                    Include.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.envoytriage.v1.ReadOperation.Include)
                            return object;
                        let message = new $root.clutch.envoytriage.v1.ReadOperation.Include();
                        if (object.clusters != null)
                            message.clusters = Boolean(object.clusters);
                        if (object.configDump != null)
                            message.configDump = Boolean(object.configDump);
                        if (object.listeners != null)
                            message.listeners = Boolean(object.listeners);
                        if (object.runtime != null)
                            message.runtime = Boolean(object.runtime);
                        if (object.stats != null)
                            message.stats = Boolean(object.stats);
                        if (object.serverInfo != null)
                            message.serverInfo = Boolean(object.serverInfo);
                        return message;
                    };

                    /**
                     * Creates a plain object from an Include message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @static
                     * @param {clutch.envoytriage.v1.ReadOperation.Include} message Include
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Include.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.clusters = false;
                            object.configDump = false;
                            object.listeners = false;
                            object.runtime = false;
                            object.stats = false;
                            object.serverInfo = false;
                        }
                        if (message.clusters != null && message.hasOwnProperty("clusters"))
                            object.clusters = message.clusters;
                        if (message.configDump != null && message.hasOwnProperty("configDump"))
                            object.configDump = message.configDump;
                        if (message.listeners != null && message.hasOwnProperty("listeners"))
                            object.listeners = message.listeners;
                        if (message.runtime != null && message.hasOwnProperty("runtime"))
                            object.runtime = message.runtime;
                        if (message.stats != null && message.hasOwnProperty("stats"))
                            object.stats = message.stats;
                        if (message.serverInfo != null && message.hasOwnProperty("serverInfo"))
                            object.serverInfo = message.serverInfo;
                        return object;
                    };

                    /**
                     * Converts this Include to JSON.
                     * @function toJSON
                     * @memberof clutch.envoytriage.v1.ReadOperation.Include
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Include.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Include;
                })();

                return ReadOperation;
            })();

            v1.ReadResponse = (function() {

                /**
                 * Properties of a ReadResponse.
                 * @memberof clutch.envoytriage.v1
                 * @interface IReadResponse
                 * @property {Array.<clutch.envoytriage.v1.IResult>|null} [results] ReadResponse results
                 */

                /**
                 * Constructs a new ReadResponse.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a ReadResponse.
                 * @implements IReadResponse
                 * @constructor
                 * @param {clutch.envoytriage.v1.IReadResponse=} [properties] Properties to set
                 */
                function ReadResponse(properties) {
                    this.results = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReadResponse results.
                 * @member {Array.<clutch.envoytriage.v1.IResult>} results
                 * @memberof clutch.envoytriage.v1.ReadResponse
                 * @instance
                 */
                ReadResponse.prototype.results = $util.emptyArray;

                /**
                 * Verifies a ReadResponse message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.ReadResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReadResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.results != null && message.hasOwnProperty("results")) {
                        if (!Array.isArray(message.results))
                            return "results: array expected";
                        for (let i = 0; i < message.results.length; ++i) {
                            let error = $root.clutch.envoytriage.v1.Result.verify(message.results[i]);
                            if (error)
                                return "results." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ReadResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.ReadResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.ReadResponse} ReadResponse
                 */
                ReadResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.ReadResponse)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.ReadResponse();
                    if (object.results) {
                        if (!Array.isArray(object.results))
                            throw TypeError(".clutch.envoytriage.v1.ReadResponse.results: array expected");
                        message.results = [];
                        for (let i = 0; i < object.results.length; ++i) {
                            if (typeof object.results[i] !== "object")
                                throw TypeError(".clutch.envoytriage.v1.ReadResponse.results: object expected");
                            message.results[i] = $root.clutch.envoytriage.v1.Result.fromObject(object.results[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ReadResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.ReadResponse
                 * @static
                 * @param {clutch.envoytriage.v1.ReadResponse} message ReadResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReadResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.results = [];
                    if (message.results && message.results.length) {
                        object.results = [];
                        for (let j = 0; j < message.results.length; ++j)
                            object.results[j] = $root.clutch.envoytriage.v1.Result.toObject(message.results[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ReadResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.ReadResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReadResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReadResponse;
            })();

            v1.Address = (function() {

                /**
                 * Properties of an Address.
                 * @memberof clutch.envoytriage.v1
                 * @interface IAddress
                 * @property {string|null} [host] Address host
                 * @property {number|null} [port] Address port
                 */

                /**
                 * Constructs a new Address.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents an Address.
                 * @implements IAddress
                 * @constructor
                 * @param {clutch.envoytriage.v1.IAddress=} [properties] Properties to set
                 */
                function Address(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Address host.
                 * @member {string} host
                 * @memberof clutch.envoytriage.v1.Address
                 * @instance
                 */
                Address.prototype.host = "";

                /**
                 * Address port.
                 * @member {number} port
                 * @memberof clutch.envoytriage.v1.Address
                 * @instance
                 */
                Address.prototype.port = 0;

                /**
                 * Verifies an Address message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.Address
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Address.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.host != null && message.hasOwnProperty("host"))
                        if (!$util.isString(message.host))
                            return "host: string expected";
                    if (message.port != null && message.hasOwnProperty("port"))
                        if (!$util.isInteger(message.port))
                            return "port: integer expected";
                    return null;
                };

                /**
                 * Creates an Address message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.Address
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.Address} Address
                 */
                Address.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.Address)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.Address();
                    if (object.host != null)
                        message.host = String(object.host);
                    if (object.port != null)
                        message.port = object.port >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from an Address message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.Address
                 * @static
                 * @param {clutch.envoytriage.v1.Address} message Address
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Address.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.host = "";
                        object.port = 0;
                    }
                    if (message.host != null && message.hasOwnProperty("host"))
                        object.host = message.host;
                    if (message.port != null && message.hasOwnProperty("port"))
                        object.port = message.port;
                    return object;
                };

                /**
                 * Converts this Address to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.Address
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Address.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Address;
            })();

            v1.Result = (function() {

                /**
                 * Properties of a Result.
                 * @memberof clutch.envoytriage.v1
                 * @interface IResult
                 * @property {clutch.envoytriage.v1.IAddress|null} [address] Result address
                 * @property {clutch.envoytriage.v1.INodeMetadata|null} [nodeMetadata] Result nodeMetadata
                 * @property {clutch.envoytriage.v1.Result.IOutput|null} [output] Result output
                 */

                /**
                 * Constructs a new Result.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a Result.
                 * @implements IResult
                 * @constructor
                 * @param {clutch.envoytriage.v1.IResult=} [properties] Properties to set
                 */
                function Result(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Result address.
                 * @member {clutch.envoytriage.v1.IAddress|null|undefined} address
                 * @memberof clutch.envoytriage.v1.Result
                 * @instance
                 */
                Result.prototype.address = null;

                /**
                 * Result nodeMetadata.
                 * @member {clutch.envoytriage.v1.INodeMetadata|null|undefined} nodeMetadata
                 * @memberof clutch.envoytriage.v1.Result
                 * @instance
                 */
                Result.prototype.nodeMetadata = null;

                /**
                 * Result output.
                 * @member {clutch.envoytriage.v1.Result.IOutput|null|undefined} output
                 * @memberof clutch.envoytriage.v1.Result
                 * @instance
                 */
                Result.prototype.output = null;

                /**
                 * Verifies a Result message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.Result
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Result.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.address != null && message.hasOwnProperty("address")) {
                        let error = $root.clutch.envoytriage.v1.Address.verify(message.address);
                        if (error)
                            return "address." + error;
                    }
                    if (message.nodeMetadata != null && message.hasOwnProperty("nodeMetadata")) {
                        let error = $root.clutch.envoytriage.v1.NodeMetadata.verify(message.nodeMetadata);
                        if (error)
                            return "nodeMetadata." + error;
                    }
                    if (message.output != null && message.hasOwnProperty("output")) {
                        let error = $root.clutch.envoytriage.v1.Result.Output.verify(message.output);
                        if (error)
                            return "output." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Result message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.Result
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.Result} Result
                 */
                Result.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.Result)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.Result();
                    if (object.address != null) {
                        if (typeof object.address !== "object")
                            throw TypeError(".clutch.envoytriage.v1.Result.address: object expected");
                        message.address = $root.clutch.envoytriage.v1.Address.fromObject(object.address);
                    }
                    if (object.nodeMetadata != null) {
                        if (typeof object.nodeMetadata !== "object")
                            throw TypeError(".clutch.envoytriage.v1.Result.nodeMetadata: object expected");
                        message.nodeMetadata = $root.clutch.envoytriage.v1.NodeMetadata.fromObject(object.nodeMetadata);
                    }
                    if (object.output != null) {
                        if (typeof object.output !== "object")
                            throw TypeError(".clutch.envoytriage.v1.Result.output: object expected");
                        message.output = $root.clutch.envoytriage.v1.Result.Output.fromObject(object.output);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Result message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.Result
                 * @static
                 * @param {clutch.envoytriage.v1.Result} message Result
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Result.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.address = null;
                        object.nodeMetadata = null;
                        object.output = null;
                    }
                    if (message.address != null && message.hasOwnProperty("address"))
                        object.address = $root.clutch.envoytriage.v1.Address.toObject(message.address, options);
                    if (message.nodeMetadata != null && message.hasOwnProperty("nodeMetadata"))
                        object.nodeMetadata = $root.clutch.envoytriage.v1.NodeMetadata.toObject(message.nodeMetadata, options);
                    if (message.output != null && message.hasOwnProperty("output"))
                        object.output = $root.clutch.envoytriage.v1.Result.Output.toObject(message.output, options);
                    return object;
                };

                /**
                 * Converts this Result to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.Result
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Result.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Result.Output = (function() {

                    /**
                     * Properties of an Output.
                     * @memberof clutch.envoytriage.v1.Result
                     * @interface IOutput
                     * @property {clutch.envoytriage.v1.IClusters|null} [clusters] Output clusters
                     * @property {clutch.envoytriage.v1.IConfigDump|null} [configDump] Output configDump
                     * @property {clutch.envoytriage.v1.IListeners|null} [listeners] Output listeners
                     * @property {clutch.envoytriage.v1.IRuntime|null} [runtime] Output runtime
                     * @property {clutch.envoytriage.v1.IStats|null} [stats] Output stats
                     * @property {clutch.envoytriage.v1.IServerInfo|null} [serverInfo] Output serverInfo
                     */

                    /**
                     * Constructs a new Output.
                     * @memberof clutch.envoytriage.v1.Result
                     * @classdesc Represents an Output.
                     * @implements IOutput
                     * @constructor
                     * @param {clutch.envoytriage.v1.Result.IOutput=} [properties] Properties to set
                     */
                    function Output(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Output clusters.
                     * @member {clutch.envoytriage.v1.IClusters|null|undefined} clusters
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @instance
                     */
                    Output.prototype.clusters = null;

                    /**
                     * Output configDump.
                     * @member {clutch.envoytriage.v1.IConfigDump|null|undefined} configDump
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @instance
                     */
                    Output.prototype.configDump = null;

                    /**
                     * Output listeners.
                     * @member {clutch.envoytriage.v1.IListeners|null|undefined} listeners
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @instance
                     */
                    Output.prototype.listeners = null;

                    /**
                     * Output runtime.
                     * @member {clutch.envoytriage.v1.IRuntime|null|undefined} runtime
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @instance
                     */
                    Output.prototype.runtime = null;

                    /**
                     * Output stats.
                     * @member {clutch.envoytriage.v1.IStats|null|undefined} stats
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @instance
                     */
                    Output.prototype.stats = null;

                    /**
                     * Output serverInfo.
                     * @member {clutch.envoytriage.v1.IServerInfo|null|undefined} serverInfo
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @instance
                     */
                    Output.prototype.serverInfo = null;

                    /**
                     * Verifies an Output message.
                     * @function verify
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Output.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.clusters != null && message.hasOwnProperty("clusters")) {
                            let error = $root.clutch.envoytriage.v1.Clusters.verify(message.clusters);
                            if (error)
                                return "clusters." + error;
                        }
                        if (message.configDump != null && message.hasOwnProperty("configDump")) {
                            let error = $root.clutch.envoytriage.v1.ConfigDump.verify(message.configDump);
                            if (error)
                                return "configDump." + error;
                        }
                        if (message.listeners != null && message.hasOwnProperty("listeners")) {
                            let error = $root.clutch.envoytriage.v1.Listeners.verify(message.listeners);
                            if (error)
                                return "listeners." + error;
                        }
                        if (message.runtime != null && message.hasOwnProperty("runtime")) {
                            let error = $root.clutch.envoytriage.v1.Runtime.verify(message.runtime);
                            if (error)
                                return "runtime." + error;
                        }
                        if (message.stats != null && message.hasOwnProperty("stats")) {
                            let error = $root.clutch.envoytriage.v1.Stats.verify(message.stats);
                            if (error)
                                return "stats." + error;
                        }
                        if (message.serverInfo != null && message.hasOwnProperty("serverInfo")) {
                            let error = $root.clutch.envoytriage.v1.ServerInfo.verify(message.serverInfo);
                            if (error)
                                return "serverInfo." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates an Output message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.envoytriage.v1.Result.Output} Output
                     */
                    Output.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.envoytriage.v1.Result.Output)
                            return object;
                        let message = new $root.clutch.envoytriage.v1.Result.Output();
                        if (object.clusters != null) {
                            if (typeof object.clusters !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Result.Output.clusters: object expected");
                            message.clusters = $root.clutch.envoytriage.v1.Clusters.fromObject(object.clusters);
                        }
                        if (object.configDump != null) {
                            if (typeof object.configDump !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Result.Output.configDump: object expected");
                            message.configDump = $root.clutch.envoytriage.v1.ConfigDump.fromObject(object.configDump);
                        }
                        if (object.listeners != null) {
                            if (typeof object.listeners !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Result.Output.listeners: object expected");
                            message.listeners = $root.clutch.envoytriage.v1.Listeners.fromObject(object.listeners);
                        }
                        if (object.runtime != null) {
                            if (typeof object.runtime !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Result.Output.runtime: object expected");
                            message.runtime = $root.clutch.envoytriage.v1.Runtime.fromObject(object.runtime);
                        }
                        if (object.stats != null) {
                            if (typeof object.stats !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Result.Output.stats: object expected");
                            message.stats = $root.clutch.envoytriage.v1.Stats.fromObject(object.stats);
                        }
                        if (object.serverInfo != null) {
                            if (typeof object.serverInfo !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Result.Output.serverInfo: object expected");
                            message.serverInfo = $root.clutch.envoytriage.v1.ServerInfo.fromObject(object.serverInfo);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from an Output message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @static
                     * @param {clutch.envoytriage.v1.Result.Output} message Output
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Output.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.clusters = null;
                            object.configDump = null;
                            object.listeners = null;
                            object.runtime = null;
                            object.stats = null;
                            object.serverInfo = null;
                        }
                        if (message.clusters != null && message.hasOwnProperty("clusters"))
                            object.clusters = $root.clutch.envoytriage.v1.Clusters.toObject(message.clusters, options);
                        if (message.configDump != null && message.hasOwnProperty("configDump"))
                            object.configDump = $root.clutch.envoytriage.v1.ConfigDump.toObject(message.configDump, options);
                        if (message.listeners != null && message.hasOwnProperty("listeners"))
                            object.listeners = $root.clutch.envoytriage.v1.Listeners.toObject(message.listeners, options);
                        if (message.runtime != null && message.hasOwnProperty("runtime"))
                            object.runtime = $root.clutch.envoytriage.v1.Runtime.toObject(message.runtime, options);
                        if (message.stats != null && message.hasOwnProperty("stats"))
                            object.stats = $root.clutch.envoytriage.v1.Stats.toObject(message.stats, options);
                        if (message.serverInfo != null && message.hasOwnProperty("serverInfo"))
                            object.serverInfo = $root.clutch.envoytriage.v1.ServerInfo.toObject(message.serverInfo, options);
                        return object;
                    };

                    /**
                     * Converts this Output to JSON.
                     * @function toJSON
                     * @memberof clutch.envoytriage.v1.Result.Output
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Output.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Output;
                })();

                return Result;
            })();

            v1.NodeMetadata = (function() {

                /**
                 * Properties of a NodeMetadata.
                 * @memberof clutch.envoytriage.v1
                 * @interface INodeMetadata
                 * @property {string|null} [serviceNode] NodeMetadata serviceNode
                 * @property {string|null} [serviceCluster] NodeMetadata serviceCluster
                 * @property {string|null} [serviceZone] NodeMetadata serviceZone
                 * @property {string|null} [version] NodeMetadata version
                 */

                /**
                 * Constructs a new NodeMetadata.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a NodeMetadata.
                 * @implements INodeMetadata
                 * @constructor
                 * @param {clutch.envoytriage.v1.INodeMetadata=} [properties] Properties to set
                 */
                function NodeMetadata(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NodeMetadata serviceNode.
                 * @member {string} serviceNode
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @instance
                 */
                NodeMetadata.prototype.serviceNode = "";

                /**
                 * NodeMetadata serviceCluster.
                 * @member {string} serviceCluster
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @instance
                 */
                NodeMetadata.prototype.serviceCluster = "";

                /**
                 * NodeMetadata serviceZone.
                 * @member {string} serviceZone
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @instance
                 */
                NodeMetadata.prototype.serviceZone = "";

                /**
                 * NodeMetadata version.
                 * @member {string} version
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @instance
                 */
                NodeMetadata.prototype.version = "";

                /**
                 * Verifies a NodeMetadata message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NodeMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.serviceNode != null && message.hasOwnProperty("serviceNode"))
                        if (!$util.isString(message.serviceNode))
                            return "serviceNode: string expected";
                    if (message.serviceCluster != null && message.hasOwnProperty("serviceCluster"))
                        if (!$util.isString(message.serviceCluster))
                            return "serviceCluster: string expected";
                    if (message.serviceZone != null && message.hasOwnProperty("serviceZone"))
                        if (!$util.isString(message.serviceZone))
                            return "serviceZone: string expected";
                    if (message.version != null && message.hasOwnProperty("version"))
                        if (!$util.isString(message.version))
                            return "version: string expected";
                    return null;
                };

                /**
                 * Creates a NodeMetadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.NodeMetadata} NodeMetadata
                 */
                NodeMetadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.NodeMetadata)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.NodeMetadata();
                    if (object.serviceNode != null)
                        message.serviceNode = String(object.serviceNode);
                    if (object.serviceCluster != null)
                        message.serviceCluster = String(object.serviceCluster);
                    if (object.serviceZone != null)
                        message.serviceZone = String(object.serviceZone);
                    if (object.version != null)
                        message.version = String(object.version);
                    return message;
                };

                /**
                 * Creates a plain object from a NodeMetadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @static
                 * @param {clutch.envoytriage.v1.NodeMetadata} message NodeMetadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NodeMetadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.serviceNode = "";
                        object.serviceCluster = "";
                        object.serviceZone = "";
                        object.version = "";
                    }
                    if (message.serviceNode != null && message.hasOwnProperty("serviceNode"))
                        object.serviceNode = message.serviceNode;
                    if (message.serviceCluster != null && message.hasOwnProperty("serviceCluster"))
                        object.serviceCluster = message.serviceCluster;
                    if (message.serviceZone != null && message.hasOwnProperty("serviceZone"))
                        object.serviceZone = message.serviceZone;
                    if (message.version != null && message.hasOwnProperty("version"))
                        object.version = message.version;
                    return object;
                };

                /**
                 * Converts this NodeMetadata to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.NodeMetadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NodeMetadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NodeMetadata;
            })();

            v1.HostStatus = (function() {

                /**
                 * Properties of a HostStatus.
                 * @memberof clutch.envoytriage.v1
                 * @interface IHostStatus
                 * @property {string|null} [address] HostStatus address
                 * @property {boolean|null} [healthy] HostStatus healthy
                 */

                /**
                 * Constructs a new HostStatus.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a HostStatus.
                 * @implements IHostStatus
                 * @constructor
                 * @param {clutch.envoytriage.v1.IHostStatus=} [properties] Properties to set
                 */
                function HostStatus(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * HostStatus address.
                 * @member {string} address
                 * @memberof clutch.envoytriage.v1.HostStatus
                 * @instance
                 */
                HostStatus.prototype.address = "";

                /**
                 * HostStatus healthy.
                 * @member {boolean} healthy
                 * @memberof clutch.envoytriage.v1.HostStatus
                 * @instance
                 */
                HostStatus.prototype.healthy = false;

                /**
                 * Verifies a HostStatus message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.HostStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HostStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.address != null && message.hasOwnProperty("address"))
                        if (!$util.isString(message.address))
                            return "address: string expected";
                    if (message.healthy != null && message.hasOwnProperty("healthy"))
                        if (typeof message.healthy !== "boolean")
                            return "healthy: boolean expected";
                    return null;
                };

                /**
                 * Creates a HostStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.HostStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.HostStatus} HostStatus
                 */
                HostStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.HostStatus)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.HostStatus();
                    if (object.address != null)
                        message.address = String(object.address);
                    if (object.healthy != null)
                        message.healthy = Boolean(object.healthy);
                    return message;
                };

                /**
                 * Creates a plain object from a HostStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.HostStatus
                 * @static
                 * @param {clutch.envoytriage.v1.HostStatus} message HostStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HostStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.address = "";
                        object.healthy = false;
                    }
                    if (message.address != null && message.hasOwnProperty("address"))
                        object.address = message.address;
                    if (message.healthy != null && message.hasOwnProperty("healthy"))
                        object.healthy = message.healthy;
                    return object;
                };

                /**
                 * Converts this HostStatus to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.HostStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HostStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return HostStatus;
            })();

            v1.ClusterStatus = (function() {

                /**
                 * Properties of a ClusterStatus.
                 * @memberof clutch.envoytriage.v1
                 * @interface IClusterStatus
                 * @property {string|null} [name] ClusterStatus name
                 * @property {Array.<clutch.envoytriage.v1.IHostStatus>|null} [hostStatuses] ClusterStatus hostStatuses
                 */

                /**
                 * Constructs a new ClusterStatus.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a ClusterStatus.
                 * @implements IClusterStatus
                 * @constructor
                 * @param {clutch.envoytriage.v1.IClusterStatus=} [properties] Properties to set
                 */
                function ClusterStatus(properties) {
                    this.hostStatuses = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ClusterStatus name.
                 * @member {string} name
                 * @memberof clutch.envoytriage.v1.ClusterStatus
                 * @instance
                 */
                ClusterStatus.prototype.name = "";

                /**
                 * ClusterStatus hostStatuses.
                 * @member {Array.<clutch.envoytriage.v1.IHostStatus>} hostStatuses
                 * @memberof clutch.envoytriage.v1.ClusterStatus
                 * @instance
                 */
                ClusterStatus.prototype.hostStatuses = $util.emptyArray;

                /**
                 * Verifies a ClusterStatus message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.ClusterStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ClusterStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.hostStatuses != null && message.hasOwnProperty("hostStatuses")) {
                        if (!Array.isArray(message.hostStatuses))
                            return "hostStatuses: array expected";
                        for (let i = 0; i < message.hostStatuses.length; ++i) {
                            let error = $root.clutch.envoytriage.v1.HostStatus.verify(message.hostStatuses[i]);
                            if (error)
                                return "hostStatuses." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ClusterStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.ClusterStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.ClusterStatus} ClusterStatus
                 */
                ClusterStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.ClusterStatus)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.ClusterStatus();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.hostStatuses) {
                        if (!Array.isArray(object.hostStatuses))
                            throw TypeError(".clutch.envoytriage.v1.ClusterStatus.hostStatuses: array expected");
                        message.hostStatuses = [];
                        for (let i = 0; i < object.hostStatuses.length; ++i) {
                            if (typeof object.hostStatuses[i] !== "object")
                                throw TypeError(".clutch.envoytriage.v1.ClusterStatus.hostStatuses: object expected");
                            message.hostStatuses[i] = $root.clutch.envoytriage.v1.HostStatus.fromObject(object.hostStatuses[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ClusterStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.ClusterStatus
                 * @static
                 * @param {clutch.envoytriage.v1.ClusterStatus} message ClusterStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ClusterStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.hostStatuses = [];
                    if (options.defaults)
                        object.name = "";
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.hostStatuses && message.hostStatuses.length) {
                        object.hostStatuses = [];
                        for (let j = 0; j < message.hostStatuses.length; ++j)
                            object.hostStatuses[j] = $root.clutch.envoytriage.v1.HostStatus.toObject(message.hostStatuses[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ClusterStatus to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.ClusterStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ClusterStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ClusterStatus;
            })();

            v1.Clusters = (function() {

                /**
                 * Properties of a Clusters.
                 * @memberof clutch.envoytriage.v1
                 * @interface IClusters
                 * @property {Array.<clutch.envoytriage.v1.IClusterStatus>|null} [clusterStatuses] Clusters clusterStatuses
                 */

                /**
                 * Constructs a new Clusters.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a Clusters.
                 * @implements IClusters
                 * @constructor
                 * @param {clutch.envoytriage.v1.IClusters=} [properties] Properties to set
                 */
                function Clusters(properties) {
                    this.clusterStatuses = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Clusters clusterStatuses.
                 * @member {Array.<clutch.envoytriage.v1.IClusterStatus>} clusterStatuses
                 * @memberof clutch.envoytriage.v1.Clusters
                 * @instance
                 */
                Clusters.prototype.clusterStatuses = $util.emptyArray;

                /**
                 * Verifies a Clusters message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.Clusters
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Clusters.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clusterStatuses != null && message.hasOwnProperty("clusterStatuses")) {
                        if (!Array.isArray(message.clusterStatuses))
                            return "clusterStatuses: array expected";
                        for (let i = 0; i < message.clusterStatuses.length; ++i) {
                            let error = $root.clutch.envoytriage.v1.ClusterStatus.verify(message.clusterStatuses[i]);
                            if (error)
                                return "clusterStatuses." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Clusters message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.Clusters
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.Clusters} Clusters
                 */
                Clusters.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.Clusters)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.Clusters();
                    if (object.clusterStatuses) {
                        if (!Array.isArray(object.clusterStatuses))
                            throw TypeError(".clutch.envoytriage.v1.Clusters.clusterStatuses: array expected");
                        message.clusterStatuses = [];
                        for (let i = 0; i < object.clusterStatuses.length; ++i) {
                            if (typeof object.clusterStatuses[i] !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Clusters.clusterStatuses: object expected");
                            message.clusterStatuses[i] = $root.clutch.envoytriage.v1.ClusterStatus.fromObject(object.clusterStatuses[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Clusters message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.Clusters
                 * @static
                 * @param {clutch.envoytriage.v1.Clusters} message Clusters
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Clusters.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.clusterStatuses = [];
                    if (message.clusterStatuses && message.clusterStatuses.length) {
                        object.clusterStatuses = [];
                        for (let j = 0; j < message.clusterStatuses.length; ++j)
                            object.clusterStatuses[j] = $root.clutch.envoytriage.v1.ClusterStatus.toObject(message.clusterStatuses[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Clusters to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.Clusters
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Clusters.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Clusters;
            })();

            v1.ConfigDump = (function() {

                /**
                 * Properties of a ConfigDump.
                 * @memberof clutch.envoytriage.v1
                 * @interface IConfigDump
                 * @property {google.protobuf.IValue|null} [value] ConfigDump value
                 */

                /**
                 * Constructs a new ConfigDump.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a ConfigDump.
                 * @implements IConfigDump
                 * @constructor
                 * @param {clutch.envoytriage.v1.IConfigDump=} [properties] Properties to set
                 */
                function ConfigDump(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ConfigDump value.
                 * @member {google.protobuf.IValue|null|undefined} value
                 * @memberof clutch.envoytriage.v1.ConfigDump
                 * @instance
                 */
                ConfigDump.prototype.value = null;

                /**
                 * Verifies a ConfigDump message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.ConfigDump
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ConfigDump.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        let error = $root.google.protobuf.Value.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ConfigDump message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.ConfigDump
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.ConfigDump} ConfigDump
                 */
                ConfigDump.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.ConfigDump)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.ConfigDump();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".clutch.envoytriage.v1.ConfigDump.value: object expected");
                        message.value = $root.google.protobuf.Value.fromObject(object.value);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ConfigDump message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.ConfigDump
                 * @static
                 * @param {clutch.envoytriage.v1.ConfigDump} message ConfigDump
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ConfigDump.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.google.protobuf.Value.toObject(message.value, options);
                    return object;
                };

                /**
                 * Converts this ConfigDump to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.ConfigDump
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ConfigDump.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ConfigDump;
            })();

            v1.ListenerStatus = (function() {

                /**
                 * Properties of a ListenerStatus.
                 * @memberof clutch.envoytriage.v1
                 * @interface IListenerStatus
                 * @property {string|null} [name] ListenerStatus name
                 * @property {string|null} [localAddress] ListenerStatus localAddress
                 */

                /**
                 * Constructs a new ListenerStatus.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a ListenerStatus.
                 * @implements IListenerStatus
                 * @constructor
                 * @param {clutch.envoytriage.v1.IListenerStatus=} [properties] Properties to set
                 */
                function ListenerStatus(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListenerStatus name.
                 * @member {string} name
                 * @memberof clutch.envoytriage.v1.ListenerStatus
                 * @instance
                 */
                ListenerStatus.prototype.name = "";

                /**
                 * ListenerStatus localAddress.
                 * @member {string} localAddress
                 * @memberof clutch.envoytriage.v1.ListenerStatus
                 * @instance
                 */
                ListenerStatus.prototype.localAddress = "";

                /**
                 * Verifies a ListenerStatus message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.ListenerStatus
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListenerStatus.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.localAddress != null && message.hasOwnProperty("localAddress"))
                        if (!$util.isString(message.localAddress))
                            return "localAddress: string expected";
                    return null;
                };

                /**
                 * Creates a ListenerStatus message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.ListenerStatus
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.ListenerStatus} ListenerStatus
                 */
                ListenerStatus.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.ListenerStatus)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.ListenerStatus();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.localAddress != null)
                        message.localAddress = String(object.localAddress);
                    return message;
                };

                /**
                 * Creates a plain object from a ListenerStatus message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.ListenerStatus
                 * @static
                 * @param {clutch.envoytriage.v1.ListenerStatus} message ListenerStatus
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListenerStatus.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.localAddress = "";
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.localAddress != null && message.hasOwnProperty("localAddress"))
                        object.localAddress = message.localAddress;
                    return object;
                };

                /**
                 * Converts this ListenerStatus to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.ListenerStatus
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListenerStatus.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListenerStatus;
            })();

            v1.Listeners = (function() {

                /**
                 * Properties of a Listeners.
                 * @memberof clutch.envoytriage.v1
                 * @interface IListeners
                 * @property {Array.<clutch.envoytriage.v1.IListenerStatus>|null} [listenerStatuses] Listeners listenerStatuses
                 */

                /**
                 * Constructs a new Listeners.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a Listeners.
                 * @implements IListeners
                 * @constructor
                 * @param {clutch.envoytriage.v1.IListeners=} [properties] Properties to set
                 */
                function Listeners(properties) {
                    this.listenerStatuses = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Listeners listenerStatuses.
                 * @member {Array.<clutch.envoytriage.v1.IListenerStatus>} listenerStatuses
                 * @memberof clutch.envoytriage.v1.Listeners
                 * @instance
                 */
                Listeners.prototype.listenerStatuses = $util.emptyArray;

                /**
                 * Verifies a Listeners message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.Listeners
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Listeners.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.listenerStatuses != null && message.hasOwnProperty("listenerStatuses")) {
                        if (!Array.isArray(message.listenerStatuses))
                            return "listenerStatuses: array expected";
                        for (let i = 0; i < message.listenerStatuses.length; ++i) {
                            let error = $root.clutch.envoytriage.v1.ListenerStatus.verify(message.listenerStatuses[i]);
                            if (error)
                                return "listenerStatuses." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Listeners message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.Listeners
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.Listeners} Listeners
                 */
                Listeners.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.Listeners)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.Listeners();
                    if (object.listenerStatuses) {
                        if (!Array.isArray(object.listenerStatuses))
                            throw TypeError(".clutch.envoytriage.v1.Listeners.listenerStatuses: array expected");
                        message.listenerStatuses = [];
                        for (let i = 0; i < object.listenerStatuses.length; ++i) {
                            if (typeof object.listenerStatuses[i] !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Listeners.listenerStatuses: object expected");
                            message.listenerStatuses[i] = $root.clutch.envoytriage.v1.ListenerStatus.fromObject(object.listenerStatuses[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Listeners message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.Listeners
                 * @static
                 * @param {clutch.envoytriage.v1.Listeners} message Listeners
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Listeners.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.listenerStatuses = [];
                    if (message.listenerStatuses && message.listenerStatuses.length) {
                        object.listenerStatuses = [];
                        for (let j = 0; j < message.listenerStatuses.length; ++j)
                            object.listenerStatuses[j] = $root.clutch.envoytriage.v1.ListenerStatus.toObject(message.listenerStatuses[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Listeners to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.Listeners
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Listeners.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Listeners;
            })();

            v1.Runtime = (function() {

                /**
                 * Properties of a Runtime.
                 * @memberof clutch.envoytriage.v1
                 * @interface IRuntime
                 * @property {Array.<clutch.envoytriage.v1.Runtime.IEntry>|null} [entries] Runtime entries
                 */

                /**
                 * Constructs a new Runtime.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a Runtime.
                 * @implements IRuntime
                 * @constructor
                 * @param {clutch.envoytriage.v1.IRuntime=} [properties] Properties to set
                 */
                function Runtime(properties) {
                    this.entries = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Runtime entries.
                 * @member {Array.<clutch.envoytriage.v1.Runtime.IEntry>} entries
                 * @memberof clutch.envoytriage.v1.Runtime
                 * @instance
                 */
                Runtime.prototype.entries = $util.emptyArray;

                /**
                 * Verifies a Runtime message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.Runtime
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Runtime.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.entries != null && message.hasOwnProperty("entries")) {
                        if (!Array.isArray(message.entries))
                            return "entries: array expected";
                        for (let i = 0; i < message.entries.length; ++i) {
                            let error = $root.clutch.envoytriage.v1.Runtime.Entry.verify(message.entries[i]);
                            if (error)
                                return "entries." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Runtime message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.Runtime
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.Runtime} Runtime
                 */
                Runtime.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.Runtime)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.Runtime();
                    if (object.entries) {
                        if (!Array.isArray(object.entries))
                            throw TypeError(".clutch.envoytriage.v1.Runtime.entries: array expected");
                        message.entries = [];
                        for (let i = 0; i < object.entries.length; ++i) {
                            if (typeof object.entries[i] !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Runtime.entries: object expected");
                            message.entries[i] = $root.clutch.envoytriage.v1.Runtime.Entry.fromObject(object.entries[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Runtime message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.Runtime
                 * @static
                 * @param {clutch.envoytriage.v1.Runtime} message Runtime
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Runtime.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.entries = [];
                    if (message.entries && message.entries.length) {
                        object.entries = [];
                        for (let j = 0; j < message.entries.length; ++j)
                            object.entries[j] = $root.clutch.envoytriage.v1.Runtime.Entry.toObject(message.entries[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Runtime to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.Runtime
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Runtime.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Runtime.Entry = (function() {

                    /**
                     * Properties of an Entry.
                     * @memberof clutch.envoytriage.v1.Runtime
                     * @interface IEntry
                     * @property {string|null} [key] Entry key
                     * @property {string|null} [value] Entry value
                     */

                    /**
                     * Constructs a new Entry.
                     * @memberof clutch.envoytriage.v1.Runtime
                     * @classdesc Represents an Entry.
                     * @implements IEntry
                     * @constructor
                     * @param {clutch.envoytriage.v1.Runtime.IEntry=} [properties] Properties to set
                     */
                    function Entry(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Entry key.
                     * @member {string} key
                     * @memberof clutch.envoytriage.v1.Runtime.Entry
                     * @instance
                     */
                    Entry.prototype.key = "";

                    /**
                     * Entry value.
                     * @member {string} value
                     * @memberof clutch.envoytriage.v1.Runtime.Entry
                     * @instance
                     */
                    Entry.prototype.value = "";

                    // OneOf field names bound to virtual getters and setters
                    let $oneOfFields;

                    /**
                     * Entry type.
                     * @member {"value"|undefined} type
                     * @memberof clutch.envoytriage.v1.Runtime.Entry
                     * @instance
                     */
                    Object.defineProperty(Entry.prototype, "type", {
                        get: $util.oneOfGetter($oneOfFields = ["value"]),
                        set: $util.oneOfSetter($oneOfFields)
                    });

                    /**
                     * Verifies an Entry message.
                     * @function verify
                     * @memberof clutch.envoytriage.v1.Runtime.Entry
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Entry.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        let properties = {};
                        if (message.key != null && message.hasOwnProperty("key"))
                            if (!$util.isString(message.key))
                                return "key: string expected";
                        if (message.value != null && message.hasOwnProperty("value")) {
                            properties.type = 1;
                            if (!$util.isString(message.value))
                                return "value: string expected";
                        }
                        return null;
                    };

                    /**
                     * Creates an Entry message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.envoytriage.v1.Runtime.Entry
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.envoytriage.v1.Runtime.Entry} Entry
                     */
                    Entry.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.envoytriage.v1.Runtime.Entry)
                            return object;
                        let message = new $root.clutch.envoytriage.v1.Runtime.Entry();
                        if (object.key != null)
                            message.key = String(object.key);
                        if (object.value != null)
                            message.value = String(object.value);
                        return message;
                    };

                    /**
                     * Creates a plain object from an Entry message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.envoytriage.v1.Runtime.Entry
                     * @static
                     * @param {clutch.envoytriage.v1.Runtime.Entry} message Entry
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Entry.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.key = "";
                        if (message.key != null && message.hasOwnProperty("key"))
                            object.key = message.key;
                        if (message.value != null && message.hasOwnProperty("value")) {
                            object.value = message.value;
                            if (options.oneofs)
                                object.type = "value";
                        }
                        return object;
                    };

                    /**
                     * Converts this Entry to JSON.
                     * @function toJSON
                     * @memberof clutch.envoytriage.v1.Runtime.Entry
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Entry.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Entry;
                })();

                return Runtime;
            })();

            v1.ServerInfo = (function() {

                /**
                 * Properties of a ServerInfo.
                 * @memberof clutch.envoytriage.v1
                 * @interface IServerInfo
                 * @property {google.protobuf.IValue|null} [value] ServerInfo value
                 */

                /**
                 * Constructs a new ServerInfo.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a ServerInfo.
                 * @implements IServerInfo
                 * @constructor
                 * @param {clutch.envoytriage.v1.IServerInfo=} [properties] Properties to set
                 */
                function ServerInfo(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ServerInfo value.
                 * @member {google.protobuf.IValue|null|undefined} value
                 * @memberof clutch.envoytriage.v1.ServerInfo
                 * @instance
                 */
                ServerInfo.prototype.value = null;

                /**
                 * Verifies a ServerInfo message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.ServerInfo
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ServerInfo.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.value != null && message.hasOwnProperty("value")) {
                        let error = $root.google.protobuf.Value.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ServerInfo message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.ServerInfo
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.ServerInfo} ServerInfo
                 */
                ServerInfo.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.ServerInfo)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.ServerInfo();
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".clutch.envoytriage.v1.ServerInfo.value: object expected");
                        message.value = $root.google.protobuf.Value.fromObject(object.value);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ServerInfo message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.ServerInfo
                 * @static
                 * @param {clutch.envoytriage.v1.ServerInfo} message ServerInfo
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ServerInfo.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.value = null;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.google.protobuf.Value.toObject(message.value, options);
                    return object;
                };

                /**
                 * Converts this ServerInfo to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.ServerInfo
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ServerInfo.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ServerInfo;
            })();

            v1.Stats = (function() {

                /**
                 * Properties of a Stats.
                 * @memberof clutch.envoytriage.v1
                 * @interface IStats
                 * @property {Array.<clutch.envoytriage.v1.Stats.IStat>|null} [stats] Stats stats
                 */

                /**
                 * Constructs a new Stats.
                 * @memberof clutch.envoytriage.v1
                 * @classdesc Represents a Stats.
                 * @implements IStats
                 * @constructor
                 * @param {clutch.envoytriage.v1.IStats=} [properties] Properties to set
                 */
                function Stats(properties) {
                    this.stats = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Stats stats.
                 * @member {Array.<clutch.envoytriage.v1.Stats.IStat>} stats
                 * @memberof clutch.envoytriage.v1.Stats
                 * @instance
                 */
                Stats.prototype.stats = $util.emptyArray;

                /**
                 * Verifies a Stats message.
                 * @function verify
                 * @memberof clutch.envoytriage.v1.Stats
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Stats.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.stats != null && message.hasOwnProperty("stats")) {
                        if (!Array.isArray(message.stats))
                            return "stats: array expected";
                        for (let i = 0; i < message.stats.length; ++i) {
                            let error = $root.clutch.envoytriage.v1.Stats.Stat.verify(message.stats[i]);
                            if (error)
                                return "stats." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Stats message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.envoytriage.v1.Stats
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.envoytriage.v1.Stats} Stats
                 */
                Stats.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.envoytriage.v1.Stats)
                        return object;
                    let message = new $root.clutch.envoytriage.v1.Stats();
                    if (object.stats) {
                        if (!Array.isArray(object.stats))
                            throw TypeError(".clutch.envoytriage.v1.Stats.stats: array expected");
                        message.stats = [];
                        for (let i = 0; i < object.stats.length; ++i) {
                            if (typeof object.stats[i] !== "object")
                                throw TypeError(".clutch.envoytriage.v1.Stats.stats: object expected");
                            message.stats[i] = $root.clutch.envoytriage.v1.Stats.Stat.fromObject(object.stats[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Stats message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.envoytriage.v1.Stats
                 * @static
                 * @param {clutch.envoytriage.v1.Stats} message Stats
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Stats.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.stats = [];
                    if (message.stats && message.stats.length) {
                        object.stats = [];
                        for (let j = 0; j < message.stats.length; ++j)
                            object.stats[j] = $root.clutch.envoytriage.v1.Stats.Stat.toObject(message.stats[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Stats to JSON.
                 * @function toJSON
                 * @memberof clutch.envoytriage.v1.Stats
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Stats.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                Stats.Stat = (function() {

                    /**
                     * Properties of a Stat.
                     * @memberof clutch.envoytriage.v1.Stats
                     * @interface IStat
                     * @property {string|null} [key] Stat key
                     * @property {number|Long|null} [value] Stat value
                     */

                    /**
                     * Constructs a new Stat.
                     * @memberof clutch.envoytriage.v1.Stats
                     * @classdesc Represents a Stat.
                     * @implements IStat
                     * @constructor
                     * @param {clutch.envoytriage.v1.Stats.IStat=} [properties] Properties to set
                     */
                    function Stat(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Stat key.
                     * @member {string} key
                     * @memberof clutch.envoytriage.v1.Stats.Stat
                     * @instance
                     */
                    Stat.prototype.key = "";

                    /**
                     * Stat value.
                     * @member {number|Long} value
                     * @memberof clutch.envoytriage.v1.Stats.Stat
                     * @instance
                     */
                    Stat.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

                    /**
                     * Verifies a Stat message.
                     * @function verify
                     * @memberof clutch.envoytriage.v1.Stats.Stat
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Stat.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.key != null && message.hasOwnProperty("key"))
                            if (!$util.isString(message.key))
                                return "key: string expected";
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                                return "value: integer|Long expected";
                        return null;
                    };

                    /**
                     * Creates a Stat message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.envoytriage.v1.Stats.Stat
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.envoytriage.v1.Stats.Stat} Stat
                     */
                    Stat.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.envoytriage.v1.Stats.Stat)
                            return object;
                        let message = new $root.clutch.envoytriage.v1.Stats.Stat();
                        if (object.key != null)
                            message.key = String(object.key);
                        if (object.value != null)
                            if ($util.Long)
                                (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                            else if (typeof object.value === "string")
                                message.value = parseInt(object.value, 10);
                            else if (typeof object.value === "number")
                                message.value = object.value;
                            else if (typeof object.value === "object")
                                message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Stat message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.envoytriage.v1.Stats.Stat
                     * @static
                     * @param {clutch.envoytriage.v1.Stats.Stat} message Stat
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Stat.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.key = "";
                            if ($util.Long) {
                                let long = new $util.Long(0, 0, true);
                                object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                            } else
                                object.value = options.longs === String ? "0" : 0;
                        }
                        if (message.key != null && message.hasOwnProperty("key"))
                            object.key = message.key;
                        if (message.value != null && message.hasOwnProperty("value"))
                            if (typeof message.value === "number")
                                object.value = options.longs === String ? String(message.value) : message.value;
                            else
                                object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                        return object;
                    };

                    /**
                     * Converts this Stat to JSON.
                     * @function toJSON
                     * @memberof clutch.envoytriage.v1.Stats.Stat
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Stat.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Stat;
                })();

                return Stats;
            })();

            return v1;
        })();

        return envoytriage;
    })();

    clutch.healthcheck = (function() {

        /**
         * Namespace healthcheck.
         * @memberof clutch
         * @namespace
         */
        const healthcheck = {};

        healthcheck.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.healthcheck
             * @namespace
             */
            const v1 = {};

            v1.HealthcheckAPI = (function() {

                /**
                 * Constructs a new HealthcheckAPI service.
                 * @memberof clutch.healthcheck.v1
                 * @classdesc Represents a HealthcheckAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function HealthcheckAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (HealthcheckAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = HealthcheckAPI;

                /**
                 * Callback as used by {@link clutch.healthcheck.v1.HealthcheckAPI#healthcheck}.
                 * @memberof clutch.healthcheck.v1.HealthcheckAPI
                 * @typedef HealthcheckCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.healthcheck.v1.HealthcheckResponse} [response] HealthcheckResponse
                 */

                /**
                 * Calls Healthcheck.
                 * @function healthcheck
                 * @memberof clutch.healthcheck.v1.HealthcheckAPI
                 * @instance
                 * @param {clutch.healthcheck.v1.IHealthcheckRequest} request HealthcheckRequest message or plain object
                 * @param {clutch.healthcheck.v1.HealthcheckAPI.HealthcheckCallback} callback Node-style callback called with the error, if any, and HealthcheckResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(HealthcheckAPI.prototype.healthcheck = function healthcheck(request, callback) {
                    return this.rpcCall(healthcheck, $root.clutch.healthcheck.v1.HealthcheckRequest, $root.clutch.healthcheck.v1.HealthcheckResponse, request, callback);
                }, "name", { value: "Healthcheck" });

                /**
                 * Calls Healthcheck.
                 * @function healthcheck
                 * @memberof clutch.healthcheck.v1.HealthcheckAPI
                 * @instance
                 * @param {clutch.healthcheck.v1.IHealthcheckRequest} request HealthcheckRequest message or plain object
                 * @returns {Promise<clutch.healthcheck.v1.HealthcheckResponse>} Promise
                 * @variation 2
                 */

                return HealthcheckAPI;
            })();

            v1.HealthcheckRequest = (function() {

                /**
                 * Properties of a HealthcheckRequest.
                 * @memberof clutch.healthcheck.v1
                 * @interface IHealthcheckRequest
                 */

                /**
                 * Constructs a new HealthcheckRequest.
                 * @memberof clutch.healthcheck.v1
                 * @classdesc Represents a HealthcheckRequest.
                 * @implements IHealthcheckRequest
                 * @constructor
                 * @param {clutch.healthcheck.v1.IHealthcheckRequest=} [properties] Properties to set
                 */
                function HealthcheckRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a HealthcheckRequest message.
                 * @function verify
                 * @memberof clutch.healthcheck.v1.HealthcheckRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HealthcheckRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a HealthcheckRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.healthcheck.v1.HealthcheckRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.healthcheck.v1.HealthcheckRequest} HealthcheckRequest
                 */
                HealthcheckRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.healthcheck.v1.HealthcheckRequest)
                        return object;
                    return new $root.clutch.healthcheck.v1.HealthcheckRequest();
                };

                /**
                 * Creates a plain object from a HealthcheckRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.healthcheck.v1.HealthcheckRequest
                 * @static
                 * @param {clutch.healthcheck.v1.HealthcheckRequest} message HealthcheckRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HealthcheckRequest.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this HealthcheckRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.healthcheck.v1.HealthcheckRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HealthcheckRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return HealthcheckRequest;
            })();

            v1.HealthcheckResponse = (function() {

                /**
                 * Properties of a HealthcheckResponse.
                 * @memberof clutch.healthcheck.v1
                 * @interface IHealthcheckResponse
                 */

                /**
                 * Constructs a new HealthcheckResponse.
                 * @memberof clutch.healthcheck.v1
                 * @classdesc Represents a HealthcheckResponse.
                 * @implements IHealthcheckResponse
                 * @constructor
                 * @param {clutch.healthcheck.v1.IHealthcheckResponse=} [properties] Properties to set
                 */
                function HealthcheckResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a HealthcheckResponse message.
                 * @function verify
                 * @memberof clutch.healthcheck.v1.HealthcheckResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HealthcheckResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a HealthcheckResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.healthcheck.v1.HealthcheckResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.healthcheck.v1.HealthcheckResponse} HealthcheckResponse
                 */
                HealthcheckResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.healthcheck.v1.HealthcheckResponse)
                        return object;
                    return new $root.clutch.healthcheck.v1.HealthcheckResponse();
                };

                /**
                 * Creates a plain object from a HealthcheckResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.healthcheck.v1.HealthcheckResponse
                 * @static
                 * @param {clutch.healthcheck.v1.HealthcheckResponse} message HealthcheckResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HealthcheckResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this HealthcheckResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.healthcheck.v1.HealthcheckResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HealthcheckResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return HealthcheckResponse;
            })();

            return v1;
        })();

        return healthcheck;
    })();

    clutch.k8s = (function() {

        /**
         * Namespace k8s.
         * @memberof clutch
         * @namespace
         */
        const k8s = {};

        k8s.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.k8s
             * @namespace
             */
            const v1 = {};

            v1.K8sAPI = (function() {

                /**
                 * Constructs a new K8sAPI service.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a K8sAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function K8sAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (K8sAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = K8sAPI;

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#describePod}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DescribePodCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DescribePodResponse} [response] DescribePodResponse
                 */

                /**
                 * Calls DescribePod.
                 * @function describePod
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribePodRequest} request DescribePodRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DescribePodCallback} callback Node-style callback called with the error, if any, and DescribePodResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.describePod = function describePod(request, callback) {
                    return this.rpcCall(describePod, $root.clutch.k8s.v1.DescribePodRequest, $root.clutch.k8s.v1.DescribePodResponse, request, callback);
                }, "name", { value: "DescribePod" });

                /**
                 * Calls DescribePod.
                 * @function describePod
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDescribePodRequest} request DescribePodRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DescribePodResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#listPods}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef ListPodsCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.ListPodsResponse} [response] ListPodsResponse
                 */

                /**
                 * Calls ListPods.
                 * @function listPods
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListPodsRequest} request ListPodsRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.ListPodsCallback} callback Node-style callback called with the error, if any, and ListPodsResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.listPods = function listPods(request, callback) {
                    return this.rpcCall(listPods, $root.clutch.k8s.v1.ListPodsRequest, $root.clutch.k8s.v1.ListPodsResponse, request, callback);
                }, "name", { value: "ListPods" });

                /**
                 * Calls ListPods.
                 * @function listPods
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IListPodsRequest} request ListPodsRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.ListPodsResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#deletePod}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef DeletePodCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.DeletePodResponse} [response] DeletePodResponse
                 */

                /**
                 * Calls DeletePod.
                 * @function deletePod
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeletePodRequest} request DeletePodRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.DeletePodCallback} callback Node-style callback called with the error, if any, and DeletePodResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.deletePod = function deletePod(request, callback) {
                    return this.rpcCall(deletePod, $root.clutch.k8s.v1.DeletePodRequest, $root.clutch.k8s.v1.DeletePodResponse, request, callback);
                }, "name", { value: "DeletePod" });

                /**
                 * Calls DeletePod.
                 * @function deletePod
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IDeletePodRequest} request DeletePodRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.DeletePodResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#updatePod}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef UpdatePodCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.UpdatePodResponse} [response] UpdatePodResponse
                 */

                /**
                 * Calls UpdatePod.
                 * @function updatePod
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IUpdatePodRequest} request UpdatePodRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.UpdatePodCallback} callback Node-style callback called with the error, if any, and UpdatePodResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.updatePod = function updatePod(request, callback) {
                    return this.rpcCall(updatePod, $root.clutch.k8s.v1.UpdatePodRequest, $root.clutch.k8s.v1.UpdatePodResponse, request, callback);
                }, "name", { value: "UpdatePod" });

                /**
                 * Calls UpdatePod.
                 * @function updatePod
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IUpdatePodRequest} request UpdatePodRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.UpdatePodResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#resizeHPA}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef ResizeHPACallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.ResizeHPAResponse} [response] ResizeHPAResponse
                 */

                /**
                 * Calls ResizeHPA.
                 * @function resizeHPA
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IResizeHPARequest} request ResizeHPARequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.ResizeHPACallback} callback Node-style callback called with the error, if any, and ResizeHPAResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.resizeHPA = function resizeHPA(request, callback) {
                    return this.rpcCall(resizeHPA, $root.clutch.k8s.v1.ResizeHPARequest, $root.clutch.k8s.v1.ResizeHPAResponse, request, callback);
                }, "name", { value: "ResizeHPA" });

                /**
                 * Calls ResizeHPA.
                 * @function resizeHPA
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IResizeHPARequest} request ResizeHPARequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.ResizeHPAResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.k8s.v1.K8sAPI#updateDeployment}.
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @typedef UpdateDeploymentCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.k8s.v1.UpdateDeploymentResponse} [response] UpdateDeploymentResponse
                 */

                /**
                 * Calls UpdateDeployment.
                 * @function updateDeployment
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IUpdateDeploymentRequest} request UpdateDeploymentRequest message or plain object
                 * @param {clutch.k8s.v1.K8sAPI.UpdateDeploymentCallback} callback Node-style callback called with the error, if any, and UpdateDeploymentResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(K8sAPI.prototype.updateDeployment = function updateDeployment(request, callback) {
                    return this.rpcCall(updateDeployment, $root.clutch.k8s.v1.UpdateDeploymentRequest, $root.clutch.k8s.v1.UpdateDeploymentResponse, request, callback);
                }, "name", { value: "UpdateDeployment" });

                /**
                 * Calls UpdateDeployment.
                 * @function updateDeployment
                 * @memberof clutch.k8s.v1.K8sAPI
                 * @instance
                 * @param {clutch.k8s.v1.IUpdateDeploymentRequest} request UpdateDeploymentRequest message or plain object
                 * @returns {Promise<clutch.k8s.v1.UpdateDeploymentResponse>} Promise
                 * @variation 2
                 */

                return K8sAPI;
            })();

            v1.DescribePodRequest = (function() {

                /**
                 * Properties of a DescribePodRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribePodRequest
                 * @property {string|null} [clientset] DescribePodRequest clientset
                 * @property {string|null} [cluster] DescribePodRequest cluster
                 * @property {string|null} [namespace] DescribePodRequest namespace
                 * @property {string|null} [name] DescribePodRequest name
                 * @property {Object.<string,string>|null} [labels] DescribePodRequest labels
                 */

                /**
                 * Constructs a new DescribePodRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribePodRequest.
                 * @implements IDescribePodRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribePodRequest=} [properties] Properties to set
                 */
                function DescribePodRequest(properties) {
                    this.labels = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribePodRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @instance
                 */
                DescribePodRequest.prototype.clientset = "";

                /**
                 * DescribePodRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @instance
                 */
                DescribePodRequest.prototype.cluster = "";

                /**
                 * DescribePodRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @instance
                 */
                DescribePodRequest.prototype.namespace = "";

                /**
                 * DescribePodRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @instance
                 */
                DescribePodRequest.prototype.name = "";

                /**
                 * DescribePodRequest labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @instance
                 */
                DescribePodRequest.prototype.labels = $util.emptyObject;

                /**
                 * Verifies a DescribePodRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribePodRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates a DescribePodRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribePodRequest} DescribePodRequest
                 */
                DescribePodRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribePodRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribePodRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.DescribePodRequest.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DescribePodRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @static
                 * @param {clutch.k8s.v1.DescribePodRequest} message DescribePodRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribePodRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.labels = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Converts this DescribePodRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribePodRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribePodRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribePodRequest;
            })();

            v1.DescribePodResponse = (function() {

                /**
                 * Properties of a DescribePodResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDescribePodResponse
                 * @property {clutch.k8s.v1.IPod|null} [pod] DescribePodResponse pod
                 */

                /**
                 * Constructs a new DescribePodResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DescribePodResponse.
                 * @implements IDescribePodResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDescribePodResponse=} [properties] Properties to set
                 */
                function DescribePodResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DescribePodResponse pod.
                 * @member {clutch.k8s.v1.IPod|null|undefined} pod
                 * @memberof clutch.k8s.v1.DescribePodResponse
                 * @instance
                 */
                DescribePodResponse.prototype.pod = null;

                /**
                 * Verifies a DescribePodResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DescribePodResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DescribePodResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pod != null && message.hasOwnProperty("pod")) {
                        let error = $root.clutch.k8s.v1.Pod.verify(message.pod);
                        if (error)
                            return "pod." + error;
                    }
                    return null;
                };

                /**
                 * Creates a DescribePodResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DescribePodResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DescribePodResponse} DescribePodResponse
                 */
                DescribePodResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DescribePodResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.DescribePodResponse();
                    if (object.pod != null) {
                        if (typeof object.pod !== "object")
                            throw TypeError(".clutch.k8s.v1.DescribePodResponse.pod: object expected");
                        message.pod = $root.clutch.k8s.v1.Pod.fromObject(object.pod);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a DescribePodResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DescribePodResponse
                 * @static
                 * @param {clutch.k8s.v1.DescribePodResponse} message DescribePodResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DescribePodResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.pod = null;
                    if (message.pod != null && message.hasOwnProperty("pod"))
                        object.pod = $root.clutch.k8s.v1.Pod.toObject(message.pod, options);
                    return object;
                };

                /**
                 * Converts this DescribePodResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DescribePodResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DescribePodResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DescribePodResponse;
            })();

            v1.Container = (function() {

                /**
                 * Properties of a Container.
                 * @memberof clutch.k8s.v1
                 * @interface IContainer
                 * @property {string|null} [name] Container name
                 * @property {string|null} [image] Container image
                 * @property {clutch.k8s.v1.Container.State|null} [state] Container state
                 * @property {boolean|null} [ready] Container ready
                 */

                /**
                 * Constructs a new Container.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a Container.
                 * @implements IContainer
                 * @constructor
                 * @param {clutch.k8s.v1.IContainer=} [properties] Properties to set
                 */
                function Container(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Container name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 */
                Container.prototype.name = "";

                /**
                 * Container image.
                 * @member {string} image
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 */
                Container.prototype.image = "";

                /**
                 * Container state.
                 * @member {clutch.k8s.v1.Container.State} state
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 */
                Container.prototype.state = 0;

                /**
                 * Container ready.
                 * @member {boolean} ready
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 */
                Container.prototype.ready = false;

                /**
                 * Verifies a Container message.
                 * @function verify
                 * @memberof clutch.k8s.v1.Container
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Container.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.image != null && message.hasOwnProperty("image"))
                        if (!$util.isString(message.image))
                            return "image: string expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                            break;
                        }
                    if (message.ready != null && message.hasOwnProperty("ready"))
                        if (typeof message.ready !== "boolean")
                            return "ready: boolean expected";
                    return null;
                };

                /**
                 * Creates a Container message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.Container
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.Container} Container
                 */
                Container.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.Container)
                        return object;
                    let message = new $root.clutch.k8s.v1.Container();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.image != null)
                        message.image = String(object.image);
                    switch (object.state) {
                    case "UNSPECIFIED":
                    case 0:
                        message.state = 0;
                        break;
                    case "UNKNOWN":
                    case 1:
                        message.state = 1;
                        break;
                    case "TERMINATED":
                    case 2:
                        message.state = 2;
                        break;
                    case "RUNNING":
                    case 3:
                        message.state = 3;
                        break;
                    case "WAITING":
                    case 4:
                        message.state = 4;
                        break;
                    }
                    if (object.ready != null)
                        message.ready = Boolean(object.ready);
                    return message;
                };

                /**
                 * Creates a plain object from a Container message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.Container
                 * @static
                 * @param {clutch.k8s.v1.Container} message Container
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Container.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.image = "";
                        object.state = options.enums === String ? "UNSPECIFIED" : 0;
                        object.ready = false;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.image != null && message.hasOwnProperty("image"))
                        object.image = message.image;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = options.enums === String ? $root.clutch.k8s.v1.Container.State[message.state] : message.state;
                    if (message.ready != null && message.hasOwnProperty("ready"))
                        object.ready = message.ready;
                    return object;
                };

                /**
                 * Converts this Container to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.Container
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Container.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * State enum.
                 * @name clutch.k8s.v1.Container.State
                 * @enum {number}
                 * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                 * @property {number} UNKNOWN=1 UNKNOWN value
                 * @property {number} TERMINATED=2 TERMINATED value
                 * @property {number} RUNNING=3 RUNNING value
                 * @property {number} WAITING=4 WAITING value
                 */
                Container.State = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNSPECIFIED"] = 0;
                    values[valuesById[1] = "UNKNOWN"] = 1;
                    values[valuesById[2] = "TERMINATED"] = 2;
                    values[valuesById[3] = "RUNNING"] = 3;
                    values[valuesById[4] = "WAITING"] = 4;
                    return values;
                })();

                return Container;
            })();

            v1.Pod = (function() {

                /**
                 * Properties of a Pod.
                 * @memberof clutch.k8s.v1
                 * @interface IPod
                 * @property {string|null} [cluster] Pod cluster
                 * @property {string|null} [namespace] Pod namespace
                 * @property {string|null} [name] Pod name
                 * @property {Array.<clutch.k8s.v1.IContainer>|null} [containers] Pod containers
                 * @property {string|null} [nodeIp] Pod nodeIp
                 * @property {string|null} [podIp] Pod podIp
                 * @property {clutch.k8s.v1.Pod.State|null} [state] Pod state
                 * @property {google.protobuf.ITimestamp|null} [startTime] Pod startTime
                 * @property {Object.<string,string>|null} [labels] Pod labels
                 * @property {Object.<string,string>|null} [annotations] Pod annotations
                 */

                /**
                 * Constructs a new Pod.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a Pod.
                 * @implements IPod
                 * @constructor
                 * @param {clutch.k8s.v1.IPod=} [properties] Properties to set
                 */
                function Pod(properties) {
                    this.containers = [];
                    this.labels = {};
                    this.annotations = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Pod cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.cluster = "";

                /**
                 * Pod namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.namespace = "";

                /**
                 * Pod name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.name = "";

                /**
                 * Pod containers.
                 * @member {Array.<clutch.k8s.v1.IContainer>} containers
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.containers = $util.emptyArray;

                /**
                 * Pod nodeIp.
                 * @member {string} nodeIp
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.nodeIp = "";

                /**
                 * Pod podIp.
                 * @member {string} podIp
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.podIp = "";

                /**
                 * Pod state.
                 * @member {clutch.k8s.v1.Pod.State} state
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.state = 0;

                /**
                 * Pod startTime.
                 * @member {google.protobuf.ITimestamp|null|undefined} startTime
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.startTime = null;

                /**
                 * Pod labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.labels = $util.emptyObject;

                /**
                 * Pod annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 */
                Pod.prototype.annotations = $util.emptyObject;

                /**
                 * Verifies a Pod message.
                 * @function verify
                 * @memberof clutch.k8s.v1.Pod
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Pod.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.containers != null && message.hasOwnProperty("containers")) {
                        if (!Array.isArray(message.containers))
                            return "containers: array expected";
                        for (let i = 0; i < message.containers.length; ++i) {
                            let error = $root.clutch.k8s.v1.Container.verify(message.containers[i]);
                            if (error)
                                return "containers." + error;
                        }
                    }
                    if (message.nodeIp != null && message.hasOwnProperty("nodeIp"))
                        if (!$util.isString(message.nodeIp))
                            return "nodeIp: string expected";
                    if (message.podIp != null && message.hasOwnProperty("podIp"))
                        if (!$util.isString(message.podIp))
                            return "podIp: string expected";
                    if (message.state != null && message.hasOwnProperty("state"))
                        switch (message.state) {
                        default:
                            return "state: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                            break;
                        }
                    if (message.startTime != null && message.hasOwnProperty("startTime")) {
                        let error = $root.google.protobuf.Timestamp.verify(message.startTime);
                        if (error)
                            return "startTime." + error;
                    }
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates a Pod message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.Pod
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.Pod} Pod
                 */
                Pod.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.Pod)
                        return object;
                    let message = new $root.clutch.k8s.v1.Pod();
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.containers) {
                        if (!Array.isArray(object.containers))
                            throw TypeError(".clutch.k8s.v1.Pod.containers: array expected");
                        message.containers = [];
                        for (let i = 0; i < object.containers.length; ++i) {
                            if (typeof object.containers[i] !== "object")
                                throw TypeError(".clutch.k8s.v1.Pod.containers: object expected");
                            message.containers[i] = $root.clutch.k8s.v1.Container.fromObject(object.containers[i]);
                        }
                    }
                    if (object.nodeIp != null)
                        message.nodeIp = String(object.nodeIp);
                    if (object.podIp != null)
                        message.podIp = String(object.podIp);
                    switch (object.state) {
                    case "UNSPECIFIED":
                    case 0:
                        message.state = 0;
                        break;
                    case "UNKNOWN":
                    case 1:
                        message.state = 1;
                        break;
                    case "PENDING":
                    case 2:
                        message.state = 2;
                        break;
                    case "RUNNING":
                    case 3:
                        message.state = 3;
                        break;
                    case "SUCCEEDED":
                    case 4:
                        message.state = 4;
                        break;
                    case "FAILED":
                    case 5:
                        message.state = 5;
                        break;
                    }
                    if (object.startTime != null) {
                        if (typeof object.startTime !== "object")
                            throw TypeError(".clutch.k8s.v1.Pod.startTime: object expected");
                        message.startTime = $root.google.protobuf.Timestamp.fromObject(object.startTime);
                    }
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.Pod.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.Pod.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                            message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Pod message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.Pod
                 * @static
                 * @param {clutch.k8s.v1.Pod} message Pod
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Pod.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.containers = [];
                    if (options.objects || options.defaults) {
                        object.labels = {};
                        object.annotations = {};
                    }
                    if (options.defaults) {
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.nodeIp = "";
                        object.podIp = "";
                        object.state = options.enums === String ? "UNSPECIFIED" : 0;
                        object.startTime = null;
                    }
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.containers && message.containers.length) {
                        object.containers = [];
                        for (let j = 0; j < message.containers.length; ++j)
                            object.containers[j] = $root.clutch.k8s.v1.Container.toObject(message.containers[j], options);
                    }
                    if (message.nodeIp != null && message.hasOwnProperty("nodeIp"))
                        object.nodeIp = message.nodeIp;
                    if (message.podIp != null && message.hasOwnProperty("podIp"))
                        object.podIp = message.podIp;
                    if (message.state != null && message.hasOwnProperty("state"))
                        object.state = options.enums === String ? $root.clutch.k8s.v1.Pod.State[message.state] : message.state;
                    if (message.startTime != null && message.hasOwnProperty("startTime"))
                        object.startTime = $root.google.protobuf.Timestamp.toObject(message.startTime, options);
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = message.annotations[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Converts this Pod to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.Pod
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Pod.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * State enum.
                 * @name clutch.k8s.v1.Pod.State
                 * @enum {number}
                 * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                 * @property {number} UNKNOWN=1 UNKNOWN value
                 * @property {number} PENDING=2 PENDING value
                 * @property {number} RUNNING=3 RUNNING value
                 * @property {number} SUCCEEDED=4 SUCCEEDED value
                 * @property {number} FAILED=5 FAILED value
                 */
                Pod.State = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNSPECIFIED"] = 0;
                    values[valuesById[1] = "UNKNOWN"] = 1;
                    values[valuesById[2] = "PENDING"] = 2;
                    values[valuesById[3] = "RUNNING"] = 3;
                    values[valuesById[4] = "SUCCEEDED"] = 4;
                    values[valuesById[5] = "FAILED"] = 5;
                    return values;
                })();

                return Pod;
            })();

            v1.ListOptions = (function() {

                /**
                 * Properties of a ListOptions.
                 * @memberof clutch.k8s.v1
                 * @interface IListOptions
                 * @property {Object.<string,string>|null} [labels] ListOptions labels
                 */

                /**
                 * Constructs a new ListOptions.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListOptions.
                 * @implements IListOptions
                 * @constructor
                 * @param {clutch.k8s.v1.IListOptions=} [properties] Properties to set
                 */
                function ListOptions(properties) {
                    this.labels = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListOptions labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.ListOptions
                 * @instance
                 */
                ListOptions.prototype.labels = $util.emptyObject;

                /**
                 * Verifies a ListOptions message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListOptions
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListOptions.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates a ListOptions message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListOptions
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListOptions} ListOptions
                 */
                ListOptions.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListOptions)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListOptions();
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.ListOptions.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListOptions message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListOptions
                 * @static
                 * @param {clutch.k8s.v1.ListOptions} message ListOptions
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListOptions.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.labels = {};
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Converts this ListOptions to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListOptions
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListOptions.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListOptions;
            })();

            v1.ListPodsRequest = (function() {

                /**
                 * Properties of a ListPodsRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IListPodsRequest
                 * @property {string|null} [clientset] ListPodsRequest clientset
                 * @property {string|null} [cluster] ListPodsRequest cluster
                 * @property {string|null} [namespace] ListPodsRequest namespace
                 * @property {clutch.k8s.v1.IListOptions|null} [options] ListPodsRequest options
                 */

                /**
                 * Constructs a new ListPodsRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListPodsRequest.
                 * @implements IListPodsRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IListPodsRequest=} [properties] Properties to set
                 */
                function ListPodsRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListPodsRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @instance
                 */
                ListPodsRequest.prototype.clientset = "";

                /**
                 * ListPodsRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @instance
                 */
                ListPodsRequest.prototype.cluster = "";

                /**
                 * ListPodsRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @instance
                 */
                ListPodsRequest.prototype.namespace = "";

                /**
                 * ListPodsRequest options.
                 * @member {clutch.k8s.v1.IListOptions|null|undefined} options
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @instance
                 */
                ListPodsRequest.prototype.options = null;

                /**
                 * Verifies a ListPodsRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListPodsRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        let error = $root.clutch.k8s.v1.ListOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ListPodsRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListPodsRequest} ListPodsRequest
                 */
                ListPodsRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListPodsRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListPodsRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".clutch.k8s.v1.ListPodsRequest.options: object expected");
                        message.options = $root.clutch.k8s.v1.ListOptions.fromObject(object.options);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListPodsRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @static
                 * @param {clutch.k8s.v1.ListPodsRequest} message ListPodsRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListPodsRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.options = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.clutch.k8s.v1.ListOptions.toObject(message.options, options);
                    return object;
                };

                /**
                 * Converts this ListPodsRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListPodsRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListPodsRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListPodsRequest;
            })();

            v1.ListPodsResponse = (function() {

                /**
                 * Properties of a ListPodsResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IListPodsResponse
                 * @property {Array.<clutch.k8s.v1.IPod>|null} [pods] ListPodsResponse pods
                 */

                /**
                 * Constructs a new ListPodsResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ListPodsResponse.
                 * @implements IListPodsResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IListPodsResponse=} [properties] Properties to set
                 */
                function ListPodsResponse(properties) {
                    this.pods = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ListPodsResponse pods.
                 * @member {Array.<clutch.k8s.v1.IPod>} pods
                 * @memberof clutch.k8s.v1.ListPodsResponse
                 * @instance
                 */
                ListPodsResponse.prototype.pods = $util.emptyArray;

                /**
                 * Verifies a ListPodsResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ListPodsResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ListPodsResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.pods != null && message.hasOwnProperty("pods")) {
                        if (!Array.isArray(message.pods))
                            return "pods: array expected";
                        for (let i = 0; i < message.pods.length; ++i) {
                            let error = $root.clutch.k8s.v1.Pod.verify(message.pods[i]);
                            if (error)
                                return "pods." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ListPodsResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ListPodsResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ListPodsResponse} ListPodsResponse
                 */
                ListPodsResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ListPodsResponse)
                        return object;
                    let message = new $root.clutch.k8s.v1.ListPodsResponse();
                    if (object.pods) {
                        if (!Array.isArray(object.pods))
                            throw TypeError(".clutch.k8s.v1.ListPodsResponse.pods: array expected");
                        message.pods = [];
                        for (let i = 0; i < object.pods.length; ++i) {
                            if (typeof object.pods[i] !== "object")
                                throw TypeError(".clutch.k8s.v1.ListPodsResponse.pods: object expected");
                            message.pods[i] = $root.clutch.k8s.v1.Pod.fromObject(object.pods[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ListPodsResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ListPodsResponse
                 * @static
                 * @param {clutch.k8s.v1.ListPodsResponse} message ListPodsResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ListPodsResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.pods = [];
                    if (message.pods && message.pods.length) {
                        object.pods = [];
                        for (let j = 0; j < message.pods.length; ++j)
                            object.pods[j] = $root.clutch.k8s.v1.Pod.toObject(message.pods[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ListPodsResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ListPodsResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ListPodsResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ListPodsResponse;
            })();

            v1.DeletePodRequest = (function() {

                /**
                 * Properties of a DeletePodRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IDeletePodRequest
                 * @property {string|null} [clientset] DeletePodRequest clientset
                 * @property {string|null} [cluster] DeletePodRequest cluster
                 * @property {string|null} [namespace] DeletePodRequest namespace
                 * @property {string|null} [name] DeletePodRequest name
                 */

                /**
                 * Constructs a new DeletePodRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeletePodRequest.
                 * @implements IDeletePodRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IDeletePodRequest=} [properties] Properties to set
                 */
                function DeletePodRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * DeletePodRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @instance
                 */
                DeletePodRequest.prototype.clientset = "";

                /**
                 * DeletePodRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @instance
                 */
                DeletePodRequest.prototype.cluster = "";

                /**
                 * DeletePodRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @instance
                 */
                DeletePodRequest.prototype.namespace = "";

                /**
                 * DeletePodRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @instance
                 */
                DeletePodRequest.prototype.name = "";

                /**
                 * Verifies a DeletePodRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeletePodRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    return null;
                };

                /**
                 * Creates a DeletePodRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeletePodRequest} DeletePodRequest
                 */
                DeletePodRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeletePodRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.DeletePodRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    return message;
                };

                /**
                 * Creates a plain object from a DeletePodRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @static
                 * @param {clutch.k8s.v1.DeletePodRequest} message DeletePodRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeletePodRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    return object;
                };

                /**
                 * Converts this DeletePodRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeletePodRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeletePodRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeletePodRequest;
            })();

            v1.DeletePodResponse = (function() {

                /**
                 * Properties of a DeletePodResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IDeletePodResponse
                 */

                /**
                 * Constructs a new DeletePodResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a DeletePodResponse.
                 * @implements IDeletePodResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IDeletePodResponse=} [properties] Properties to set
                 */
                function DeletePodResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a DeletePodResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.DeletePodResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                DeletePodResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a DeletePodResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.DeletePodResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.DeletePodResponse} DeletePodResponse
                 */
                DeletePodResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.DeletePodResponse)
                        return object;
                    return new $root.clutch.k8s.v1.DeletePodResponse();
                };

                /**
                 * Creates a plain object from a DeletePodResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.DeletePodResponse
                 * @static
                 * @param {clutch.k8s.v1.DeletePodResponse} message DeletePodResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                DeletePodResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this DeletePodResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.DeletePodResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                DeletePodResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return DeletePodResponse;
            })();

            v1.UpdatePodRequest = (function() {

                /**
                 * Properties of an UpdatePodRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IUpdatePodRequest
                 * @property {string|null} [clientset] UpdatePodRequest clientset
                 * @property {string|null} [cluster] UpdatePodRequest cluster
                 * @property {string|null} [namespace] UpdatePodRequest namespace
                 * @property {string|null} [name] UpdatePodRequest name
                 * @property {clutch.k8s.v1.IExpectedObjectMetaFields|null} [expectedObjectMetaFields] UpdatePodRequest expectedObjectMetaFields
                 * @property {clutch.k8s.v1.IObjectMetaFields|null} [objectMetaFields] UpdatePodRequest objectMetaFields
                 * @property {clutch.k8s.v1.IRemoveObjectMetaFields|null} [removeObjectMetaFields] UpdatePodRequest removeObjectMetaFields
                 */

                /**
                 * Constructs a new UpdatePodRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an UpdatePodRequest.
                 * @implements IUpdatePodRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IUpdatePodRequest=} [properties] Properties to set
                 */
                function UpdatePodRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdatePodRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 */
                UpdatePodRequest.prototype.clientset = "";

                /**
                 * UpdatePodRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 */
                UpdatePodRequest.prototype.cluster = "";

                /**
                 * UpdatePodRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 */
                UpdatePodRequest.prototype.namespace = "";

                /**
                 * UpdatePodRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 */
                UpdatePodRequest.prototype.name = "";

                /**
                 * UpdatePodRequest expectedObjectMetaFields.
                 * @member {clutch.k8s.v1.IExpectedObjectMetaFields|null|undefined} expectedObjectMetaFields
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 */
                UpdatePodRequest.prototype.expectedObjectMetaFields = null;

                /**
                 * UpdatePodRequest objectMetaFields.
                 * @member {clutch.k8s.v1.IObjectMetaFields|null|undefined} objectMetaFields
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 */
                UpdatePodRequest.prototype.objectMetaFields = null;

                /**
                 * UpdatePodRequest removeObjectMetaFields.
                 * @member {clutch.k8s.v1.IRemoveObjectMetaFields|null|undefined} removeObjectMetaFields
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 */
                UpdatePodRequest.prototype.removeObjectMetaFields = null;

                /**
                 * Verifies an UpdatePodRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdatePodRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.expectedObjectMetaFields != null && message.hasOwnProperty("expectedObjectMetaFields")) {
                        let error = $root.clutch.k8s.v1.ExpectedObjectMetaFields.verify(message.expectedObjectMetaFields);
                        if (error)
                            return "expectedObjectMetaFields." + error;
                    }
                    if (message.objectMetaFields != null && message.hasOwnProperty("objectMetaFields")) {
                        let error = $root.clutch.k8s.v1.ObjectMetaFields.verify(message.objectMetaFields);
                        if (error)
                            return "objectMetaFields." + error;
                    }
                    if (message.removeObjectMetaFields != null && message.hasOwnProperty("removeObjectMetaFields")) {
                        let error = $root.clutch.k8s.v1.RemoveObjectMetaFields.verify(message.removeObjectMetaFields);
                        if (error)
                            return "removeObjectMetaFields." + error;
                    }
                    return null;
                };

                /**
                 * Creates an UpdatePodRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.UpdatePodRequest} UpdatePodRequest
                 */
                UpdatePodRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.UpdatePodRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.UpdatePodRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.expectedObjectMetaFields != null) {
                        if (typeof object.expectedObjectMetaFields !== "object")
                            throw TypeError(".clutch.k8s.v1.UpdatePodRequest.expectedObjectMetaFields: object expected");
                        message.expectedObjectMetaFields = $root.clutch.k8s.v1.ExpectedObjectMetaFields.fromObject(object.expectedObjectMetaFields);
                    }
                    if (object.objectMetaFields != null) {
                        if (typeof object.objectMetaFields !== "object")
                            throw TypeError(".clutch.k8s.v1.UpdatePodRequest.objectMetaFields: object expected");
                        message.objectMetaFields = $root.clutch.k8s.v1.ObjectMetaFields.fromObject(object.objectMetaFields);
                    }
                    if (object.removeObjectMetaFields != null) {
                        if (typeof object.removeObjectMetaFields !== "object")
                            throw TypeError(".clutch.k8s.v1.UpdatePodRequest.removeObjectMetaFields: object expected");
                        message.removeObjectMetaFields = $root.clutch.k8s.v1.RemoveObjectMetaFields.fromObject(object.removeObjectMetaFields);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an UpdatePodRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @static
                 * @param {clutch.k8s.v1.UpdatePodRequest} message UpdatePodRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdatePodRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.expectedObjectMetaFields = null;
                        object.objectMetaFields = null;
                        object.removeObjectMetaFields = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.expectedObjectMetaFields != null && message.hasOwnProperty("expectedObjectMetaFields"))
                        object.expectedObjectMetaFields = $root.clutch.k8s.v1.ExpectedObjectMetaFields.toObject(message.expectedObjectMetaFields, options);
                    if (message.objectMetaFields != null && message.hasOwnProperty("objectMetaFields"))
                        object.objectMetaFields = $root.clutch.k8s.v1.ObjectMetaFields.toObject(message.objectMetaFields, options);
                    if (message.removeObjectMetaFields != null && message.hasOwnProperty("removeObjectMetaFields"))
                        object.removeObjectMetaFields = $root.clutch.k8s.v1.RemoveObjectMetaFields.toObject(message.removeObjectMetaFields, options);
                    return object;
                };

                /**
                 * Converts this UpdatePodRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.UpdatePodRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdatePodRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdatePodRequest;
            })();

            v1.UpdatePodResponse = (function() {

                /**
                 * Properties of an UpdatePodResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IUpdatePodResponse
                 */

                /**
                 * Constructs a new UpdatePodResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an UpdatePodResponse.
                 * @implements IUpdatePodResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IUpdatePodResponse=} [properties] Properties to set
                 */
                function UpdatePodResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies an UpdatePodResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.UpdatePodResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdatePodResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an UpdatePodResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.UpdatePodResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.UpdatePodResponse} UpdatePodResponse
                 */
                UpdatePodResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.UpdatePodResponse)
                        return object;
                    return new $root.clutch.k8s.v1.UpdatePodResponse();
                };

                /**
                 * Creates a plain object from an UpdatePodResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.UpdatePodResponse
                 * @static
                 * @param {clutch.k8s.v1.UpdatePodResponse} message UpdatePodResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdatePodResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this UpdatePodResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.UpdatePodResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdatePodResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdatePodResponse;
            })();

            v1.HPA = (function() {

                /**
                 * Properties of a HPA.
                 * @memberof clutch.k8s.v1
                 * @interface IHPA
                 * @property {string|null} [cluster] HPA cluster
                 * @property {string|null} [namespace] HPA namespace
                 * @property {string|null} [name] HPA name
                 * @property {clutch.k8s.v1.HPA.ISizing|null} [sizing] HPA sizing
                 * @property {Object.<string,string>|null} [labels] HPA labels
                 * @property {Object.<string,string>|null} [annotations] HPA annotations
                 */

                /**
                 * Constructs a new HPA.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a HPA.
                 * @implements IHPA
                 * @constructor
                 * @param {clutch.k8s.v1.IHPA=} [properties] Properties to set
                 */
                function HPA(properties) {
                    this.labels = {};
                    this.annotations = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * HPA cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.HPA
                 * @instance
                 */
                HPA.prototype.cluster = "";

                /**
                 * HPA namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.HPA
                 * @instance
                 */
                HPA.prototype.namespace = "";

                /**
                 * HPA name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.HPA
                 * @instance
                 */
                HPA.prototype.name = "";

                /**
                 * HPA sizing.
                 * @member {clutch.k8s.v1.HPA.ISizing|null|undefined} sizing
                 * @memberof clutch.k8s.v1.HPA
                 * @instance
                 */
                HPA.prototype.sizing = null;

                /**
                 * HPA labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.HPA
                 * @instance
                 */
                HPA.prototype.labels = $util.emptyObject;

                /**
                 * HPA annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof clutch.k8s.v1.HPA
                 * @instance
                 */
                HPA.prototype.annotations = $util.emptyObject;

                /**
                 * Verifies a HPA message.
                 * @function verify
                 * @memberof clutch.k8s.v1.HPA
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                HPA.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.sizing != null && message.hasOwnProperty("sizing")) {
                        let error = $root.clutch.k8s.v1.HPA.Sizing.verify(message.sizing);
                        if (error)
                            return "sizing." + error;
                    }
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates a HPA message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.HPA
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.HPA} HPA
                 */
                HPA.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.HPA)
                        return object;
                    let message = new $root.clutch.k8s.v1.HPA();
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.sizing != null) {
                        if (typeof object.sizing !== "object")
                            throw TypeError(".clutch.k8s.v1.HPA.sizing: object expected");
                        message.sizing = $root.clutch.k8s.v1.HPA.Sizing.fromObject(object.sizing);
                    }
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.HPA.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.HPA.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                            message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a HPA message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.HPA
                 * @static
                 * @param {clutch.k8s.v1.HPA} message HPA
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                HPA.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.labels = {};
                        object.annotations = {};
                    }
                    if (options.defaults) {
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.sizing = null;
                    }
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.sizing != null && message.hasOwnProperty("sizing"))
                        object.sizing = $root.clutch.k8s.v1.HPA.Sizing.toObject(message.sizing, options);
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = message.annotations[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Converts this HPA to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.HPA
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                HPA.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                HPA.Sizing = (function() {

                    /**
                     * Properties of a Sizing.
                     * @memberof clutch.k8s.v1.HPA
                     * @interface ISizing
                     * @property {number|null} [minReplicas] Sizing minReplicas
                     * @property {number|null} [maxReplicas] Sizing maxReplicas
                     * @property {number|null} [currentReplicas] Sizing currentReplicas
                     * @property {number|null} [desiredReplicas] Sizing desiredReplicas
                     */

                    /**
                     * Constructs a new Sizing.
                     * @memberof clutch.k8s.v1.HPA
                     * @classdesc Represents a Sizing.
                     * @implements ISizing
                     * @constructor
                     * @param {clutch.k8s.v1.HPA.ISizing=} [properties] Properties to set
                     */
                    function Sizing(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Sizing minReplicas.
                     * @member {number} minReplicas
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @instance
                     */
                    Sizing.prototype.minReplicas = 0;

                    /**
                     * Sizing maxReplicas.
                     * @member {number} maxReplicas
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @instance
                     */
                    Sizing.prototype.maxReplicas = 0;

                    /**
                     * Sizing currentReplicas.
                     * @member {number} currentReplicas
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @instance
                     */
                    Sizing.prototype.currentReplicas = 0;

                    /**
                     * Sizing desiredReplicas.
                     * @member {number} desiredReplicas
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @instance
                     */
                    Sizing.prototype.desiredReplicas = 0;

                    /**
                     * Verifies a Sizing message.
                     * @function verify
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Sizing.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.minReplicas != null && message.hasOwnProperty("minReplicas"))
                            if (!$util.isInteger(message.minReplicas))
                                return "minReplicas: integer expected";
                        if (message.maxReplicas != null && message.hasOwnProperty("maxReplicas"))
                            if (!$util.isInteger(message.maxReplicas))
                                return "maxReplicas: integer expected";
                        if (message.currentReplicas != null && message.hasOwnProperty("currentReplicas"))
                            if (!$util.isInteger(message.currentReplicas))
                                return "currentReplicas: integer expected";
                        if (message.desiredReplicas != null && message.hasOwnProperty("desiredReplicas"))
                            if (!$util.isInteger(message.desiredReplicas))
                                return "desiredReplicas: integer expected";
                        return null;
                    };

                    /**
                     * Creates a Sizing message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.k8s.v1.HPA.Sizing} Sizing
                     */
                    Sizing.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.k8s.v1.HPA.Sizing)
                            return object;
                        let message = new $root.clutch.k8s.v1.HPA.Sizing();
                        if (object.minReplicas != null)
                            message.minReplicas = object.minReplicas >>> 0;
                        if (object.maxReplicas != null)
                            message.maxReplicas = object.maxReplicas >>> 0;
                        if (object.currentReplicas != null)
                            message.currentReplicas = object.currentReplicas >>> 0;
                        if (object.desiredReplicas != null)
                            message.desiredReplicas = object.desiredReplicas >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a Sizing message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @static
                     * @param {clutch.k8s.v1.HPA.Sizing} message Sizing
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Sizing.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.minReplicas = 0;
                            object.maxReplicas = 0;
                            object.currentReplicas = 0;
                            object.desiredReplicas = 0;
                        }
                        if (message.minReplicas != null && message.hasOwnProperty("minReplicas"))
                            object.minReplicas = message.minReplicas;
                        if (message.maxReplicas != null && message.hasOwnProperty("maxReplicas"))
                            object.maxReplicas = message.maxReplicas;
                        if (message.currentReplicas != null && message.hasOwnProperty("currentReplicas"))
                            object.currentReplicas = message.currentReplicas;
                        if (message.desiredReplicas != null && message.hasOwnProperty("desiredReplicas"))
                            object.desiredReplicas = message.desiredReplicas;
                        return object;
                    };

                    /**
                     * Converts this Sizing to JSON.
                     * @function toJSON
                     * @memberof clutch.k8s.v1.HPA.Sizing
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Sizing.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Sizing;
                })();

                return HPA;
            })();

            v1.ResizeHPARequest = (function() {

                /**
                 * Properties of a ResizeHPARequest.
                 * @memberof clutch.k8s.v1
                 * @interface IResizeHPARequest
                 * @property {string|null} [clientset] ResizeHPARequest clientset
                 * @property {string|null} [cluster] ResizeHPARequest cluster
                 * @property {string|null} [namespace] ResizeHPARequest namespace
                 * @property {string|null} [name] ResizeHPARequest name
                 * @property {clutch.k8s.v1.ResizeHPARequest.ISizing|null} [sizing] ResizeHPARequest sizing
                 */

                /**
                 * Constructs a new ResizeHPARequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ResizeHPARequest.
                 * @implements IResizeHPARequest
                 * @constructor
                 * @param {clutch.k8s.v1.IResizeHPARequest=} [properties] Properties to set
                 */
                function ResizeHPARequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ResizeHPARequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @instance
                 */
                ResizeHPARequest.prototype.clientset = "";

                /**
                 * ResizeHPARequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @instance
                 */
                ResizeHPARequest.prototype.cluster = "";

                /**
                 * ResizeHPARequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @instance
                 */
                ResizeHPARequest.prototype.namespace = "";

                /**
                 * ResizeHPARequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @instance
                 */
                ResizeHPARequest.prototype.name = "";

                /**
                 * ResizeHPARequest sizing.
                 * @member {clutch.k8s.v1.ResizeHPARequest.ISizing|null|undefined} sizing
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @instance
                 */
                ResizeHPARequest.prototype.sizing = null;

                /**
                 * Verifies a ResizeHPARequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ResizeHPARequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.sizing != null && message.hasOwnProperty("sizing")) {
                        let error = $root.clutch.k8s.v1.ResizeHPARequest.Sizing.verify(message.sizing);
                        if (error)
                            return "sizing." + error;
                    }
                    return null;
                };

                /**
                 * Creates a ResizeHPARequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ResizeHPARequest} ResizeHPARequest
                 */
                ResizeHPARequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ResizeHPARequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.ResizeHPARequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.sizing != null) {
                        if (typeof object.sizing !== "object")
                            throw TypeError(".clutch.k8s.v1.ResizeHPARequest.sizing: object expected");
                        message.sizing = $root.clutch.k8s.v1.ResizeHPARequest.Sizing.fromObject(object.sizing);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ResizeHPARequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @static
                 * @param {clutch.k8s.v1.ResizeHPARequest} message ResizeHPARequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ResizeHPARequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.sizing = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.sizing != null && message.hasOwnProperty("sizing"))
                        object.sizing = $root.clutch.k8s.v1.ResizeHPARequest.Sizing.toObject(message.sizing, options);
                    return object;
                };

                /**
                 * Converts this ResizeHPARequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ResizeHPARequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ResizeHPARequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                ResizeHPARequest.Sizing = (function() {

                    /**
                     * Properties of a Sizing.
                     * @memberof clutch.k8s.v1.ResizeHPARequest
                     * @interface ISizing
                     * @property {number|null} [min] Sizing min
                     * @property {number|null} [max] Sizing max
                     */

                    /**
                     * Constructs a new Sizing.
                     * @memberof clutch.k8s.v1.ResizeHPARequest
                     * @classdesc Represents a Sizing.
                     * @implements ISizing
                     * @constructor
                     * @param {clutch.k8s.v1.ResizeHPARequest.ISizing=} [properties] Properties to set
                     */
                    function Sizing(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Sizing min.
                     * @member {number} min
                     * @memberof clutch.k8s.v1.ResizeHPARequest.Sizing
                     * @instance
                     */
                    Sizing.prototype.min = 0;

                    /**
                     * Sizing max.
                     * @member {number} max
                     * @memberof clutch.k8s.v1.ResizeHPARequest.Sizing
                     * @instance
                     */
                    Sizing.prototype.max = 0;

                    /**
                     * Verifies a Sizing message.
                     * @function verify
                     * @memberof clutch.k8s.v1.ResizeHPARequest.Sizing
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Sizing.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.min != null && message.hasOwnProperty("min"))
                            if (!$util.isInteger(message.min))
                                return "min: integer expected";
                        if (message.max != null && message.hasOwnProperty("max"))
                            if (!$util.isInteger(message.max))
                                return "max: integer expected";
                        return null;
                    };

                    /**
                     * Creates a Sizing message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.k8s.v1.ResizeHPARequest.Sizing
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.k8s.v1.ResizeHPARequest.Sizing} Sizing
                     */
                    Sizing.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.k8s.v1.ResizeHPARequest.Sizing)
                            return object;
                        let message = new $root.clutch.k8s.v1.ResizeHPARequest.Sizing();
                        if (object.min != null)
                            message.min = object.min >>> 0;
                        if (object.max != null)
                            message.max = object.max >>> 0;
                        return message;
                    };

                    /**
                     * Creates a plain object from a Sizing message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.k8s.v1.ResizeHPARequest.Sizing
                     * @static
                     * @param {clutch.k8s.v1.ResizeHPARequest.Sizing} message Sizing
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Sizing.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.min = 0;
                            object.max = 0;
                        }
                        if (message.min != null && message.hasOwnProperty("min"))
                            object.min = message.min;
                        if (message.max != null && message.hasOwnProperty("max"))
                            object.max = message.max;
                        return object;
                    };

                    /**
                     * Converts this Sizing to JSON.
                     * @function toJSON
                     * @memberof clutch.k8s.v1.ResizeHPARequest.Sizing
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Sizing.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Sizing;
                })();

                return ResizeHPARequest;
            })();

            v1.ResizeHPAResponse = (function() {

                /**
                 * Properties of a ResizeHPAResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IResizeHPAResponse
                 */

                /**
                 * Constructs a new ResizeHPAResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a ResizeHPAResponse.
                 * @implements IResizeHPAResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IResizeHPAResponse=} [properties] Properties to set
                 */
                function ResizeHPAResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies a ResizeHPAResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ResizeHPAResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ResizeHPAResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates a ResizeHPAResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ResizeHPAResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ResizeHPAResponse} ResizeHPAResponse
                 */
                ResizeHPAResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ResizeHPAResponse)
                        return object;
                    return new $root.clutch.k8s.v1.ResizeHPAResponse();
                };

                /**
                 * Creates a plain object from a ResizeHPAResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ResizeHPAResponse
                 * @static
                 * @param {clutch.k8s.v1.ResizeHPAResponse} message ResizeHPAResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ResizeHPAResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this ResizeHPAResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ResizeHPAResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ResizeHPAResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ResizeHPAResponse;
            })();

            v1.Deployment = (function() {

                /**
                 * Properties of a Deployment.
                 * @memberof clutch.k8s.v1
                 * @interface IDeployment
                 * @property {string|null} [cluster] Deployment cluster
                 * @property {string|null} [namespace] Deployment namespace
                 * @property {string|null} [name] Deployment name
                 * @property {Object.<string,string>|null} [labels] Deployment labels
                 * @property {Object.<string,string>|null} [annotations] Deployment annotations
                 */

                /**
                 * Constructs a new Deployment.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a Deployment.
                 * @implements IDeployment
                 * @constructor
                 * @param {clutch.k8s.v1.IDeployment=} [properties] Properties to set
                 */
                function Deployment(properties) {
                    this.labels = {};
                    this.annotations = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Deployment cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.Deployment
                 * @instance
                 */
                Deployment.prototype.cluster = "";

                /**
                 * Deployment namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.Deployment
                 * @instance
                 */
                Deployment.prototype.namespace = "";

                /**
                 * Deployment name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.Deployment
                 * @instance
                 */
                Deployment.prototype.name = "";

                /**
                 * Deployment labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.Deployment
                 * @instance
                 */
                Deployment.prototype.labels = $util.emptyObject;

                /**
                 * Deployment annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof clutch.k8s.v1.Deployment
                 * @instance
                 */
                Deployment.prototype.annotations = $util.emptyObject;

                /**
                 * Verifies a Deployment message.
                 * @function verify
                 * @memberof clutch.k8s.v1.Deployment
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Deployment.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates a Deployment message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.Deployment
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.Deployment} Deployment
                 */
                Deployment.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.Deployment)
                        return object;
                    let message = new $root.clutch.k8s.v1.Deployment();
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.Deployment.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.Deployment.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                            message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Deployment message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.Deployment
                 * @static
                 * @param {clutch.k8s.v1.Deployment} message Deployment
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Deployment.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.labels = {};
                        object.annotations = {};
                    }
                    if (options.defaults) {
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                    }
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = message.annotations[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Converts this Deployment to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.Deployment
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Deployment.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Deployment;
            })();

            v1.UpdateDeploymentRequest = (function() {

                /**
                 * Properties of an UpdateDeploymentRequest.
                 * @memberof clutch.k8s.v1
                 * @interface IUpdateDeploymentRequest
                 * @property {string|null} [clientset] UpdateDeploymentRequest clientset
                 * @property {string|null} [cluster] UpdateDeploymentRequest cluster
                 * @property {string|null} [namespace] UpdateDeploymentRequest namespace
                 * @property {string|null} [name] UpdateDeploymentRequest name
                 * @property {clutch.k8s.v1.UpdateDeploymentRequest.IFields|null} [fields] UpdateDeploymentRequest fields
                 */

                /**
                 * Constructs a new UpdateDeploymentRequest.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an UpdateDeploymentRequest.
                 * @implements IUpdateDeploymentRequest
                 * @constructor
                 * @param {clutch.k8s.v1.IUpdateDeploymentRequest=} [properties] Properties to set
                 */
                function UpdateDeploymentRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * UpdateDeploymentRequest clientset.
                 * @member {string} clientset
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @instance
                 */
                UpdateDeploymentRequest.prototype.clientset = "";

                /**
                 * UpdateDeploymentRequest cluster.
                 * @member {string} cluster
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @instance
                 */
                UpdateDeploymentRequest.prototype.cluster = "";

                /**
                 * UpdateDeploymentRequest namespace.
                 * @member {string} namespace
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @instance
                 */
                UpdateDeploymentRequest.prototype.namespace = "";

                /**
                 * UpdateDeploymentRequest name.
                 * @member {string} name
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @instance
                 */
                UpdateDeploymentRequest.prototype.name = "";

                /**
                 * UpdateDeploymentRequest fields.
                 * @member {clutch.k8s.v1.UpdateDeploymentRequest.IFields|null|undefined} fields
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @instance
                 */
                UpdateDeploymentRequest.prototype.fields = null;

                /**
                 * Verifies an UpdateDeploymentRequest message.
                 * @function verify
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateDeploymentRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        if (!$util.isString(message.clientset))
                            return "clientset: string expected";
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        if (!$util.isString(message.cluster))
                            return "cluster: string expected";
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        if (!$util.isString(message.namespace))
                            return "namespace: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.fields != null && message.hasOwnProperty("fields")) {
                        let error = $root.clutch.k8s.v1.UpdateDeploymentRequest.Fields.verify(message.fields);
                        if (error)
                            return "fields." + error;
                    }
                    return null;
                };

                /**
                 * Creates an UpdateDeploymentRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.UpdateDeploymentRequest} UpdateDeploymentRequest
                 */
                UpdateDeploymentRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.UpdateDeploymentRequest)
                        return object;
                    let message = new $root.clutch.k8s.v1.UpdateDeploymentRequest();
                    if (object.clientset != null)
                        message.clientset = String(object.clientset);
                    if (object.cluster != null)
                        message.cluster = String(object.cluster);
                    if (object.namespace != null)
                        message.namespace = String(object.namespace);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.fields != null) {
                        if (typeof object.fields !== "object")
                            throw TypeError(".clutch.k8s.v1.UpdateDeploymentRequest.fields: object expected");
                        message.fields = $root.clutch.k8s.v1.UpdateDeploymentRequest.Fields.fromObject(object.fields);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an UpdateDeploymentRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @static
                 * @param {clutch.k8s.v1.UpdateDeploymentRequest} message UpdateDeploymentRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateDeploymentRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.clientset = "";
                        object.cluster = "";
                        object.namespace = "";
                        object.name = "";
                        object.fields = null;
                    }
                    if (message.clientset != null && message.hasOwnProperty("clientset"))
                        object.clientset = message.clientset;
                    if (message.cluster != null && message.hasOwnProperty("cluster"))
                        object.cluster = message.cluster;
                    if (message.namespace != null && message.hasOwnProperty("namespace"))
                        object.namespace = message.namespace;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.fields != null && message.hasOwnProperty("fields"))
                        object.fields = $root.clutch.k8s.v1.UpdateDeploymentRequest.Fields.toObject(message.fields, options);
                    return object;
                };

                /**
                 * Converts this UpdateDeploymentRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateDeploymentRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                UpdateDeploymentRequest.Fields = (function() {

                    /**
                     * Properties of a Fields.
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                     * @interface IFields
                     * @property {Object.<string,string>|null} [labels] Fields labels
                     * @property {Object.<string,string>|null} [annotations] Fields annotations
                     */

                    /**
                     * Constructs a new Fields.
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest
                     * @classdesc Represents a Fields.
                     * @implements IFields
                     * @constructor
                     * @param {clutch.k8s.v1.UpdateDeploymentRequest.IFields=} [properties] Properties to set
                     */
                    function Fields(properties) {
                        this.labels = {};
                        this.annotations = {};
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Fields labels.
                     * @member {Object.<string,string>} labels
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest.Fields
                     * @instance
                     */
                    Fields.prototype.labels = $util.emptyObject;

                    /**
                     * Fields annotations.
                     * @member {Object.<string,string>} annotations
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest.Fields
                     * @instance
                     */
                    Fields.prototype.annotations = $util.emptyObject;

                    /**
                     * Verifies a Fields message.
                     * @function verify
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest.Fields
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Fields.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.labels != null && message.hasOwnProperty("labels")) {
                            if (!$util.isObject(message.labels))
                                return "labels: object expected";
                            let key = Object.keys(message.labels);
                            for (let i = 0; i < key.length; ++i)
                                if (!$util.isString(message.labels[key[i]]))
                                    return "labels: string{k:string} expected";
                        }
                        if (message.annotations != null && message.hasOwnProperty("annotations")) {
                            if (!$util.isObject(message.annotations))
                                return "annotations: object expected";
                            let key = Object.keys(message.annotations);
                            for (let i = 0; i < key.length; ++i)
                                if (!$util.isString(message.annotations[key[i]]))
                                    return "annotations: string{k:string} expected";
                        }
                        return null;
                    };

                    /**
                     * Creates a Fields message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest.Fields
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.k8s.v1.UpdateDeploymentRequest.Fields} Fields
                     */
                    Fields.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.k8s.v1.UpdateDeploymentRequest.Fields)
                            return object;
                        let message = new $root.clutch.k8s.v1.UpdateDeploymentRequest.Fields();
                        if (object.labels) {
                            if (typeof object.labels !== "object")
                                throw TypeError(".clutch.k8s.v1.UpdateDeploymentRequest.Fields.labels: object expected");
                            message.labels = {};
                            for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                                message.labels[keys[i]] = String(object.labels[keys[i]]);
                        }
                        if (object.annotations) {
                            if (typeof object.annotations !== "object")
                                throw TypeError(".clutch.k8s.v1.UpdateDeploymentRequest.Fields.annotations: object expected");
                            message.annotations = {};
                            for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                                message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a Fields message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest.Fields
                     * @static
                     * @param {clutch.k8s.v1.UpdateDeploymentRequest.Fields} message Fields
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Fields.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.objects || options.defaults) {
                            object.labels = {};
                            object.annotations = {};
                        }
                        let keys2;
                        if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                            object.labels = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.labels[keys2[j]] = message.labels[keys2[j]];
                        }
                        if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                            object.annotations = {};
                            for (let j = 0; j < keys2.length; ++j)
                                object.annotations[keys2[j]] = message.annotations[keys2[j]];
                        }
                        return object;
                    };

                    /**
                     * Converts this Fields to JSON.
                     * @function toJSON
                     * @memberof clutch.k8s.v1.UpdateDeploymentRequest.Fields
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Fields.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Fields;
                })();

                return UpdateDeploymentRequest;
            })();

            v1.UpdateDeploymentResponse = (function() {

                /**
                 * Properties of an UpdateDeploymentResponse.
                 * @memberof clutch.k8s.v1
                 * @interface IUpdateDeploymentResponse
                 */

                /**
                 * Constructs a new UpdateDeploymentResponse.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an UpdateDeploymentResponse.
                 * @implements IUpdateDeploymentResponse
                 * @constructor
                 * @param {clutch.k8s.v1.IUpdateDeploymentResponse=} [properties] Properties to set
                 */
                function UpdateDeploymentResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Verifies an UpdateDeploymentResponse message.
                 * @function verify
                 * @memberof clutch.k8s.v1.UpdateDeploymentResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                UpdateDeploymentResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    return null;
                };

                /**
                 * Creates an UpdateDeploymentResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.UpdateDeploymentResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.UpdateDeploymentResponse} UpdateDeploymentResponse
                 */
                UpdateDeploymentResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.UpdateDeploymentResponse)
                        return object;
                    return new $root.clutch.k8s.v1.UpdateDeploymentResponse();
                };

                /**
                 * Creates a plain object from an UpdateDeploymentResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.UpdateDeploymentResponse
                 * @static
                 * @param {clutch.k8s.v1.UpdateDeploymentResponse} message UpdateDeploymentResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                UpdateDeploymentResponse.toObject = function toObject() {
                    return {};
                };

                /**
                 * Converts this UpdateDeploymentResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.UpdateDeploymentResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                UpdateDeploymentResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return UpdateDeploymentResponse;
            })();

            v1.ExpectedObjectMetaFields = (function() {

                /**
                 * Properties of an ExpectedObjectMetaFields.
                 * @memberof clutch.k8s.v1
                 * @interface IExpectedObjectMetaFields
                 * @property {Object.<string,google.protobuf.IStringValue>|null} [labels] ExpectedObjectMetaFields labels
                 * @property {Object.<string,google.protobuf.IStringValue>|null} [annotations] ExpectedObjectMetaFields annotations
                 */

                /**
                 * Constructs a new ExpectedObjectMetaFields.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an ExpectedObjectMetaFields.
                 * @implements IExpectedObjectMetaFields
                 * @constructor
                 * @param {clutch.k8s.v1.IExpectedObjectMetaFields=} [properties] Properties to set
                 */
                function ExpectedObjectMetaFields(properties) {
                    this.labels = {};
                    this.annotations = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExpectedObjectMetaFields labels.
                 * @member {Object.<string,google.protobuf.IStringValue>} labels
                 * @memberof clutch.k8s.v1.ExpectedObjectMetaFields
                 * @instance
                 */
                ExpectedObjectMetaFields.prototype.labels = $util.emptyObject;

                /**
                 * ExpectedObjectMetaFields annotations.
                 * @member {Object.<string,google.protobuf.IStringValue>} annotations
                 * @memberof clutch.k8s.v1.ExpectedObjectMetaFields
                 * @instance
                 */
                ExpectedObjectMetaFields.prototype.annotations = $util.emptyObject;

                /**
                 * Verifies an ExpectedObjectMetaFields message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ExpectedObjectMetaFields
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExpectedObjectMetaFields.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.google.protobuf.StringValue.verify(message.labels[key[i]]);
                            if (error)
                                return "labels." + error;
                        }
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.google.protobuf.StringValue.verify(message.annotations[key[i]]);
                            if (error)
                                return "annotations." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an ExpectedObjectMetaFields message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ExpectedObjectMetaFields
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ExpectedObjectMetaFields} ExpectedObjectMetaFields
                 */
                ExpectedObjectMetaFields.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ExpectedObjectMetaFields)
                        return object;
                    let message = new $root.clutch.k8s.v1.ExpectedObjectMetaFields();
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.ExpectedObjectMetaFields.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i) {
                            if (typeof object.labels[keys[i]] !== "object")
                                throw TypeError(".clutch.k8s.v1.ExpectedObjectMetaFields.labels: object expected");
                            message.labels[keys[i]] = $root.google.protobuf.StringValue.fromObject(object.labels[keys[i]]);
                        }
                    }
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.ExpectedObjectMetaFields.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i) {
                            if (typeof object.annotations[keys[i]] !== "object")
                                throw TypeError(".clutch.k8s.v1.ExpectedObjectMetaFields.annotations: object expected");
                            message.annotations[keys[i]] = $root.google.protobuf.StringValue.fromObject(object.annotations[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ExpectedObjectMetaFields message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ExpectedObjectMetaFields
                 * @static
                 * @param {clutch.k8s.v1.ExpectedObjectMetaFields} message ExpectedObjectMetaFields
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExpectedObjectMetaFields.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.labels = {};
                        object.annotations = {};
                    }
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = $root.google.protobuf.StringValue.toObject(message.labels[keys2[j]], options);
                    }
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = $root.google.protobuf.StringValue.toObject(message.annotations[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Converts this ExpectedObjectMetaFields to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ExpectedObjectMetaFields
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExpectedObjectMetaFields.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExpectedObjectMetaFields;
            })();

            v1.ObjectMetaFields = (function() {

                /**
                 * Properties of an ObjectMetaFields.
                 * @memberof clutch.k8s.v1
                 * @interface IObjectMetaFields
                 * @property {Object.<string,string>|null} [labels] ObjectMetaFields labels
                 * @property {Object.<string,string>|null} [annotations] ObjectMetaFields annotations
                 */

                /**
                 * Constructs a new ObjectMetaFields.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents an ObjectMetaFields.
                 * @implements IObjectMetaFields
                 * @constructor
                 * @param {clutch.k8s.v1.IObjectMetaFields=} [properties] Properties to set
                 */
                function ObjectMetaFields(properties) {
                    this.labels = {};
                    this.annotations = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ObjectMetaFields labels.
                 * @member {Object.<string,string>} labels
                 * @memberof clutch.k8s.v1.ObjectMetaFields
                 * @instance
                 */
                ObjectMetaFields.prototype.labels = $util.emptyObject;

                /**
                 * ObjectMetaFields annotations.
                 * @member {Object.<string,string>} annotations
                 * @memberof clutch.k8s.v1.ObjectMetaFields
                 * @instance
                 */
                ObjectMetaFields.prototype.annotations = $util.emptyObject;

                /**
                 * Verifies an ObjectMetaFields message.
                 * @function verify
                 * @memberof clutch.k8s.v1.ObjectMetaFields
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ObjectMetaFields.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!$util.isObject(message.labels))
                            return "labels: object expected";
                        let key = Object.keys(message.labels);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.labels[key[i]]))
                                return "labels: string{k:string} expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!$util.isObject(message.annotations))
                            return "annotations: object expected";
                        let key = Object.keys(message.annotations);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.annotations[key[i]]))
                                return "annotations: string{k:string} expected";
                    }
                    return null;
                };

                /**
                 * Creates an ObjectMetaFields message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.ObjectMetaFields
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.ObjectMetaFields} ObjectMetaFields
                 */
                ObjectMetaFields.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.ObjectMetaFields)
                        return object;
                    let message = new $root.clutch.k8s.v1.ObjectMetaFields();
                    if (object.labels) {
                        if (typeof object.labels !== "object")
                            throw TypeError(".clutch.k8s.v1.ObjectMetaFields.labels: object expected");
                        message.labels = {};
                        for (let keys = Object.keys(object.labels), i = 0; i < keys.length; ++i)
                            message.labels[keys[i]] = String(object.labels[keys[i]]);
                    }
                    if (object.annotations) {
                        if (typeof object.annotations !== "object")
                            throw TypeError(".clutch.k8s.v1.ObjectMetaFields.annotations: object expected");
                        message.annotations = {};
                        for (let keys = Object.keys(object.annotations), i = 0; i < keys.length; ++i)
                            message.annotations[keys[i]] = String(object.annotations[keys[i]]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ObjectMetaFields message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.ObjectMetaFields
                 * @static
                 * @param {clutch.k8s.v1.ObjectMetaFields} message ObjectMetaFields
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ObjectMetaFields.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.labels = {};
                        object.annotations = {};
                    }
                    let keys2;
                    if (message.labels && (keys2 = Object.keys(message.labels)).length) {
                        object.labels = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.labels[keys2[j]] = message.labels[keys2[j]];
                    }
                    if (message.annotations && (keys2 = Object.keys(message.annotations)).length) {
                        object.annotations = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.annotations[keys2[j]] = message.annotations[keys2[j]];
                    }
                    return object;
                };

                /**
                 * Converts this ObjectMetaFields to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.ObjectMetaFields
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ObjectMetaFields.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ObjectMetaFields;
            })();

            v1.RemoveObjectMetaFields = (function() {

                /**
                 * Properties of a RemoveObjectMetaFields.
                 * @memberof clutch.k8s.v1
                 * @interface IRemoveObjectMetaFields
                 * @property {Array.<string>|null} [labels] RemoveObjectMetaFields labels
                 * @property {Array.<string>|null} [annotations] RemoveObjectMetaFields annotations
                 */

                /**
                 * Constructs a new RemoveObjectMetaFields.
                 * @memberof clutch.k8s.v1
                 * @classdesc Represents a RemoveObjectMetaFields.
                 * @implements IRemoveObjectMetaFields
                 * @constructor
                 * @param {clutch.k8s.v1.IRemoveObjectMetaFields=} [properties] Properties to set
                 */
                function RemoveObjectMetaFields(properties) {
                    this.labels = [];
                    this.annotations = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * RemoveObjectMetaFields labels.
                 * @member {Array.<string>} labels
                 * @memberof clutch.k8s.v1.RemoveObjectMetaFields
                 * @instance
                 */
                RemoveObjectMetaFields.prototype.labels = $util.emptyArray;

                /**
                 * RemoveObjectMetaFields annotations.
                 * @member {Array.<string>} annotations
                 * @memberof clutch.k8s.v1.RemoveObjectMetaFields
                 * @instance
                 */
                RemoveObjectMetaFields.prototype.annotations = $util.emptyArray;

                /**
                 * Verifies a RemoveObjectMetaFields message.
                 * @function verify
                 * @memberof clutch.k8s.v1.RemoveObjectMetaFields
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                RemoveObjectMetaFields.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.labels != null && message.hasOwnProperty("labels")) {
                        if (!Array.isArray(message.labels))
                            return "labels: array expected";
                        for (let i = 0; i < message.labels.length; ++i)
                            if (!$util.isString(message.labels[i]))
                                return "labels: string[] expected";
                    }
                    if (message.annotations != null && message.hasOwnProperty("annotations")) {
                        if (!Array.isArray(message.annotations))
                            return "annotations: array expected";
                        for (let i = 0; i < message.annotations.length; ++i)
                            if (!$util.isString(message.annotations[i]))
                                return "annotations: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a RemoveObjectMetaFields message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.k8s.v1.RemoveObjectMetaFields
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.k8s.v1.RemoveObjectMetaFields} RemoveObjectMetaFields
                 */
                RemoveObjectMetaFields.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.k8s.v1.RemoveObjectMetaFields)
                        return object;
                    let message = new $root.clutch.k8s.v1.RemoveObjectMetaFields();
                    if (object.labels) {
                        if (!Array.isArray(object.labels))
                            throw TypeError(".clutch.k8s.v1.RemoveObjectMetaFields.labels: array expected");
                        message.labels = [];
                        for (let i = 0; i < object.labels.length; ++i)
                            message.labels[i] = String(object.labels[i]);
                    }
                    if (object.annotations) {
                        if (!Array.isArray(object.annotations))
                            throw TypeError(".clutch.k8s.v1.RemoveObjectMetaFields.annotations: array expected");
                        message.annotations = [];
                        for (let i = 0; i < object.annotations.length; ++i)
                            message.annotations[i] = String(object.annotations[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a RemoveObjectMetaFields message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.k8s.v1.RemoveObjectMetaFields
                 * @static
                 * @param {clutch.k8s.v1.RemoveObjectMetaFields} message RemoveObjectMetaFields
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                RemoveObjectMetaFields.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.labels = [];
                        object.annotations = [];
                    }
                    if (message.labels && message.labels.length) {
                        object.labels = [];
                        for (let j = 0; j < message.labels.length; ++j)
                            object.labels[j] = message.labels[j];
                    }
                    if (message.annotations && message.annotations.length) {
                        object.annotations = [];
                        for (let j = 0; j < message.annotations.length; ++j)
                            object.annotations[j] = message.annotations[j];
                    }
                    return object;
                };

                /**
                 * Converts this RemoveObjectMetaFields to JSON.
                 * @function toJSON
                 * @memberof clutch.k8s.v1.RemoveObjectMetaFields
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                RemoveObjectMetaFields.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return RemoveObjectMetaFields;
            })();

            return v1;
        })();

        return k8s;
    })();

    clutch.resolver = (function() {

        /**
         * Namespace resolver.
         * @memberof clutch
         * @namespace
         */
        const resolver = {};

        resolver.aws = (function() {

            /**
             * Namespace aws.
             * @memberof clutch.resolver
             * @namespace
             */
            const aws = {};

            aws.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.resolver.aws
                 * @namespace
                 */
                const v1 = {};

                v1.InstanceID = (function() {

                    /**
                     * Properties of an InstanceID.
                     * @memberof clutch.resolver.aws.v1
                     * @interface IInstanceID
                     * @property {string|null} [id] InstanceID id
                     * @property {string|null} [region] InstanceID region
                     */

                    /**
                     * Constructs a new InstanceID.
                     * @memberof clutch.resolver.aws.v1
                     * @classdesc Represents an InstanceID.
                     * @implements IInstanceID
                     * @constructor
                     * @param {clutch.resolver.aws.v1.IInstanceID=} [properties] Properties to set
                     */
                    function InstanceID(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * InstanceID id.
                     * @member {string} id
                     * @memberof clutch.resolver.aws.v1.InstanceID
                     * @instance
                     */
                    InstanceID.prototype.id = "";

                    /**
                     * InstanceID region.
                     * @member {string} region
                     * @memberof clutch.resolver.aws.v1.InstanceID
                     * @instance
                     */
                    InstanceID.prototype.region = "";

                    /**
                     * Verifies an InstanceID message.
                     * @function verify
                     * @memberof clutch.resolver.aws.v1.InstanceID
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    InstanceID.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.id != null && message.hasOwnProperty("id"))
                            if (!$util.isString(message.id))
                                return "id: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        return null;
                    };

                    /**
                     * Creates an InstanceID message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.aws.v1.InstanceID
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.aws.v1.InstanceID} InstanceID
                     */
                    InstanceID.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.aws.v1.InstanceID)
                            return object;
                        let message = new $root.clutch.resolver.aws.v1.InstanceID();
                        if (object.id != null)
                            message.id = String(object.id);
                        if (object.region != null)
                            message.region = String(object.region);
                        return message;
                    };

                    /**
                     * Creates a plain object from an InstanceID message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.aws.v1.InstanceID
                     * @static
                     * @param {clutch.resolver.aws.v1.InstanceID} message InstanceID
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    InstanceID.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.id = "";
                            object.region = "";
                        }
                        if (message.id != null && message.hasOwnProperty("id"))
                            object.id = message.id;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        return object;
                    };

                    /**
                     * Converts this InstanceID to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.aws.v1.InstanceID
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    InstanceID.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return InstanceID;
                })();

                v1.AutoscalingGroupName = (function() {

                    /**
                     * Properties of an AutoscalingGroupName.
                     * @memberof clutch.resolver.aws.v1
                     * @interface IAutoscalingGroupName
                     * @property {string|null} [name] AutoscalingGroupName name
                     * @property {string|null} [region] AutoscalingGroupName region
                     */

                    /**
                     * Constructs a new AutoscalingGroupName.
                     * @memberof clutch.resolver.aws.v1
                     * @classdesc Represents an AutoscalingGroupName.
                     * @implements IAutoscalingGroupName
                     * @constructor
                     * @param {clutch.resolver.aws.v1.IAutoscalingGroupName=} [properties] Properties to set
                     */
                    function AutoscalingGroupName(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * AutoscalingGroupName name.
                     * @member {string} name
                     * @memberof clutch.resolver.aws.v1.AutoscalingGroupName
                     * @instance
                     */
                    AutoscalingGroupName.prototype.name = "";

                    /**
                     * AutoscalingGroupName region.
                     * @member {string} region
                     * @memberof clutch.resolver.aws.v1.AutoscalingGroupName
                     * @instance
                     */
                    AutoscalingGroupName.prototype.region = "";

                    /**
                     * Verifies an AutoscalingGroupName message.
                     * @function verify
                     * @memberof clutch.resolver.aws.v1.AutoscalingGroupName
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    AutoscalingGroupName.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        return null;
                    };

                    /**
                     * Creates an AutoscalingGroupName message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.aws.v1.AutoscalingGroupName
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.aws.v1.AutoscalingGroupName} AutoscalingGroupName
                     */
                    AutoscalingGroupName.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.aws.v1.AutoscalingGroupName)
                            return object;
                        let message = new $root.clutch.resolver.aws.v1.AutoscalingGroupName();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.region != null)
                            message.region = String(object.region);
                        return message;
                    };

                    /**
                     * Creates a plain object from an AutoscalingGroupName message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.aws.v1.AutoscalingGroupName
                     * @static
                     * @param {clutch.resolver.aws.v1.AutoscalingGroupName} message AutoscalingGroupName
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    AutoscalingGroupName.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.region = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        return object;
                    };

                    /**
                     * Converts this AutoscalingGroupName to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.aws.v1.AutoscalingGroupName
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    AutoscalingGroupName.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return AutoscalingGroupName;
                })();

                v1.KinesisStreamName = (function() {

                    /**
                     * Properties of a KinesisStreamName.
                     * @memberof clutch.resolver.aws.v1
                     * @interface IKinesisStreamName
                     * @property {string|null} [name] KinesisStreamName name
                     * @property {string|null} [region] KinesisStreamName region
                     */

                    /**
                     * Constructs a new KinesisStreamName.
                     * @memberof clutch.resolver.aws.v1
                     * @classdesc Represents a KinesisStreamName.
                     * @implements IKinesisStreamName
                     * @constructor
                     * @param {clutch.resolver.aws.v1.IKinesisStreamName=} [properties] Properties to set
                     */
                    function KinesisStreamName(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * KinesisStreamName name.
                     * @member {string} name
                     * @memberof clutch.resolver.aws.v1.KinesisStreamName
                     * @instance
                     */
                    KinesisStreamName.prototype.name = "";

                    /**
                     * KinesisStreamName region.
                     * @member {string} region
                     * @memberof clutch.resolver.aws.v1.KinesisStreamName
                     * @instance
                     */
                    KinesisStreamName.prototype.region = "";

                    /**
                     * Verifies a KinesisStreamName message.
                     * @function verify
                     * @memberof clutch.resolver.aws.v1.KinesisStreamName
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    KinesisStreamName.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.region != null && message.hasOwnProperty("region"))
                            if (!$util.isString(message.region))
                                return "region: string expected";
                        return null;
                    };

                    /**
                     * Creates a KinesisStreamName message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.aws.v1.KinesisStreamName
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.aws.v1.KinesisStreamName} KinesisStreamName
                     */
                    KinesisStreamName.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.aws.v1.KinesisStreamName)
                            return object;
                        let message = new $root.clutch.resolver.aws.v1.KinesisStreamName();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.region != null)
                            message.region = String(object.region);
                        return message;
                    };

                    /**
                     * Creates a plain object from a KinesisStreamName message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.aws.v1.KinesisStreamName
                     * @static
                     * @param {clutch.resolver.aws.v1.KinesisStreamName} message KinesisStreamName
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    KinesisStreamName.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.region = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.region != null && message.hasOwnProperty("region"))
                            object.region = message.region;
                        return object;
                    };

                    /**
                     * Converts this KinesisStreamName to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.aws.v1.KinesisStreamName
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    KinesisStreamName.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return KinesisStreamName;
                })();

                return v1;
            })();

            return aws;
        })();

        resolver.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.resolver
             * @namespace
             */
            const v1 = {};

            v1.StringField = (function() {

                /**
                 * Properties of a StringField.
                 * @memberof clutch.resolver.v1
                 * @interface IStringField
                 * @property {string|null} [placeholder] StringField placeholder
                 * @property {string|null} [defaultValue] StringField defaultValue
                 */

                /**
                 * Constructs a new StringField.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a StringField.
                 * @implements IStringField
                 * @constructor
                 * @param {clutch.resolver.v1.IStringField=} [properties] Properties to set
                 */
                function StringField(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * StringField placeholder.
                 * @member {string} placeholder
                 * @memberof clutch.resolver.v1.StringField
                 * @instance
                 */
                StringField.prototype.placeholder = "";

                /**
                 * StringField defaultValue.
                 * @member {string} defaultValue
                 * @memberof clutch.resolver.v1.StringField
                 * @instance
                 */
                StringField.prototype.defaultValue = "";

                /**
                 * Verifies a StringField message.
                 * @function verify
                 * @memberof clutch.resolver.v1.StringField
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                StringField.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.placeholder != null && message.hasOwnProperty("placeholder"))
                        if (!$util.isString(message.placeholder))
                            return "placeholder: string expected";
                    if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                        if (!$util.isString(message.defaultValue))
                            return "defaultValue: string expected";
                    return null;
                };

                /**
                 * Creates a StringField message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.StringField
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.StringField} StringField
                 */
                StringField.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.StringField)
                        return object;
                    let message = new $root.clutch.resolver.v1.StringField();
                    if (object.placeholder != null)
                        message.placeholder = String(object.placeholder);
                    if (object.defaultValue != null)
                        message.defaultValue = String(object.defaultValue);
                    return message;
                };

                /**
                 * Creates a plain object from a StringField message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.StringField
                 * @static
                 * @param {clutch.resolver.v1.StringField} message StringField
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                StringField.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.placeholder = "";
                        object.defaultValue = "";
                    }
                    if (message.placeholder != null && message.hasOwnProperty("placeholder"))
                        object.placeholder = message.placeholder;
                    if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                        object.defaultValue = message.defaultValue;
                    return object;
                };

                /**
                 * Converts this StringField to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.StringField
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                StringField.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return StringField;
            })();

            v1.Option = (function() {

                /**
                 * Properties of an Option.
                 * @memberof clutch.resolver.v1
                 * @interface IOption
                 * @property {string|null} [displayName] Option displayName
                 * @property {string|null} [stringValue] Option stringValue
                 */

                /**
                 * Constructs a new Option.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents an Option.
                 * @implements IOption
                 * @constructor
                 * @param {clutch.resolver.v1.IOption=} [properties] Properties to set
                 */
                function Option(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Option displayName.
                 * @member {string} displayName
                 * @memberof clutch.resolver.v1.Option
                 * @instance
                 */
                Option.prototype.displayName = "";

                /**
                 * Option stringValue.
                 * @member {string} stringValue
                 * @memberof clutch.resolver.v1.Option
                 * @instance
                 */
                Option.prototype.stringValue = "";

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * Option value.
                 * @member {"stringValue"|undefined} value
                 * @memberof clutch.resolver.v1.Option
                 * @instance
                 */
                Object.defineProperty(Option.prototype, "value", {
                    get: $util.oneOfGetter($oneOfFields = ["stringValue"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies an Option message.
                 * @function verify
                 * @memberof clutch.resolver.v1.Option
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Option.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        if (!$util.isString(message.displayName))
                            return "displayName: string expected";
                    if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                        properties.value = 1;
                        if (!$util.isString(message.stringValue))
                            return "stringValue: string expected";
                    }
                    return null;
                };

                /**
                 * Creates an Option message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.Option
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.Option} Option
                 */
                Option.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.Option)
                        return object;
                    let message = new $root.clutch.resolver.v1.Option();
                    if (object.displayName != null)
                        message.displayName = String(object.displayName);
                    if (object.stringValue != null)
                        message.stringValue = String(object.stringValue);
                    return message;
                };

                /**
                 * Creates a plain object from an Option message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.Option
                 * @static
                 * @param {clutch.resolver.v1.Option} message Option
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Option.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.displayName = "";
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        object.displayName = message.displayName;
                    if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                        object.stringValue = message.stringValue;
                        if (options.oneofs)
                            object.value = "stringValue";
                    }
                    return object;
                };

                /**
                 * Converts this Option to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.Option
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Option.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Option;
            })();

            v1.OptionField = (function() {

                /**
                 * Properties of an OptionField.
                 * @memberof clutch.resolver.v1
                 * @interface IOptionField
                 * @property {boolean|null} [includeAllOption] OptionField includeAllOption
                 * @property {Array.<string>|null} [includeDynamicOptions] OptionField includeDynamicOptions
                 * @property {Array.<clutch.resolver.v1.IOption>|null} [options] OptionField options
                 */

                /**
                 * Constructs a new OptionField.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents an OptionField.
                 * @implements IOptionField
                 * @constructor
                 * @param {clutch.resolver.v1.IOptionField=} [properties] Properties to set
                 */
                function OptionField(properties) {
                    this.includeDynamicOptions = [];
                    this.options = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * OptionField includeAllOption.
                 * @member {boolean} includeAllOption
                 * @memberof clutch.resolver.v1.OptionField
                 * @instance
                 */
                OptionField.prototype.includeAllOption = false;

                /**
                 * OptionField includeDynamicOptions.
                 * @member {Array.<string>} includeDynamicOptions
                 * @memberof clutch.resolver.v1.OptionField
                 * @instance
                 */
                OptionField.prototype.includeDynamicOptions = $util.emptyArray;

                /**
                 * OptionField options.
                 * @member {Array.<clutch.resolver.v1.IOption>} options
                 * @memberof clutch.resolver.v1.OptionField
                 * @instance
                 */
                OptionField.prototype.options = $util.emptyArray;

                /**
                 * Verifies an OptionField message.
                 * @function verify
                 * @memberof clutch.resolver.v1.OptionField
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                OptionField.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.includeAllOption != null && message.hasOwnProperty("includeAllOption"))
                        if (typeof message.includeAllOption !== "boolean")
                            return "includeAllOption: boolean expected";
                    if (message.includeDynamicOptions != null && message.hasOwnProperty("includeDynamicOptions")) {
                        if (!Array.isArray(message.includeDynamicOptions))
                            return "includeDynamicOptions: array expected";
                        for (let i = 0; i < message.includeDynamicOptions.length; ++i)
                            if (!$util.isString(message.includeDynamicOptions[i]))
                                return "includeDynamicOptions: string[] expected";
                    }
                    if (message.options != null && message.hasOwnProperty("options")) {
                        if (!Array.isArray(message.options))
                            return "options: array expected";
                        for (let i = 0; i < message.options.length; ++i) {
                            let error = $root.clutch.resolver.v1.Option.verify(message.options[i]);
                            if (error)
                                return "options." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an OptionField message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.OptionField
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.OptionField} OptionField
                 */
                OptionField.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.OptionField)
                        return object;
                    let message = new $root.clutch.resolver.v1.OptionField();
                    if (object.includeAllOption != null)
                        message.includeAllOption = Boolean(object.includeAllOption);
                    if (object.includeDynamicOptions) {
                        if (!Array.isArray(object.includeDynamicOptions))
                            throw TypeError(".clutch.resolver.v1.OptionField.includeDynamicOptions: array expected");
                        message.includeDynamicOptions = [];
                        for (let i = 0; i < object.includeDynamicOptions.length; ++i)
                            message.includeDynamicOptions[i] = String(object.includeDynamicOptions[i]);
                    }
                    if (object.options) {
                        if (!Array.isArray(object.options))
                            throw TypeError(".clutch.resolver.v1.OptionField.options: array expected");
                        message.options = [];
                        for (let i = 0; i < object.options.length; ++i) {
                            if (typeof object.options[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.OptionField.options: object expected");
                            message.options[i] = $root.clutch.resolver.v1.Option.fromObject(object.options[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an OptionField message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.OptionField
                 * @static
                 * @param {clutch.resolver.v1.OptionField} message OptionField
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                OptionField.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.includeDynamicOptions = [];
                        object.options = [];
                    }
                    if (options.defaults)
                        object.includeAllOption = false;
                    if (message.includeAllOption != null && message.hasOwnProperty("includeAllOption"))
                        object.includeAllOption = message.includeAllOption;
                    if (message.includeDynamicOptions && message.includeDynamicOptions.length) {
                        object.includeDynamicOptions = [];
                        for (let j = 0; j < message.includeDynamicOptions.length; ++j)
                            object.includeDynamicOptions[j] = message.includeDynamicOptions[j];
                    }
                    if (message.options && message.options.length) {
                        object.options = [];
                        for (let j = 0; j < message.options.length; ++j)
                            object.options[j] = $root.clutch.resolver.v1.Option.toObject(message.options[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this OptionField to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.OptionField
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                OptionField.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return OptionField;
            })();

            v1.Field = (function() {

                /**
                 * Properties of a Field.
                 * @memberof clutch.resolver.v1
                 * @interface IField
                 * @property {string|null} [name] Field name
                 * @property {clutch.resolver.v1.IFieldMetadata|null} [metadata] Field metadata
                 */

                /**
                 * Constructs a new Field.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a Field.
                 * @implements IField
                 * @constructor
                 * @param {clutch.resolver.v1.IField=} [properties] Properties to set
                 */
                function Field(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Field name.
                 * @member {string} name
                 * @memberof clutch.resolver.v1.Field
                 * @instance
                 */
                Field.prototype.name = "";

                /**
                 * Field metadata.
                 * @member {clutch.resolver.v1.IFieldMetadata|null|undefined} metadata
                 * @memberof clutch.resolver.v1.Field
                 * @instance
                 */
                Field.prototype.metadata = null;

                /**
                 * Verifies a Field message.
                 * @function verify
                 * @memberof clutch.resolver.v1.Field
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Field.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        let error = $root.clutch.resolver.v1.FieldMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Field message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.Field
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.Field} Field
                 */
                Field.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.Field)
                        return object;
                    let message = new $root.clutch.resolver.v1.Field();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.metadata != null) {
                        if (typeof object.metadata !== "object")
                            throw TypeError(".clutch.resolver.v1.Field.metadata: object expected");
                        message.metadata = $root.clutch.resolver.v1.FieldMetadata.fromObject(object.metadata);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Field message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.Field
                 * @static
                 * @param {clutch.resolver.v1.Field} message Field
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Field.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.name = "";
                        object.metadata = null;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        object.metadata = $root.clutch.resolver.v1.FieldMetadata.toObject(message.metadata, options);
                    return object;
                };

                /**
                 * Converts this Field to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.Field
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Field.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Field;
            })();

            v1.FieldMetadata = (function() {

                /**
                 * Properties of a FieldMetadata.
                 * @memberof clutch.resolver.v1
                 * @interface IFieldMetadata
                 * @property {string|null} [displayName] FieldMetadata displayName
                 * @property {boolean|null} [required] FieldMetadata required
                 * @property {clutch.resolver.v1.IStringField|null} [stringField] FieldMetadata stringField
                 * @property {clutch.resolver.v1.IOptionField|null} [optionField] FieldMetadata optionField
                 */

                /**
                 * Constructs a new FieldMetadata.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a FieldMetadata.
                 * @implements IFieldMetadata
                 * @constructor
                 * @param {clutch.resolver.v1.IFieldMetadata=} [properties] Properties to set
                 */
                function FieldMetadata(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FieldMetadata displayName.
                 * @member {string} displayName
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @instance
                 */
                FieldMetadata.prototype.displayName = "";

                /**
                 * FieldMetadata required.
                 * @member {boolean} required
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @instance
                 */
                FieldMetadata.prototype.required = false;

                /**
                 * FieldMetadata stringField.
                 * @member {clutch.resolver.v1.IStringField|null|undefined} stringField
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @instance
                 */
                FieldMetadata.prototype.stringField = null;

                /**
                 * FieldMetadata optionField.
                 * @member {clutch.resolver.v1.IOptionField|null|undefined} optionField
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @instance
                 */
                FieldMetadata.prototype.optionField = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * FieldMetadata type.
                 * @member {"stringField"|"optionField"|undefined} type
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @instance
                 */
                Object.defineProperty(FieldMetadata.prototype, "type", {
                    get: $util.oneOfGetter($oneOfFields = ["stringField", "optionField"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies a FieldMetadata message.
                 * @function verify
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FieldMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        if (!$util.isString(message.displayName))
                            return "displayName: string expected";
                    if (message.required != null && message.hasOwnProperty("required"))
                        if (typeof message.required !== "boolean")
                            return "required: boolean expected";
                    if (message.stringField != null && message.hasOwnProperty("stringField")) {
                        properties.type = 1;
                        {
                            let error = $root.clutch.resolver.v1.StringField.verify(message.stringField);
                            if (error)
                                return "stringField." + error;
                        }
                    }
                    if (message.optionField != null && message.hasOwnProperty("optionField")) {
                        if (properties.type === 1)
                            return "type: multiple values";
                        properties.type = 1;
                        {
                            let error = $root.clutch.resolver.v1.OptionField.verify(message.optionField);
                            if (error)
                                return "optionField." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a FieldMetadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.FieldMetadata} FieldMetadata
                 */
                FieldMetadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.FieldMetadata)
                        return object;
                    let message = new $root.clutch.resolver.v1.FieldMetadata();
                    if (object.displayName != null)
                        message.displayName = String(object.displayName);
                    if (object.required != null)
                        message.required = Boolean(object.required);
                    if (object.stringField != null) {
                        if (typeof object.stringField !== "object")
                            throw TypeError(".clutch.resolver.v1.FieldMetadata.stringField: object expected");
                        message.stringField = $root.clutch.resolver.v1.StringField.fromObject(object.stringField);
                    }
                    if (object.optionField != null) {
                        if (typeof object.optionField !== "object")
                            throw TypeError(".clutch.resolver.v1.FieldMetadata.optionField: object expected");
                        message.optionField = $root.clutch.resolver.v1.OptionField.fromObject(object.optionField);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FieldMetadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @static
                 * @param {clutch.resolver.v1.FieldMetadata} message FieldMetadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FieldMetadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.displayName = "";
                        object.required = false;
                    }
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        object.displayName = message.displayName;
                    if (message.required != null && message.hasOwnProperty("required"))
                        object.required = message.required;
                    if (message.stringField != null && message.hasOwnProperty("stringField")) {
                        object.stringField = $root.clutch.resolver.v1.StringField.toObject(message.stringField, options);
                        if (options.oneofs)
                            object.type = "stringField";
                    }
                    if (message.optionField != null && message.hasOwnProperty("optionField")) {
                        object.optionField = $root.clutch.resolver.v1.OptionField.toObject(message.optionField, options);
                        if (options.oneofs)
                            object.type = "optionField";
                    }
                    return object;
                };

                /**
                 * Converts this FieldMetadata to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.FieldMetadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FieldMetadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FieldMetadata;
            })();

            v1.SchemaMetadata = (function() {

                /**
                 * Properties of a SchemaMetadata.
                 * @memberof clutch.resolver.v1
                 * @interface ISchemaMetadata
                 * @property {string|null} [displayName] SchemaMetadata displayName
                 * @property {boolean|null} [searchable] SchemaMetadata searchable
                 */

                /**
                 * Constructs a new SchemaMetadata.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a SchemaMetadata.
                 * @implements ISchemaMetadata
                 * @constructor
                 * @param {clutch.resolver.v1.ISchemaMetadata=} [properties] Properties to set
                 */
                function SchemaMetadata(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SchemaMetadata displayName.
                 * @member {string} displayName
                 * @memberof clutch.resolver.v1.SchemaMetadata
                 * @instance
                 */
                SchemaMetadata.prototype.displayName = "";

                /**
                 * SchemaMetadata searchable.
                 * @member {boolean} searchable
                 * @memberof clutch.resolver.v1.SchemaMetadata
                 * @instance
                 */
                SchemaMetadata.prototype.searchable = false;

                /**
                 * Verifies a SchemaMetadata message.
                 * @function verify
                 * @memberof clutch.resolver.v1.SchemaMetadata
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SchemaMetadata.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        if (!$util.isString(message.displayName))
                            return "displayName: string expected";
                    if (message.searchable != null && message.hasOwnProperty("searchable"))
                        if (typeof message.searchable !== "boolean")
                            return "searchable: boolean expected";
                    return null;
                };

                /**
                 * Creates a SchemaMetadata message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.SchemaMetadata
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.SchemaMetadata} SchemaMetadata
                 */
                SchemaMetadata.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.SchemaMetadata)
                        return object;
                    let message = new $root.clutch.resolver.v1.SchemaMetadata();
                    if (object.displayName != null)
                        message.displayName = String(object.displayName);
                    if (object.searchable != null)
                        message.searchable = Boolean(object.searchable);
                    return message;
                };

                /**
                 * Creates a plain object from a SchemaMetadata message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.SchemaMetadata
                 * @static
                 * @param {clutch.resolver.v1.SchemaMetadata} message SchemaMetadata
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SchemaMetadata.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.displayName = "";
                        object.searchable = false;
                    }
                    if (message.displayName != null && message.hasOwnProperty("displayName"))
                        object.displayName = message.displayName;
                    if (message.searchable != null && message.hasOwnProperty("searchable"))
                        object.searchable = message.searchable;
                    return object;
                };

                /**
                 * Converts this SchemaMetadata to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.SchemaMetadata
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SchemaMetadata.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SchemaMetadata;
            })();

            v1.Schema = (function() {

                /**
                 * Properties of a Schema.
                 * @memberof clutch.resolver.v1
                 * @interface ISchema
                 * @property {string|null} [typeUrl] Schema typeUrl
                 * @property {clutch.resolver.v1.ISchemaMetadata|null} [metadata] Schema metadata
                 * @property {Array.<clutch.resolver.v1.IField>|null} [fields] Schema fields
                 * @property {google.rpc.IStatus|null} [error] Schema error
                 */

                /**
                 * Constructs a new Schema.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a Schema.
                 * @implements ISchema
                 * @constructor
                 * @param {clutch.resolver.v1.ISchema=} [properties] Properties to set
                 */
                function Schema(properties) {
                    this.fields = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Schema typeUrl.
                 * @member {string} typeUrl
                 * @memberof clutch.resolver.v1.Schema
                 * @instance
                 */
                Schema.prototype.typeUrl = "";

                /**
                 * Schema metadata.
                 * @member {clutch.resolver.v1.ISchemaMetadata|null|undefined} metadata
                 * @memberof clutch.resolver.v1.Schema
                 * @instance
                 */
                Schema.prototype.metadata = null;

                /**
                 * Schema fields.
                 * @member {Array.<clutch.resolver.v1.IField>} fields
                 * @memberof clutch.resolver.v1.Schema
                 * @instance
                 */
                Schema.prototype.fields = $util.emptyArray;

                /**
                 * Schema error.
                 * @member {google.rpc.IStatus|null|undefined} error
                 * @memberof clutch.resolver.v1.Schema
                 * @instance
                 */
                Schema.prototype.error = null;

                /**
                 * Verifies a Schema message.
                 * @function verify
                 * @memberof clutch.resolver.v1.Schema
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Schema.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        if (!$util.isString(message.typeUrl))
                            return "typeUrl: string expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        let error = $root.clutch.resolver.v1.SchemaMetadata.verify(message.metadata);
                        if (error)
                            return "metadata." + error;
                    }
                    if (message.fields != null && message.hasOwnProperty("fields")) {
                        if (!Array.isArray(message.fields))
                            return "fields: array expected";
                        for (let i = 0; i < message.fields.length; ++i) {
                            let error = $root.clutch.resolver.v1.Field.verify(message.fields[i]);
                            if (error)
                                return "fields." + error;
                        }
                    }
                    if (message.error != null && message.hasOwnProperty("error")) {
                        let error = $root.google.rpc.Status.verify(message.error);
                        if (error)
                            return "error." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Schema message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.Schema
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.Schema} Schema
                 */
                Schema.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.Schema)
                        return object;
                    let message = new $root.clutch.resolver.v1.Schema();
                    if (object.typeUrl != null)
                        message.typeUrl = String(object.typeUrl);
                    if (object.metadata != null) {
                        if (typeof object.metadata !== "object")
                            throw TypeError(".clutch.resolver.v1.Schema.metadata: object expected");
                        message.metadata = $root.clutch.resolver.v1.SchemaMetadata.fromObject(object.metadata);
                    }
                    if (object.fields) {
                        if (!Array.isArray(object.fields))
                            throw TypeError(".clutch.resolver.v1.Schema.fields: array expected");
                        message.fields = [];
                        for (let i = 0; i < object.fields.length; ++i) {
                            if (typeof object.fields[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.Schema.fields: object expected");
                            message.fields[i] = $root.clutch.resolver.v1.Field.fromObject(object.fields[i]);
                        }
                    }
                    if (object.error != null) {
                        if (typeof object.error !== "object")
                            throw TypeError(".clutch.resolver.v1.Schema.error: object expected");
                        message.error = $root.google.rpc.Status.fromObject(object.error);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Schema message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.Schema
                 * @static
                 * @param {clutch.resolver.v1.Schema} message Schema
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Schema.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.fields = [];
                    if (options.defaults) {
                        object.typeUrl = "";
                        object.metadata = null;
                        object.error = null;
                    }
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        object.typeUrl = message.typeUrl;
                    if (message.metadata != null && message.hasOwnProperty("metadata"))
                        object.metadata = $root.clutch.resolver.v1.SchemaMetadata.toObject(message.metadata, options);
                    if (message.fields && message.fields.length) {
                        object.fields = [];
                        for (let j = 0; j < message.fields.length; ++j)
                            object.fields[j] = $root.clutch.resolver.v1.Field.toObject(message.fields[j], options);
                    }
                    if (message.error != null && message.hasOwnProperty("error"))
                        object.error = $root.google.rpc.Status.toObject(message.error, options);
                    return object;
                };

                /**
                 * Converts this Schema to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.Schema
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Schema.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Schema;
            })();

            v1.ResolverAPI = (function() {

                /**
                 * Constructs a new ResolverAPI service.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a ResolverAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function ResolverAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (ResolverAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = ResolverAPI;

                /**
                 * Callback as used by {@link clutch.resolver.v1.ResolverAPI#getObjectSchemas}.
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @typedef GetObjectSchemasCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.resolver.v1.GetObjectSchemasResponse} [response] GetObjectSchemasResponse
                 */

                /**
                 * Calls GetObjectSchemas.
                 * @function getObjectSchemas
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @instance
                 * @param {clutch.resolver.v1.IGetObjectSchemasRequest} request GetObjectSchemasRequest message or plain object
                 * @param {clutch.resolver.v1.ResolverAPI.GetObjectSchemasCallback} callback Node-style callback called with the error, if any, and GetObjectSchemasResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ResolverAPI.prototype.getObjectSchemas = function getObjectSchemas(request, callback) {
                    return this.rpcCall(getObjectSchemas, $root.clutch.resolver.v1.GetObjectSchemasRequest, $root.clutch.resolver.v1.GetObjectSchemasResponse, request, callback);
                }, "name", { value: "GetObjectSchemas" });

                /**
                 * Calls GetObjectSchemas.
                 * @function getObjectSchemas
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @instance
                 * @param {clutch.resolver.v1.IGetObjectSchemasRequest} request GetObjectSchemasRequest message or plain object
                 * @returns {Promise<clutch.resolver.v1.GetObjectSchemasResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.resolver.v1.ResolverAPI#search}.
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @typedef SearchCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.resolver.v1.SearchResponse} [response] SearchResponse
                 */

                /**
                 * Calls Search.
                 * @function search
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @instance
                 * @param {clutch.resolver.v1.ISearchRequest} request SearchRequest message or plain object
                 * @param {clutch.resolver.v1.ResolverAPI.SearchCallback} callback Node-style callback called with the error, if any, and SearchResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ResolverAPI.prototype.search = function search(request, callback) {
                    return this.rpcCall(search, $root.clutch.resolver.v1.SearchRequest, $root.clutch.resolver.v1.SearchResponse, request, callback);
                }, "name", { value: "Search" });

                /**
                 * Calls Search.
                 * @function search
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @instance
                 * @param {clutch.resolver.v1.ISearchRequest} request SearchRequest message or plain object
                 * @returns {Promise<clutch.resolver.v1.SearchResponse>} Promise
                 * @variation 2
                 */

                /**
                 * Callback as used by {@link clutch.resolver.v1.ResolverAPI#resolve}.
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @typedef ResolveCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.resolver.v1.ResolveResponse} [response] ResolveResponse
                 */

                /**
                 * Calls Resolve.
                 * @function resolve
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @instance
                 * @param {clutch.resolver.v1.IResolveRequest} request ResolveRequest message or plain object
                 * @param {clutch.resolver.v1.ResolverAPI.ResolveCallback} callback Node-style callback called with the error, if any, and ResolveResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(ResolverAPI.prototype.resolve = function resolve(request, callback) {
                    return this.rpcCall(resolve, $root.clutch.resolver.v1.ResolveRequest, $root.clutch.resolver.v1.ResolveResponse, request, callback);
                }, "name", { value: "Resolve" });

                /**
                 * Calls Resolve.
                 * @function resolve
                 * @memberof clutch.resolver.v1.ResolverAPI
                 * @instance
                 * @param {clutch.resolver.v1.IResolveRequest} request ResolveRequest message or plain object
                 * @returns {Promise<clutch.resolver.v1.ResolveResponse>} Promise
                 * @variation 2
                 */

                return ResolverAPI;
            })();

            v1.ResolveRequest = (function() {

                /**
                 * Properties of a ResolveRequest.
                 * @memberof clutch.resolver.v1
                 * @interface IResolveRequest
                 * @property {string|null} [want] ResolveRequest want
                 * @property {google.protobuf.IAny|null} [have] ResolveRequest have
                 * @property {number|null} [limit] ResolveRequest limit
                 */

                /**
                 * Constructs a new ResolveRequest.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a ResolveRequest.
                 * @implements IResolveRequest
                 * @constructor
                 * @param {clutch.resolver.v1.IResolveRequest=} [properties] Properties to set
                 */
                function ResolveRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ResolveRequest want.
                 * @member {string} want
                 * @memberof clutch.resolver.v1.ResolveRequest
                 * @instance
                 */
                ResolveRequest.prototype.want = "";

                /**
                 * ResolveRequest have.
                 * @member {google.protobuf.IAny|null|undefined} have
                 * @memberof clutch.resolver.v1.ResolveRequest
                 * @instance
                 */
                ResolveRequest.prototype.have = null;

                /**
                 * ResolveRequest limit.
                 * @member {number} limit
                 * @memberof clutch.resolver.v1.ResolveRequest
                 * @instance
                 */
                ResolveRequest.prototype.limit = 0;

                /**
                 * Verifies a ResolveRequest message.
                 * @function verify
                 * @memberof clutch.resolver.v1.ResolveRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ResolveRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.want != null && message.hasOwnProperty("want"))
                        if (!$util.isString(message.want))
                            return "want: string expected";
                    if (message.have != null && message.hasOwnProperty("have")) {
                        let error = $root.google.protobuf.Any.verify(message.have);
                        if (error)
                            return "have." + error;
                    }
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    return null;
                };

                /**
                 * Creates a ResolveRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.ResolveRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.ResolveRequest} ResolveRequest
                 */
                ResolveRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.ResolveRequest)
                        return object;
                    let message = new $root.clutch.resolver.v1.ResolveRequest();
                    if (object.want != null)
                        message.want = String(object.want);
                    if (object.have != null) {
                        if (typeof object.have !== "object")
                            throw TypeError(".clutch.resolver.v1.ResolveRequest.have: object expected");
                        message.have = $root.google.protobuf.Any.fromObject(object.have);
                    }
                    if (object.limit != null)
                        message.limit = object.limit >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ResolveRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.ResolveRequest
                 * @static
                 * @param {clutch.resolver.v1.ResolveRequest} message ResolveRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ResolveRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.want = "";
                        object.have = null;
                        object.limit = 0;
                    }
                    if (message.want != null && message.hasOwnProperty("want"))
                        object.want = message.want;
                    if (message.have != null && message.hasOwnProperty("have"))
                        object.have = $root.google.protobuf.Any.toObject(message.have, options);
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        object.limit = message.limit;
                    return object;
                };

                /**
                 * Converts this ResolveRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.ResolveRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ResolveRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ResolveRequest;
            })();

            v1.ResolveResponse = (function() {

                /**
                 * Properties of a ResolveResponse.
                 * @memberof clutch.resolver.v1
                 * @interface IResolveResponse
                 * @property {Array.<google.protobuf.IAny>|null} [results] ResolveResponse results
                 * @property {Array.<google.rpc.IStatus>|null} [partialFailures] ResolveResponse partialFailures
                 */

                /**
                 * Constructs a new ResolveResponse.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a ResolveResponse.
                 * @implements IResolveResponse
                 * @constructor
                 * @param {clutch.resolver.v1.IResolveResponse=} [properties] Properties to set
                 */
                function ResolveResponse(properties) {
                    this.results = [];
                    this.partialFailures = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ResolveResponse results.
                 * @member {Array.<google.protobuf.IAny>} results
                 * @memberof clutch.resolver.v1.ResolveResponse
                 * @instance
                 */
                ResolveResponse.prototype.results = $util.emptyArray;

                /**
                 * ResolveResponse partialFailures.
                 * @member {Array.<google.rpc.IStatus>} partialFailures
                 * @memberof clutch.resolver.v1.ResolveResponse
                 * @instance
                 */
                ResolveResponse.prototype.partialFailures = $util.emptyArray;

                /**
                 * Verifies a ResolveResponse message.
                 * @function verify
                 * @memberof clutch.resolver.v1.ResolveResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ResolveResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.results != null && message.hasOwnProperty("results")) {
                        if (!Array.isArray(message.results))
                            return "results: array expected";
                        for (let i = 0; i < message.results.length; ++i) {
                            let error = $root.google.protobuf.Any.verify(message.results[i]);
                            if (error)
                                return "results." + error;
                        }
                    }
                    if (message.partialFailures != null && message.hasOwnProperty("partialFailures")) {
                        if (!Array.isArray(message.partialFailures))
                            return "partialFailures: array expected";
                        for (let i = 0; i < message.partialFailures.length; ++i) {
                            let error = $root.google.rpc.Status.verify(message.partialFailures[i]);
                            if (error)
                                return "partialFailures." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a ResolveResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.ResolveResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.ResolveResponse} ResolveResponse
                 */
                ResolveResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.ResolveResponse)
                        return object;
                    let message = new $root.clutch.resolver.v1.ResolveResponse();
                    if (object.results) {
                        if (!Array.isArray(object.results))
                            throw TypeError(".clutch.resolver.v1.ResolveResponse.results: array expected");
                        message.results = [];
                        for (let i = 0; i < object.results.length; ++i) {
                            if (typeof object.results[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.ResolveResponse.results: object expected");
                            message.results[i] = $root.google.protobuf.Any.fromObject(object.results[i]);
                        }
                    }
                    if (object.partialFailures) {
                        if (!Array.isArray(object.partialFailures))
                            throw TypeError(".clutch.resolver.v1.ResolveResponse.partialFailures: array expected");
                        message.partialFailures = [];
                        for (let i = 0; i < object.partialFailures.length; ++i) {
                            if (typeof object.partialFailures[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.ResolveResponse.partialFailures: object expected");
                            message.partialFailures[i] = $root.google.rpc.Status.fromObject(object.partialFailures[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a ResolveResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.ResolveResponse
                 * @static
                 * @param {clutch.resolver.v1.ResolveResponse} message ResolveResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ResolveResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.results = [];
                        object.partialFailures = [];
                    }
                    if (message.results && message.results.length) {
                        object.results = [];
                        for (let j = 0; j < message.results.length; ++j)
                            object.results[j] = $root.google.protobuf.Any.toObject(message.results[j], options);
                    }
                    if (message.partialFailures && message.partialFailures.length) {
                        object.partialFailures = [];
                        for (let j = 0; j < message.partialFailures.length; ++j)
                            object.partialFailures[j] = $root.google.rpc.Status.toObject(message.partialFailures[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this ResolveResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.ResolveResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ResolveResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ResolveResponse;
            })();

            v1.SearchRequest = (function() {

                /**
                 * Properties of a SearchRequest.
                 * @memberof clutch.resolver.v1
                 * @interface ISearchRequest
                 * @property {string|null} [want] SearchRequest want
                 * @property {string|null} [query] SearchRequest query
                 * @property {number|null} [limit] SearchRequest limit
                 */

                /**
                 * Constructs a new SearchRequest.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a SearchRequest.
                 * @implements ISearchRequest
                 * @constructor
                 * @param {clutch.resolver.v1.ISearchRequest=} [properties] Properties to set
                 */
                function SearchRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SearchRequest want.
                 * @member {string} want
                 * @memberof clutch.resolver.v1.SearchRequest
                 * @instance
                 */
                SearchRequest.prototype.want = "";

                /**
                 * SearchRequest query.
                 * @member {string} query
                 * @memberof clutch.resolver.v1.SearchRequest
                 * @instance
                 */
                SearchRequest.prototype.query = "";

                /**
                 * SearchRequest limit.
                 * @member {number} limit
                 * @memberof clutch.resolver.v1.SearchRequest
                 * @instance
                 */
                SearchRequest.prototype.limit = 0;

                /**
                 * Verifies a SearchRequest message.
                 * @function verify
                 * @memberof clutch.resolver.v1.SearchRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SearchRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.want != null && message.hasOwnProperty("want"))
                        if (!$util.isString(message.want))
                            return "want: string expected";
                    if (message.query != null && message.hasOwnProperty("query"))
                        if (!$util.isString(message.query))
                            return "query: string expected";
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        if (!$util.isInteger(message.limit))
                            return "limit: integer expected";
                    return null;
                };

                /**
                 * Creates a SearchRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.SearchRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.SearchRequest} SearchRequest
                 */
                SearchRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.SearchRequest)
                        return object;
                    let message = new $root.clutch.resolver.v1.SearchRequest();
                    if (object.want != null)
                        message.want = String(object.want);
                    if (object.query != null)
                        message.query = String(object.query);
                    if (object.limit != null)
                        message.limit = object.limit >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a SearchRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.SearchRequest
                 * @static
                 * @param {clutch.resolver.v1.SearchRequest} message SearchRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SearchRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.want = "";
                        object.query = "";
                        object.limit = 0;
                    }
                    if (message.want != null && message.hasOwnProperty("want"))
                        object.want = message.want;
                    if (message.query != null && message.hasOwnProperty("query"))
                        object.query = message.query;
                    if (message.limit != null && message.hasOwnProperty("limit"))
                        object.limit = message.limit;
                    return object;
                };

                /**
                 * Converts this SearchRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.SearchRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SearchRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SearchRequest;
            })();

            v1.SearchResponse = (function() {

                /**
                 * Properties of a SearchResponse.
                 * @memberof clutch.resolver.v1
                 * @interface ISearchResponse
                 * @property {Array.<google.protobuf.IAny>|null} [results] SearchResponse results
                 * @property {Array.<google.rpc.IStatus>|null} [partialFailures] SearchResponse partialFailures
                 */

                /**
                 * Constructs a new SearchResponse.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a SearchResponse.
                 * @implements ISearchResponse
                 * @constructor
                 * @param {clutch.resolver.v1.ISearchResponse=} [properties] Properties to set
                 */
                function SearchResponse(properties) {
                    this.results = [];
                    this.partialFailures = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * SearchResponse results.
                 * @member {Array.<google.protobuf.IAny>} results
                 * @memberof clutch.resolver.v1.SearchResponse
                 * @instance
                 */
                SearchResponse.prototype.results = $util.emptyArray;

                /**
                 * SearchResponse partialFailures.
                 * @member {Array.<google.rpc.IStatus>} partialFailures
                 * @memberof clutch.resolver.v1.SearchResponse
                 * @instance
                 */
                SearchResponse.prototype.partialFailures = $util.emptyArray;

                /**
                 * Verifies a SearchResponse message.
                 * @function verify
                 * @memberof clutch.resolver.v1.SearchResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                SearchResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.results != null && message.hasOwnProperty("results")) {
                        if (!Array.isArray(message.results))
                            return "results: array expected";
                        for (let i = 0; i < message.results.length; ++i) {
                            let error = $root.google.protobuf.Any.verify(message.results[i]);
                            if (error)
                                return "results." + error;
                        }
                    }
                    if (message.partialFailures != null && message.hasOwnProperty("partialFailures")) {
                        if (!Array.isArray(message.partialFailures))
                            return "partialFailures: array expected";
                        for (let i = 0; i < message.partialFailures.length; ++i) {
                            let error = $root.google.rpc.Status.verify(message.partialFailures[i]);
                            if (error)
                                return "partialFailures." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a SearchResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.SearchResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.SearchResponse} SearchResponse
                 */
                SearchResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.SearchResponse)
                        return object;
                    let message = new $root.clutch.resolver.v1.SearchResponse();
                    if (object.results) {
                        if (!Array.isArray(object.results))
                            throw TypeError(".clutch.resolver.v1.SearchResponse.results: array expected");
                        message.results = [];
                        for (let i = 0; i < object.results.length; ++i) {
                            if (typeof object.results[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.SearchResponse.results: object expected");
                            message.results[i] = $root.google.protobuf.Any.fromObject(object.results[i]);
                        }
                    }
                    if (object.partialFailures) {
                        if (!Array.isArray(object.partialFailures))
                            throw TypeError(".clutch.resolver.v1.SearchResponse.partialFailures: array expected");
                        message.partialFailures = [];
                        for (let i = 0; i < object.partialFailures.length; ++i) {
                            if (typeof object.partialFailures[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.SearchResponse.partialFailures: object expected");
                            message.partialFailures[i] = $root.google.rpc.Status.fromObject(object.partialFailures[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a SearchResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.SearchResponse
                 * @static
                 * @param {clutch.resolver.v1.SearchResponse} message SearchResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                SearchResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.results = [];
                        object.partialFailures = [];
                    }
                    if (message.results && message.results.length) {
                        object.results = [];
                        for (let j = 0; j < message.results.length; ++j)
                            object.results[j] = $root.google.protobuf.Any.toObject(message.results[j], options);
                    }
                    if (message.partialFailures && message.partialFailures.length) {
                        object.partialFailures = [];
                        for (let j = 0; j < message.partialFailures.length; ++j)
                            object.partialFailures[j] = $root.google.rpc.Status.toObject(message.partialFailures[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this SearchResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.SearchResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                SearchResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return SearchResponse;
            })();

            v1.GetObjectSchemasRequest = (function() {

                /**
                 * Properties of a GetObjectSchemasRequest.
                 * @memberof clutch.resolver.v1
                 * @interface IGetObjectSchemasRequest
                 * @property {string|null} [typeUrl] GetObjectSchemasRequest typeUrl
                 */

                /**
                 * Constructs a new GetObjectSchemasRequest.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a GetObjectSchemasRequest.
                 * @implements IGetObjectSchemasRequest
                 * @constructor
                 * @param {clutch.resolver.v1.IGetObjectSchemasRequest=} [properties] Properties to set
                 */
                function GetObjectSchemasRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetObjectSchemasRequest typeUrl.
                 * @member {string} typeUrl
                 * @memberof clutch.resolver.v1.GetObjectSchemasRequest
                 * @instance
                 */
                GetObjectSchemasRequest.prototype.typeUrl = "";

                /**
                 * Verifies a GetObjectSchemasRequest message.
                 * @function verify
                 * @memberof clutch.resolver.v1.GetObjectSchemasRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetObjectSchemasRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        if (!$util.isString(message.typeUrl))
                            return "typeUrl: string expected";
                    return null;
                };

                /**
                 * Creates a GetObjectSchemasRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.GetObjectSchemasRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.GetObjectSchemasRequest} GetObjectSchemasRequest
                 */
                GetObjectSchemasRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.GetObjectSchemasRequest)
                        return object;
                    let message = new $root.clutch.resolver.v1.GetObjectSchemasRequest();
                    if (object.typeUrl != null)
                        message.typeUrl = String(object.typeUrl);
                    return message;
                };

                /**
                 * Creates a plain object from a GetObjectSchemasRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.GetObjectSchemasRequest
                 * @static
                 * @param {clutch.resolver.v1.GetObjectSchemasRequest} message GetObjectSchemasRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetObjectSchemasRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.typeUrl = "";
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        object.typeUrl = message.typeUrl;
                    return object;
                };

                /**
                 * Converts this GetObjectSchemasRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.GetObjectSchemasRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetObjectSchemasRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetObjectSchemasRequest;
            })();

            v1.GetObjectSchemasResponse = (function() {

                /**
                 * Properties of a GetObjectSchemasResponse.
                 * @memberof clutch.resolver.v1
                 * @interface IGetObjectSchemasResponse
                 * @property {string|null} [typeUrl] GetObjectSchemasResponse typeUrl
                 * @property {Array.<clutch.resolver.v1.ISchema>|null} [schemas] GetObjectSchemasResponse schemas
                 */

                /**
                 * Constructs a new GetObjectSchemasResponse.
                 * @memberof clutch.resolver.v1
                 * @classdesc Represents a GetObjectSchemasResponse.
                 * @implements IGetObjectSchemasResponse
                 * @constructor
                 * @param {clutch.resolver.v1.IGetObjectSchemasResponse=} [properties] Properties to set
                 */
                function GetObjectSchemasResponse(properties) {
                    this.schemas = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetObjectSchemasResponse typeUrl.
                 * @member {string} typeUrl
                 * @memberof clutch.resolver.v1.GetObjectSchemasResponse
                 * @instance
                 */
                GetObjectSchemasResponse.prototype.typeUrl = "";

                /**
                 * GetObjectSchemasResponse schemas.
                 * @member {Array.<clutch.resolver.v1.ISchema>} schemas
                 * @memberof clutch.resolver.v1.GetObjectSchemasResponse
                 * @instance
                 */
                GetObjectSchemasResponse.prototype.schemas = $util.emptyArray;

                /**
                 * Verifies a GetObjectSchemasResponse message.
                 * @function verify
                 * @memberof clutch.resolver.v1.GetObjectSchemasResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetObjectSchemasResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        if (!$util.isString(message.typeUrl))
                            return "typeUrl: string expected";
                    if (message.schemas != null && message.hasOwnProperty("schemas")) {
                        if (!Array.isArray(message.schemas))
                            return "schemas: array expected";
                        for (let i = 0; i < message.schemas.length; ++i) {
                            let error = $root.clutch.resolver.v1.Schema.verify(message.schemas[i]);
                            if (error)
                                return "schemas." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetObjectSchemasResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.resolver.v1.GetObjectSchemasResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.resolver.v1.GetObjectSchemasResponse} GetObjectSchemasResponse
                 */
                GetObjectSchemasResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.resolver.v1.GetObjectSchemasResponse)
                        return object;
                    let message = new $root.clutch.resolver.v1.GetObjectSchemasResponse();
                    if (object.typeUrl != null)
                        message.typeUrl = String(object.typeUrl);
                    if (object.schemas) {
                        if (!Array.isArray(object.schemas))
                            throw TypeError(".clutch.resolver.v1.GetObjectSchemasResponse.schemas: array expected");
                        message.schemas = [];
                        for (let i = 0; i < object.schemas.length; ++i) {
                            if (typeof object.schemas[i] !== "object")
                                throw TypeError(".clutch.resolver.v1.GetObjectSchemasResponse.schemas: object expected");
                            message.schemas[i] = $root.clutch.resolver.v1.Schema.fromObject(object.schemas[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetObjectSchemasResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.resolver.v1.GetObjectSchemasResponse
                 * @static
                 * @param {clutch.resolver.v1.GetObjectSchemasResponse} message GetObjectSchemasResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetObjectSchemasResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.schemas = [];
                    if (options.defaults)
                        object.typeUrl = "";
                    if (message.typeUrl != null && message.hasOwnProperty("typeUrl"))
                        object.typeUrl = message.typeUrl;
                    if (message.schemas && message.schemas.length) {
                        object.schemas = [];
                        for (let j = 0; j < message.schemas.length; ++j)
                            object.schemas[j] = $root.clutch.resolver.v1.Schema.toObject(message.schemas[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetObjectSchemasResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.resolver.v1.GetObjectSchemasResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetObjectSchemasResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetObjectSchemasResponse;
            })();

            return v1;
        })();

        resolver.k8s = (function() {

            /**
             * Namespace k8s.
             * @memberof clutch.resolver
             * @namespace
             */
            const k8s = {};

            k8s.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.resolver.k8s
                 * @namespace
                 */
                const v1 = {};

                v1.PodID = (function() {

                    /**
                     * Properties of a PodID.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface IPodID
                     * @property {string|null} [name] PodID name
                     * @property {string|null} [clientset] PodID clientset
                     * @property {string|null} [namespace] PodID namespace
                     */

                    /**
                     * Constructs a new PodID.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a PodID.
                     * @implements IPodID
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.IPodID=} [properties] Properties to set
                     */
                    function PodID(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * PodID name.
                     * @member {string} name
                     * @memberof clutch.resolver.k8s.v1.PodID
                     * @instance
                     */
                    PodID.prototype.name = "";

                    /**
                     * PodID clientset.
                     * @member {string} clientset
                     * @memberof clutch.resolver.k8s.v1.PodID
                     * @instance
                     */
                    PodID.prototype.clientset = "";

                    /**
                     * PodID namespace.
                     * @member {string} namespace
                     * @memberof clutch.resolver.k8s.v1.PodID
                     * @instance
                     */
                    PodID.prototype.namespace = "";

                    /**
                     * Verifies a PodID message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.PodID
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    PodID.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            if (!$util.isString(message.clientset))
                                return "clientset: string expected";
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            if (!$util.isString(message.namespace))
                                return "namespace: string expected";
                        return null;
                    };

                    /**
                     * Creates a PodID message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.PodID
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.PodID} PodID
                     */
                    PodID.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.PodID)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.PodID();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.clientset != null)
                            message.clientset = String(object.clientset);
                        if (object.namespace != null)
                            message.namespace = String(object.namespace);
                        return message;
                    };

                    /**
                     * Creates a plain object from a PodID message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.PodID
                     * @static
                     * @param {clutch.resolver.k8s.v1.PodID} message PodID
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    PodID.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.clientset = "";
                            object.namespace = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            object.clientset = message.clientset;
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            object.namespace = message.namespace;
                        return object;
                    };

                    /**
                     * Converts this PodID to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.PodID
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    PodID.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return PodID;
                })();

                v1.IPAddress = (function() {

                    /**
                     * Properties of a IPAddress.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface IIPAddress
                     * @property {string|null} [ipAddress] IPAddress ipAddress
                     */

                    /**
                     * Constructs a new IPAddress.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a IPAddress.
                     * @implements IIPAddress
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.IIPAddress=} [properties] Properties to set
                     */
                    function IPAddress(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * IPAddress ipAddress.
                     * @member {string} ipAddress
                     * @memberof clutch.resolver.k8s.v1.IPAddress
                     * @instance
                     */
                    IPAddress.prototype.ipAddress = "";

                    /**
                     * Verifies a IPAddress message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.IPAddress
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    IPAddress.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                            if (!$util.isString(message.ipAddress))
                                return "ipAddress: string expected";
                        return null;
                    };

                    /**
                     * Creates a IPAddress message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.IPAddress
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.IPAddress} IPAddress
                     */
                    IPAddress.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.IPAddress)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.IPAddress();
                        if (object.ipAddress != null)
                            message.ipAddress = String(object.ipAddress);
                        return message;
                    };

                    /**
                     * Creates a plain object from a IPAddress message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.IPAddress
                     * @static
                     * @param {clutch.resolver.k8s.v1.IPAddress} message IPAddress
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    IPAddress.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.ipAddress = "";
                        if (message.ipAddress != null && message.hasOwnProperty("ipAddress"))
                            object.ipAddress = message.ipAddress;
                        return object;
                    };

                    /**
                     * Converts this IPAddress to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.IPAddress
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    IPAddress.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return IPAddress;
                })();

                v1.HPAName = (function() {

                    /**
                     * Properties of a HPAName.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface IHPAName
                     * @property {string|null} [name] HPAName name
                     * @property {string|null} [clientset] HPAName clientset
                     * @property {string|null} [namespace] HPAName namespace
                     */

                    /**
                     * Constructs a new HPAName.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a HPAName.
                     * @implements IHPAName
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.IHPAName=} [properties] Properties to set
                     */
                    function HPAName(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * HPAName name.
                     * @member {string} name
                     * @memberof clutch.resolver.k8s.v1.HPAName
                     * @instance
                     */
                    HPAName.prototype.name = "";

                    /**
                     * HPAName clientset.
                     * @member {string} clientset
                     * @memberof clutch.resolver.k8s.v1.HPAName
                     * @instance
                     */
                    HPAName.prototype.clientset = "";

                    /**
                     * HPAName namespace.
                     * @member {string} namespace
                     * @memberof clutch.resolver.k8s.v1.HPAName
                     * @instance
                     */
                    HPAName.prototype.namespace = "";

                    /**
                     * Verifies a HPAName message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.HPAName
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    HPAName.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            if (!$util.isString(message.clientset))
                                return "clientset: string expected";
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            if (!$util.isString(message.namespace))
                                return "namespace: string expected";
                        return null;
                    };

                    /**
                     * Creates a HPAName message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.HPAName
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.HPAName} HPAName
                     */
                    HPAName.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.HPAName)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.HPAName();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.clientset != null)
                            message.clientset = String(object.clientset);
                        if (object.namespace != null)
                            message.namespace = String(object.namespace);
                        return message;
                    };

                    /**
                     * Creates a plain object from a HPAName message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.HPAName
                     * @static
                     * @param {clutch.resolver.k8s.v1.HPAName} message HPAName
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    HPAName.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.clientset = "";
                            object.namespace = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            object.clientset = message.clientset;
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            object.namespace = message.namespace;
                        return object;
                    };

                    /**
                     * Converts this HPAName to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.HPAName
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    HPAName.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return HPAName;
                })();

                v1.Deployment = (function() {

                    /**
                     * Properties of a Deployment.
                     * @memberof clutch.resolver.k8s.v1
                     * @interface IDeployment
                     * @property {string|null} [name] Deployment name
                     * @property {string|null} [clientset] Deployment clientset
                     * @property {string|null} [namespace] Deployment namespace
                     */

                    /**
                     * Constructs a new Deployment.
                     * @memberof clutch.resolver.k8s.v1
                     * @classdesc Represents a Deployment.
                     * @implements IDeployment
                     * @constructor
                     * @param {clutch.resolver.k8s.v1.IDeployment=} [properties] Properties to set
                     */
                    function Deployment(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * Deployment name.
                     * @member {string} name
                     * @memberof clutch.resolver.k8s.v1.Deployment
                     * @instance
                     */
                    Deployment.prototype.name = "";

                    /**
                     * Deployment clientset.
                     * @member {string} clientset
                     * @memberof clutch.resolver.k8s.v1.Deployment
                     * @instance
                     */
                    Deployment.prototype.clientset = "";

                    /**
                     * Deployment namespace.
                     * @member {string} namespace
                     * @memberof clutch.resolver.k8s.v1.Deployment
                     * @instance
                     */
                    Deployment.prototype.namespace = "";

                    /**
                     * Verifies a Deployment message.
                     * @function verify
                     * @memberof clutch.resolver.k8s.v1.Deployment
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    Deployment.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.name != null && message.hasOwnProperty("name"))
                            if (!$util.isString(message.name))
                                return "name: string expected";
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            if (!$util.isString(message.clientset))
                                return "clientset: string expected";
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            if (!$util.isString(message.namespace))
                                return "namespace: string expected";
                        return null;
                    };

                    /**
                     * Creates a Deployment message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.resolver.k8s.v1.Deployment
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.resolver.k8s.v1.Deployment} Deployment
                     */
                    Deployment.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.resolver.k8s.v1.Deployment)
                            return object;
                        let message = new $root.clutch.resolver.k8s.v1.Deployment();
                        if (object.name != null)
                            message.name = String(object.name);
                        if (object.clientset != null)
                            message.clientset = String(object.clientset);
                        if (object.namespace != null)
                            message.namespace = String(object.namespace);
                        return message;
                    };

                    /**
                     * Creates a plain object from a Deployment message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.resolver.k8s.v1.Deployment
                     * @static
                     * @param {clutch.resolver.k8s.v1.Deployment} message Deployment
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    Deployment.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.name = "";
                            object.clientset = "";
                            object.namespace = "";
                        }
                        if (message.name != null && message.hasOwnProperty("name"))
                            object.name = message.name;
                        if (message.clientset != null && message.hasOwnProperty("clientset"))
                            object.clientset = message.clientset;
                        if (message.namespace != null && message.hasOwnProperty("namespace"))
                            object.namespace = message.namespace;
                        return object;
                    };

                    /**
                     * Converts this Deployment to JSON.
                     * @function toJSON
                     * @memberof clutch.resolver.k8s.v1.Deployment
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    Deployment.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return Deployment;
                })();

                return v1;
            })();

            return k8s;
        })();

        return resolver;
    })();

    clutch.sourcecontrol = (function() {

        /**
         * Namespace sourcecontrol.
         * @memberof clutch
         * @namespace
         */
        const sourcecontrol = {};

        sourcecontrol.github = (function() {

            /**
             * Namespace github.
             * @memberof clutch.sourcecontrol
             * @namespace
             */
            const github = {};

            github.v1 = (function() {

                /**
                 * Namespace v1.
                 * @memberof clutch.sourcecontrol.github
                 * @namespace
                 */
                const v1 = {};

                v1.RepositoryParameters = (function() {

                    /**
                     * Properties of a RepositoryParameters.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @interface IRepositoryParameters
                     * @property {clutch.sourcecontrol.github.v1.RepositoryParameters.Visibility|null} [visibility] RepositoryParameters visibility
                     * @property {google.protobuf.IBoolValue|null} [allowMergeCommit] RepositoryParameters allowMergeCommit
                     * @property {google.protobuf.IBoolValue|null} [allowRebaseMerge] RepositoryParameters allowRebaseMerge
                     * @property {google.protobuf.IBoolValue|null} [allowSquashMerge] RepositoryParameters allowSquashMerge
                     */

                    /**
                     * Constructs a new RepositoryParameters.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @classdesc Represents a RepositoryParameters.
                     * @implements IRepositoryParameters
                     * @constructor
                     * @param {clutch.sourcecontrol.github.v1.IRepositoryParameters=} [properties] Properties to set
                     */
                    function RepositoryParameters(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * RepositoryParameters visibility.
                     * @member {clutch.sourcecontrol.github.v1.RepositoryParameters.Visibility} visibility
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @instance
                     */
                    RepositoryParameters.prototype.visibility = 0;

                    /**
                     * RepositoryParameters allowMergeCommit.
                     * @member {google.protobuf.IBoolValue|null|undefined} allowMergeCommit
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @instance
                     */
                    RepositoryParameters.prototype.allowMergeCommit = null;

                    /**
                     * RepositoryParameters allowRebaseMerge.
                     * @member {google.protobuf.IBoolValue|null|undefined} allowRebaseMerge
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @instance
                     */
                    RepositoryParameters.prototype.allowRebaseMerge = null;

                    /**
                     * RepositoryParameters allowSquashMerge.
                     * @member {google.protobuf.IBoolValue|null|undefined} allowSquashMerge
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @instance
                     */
                    RepositoryParameters.prototype.allowSquashMerge = null;

                    /**
                     * Verifies a RepositoryParameters message.
                     * @function verify
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    RepositoryParameters.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.visibility != null && message.hasOwnProperty("visibility"))
                            switch (message.visibility) {
                            default:
                                return "visibility: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                                break;
                            }
                        if (message.allowMergeCommit != null && message.hasOwnProperty("allowMergeCommit")) {
                            let error = $root.google.protobuf.BoolValue.verify(message.allowMergeCommit);
                            if (error)
                                return "allowMergeCommit." + error;
                        }
                        if (message.allowRebaseMerge != null && message.hasOwnProperty("allowRebaseMerge")) {
                            let error = $root.google.protobuf.BoolValue.verify(message.allowRebaseMerge);
                            if (error)
                                return "allowRebaseMerge." + error;
                        }
                        if (message.allowSquashMerge != null && message.hasOwnProperty("allowSquashMerge")) {
                            let error = $root.google.protobuf.BoolValue.verify(message.allowSquashMerge);
                            if (error)
                                return "allowSquashMerge." + error;
                        }
                        return null;
                    };

                    /**
                     * Creates a RepositoryParameters message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.sourcecontrol.github.v1.RepositoryParameters} RepositoryParameters
                     */
                    RepositoryParameters.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.sourcecontrol.github.v1.RepositoryParameters)
                            return object;
                        let message = new $root.clutch.sourcecontrol.github.v1.RepositoryParameters();
                        switch (object.visibility) {
                        case "UNSPECIFIED":
                        case 0:
                            message.visibility = 0;
                            break;
                        case "PUBLIC":
                        case 1:
                            message.visibility = 1;
                            break;
                        case "PRIVATE":
                        case 2:
                            message.visibility = 2;
                            break;
                        }
                        if (object.allowMergeCommit != null) {
                            if (typeof object.allowMergeCommit !== "object")
                                throw TypeError(".clutch.sourcecontrol.github.v1.RepositoryParameters.allowMergeCommit: object expected");
                            message.allowMergeCommit = $root.google.protobuf.BoolValue.fromObject(object.allowMergeCommit);
                        }
                        if (object.allowRebaseMerge != null) {
                            if (typeof object.allowRebaseMerge !== "object")
                                throw TypeError(".clutch.sourcecontrol.github.v1.RepositoryParameters.allowRebaseMerge: object expected");
                            message.allowRebaseMerge = $root.google.protobuf.BoolValue.fromObject(object.allowRebaseMerge);
                        }
                        if (object.allowSquashMerge != null) {
                            if (typeof object.allowSquashMerge !== "object")
                                throw TypeError(".clutch.sourcecontrol.github.v1.RepositoryParameters.allowSquashMerge: object expected");
                            message.allowSquashMerge = $root.google.protobuf.BoolValue.fromObject(object.allowSquashMerge);
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a RepositoryParameters message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @static
                     * @param {clutch.sourcecontrol.github.v1.RepositoryParameters} message RepositoryParameters
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    RepositoryParameters.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.visibility = options.enums === String ? "UNSPECIFIED" : 0;
                            object.allowMergeCommit = null;
                            object.allowRebaseMerge = null;
                            object.allowSquashMerge = null;
                        }
                        if (message.visibility != null && message.hasOwnProperty("visibility"))
                            object.visibility = options.enums === String ? $root.clutch.sourcecontrol.github.v1.RepositoryParameters.Visibility[message.visibility] : message.visibility;
                        if (message.allowMergeCommit != null && message.hasOwnProperty("allowMergeCommit"))
                            object.allowMergeCommit = $root.google.protobuf.BoolValue.toObject(message.allowMergeCommit, options);
                        if (message.allowRebaseMerge != null && message.hasOwnProperty("allowRebaseMerge"))
                            object.allowRebaseMerge = $root.google.protobuf.BoolValue.toObject(message.allowRebaseMerge, options);
                        if (message.allowSquashMerge != null && message.hasOwnProperty("allowSquashMerge"))
                            object.allowSquashMerge = $root.google.protobuf.BoolValue.toObject(message.allowSquashMerge, options);
                        return object;
                    };

                    /**
                     * Converts this RepositoryParameters to JSON.
                     * @function toJSON
                     * @memberof clutch.sourcecontrol.github.v1.RepositoryParameters
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    RepositoryParameters.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    /**
                     * Visibility enum.
                     * @name clutch.sourcecontrol.github.v1.RepositoryParameters.Visibility
                     * @enum {number}
                     * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                     * @property {number} PUBLIC=1 PUBLIC value
                     * @property {number} PRIVATE=2 PRIVATE value
                     */
                    RepositoryParameters.Visibility = (function() {
                        const valuesById = {}, values = Object.create(valuesById);
                        values[valuesById[0] = "UNSPECIFIED"] = 0;
                        values[valuesById[1] = "PUBLIC"] = 1;
                        values[valuesById[2] = "PRIVATE"] = 2;
                        return values;
                    })();

                    return RepositoryParameters;
                })();

                v1.CreateRepositoryOptions = (function() {

                    /**
                     * Properties of a CreateRepositoryOptions.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @interface ICreateRepositoryOptions
                     * @property {clutch.sourcecontrol.github.v1.IRepositoryParameters|null} [parameters] CreateRepositoryOptions parameters
                     * @property {boolean|null} [autoInit] CreateRepositoryOptions autoInit
                     */

                    /**
                     * Constructs a new CreateRepositoryOptions.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @classdesc Represents a CreateRepositoryOptions.
                     * @implements ICreateRepositoryOptions
                     * @constructor
                     * @param {clutch.sourcecontrol.github.v1.ICreateRepositoryOptions=} [properties] Properties to set
                     */
                    function CreateRepositoryOptions(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CreateRepositoryOptions parameters.
                     * @member {clutch.sourcecontrol.github.v1.IRepositoryParameters|null|undefined} parameters
                     * @memberof clutch.sourcecontrol.github.v1.CreateRepositoryOptions
                     * @instance
                     */
                    CreateRepositoryOptions.prototype.parameters = null;

                    /**
                     * CreateRepositoryOptions autoInit.
                     * @member {boolean} autoInit
                     * @memberof clutch.sourcecontrol.github.v1.CreateRepositoryOptions
                     * @instance
                     */
                    CreateRepositoryOptions.prototype.autoInit = false;

                    /**
                     * Verifies a CreateRepositoryOptions message.
                     * @function verify
                     * @memberof clutch.sourcecontrol.github.v1.CreateRepositoryOptions
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CreateRepositoryOptions.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.parameters != null && message.hasOwnProperty("parameters")) {
                            let error = $root.clutch.sourcecontrol.github.v1.RepositoryParameters.verify(message.parameters);
                            if (error)
                                return "parameters." + error;
                        }
                        if (message.autoInit != null && message.hasOwnProperty("autoInit"))
                            if (typeof message.autoInit !== "boolean")
                                return "autoInit: boolean expected";
                        return null;
                    };

                    /**
                     * Creates a CreateRepositoryOptions message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.sourcecontrol.github.v1.CreateRepositoryOptions
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.sourcecontrol.github.v1.CreateRepositoryOptions} CreateRepositoryOptions
                     */
                    CreateRepositoryOptions.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.sourcecontrol.github.v1.CreateRepositoryOptions)
                            return object;
                        let message = new $root.clutch.sourcecontrol.github.v1.CreateRepositoryOptions();
                        if (object.parameters != null) {
                            if (typeof object.parameters !== "object")
                                throw TypeError(".clutch.sourcecontrol.github.v1.CreateRepositoryOptions.parameters: object expected");
                            message.parameters = $root.clutch.sourcecontrol.github.v1.RepositoryParameters.fromObject(object.parameters);
                        }
                        if (object.autoInit != null)
                            message.autoInit = Boolean(object.autoInit);
                        return message;
                    };

                    /**
                     * Creates a plain object from a CreateRepositoryOptions message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.sourcecontrol.github.v1.CreateRepositoryOptions
                     * @static
                     * @param {clutch.sourcecontrol.github.v1.CreateRepositoryOptions} message CreateRepositoryOptions
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CreateRepositoryOptions.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.parameters = null;
                            object.autoInit = false;
                        }
                        if (message.parameters != null && message.hasOwnProperty("parameters"))
                            object.parameters = $root.clutch.sourcecontrol.github.v1.RepositoryParameters.toObject(message.parameters, options);
                        if (message.autoInit != null && message.hasOwnProperty("autoInit"))
                            object.autoInit = message.autoInit;
                        return object;
                    };

                    /**
                     * Converts this CreateRepositoryOptions to JSON.
                     * @function toJSON
                     * @memberof clutch.sourcecontrol.github.v1.CreateRepositoryOptions
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CreateRepositoryOptions.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CreateRepositoryOptions;
                })();

                v1.UpdateRepositoryOptions = (function() {

                    /**
                     * Properties of an UpdateRepositoryOptions.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @interface IUpdateRepositoryOptions
                     * @property {clutch.sourcecontrol.github.v1.IRepositoryParameters|null} [parameters] UpdateRepositoryOptions parameters
                     * @property {boolean|null} [archived] UpdateRepositoryOptions archived
                     */

                    /**
                     * Constructs a new UpdateRepositoryOptions.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @classdesc Represents an UpdateRepositoryOptions.
                     * @implements IUpdateRepositoryOptions
                     * @constructor
                     * @param {clutch.sourcecontrol.github.v1.IUpdateRepositoryOptions=} [properties] Properties to set
                     */
                    function UpdateRepositoryOptions(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * UpdateRepositoryOptions parameters.
                     * @member {clutch.sourcecontrol.github.v1.IRepositoryParameters|null|undefined} parameters
                     * @memberof clutch.sourcecontrol.github.v1.UpdateRepositoryOptions
                     * @instance
                     */
                    UpdateRepositoryOptions.prototype.parameters = null;

                    /**
                     * UpdateRepositoryOptions archived.
                     * @member {boolean} archived
                     * @memberof clutch.sourcecontrol.github.v1.UpdateRepositoryOptions
                     * @instance
                     */
                    UpdateRepositoryOptions.prototype.archived = false;

                    /**
                     * Verifies an UpdateRepositoryOptions message.
                     * @function verify
                     * @memberof clutch.sourcecontrol.github.v1.UpdateRepositoryOptions
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    UpdateRepositoryOptions.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.parameters != null && message.hasOwnProperty("parameters")) {
                            let error = $root.clutch.sourcecontrol.github.v1.RepositoryParameters.verify(message.parameters);
                            if (error)
                                return "parameters." + error;
                        }
                        if (message.archived != null && message.hasOwnProperty("archived"))
                            if (typeof message.archived !== "boolean")
                                return "archived: boolean expected";
                        return null;
                    };

                    /**
                     * Creates an UpdateRepositoryOptions message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.sourcecontrol.github.v1.UpdateRepositoryOptions
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.sourcecontrol.github.v1.UpdateRepositoryOptions} UpdateRepositoryOptions
                     */
                    UpdateRepositoryOptions.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.sourcecontrol.github.v1.UpdateRepositoryOptions)
                            return object;
                        let message = new $root.clutch.sourcecontrol.github.v1.UpdateRepositoryOptions();
                        if (object.parameters != null) {
                            if (typeof object.parameters !== "object")
                                throw TypeError(".clutch.sourcecontrol.github.v1.UpdateRepositoryOptions.parameters: object expected");
                            message.parameters = $root.clutch.sourcecontrol.github.v1.RepositoryParameters.fromObject(object.parameters);
                        }
                        if (object.archived != null)
                            message.archived = Boolean(object.archived);
                        return message;
                    };

                    /**
                     * Creates a plain object from an UpdateRepositoryOptions message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.sourcecontrol.github.v1.UpdateRepositoryOptions
                     * @static
                     * @param {clutch.sourcecontrol.github.v1.UpdateRepositoryOptions} message UpdateRepositoryOptions
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    UpdateRepositoryOptions.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults) {
                            object.parameters = null;
                            object.archived = false;
                        }
                        if (message.parameters != null && message.hasOwnProperty("parameters"))
                            object.parameters = $root.clutch.sourcecontrol.github.v1.RepositoryParameters.toObject(message.parameters, options);
                        if (message.archived != null && message.hasOwnProperty("archived"))
                            object.archived = message.archived;
                        return object;
                    };

                    /**
                     * Converts this UpdateRepositoryOptions to JSON.
                     * @function toJSON
                     * @memberof clutch.sourcecontrol.github.v1.UpdateRepositoryOptions
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    UpdateRepositoryOptions.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return UpdateRepositoryOptions;
                })();

                /**
                 * CommitCompareStatus enum.
                 * @name clutch.sourcecontrol.github.v1.CommitCompareStatus
                 * @enum {number}
                 * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                 * @property {number} UNKNOWN=1 UNKNOWN value
                 * @property {number} BEHIND=2 BEHIND value
                 * @property {number} AHEAD=3 AHEAD value
                 * @property {number} IDENTICAL=4 IDENTICAL value
                 */
                v1.CommitCompareStatus = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNSPECIFIED"] = 0;
                    values[valuesById[1] = "UNKNOWN"] = 1;
                    values[valuesById[2] = "BEHIND"] = 2;
                    values[valuesById[3] = "AHEAD"] = 3;
                    values[valuesById[4] = "IDENTICAL"] = 4;
                    return values;
                })();

                v1.CommitComparison = (function() {

                    /**
                     * Properties of a CommitComparison.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @interface ICommitComparison
                     * @property {clutch.sourcecontrol.github.v1.CommitCompareStatus|null} [status] CommitComparison status
                     */

                    /**
                     * Constructs a new CommitComparison.
                     * @memberof clutch.sourcecontrol.github.v1
                     * @classdesc Represents a CommitComparison.
                     * @implements ICommitComparison
                     * @constructor
                     * @param {clutch.sourcecontrol.github.v1.ICommitComparison=} [properties] Properties to set
                     */
                    function CommitComparison(properties) {
                        if (properties)
                            for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                                if (properties[keys[i]] != null)
                                    this[keys[i]] = properties[keys[i]];
                    }

                    /**
                     * CommitComparison status.
                     * @member {clutch.sourcecontrol.github.v1.CommitCompareStatus} status
                     * @memberof clutch.sourcecontrol.github.v1.CommitComparison
                     * @instance
                     */
                    CommitComparison.prototype.status = 0;

                    /**
                     * Verifies a CommitComparison message.
                     * @function verify
                     * @memberof clutch.sourcecontrol.github.v1.CommitComparison
                     * @static
                     * @param {Object.<string,*>} message Plain object to verify
                     * @returns {string|null} `null` if valid, otherwise the reason why it is not
                     */
                    CommitComparison.verify = function verify(message) {
                        if (typeof message !== "object" || message === null)
                            return "object expected";
                        if (message.status != null && message.hasOwnProperty("status"))
                            switch (message.status) {
                            default:
                                return "status: enum value expected";
                            case 0:
                            case 1:
                            case 2:
                            case 3:
                            case 4:
                                break;
                            }
                        return null;
                    };

                    /**
                     * Creates a CommitComparison message from a plain object. Also converts values to their respective internal types.
                     * @function fromObject
                     * @memberof clutch.sourcecontrol.github.v1.CommitComparison
                     * @static
                     * @param {Object.<string,*>} object Plain object
                     * @returns {clutch.sourcecontrol.github.v1.CommitComparison} CommitComparison
                     */
                    CommitComparison.fromObject = function fromObject(object) {
                        if (object instanceof $root.clutch.sourcecontrol.github.v1.CommitComparison)
                            return object;
                        let message = new $root.clutch.sourcecontrol.github.v1.CommitComparison();
                        switch (object.status) {
                        case "UNSPECIFIED":
                        case 0:
                            message.status = 0;
                            break;
                        case "UNKNOWN":
                        case 1:
                            message.status = 1;
                            break;
                        case "BEHIND":
                        case 2:
                            message.status = 2;
                            break;
                        case "AHEAD":
                        case 3:
                            message.status = 3;
                            break;
                        case "IDENTICAL":
                        case 4:
                            message.status = 4;
                            break;
                        }
                        return message;
                    };

                    /**
                     * Creates a plain object from a CommitComparison message. Also converts values to other types if specified.
                     * @function toObject
                     * @memberof clutch.sourcecontrol.github.v1.CommitComparison
                     * @static
                     * @param {clutch.sourcecontrol.github.v1.CommitComparison} message CommitComparison
                     * @param {$protobuf.IConversionOptions} [options] Conversion options
                     * @returns {Object.<string,*>} Plain object
                     */
                    CommitComparison.toObject = function toObject(message, options) {
                        if (!options)
                            options = {};
                        let object = {};
                        if (options.defaults)
                            object.status = options.enums === String ? "UNSPECIFIED" : 0;
                        if (message.status != null && message.hasOwnProperty("status"))
                            object.status = options.enums === String ? $root.clutch.sourcecontrol.github.v1.CommitCompareStatus[message.status] : message.status;
                        return object;
                    };

                    /**
                     * Converts this CommitComparison to JSON.
                     * @function toJSON
                     * @memberof clutch.sourcecontrol.github.v1.CommitComparison
                     * @instance
                     * @returns {Object.<string,*>} JSON object
                     */
                    CommitComparison.prototype.toJSON = function toJSON() {
                        return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                    };

                    return CommitComparison;
                })();

                return v1;
            })();

            return github;
        })();

        sourcecontrol.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.sourcecontrol
             * @namespace
             */
            const v1 = {};

            v1.SourceControlAPI = (function() {

                /**
                 * Constructs a new SourceControlAPI service.
                 * @memberof clutch.sourcecontrol.v1
                 * @classdesc Represents a SourceControlAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function SourceControlAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (SourceControlAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = SourceControlAPI;

                /**
                 * Callback as used by {@link clutch.sourcecontrol.v1.SourceControlAPI#createRepository}.
                 * @memberof clutch.sourcecontrol.v1.SourceControlAPI
                 * @typedef CreateRepositoryCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.sourcecontrol.v1.CreateRepositoryResponse} [response] CreateRepositoryResponse
                 */

                /**
                 * Calls CreateRepository.
                 * @function createRepository
                 * @memberof clutch.sourcecontrol.v1.SourceControlAPI
                 * @instance
                 * @param {clutch.sourcecontrol.v1.ICreateRepositoryRequest} request CreateRepositoryRequest message or plain object
                 * @param {clutch.sourcecontrol.v1.SourceControlAPI.CreateRepositoryCallback} callback Node-style callback called with the error, if any, and CreateRepositoryResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(SourceControlAPI.prototype.createRepository = function createRepository(request, callback) {
                    return this.rpcCall(createRepository, $root.clutch.sourcecontrol.v1.CreateRepositoryRequest, $root.clutch.sourcecontrol.v1.CreateRepositoryResponse, request, callback);
                }, "name", { value: "CreateRepository" });

                /**
                 * Calls CreateRepository.
                 * @function createRepository
                 * @memberof clutch.sourcecontrol.v1.SourceControlAPI
                 * @instance
                 * @param {clutch.sourcecontrol.v1.ICreateRepositoryRequest} request CreateRepositoryRequest message or plain object
                 * @returns {Promise<clutch.sourcecontrol.v1.CreateRepositoryResponse>} Promise
                 * @variation 2
                 */

                return SourceControlAPI;
            })();

            v1.CreateRepositoryRequest = (function() {

                /**
                 * Properties of a CreateRepositoryRequest.
                 * @memberof clutch.sourcecontrol.v1
                 * @interface ICreateRepositoryRequest
                 * @property {string|null} [owner] CreateRepositoryRequest owner
                 * @property {string|null} [name] CreateRepositoryRequest name
                 * @property {string|null} [description] CreateRepositoryRequest description
                 * @property {google.protobuf.IAny|null} [customOptions] CreateRepositoryRequest customOptions
                 * @property {clutch.sourcecontrol.github.v1.ICreateRepositoryOptions|null} [githubOptions] CreateRepositoryRequest githubOptions
                 */

                /**
                 * Constructs a new CreateRepositoryRequest.
                 * @memberof clutch.sourcecontrol.v1
                 * @classdesc Represents a CreateRepositoryRequest.
                 * @implements ICreateRepositoryRequest
                 * @constructor
                 * @param {clutch.sourcecontrol.v1.ICreateRepositoryRequest=} [properties] Properties to set
                 */
                function CreateRepositoryRequest(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateRepositoryRequest owner.
                 * @member {string} owner
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @instance
                 */
                CreateRepositoryRequest.prototype.owner = "";

                /**
                 * CreateRepositoryRequest name.
                 * @member {string} name
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @instance
                 */
                CreateRepositoryRequest.prototype.name = "";

                /**
                 * CreateRepositoryRequest description.
                 * @member {string} description
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @instance
                 */
                CreateRepositoryRequest.prototype.description = "";

                /**
                 * CreateRepositoryRequest customOptions.
                 * @member {google.protobuf.IAny|null|undefined} customOptions
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @instance
                 */
                CreateRepositoryRequest.prototype.customOptions = null;

                /**
                 * CreateRepositoryRequest githubOptions.
                 * @member {clutch.sourcecontrol.github.v1.ICreateRepositoryOptions|null|undefined} githubOptions
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @instance
                 */
                CreateRepositoryRequest.prototype.githubOptions = null;

                // OneOf field names bound to virtual getters and setters
                let $oneOfFields;

                /**
                 * CreateRepositoryRequest options.
                 * @member {"customOptions"|"githubOptions"|undefined} options
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @instance
                 */
                Object.defineProperty(CreateRepositoryRequest.prototype, "options", {
                    get: $util.oneOfGetter($oneOfFields = ["customOptions", "githubOptions"]),
                    set: $util.oneOfSetter($oneOfFields)
                });

                /**
                 * Verifies a CreateRepositoryRequest message.
                 * @function verify
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateRepositoryRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    let properties = {};
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        if (!$util.isString(message.owner))
                            return "owner: string expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.description != null && message.hasOwnProperty("description"))
                        if (!$util.isString(message.description))
                            return "description: string expected";
                    if (message.customOptions != null && message.hasOwnProperty("customOptions")) {
                        properties.options = 1;
                        {
                            let error = $root.google.protobuf.Any.verify(message.customOptions);
                            if (error)
                                return "customOptions." + error;
                        }
                    }
                    if (message.githubOptions != null && message.hasOwnProperty("githubOptions")) {
                        if (properties.options === 1)
                            return "options: multiple values";
                        properties.options = 1;
                        {
                            let error = $root.clutch.sourcecontrol.github.v1.CreateRepositoryOptions.verify(message.githubOptions);
                            if (error)
                                return "githubOptions." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a CreateRepositoryRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.sourcecontrol.v1.CreateRepositoryRequest} CreateRepositoryRequest
                 */
                CreateRepositoryRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.sourcecontrol.v1.CreateRepositoryRequest)
                        return object;
                    let message = new $root.clutch.sourcecontrol.v1.CreateRepositoryRequest();
                    if (object.owner != null)
                        message.owner = String(object.owner);
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.description != null)
                        message.description = String(object.description);
                    if (object.customOptions != null) {
                        if (typeof object.customOptions !== "object")
                            throw TypeError(".clutch.sourcecontrol.v1.CreateRepositoryRequest.customOptions: object expected");
                        message.customOptions = $root.google.protobuf.Any.fromObject(object.customOptions);
                    }
                    if (object.githubOptions != null) {
                        if (typeof object.githubOptions !== "object")
                            throw TypeError(".clutch.sourcecontrol.v1.CreateRepositoryRequest.githubOptions: object expected");
                        message.githubOptions = $root.clutch.sourcecontrol.github.v1.CreateRepositoryOptions.fromObject(object.githubOptions);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a CreateRepositoryRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @static
                 * @param {clutch.sourcecontrol.v1.CreateRepositoryRequest} message CreateRepositoryRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateRepositoryRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.owner = "";
                        object.name = "";
                        object.description = "";
                    }
                    if (message.owner != null && message.hasOwnProperty("owner"))
                        object.owner = message.owner;
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.description != null && message.hasOwnProperty("description"))
                        object.description = message.description;
                    if (message.customOptions != null && message.hasOwnProperty("customOptions")) {
                        object.customOptions = $root.google.protobuf.Any.toObject(message.customOptions, options);
                        if (options.oneofs)
                            object.options = "customOptions";
                    }
                    if (message.githubOptions != null && message.hasOwnProperty("githubOptions")) {
                        object.githubOptions = $root.clutch.sourcecontrol.github.v1.CreateRepositoryOptions.toObject(message.githubOptions, options);
                        if (options.oneofs)
                            object.options = "githubOptions";
                    }
                    return object;
                };

                /**
                 * Converts this CreateRepositoryRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateRepositoryRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateRepositoryRequest;
            })();

            v1.CreateRepositoryResponse = (function() {

                /**
                 * Properties of a CreateRepositoryResponse.
                 * @memberof clutch.sourcecontrol.v1
                 * @interface ICreateRepositoryResponse
                 * @property {string|null} [url] CreateRepositoryResponse url
                 */

                /**
                 * Constructs a new CreateRepositoryResponse.
                 * @memberof clutch.sourcecontrol.v1
                 * @classdesc Represents a CreateRepositoryResponse.
                 * @implements ICreateRepositoryResponse
                 * @constructor
                 * @param {clutch.sourcecontrol.v1.ICreateRepositoryResponse=} [properties] Properties to set
                 */
                function CreateRepositoryResponse(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * CreateRepositoryResponse url.
                 * @member {string} url
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryResponse
                 * @instance
                 */
                CreateRepositoryResponse.prototype.url = "";

                /**
                 * Verifies a CreateRepositoryResponse message.
                 * @function verify
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                CreateRepositoryResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.url != null && message.hasOwnProperty("url"))
                        if (!$util.isString(message.url))
                            return "url: string expected";
                    return null;
                };

                /**
                 * Creates a CreateRepositoryResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.sourcecontrol.v1.CreateRepositoryResponse} CreateRepositoryResponse
                 */
                CreateRepositoryResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.sourcecontrol.v1.CreateRepositoryResponse)
                        return object;
                    let message = new $root.clutch.sourcecontrol.v1.CreateRepositoryResponse();
                    if (object.url != null)
                        message.url = String(object.url);
                    return message;
                };

                /**
                 * Creates a plain object from a CreateRepositoryResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryResponse
                 * @static
                 * @param {clutch.sourcecontrol.v1.CreateRepositoryResponse} message CreateRepositoryResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                CreateRepositoryResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults)
                        object.url = "";
                    if (message.url != null && message.hasOwnProperty("url"))
                        object.url = message.url;
                    return object;
                };

                /**
                 * Converts this CreateRepositoryResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.sourcecontrol.v1.CreateRepositoryResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                CreateRepositoryResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return CreateRepositoryResponse;
            })();

            return v1;
        })();

        return sourcecontrol;
    })();

    clutch.topology = (function() {

        /**
         * Namespace topology.
         * @memberof clutch
         * @namespace
         */
        const topology = {};

        topology.v1 = (function() {

            /**
             * Namespace v1.
             * @memberof clutch.topology
             * @namespace
             */
            const v1 = {};

            v1.TopologyAPI = (function() {

                /**
                 * Constructs a new TopologyAPI service.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a TopologyAPI
                 * @extends $protobuf.rpc.Service
                 * @constructor
                 * @param {$protobuf.RPCImpl} rpcImpl RPC implementation
                 * @param {boolean} [requestDelimited=false] Whether requests are length-delimited
                 * @param {boolean} [responseDelimited=false] Whether responses are length-delimited
                 */
                function TopologyAPI(rpcImpl, requestDelimited, responseDelimited) {
                    $protobuf.rpc.Service.call(this, rpcImpl, requestDelimited, responseDelimited);
                }

                (TopologyAPI.prototype = Object.create($protobuf.rpc.Service.prototype)).constructor = TopologyAPI;

                /**
                 * Callback as used by {@link clutch.topology.v1.TopologyAPI#getTopology}.
                 * @memberof clutch.topology.v1.TopologyAPI
                 * @typedef GetTopologyCallback
                 * @type {function}
                 * @param {Error|null} error Error, if any
                 * @param {clutch.topology.v1.GetTopologyResponse} [response] GetTopologyResponse
                 */

                /**
                 * Calls GetTopology.
                 * @function getTopology
                 * @memberof clutch.topology.v1.TopologyAPI
                 * @instance
                 * @param {clutch.topology.v1.IGetTopologyRequest} request GetTopologyRequest message or plain object
                 * @param {clutch.topology.v1.TopologyAPI.GetTopologyCallback} callback Node-style callback called with the error, if any, and GetTopologyResponse
                 * @returns {undefined}
                 * @variation 1
                 */
                Object.defineProperty(TopologyAPI.prototype.getTopology = function getTopology(request, callback) {
                    return this.rpcCall(getTopology, $root.clutch.topology.v1.GetTopologyRequest, $root.clutch.topology.v1.GetTopologyResponse, request, callback);
                }, "name", { value: "GetTopology" });

                /**
                 * Calls GetTopology.
                 * @function getTopology
                 * @memberof clutch.topology.v1.TopologyAPI
                 * @instance
                 * @param {clutch.topology.v1.IGetTopologyRequest} request GetTopologyRequest message or plain object
                 * @returns {Promise<clutch.topology.v1.GetTopologyResponse>} Promise
                 * @variation 2
                 */

                return TopologyAPI;
            })();

            v1.GetTopologyRequest = (function() {

                /**
                 * Properties of a GetTopologyRequest.
                 * @memberof clutch.topology.v1
                 * @interface IGetTopologyRequest
                 * @property {Array.<clutch.topology.v1.IQuery>|null} [queries] GetTopologyRequest queries
                 */

                /**
                 * Constructs a new GetTopologyRequest.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a GetTopologyRequest.
                 * @implements IGetTopologyRequest
                 * @constructor
                 * @param {clutch.topology.v1.IGetTopologyRequest=} [properties] Properties to set
                 */
                function GetTopologyRequest(properties) {
                    this.queries = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetTopologyRequest queries.
                 * @member {Array.<clutch.topology.v1.IQuery>} queries
                 * @memberof clutch.topology.v1.GetTopologyRequest
                 * @instance
                 */
                GetTopologyRequest.prototype.queries = $util.emptyArray;

                /**
                 * Verifies a GetTopologyRequest message.
                 * @function verify
                 * @memberof clutch.topology.v1.GetTopologyRequest
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetTopologyRequest.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.queries != null && message.hasOwnProperty("queries")) {
                        if (!Array.isArray(message.queries))
                            return "queries: array expected";
                        for (let i = 0; i < message.queries.length; ++i) {
                            let error = $root.clutch.topology.v1.Query.verify(message.queries[i]);
                            if (error)
                                return "queries." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetTopologyRequest message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.GetTopologyRequest
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.GetTopologyRequest} GetTopologyRequest
                 */
                GetTopologyRequest.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.GetTopologyRequest)
                        return object;
                    let message = new $root.clutch.topology.v1.GetTopologyRequest();
                    if (object.queries) {
                        if (!Array.isArray(object.queries))
                            throw TypeError(".clutch.topology.v1.GetTopologyRequest.queries: array expected");
                        message.queries = [];
                        for (let i = 0; i < object.queries.length; ++i) {
                            if (typeof object.queries[i] !== "object")
                                throw TypeError(".clutch.topology.v1.GetTopologyRequest.queries: object expected");
                            message.queries[i] = $root.clutch.topology.v1.Query.fromObject(object.queries[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetTopologyRequest message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.GetTopologyRequest
                 * @static
                 * @param {clutch.topology.v1.GetTopologyRequest} message GetTopologyRequest
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetTopologyRequest.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.queries = [];
                    if (message.queries && message.queries.length) {
                        object.queries = [];
                        for (let j = 0; j < message.queries.length; ++j)
                            object.queries[j] = $root.clutch.topology.v1.Query.toObject(message.queries[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetTopologyRequest to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.GetTopologyRequest
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetTopologyRequest.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetTopologyRequest;
            })();

            v1.GetTopologyResponse = (function() {

                /**
                 * Properties of a GetTopologyResponse.
                 * @memberof clutch.topology.v1
                 * @interface IGetTopologyResponse
                 * @property {Array.<clutch.topology.v1.IQueryResult>|null} [results] GetTopologyResponse results
                 */

                /**
                 * Constructs a new GetTopologyResponse.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a GetTopologyResponse.
                 * @implements IGetTopologyResponse
                 * @constructor
                 * @param {clutch.topology.v1.IGetTopologyResponse=} [properties] Properties to set
                 */
                function GetTopologyResponse(properties) {
                    this.results = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * GetTopologyResponse results.
                 * @member {Array.<clutch.topology.v1.IQueryResult>} results
                 * @memberof clutch.topology.v1.GetTopologyResponse
                 * @instance
                 */
                GetTopologyResponse.prototype.results = $util.emptyArray;

                /**
                 * Verifies a GetTopologyResponse message.
                 * @function verify
                 * @memberof clutch.topology.v1.GetTopologyResponse
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                GetTopologyResponse.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.results != null && message.hasOwnProperty("results")) {
                        if (!Array.isArray(message.results))
                            return "results: array expected";
                        for (let i = 0; i < message.results.length; ++i) {
                            let error = $root.clutch.topology.v1.QueryResult.verify(message.results[i]);
                            if (error)
                                return "results." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a GetTopologyResponse message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.GetTopologyResponse
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.GetTopologyResponse} GetTopologyResponse
                 */
                GetTopologyResponse.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.GetTopologyResponse)
                        return object;
                    let message = new $root.clutch.topology.v1.GetTopologyResponse();
                    if (object.results) {
                        if (!Array.isArray(object.results))
                            throw TypeError(".clutch.topology.v1.GetTopologyResponse.results: array expected");
                        message.results = [];
                        for (let i = 0; i < object.results.length; ++i) {
                            if (typeof object.results[i] !== "object")
                                throw TypeError(".clutch.topology.v1.GetTopologyResponse.results: object expected");
                            message.results[i] = $root.clutch.topology.v1.QueryResult.fromObject(object.results[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a GetTopologyResponse message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.GetTopologyResponse
                 * @static
                 * @param {clutch.topology.v1.GetTopologyResponse} message GetTopologyResponse
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                GetTopologyResponse.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.results = [];
                    if (message.results && message.results.length) {
                        object.results = [];
                        for (let j = 0; j < message.results.length; ++j)
                            object.results[j] = $root.clutch.topology.v1.QueryResult.toObject(message.results[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this GetTopologyResponse to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.GetTopologyResponse
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                GetTopologyResponse.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return GetTopologyResponse;
            })();

            v1.FeatureQuery = (function() {

                /**
                 * Properties of a FeatureQuery.
                 * @memberof clutch.topology.v1
                 * @interface IFeatureQuery
                 * @property {string|null} [name] FeatureQuery name
                 * @property {Array.<string>|null} [values] FeatureQuery values
                 */

                /**
                 * Constructs a new FeatureQuery.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a FeatureQuery.
                 * @implements IFeatureQuery
                 * @constructor
                 * @param {clutch.topology.v1.IFeatureQuery=} [properties] Properties to set
                 */
                function FeatureQuery(properties) {
                    this.values = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * FeatureQuery name.
                 * @member {string} name
                 * @memberof clutch.topology.v1.FeatureQuery
                 * @instance
                 */
                FeatureQuery.prototype.name = "";

                /**
                 * FeatureQuery values.
                 * @member {Array.<string>} values
                 * @memberof clutch.topology.v1.FeatureQuery
                 * @instance
                 */
                FeatureQuery.prototype.values = $util.emptyArray;

                /**
                 * Verifies a FeatureQuery message.
                 * @function verify
                 * @memberof clutch.topology.v1.FeatureQuery
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                FeatureQuery.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.values != null && message.hasOwnProperty("values")) {
                        if (!Array.isArray(message.values))
                            return "values: array expected";
                        for (let i = 0; i < message.values.length; ++i)
                            if (!$util.isString(message.values[i]))
                                return "values: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a FeatureQuery message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.FeatureQuery
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.FeatureQuery} FeatureQuery
                 */
                FeatureQuery.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.FeatureQuery)
                        return object;
                    let message = new $root.clutch.topology.v1.FeatureQuery();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.values) {
                        if (!Array.isArray(object.values))
                            throw TypeError(".clutch.topology.v1.FeatureQuery.values: array expected");
                        message.values = [];
                        for (let i = 0; i < object.values.length; ++i)
                            message.values[i] = String(object.values[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a FeatureQuery message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.FeatureQuery
                 * @static
                 * @param {clutch.topology.v1.FeatureQuery} message FeatureQuery
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                FeatureQuery.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.values = [];
                    if (options.defaults)
                        object.name = "";
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.values && message.values.length) {
                        object.values = [];
                        for (let j = 0; j < message.values.length; ++j)
                            object.values[j] = message.values[j];
                    }
                    return object;
                };

                /**
                 * Converts this FeatureQuery to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.FeatureQuery
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                FeatureQuery.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return FeatureQuery;
            })();

            v1.Constraint = (function() {

                /**
                 * Properties of a Constraint.
                 * @memberof clutch.topology.v1
                 * @interface IConstraint
                 * @property {clutch.topology.v1.Constraint.Operator|null} [operator] Constraint operator
                 * @property {google.protobuf.IValue|null} [value] Constraint value
                 */

                /**
                 * Constructs a new Constraint.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a Constraint.
                 * @implements IConstraint
                 * @constructor
                 * @param {clutch.topology.v1.IConstraint=} [properties] Properties to set
                 */
                function Constraint(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Constraint operator.
                 * @member {clutch.topology.v1.Constraint.Operator} operator
                 * @memberof clutch.topology.v1.Constraint
                 * @instance
                 */
                Constraint.prototype.operator = 0;

                /**
                 * Constraint value.
                 * @member {google.protobuf.IValue|null|undefined} value
                 * @memberof clutch.topology.v1.Constraint
                 * @instance
                 */
                Constraint.prototype.value = null;

                /**
                 * Verifies a Constraint message.
                 * @function verify
                 * @memberof clutch.topology.v1.Constraint
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Constraint.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.operator != null && message.hasOwnProperty("operator"))
                        switch (message.operator) {
                        default:
                            return "operator: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                        case 8:
                        case 9:
                            break;
                        }
                    if (message.value != null && message.hasOwnProperty("value")) {
                        let error = $root.google.protobuf.Value.verify(message.value);
                        if (error)
                            return "value." + error;
                    }
                    return null;
                };

                /**
                 * Creates a Constraint message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.Constraint
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.Constraint} Constraint
                 */
                Constraint.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.Constraint)
                        return object;
                    let message = new $root.clutch.topology.v1.Constraint();
                    switch (object.operator) {
                    case "UNSPECIFIED":
                    case 0:
                        message.operator = 0;
                        break;
                    case "EQUAL":
                    case 1:
                        message.operator = 1;
                        break;
                    case "NOT_EQUAL":
                    case 2:
                        message.operator = 2;
                        break;
                    case "GREATER_THAN":
                    case 3:
                        message.operator = 3;
                        break;
                    case "GREATER_THAN_OR_EQUAL":
                    case 4:
                        message.operator = 4;
                        break;
                    case "LESS_THAN":
                    case 5:
                        message.operator = 5;
                        break;
                    case "LESS_THAN_OR_EQUAL":
                    case 6:
                        message.operator = 6;
                        break;
                    case "CONTAINS_STRING":
                    case 7:
                        message.operator = 7;
                        break;
                    case "CONTAINS_VALUE":
                    case 8:
                        message.operator = 8;
                        break;
                    case "CONTAINS_KEY":
                    case 9:
                        message.operator = 9;
                        break;
                    }
                    if (object.value != null) {
                        if (typeof object.value !== "object")
                            throw TypeError(".clutch.topology.v1.Constraint.value: object expected");
                        message.value = $root.google.protobuf.Value.fromObject(object.value);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Constraint message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.Constraint
                 * @static
                 * @param {clutch.topology.v1.Constraint} message Constraint
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Constraint.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.operator = options.enums === String ? "UNSPECIFIED" : 0;
                        object.value = null;
                    }
                    if (message.operator != null && message.hasOwnProperty("operator"))
                        object.operator = options.enums === String ? $root.clutch.topology.v1.Constraint.Operator[message.operator] : message.operator;
                    if (message.value != null && message.hasOwnProperty("value"))
                        object.value = $root.google.protobuf.Value.toObject(message.value, options);
                    return object;
                };

                /**
                 * Converts this Constraint to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.Constraint
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Constraint.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Operator enum.
                 * @name clutch.topology.v1.Constraint.Operator
                 * @enum {number}
                 * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                 * @property {number} EQUAL=1 EQUAL value
                 * @property {number} NOT_EQUAL=2 NOT_EQUAL value
                 * @property {number} GREATER_THAN=3 GREATER_THAN value
                 * @property {number} GREATER_THAN_OR_EQUAL=4 GREATER_THAN_OR_EQUAL value
                 * @property {number} LESS_THAN=5 LESS_THAN value
                 * @property {number} LESS_THAN_OR_EQUAL=6 LESS_THAN_OR_EQUAL value
                 * @property {number} CONTAINS_STRING=7 CONTAINS_STRING value
                 * @property {number} CONTAINS_VALUE=8 CONTAINS_VALUE value
                 * @property {number} CONTAINS_KEY=9 CONTAINS_KEY value
                 */
                Constraint.Operator = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNSPECIFIED"] = 0;
                    values[valuesById[1] = "EQUAL"] = 1;
                    values[valuesById[2] = "NOT_EQUAL"] = 2;
                    values[valuesById[3] = "GREATER_THAN"] = 3;
                    values[valuesById[4] = "GREATER_THAN_OR_EQUAL"] = 4;
                    values[valuesById[5] = "LESS_THAN"] = 5;
                    values[valuesById[6] = "LESS_THAN_OR_EQUAL"] = 6;
                    values[valuesById[7] = "CONTAINS_STRING"] = 7;
                    values[valuesById[8] = "CONTAINS_VALUE"] = 8;
                    values[valuesById[9] = "CONTAINS_KEY"] = 9;
                    return values;
                })();

                return Constraint;
            })();

            v1.MetadataQuery = (function() {

                /**
                 * Properties of a MetadataQuery.
                 * @memberof clutch.topology.v1
                 * @interface IMetadataQuery
                 * @property {string|null} [name] MetadataQuery name
                 * @property {google.protobuf.IStruct|null} [params] MetadataQuery params
                 * @property {clutch.topology.v1.MetadataQuery.Aggregation|null} [aggregation] MetadataQuery aggregation
                 * @property {Array.<clutch.topology.v1.IConstraint>|null} [constraints] MetadataQuery constraints
                 */

                /**
                 * Constructs a new MetadataQuery.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a MetadataQuery.
                 * @implements IMetadataQuery
                 * @constructor
                 * @param {clutch.topology.v1.IMetadataQuery=} [properties] Properties to set
                 */
                function MetadataQuery(properties) {
                    this.constraints = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * MetadataQuery name.
                 * @member {string} name
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @instance
                 */
                MetadataQuery.prototype.name = "";

                /**
                 * MetadataQuery params.
                 * @member {google.protobuf.IStruct|null|undefined} params
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @instance
                 */
                MetadataQuery.prototype.params = null;

                /**
                 * MetadataQuery aggregation.
                 * @member {clutch.topology.v1.MetadataQuery.Aggregation} aggregation
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @instance
                 */
                MetadataQuery.prototype.aggregation = 0;

                /**
                 * MetadataQuery constraints.
                 * @member {Array.<clutch.topology.v1.IConstraint>} constraints
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @instance
                 */
                MetadataQuery.prototype.constraints = $util.emptyArray;

                /**
                 * Verifies a MetadataQuery message.
                 * @function verify
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                MetadataQuery.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.name != null && message.hasOwnProperty("name"))
                        if (!$util.isString(message.name))
                            return "name: string expected";
                    if (message.params != null && message.hasOwnProperty("params")) {
                        let error = $root.google.protobuf.Struct.verify(message.params);
                        if (error)
                            return "params." + error;
                    }
                    if (message.aggregation != null && message.hasOwnProperty("aggregation"))
                        switch (message.aggregation) {
                        default:
                            return "aggregation: enum value expected";
                        case 0:
                        case 1:
                        case 2:
                        case 3:
                        case 4:
                        case 5:
                        case 6:
                        case 7:
                            break;
                        }
                    if (message.constraints != null && message.hasOwnProperty("constraints")) {
                        if (!Array.isArray(message.constraints))
                            return "constraints: array expected";
                        for (let i = 0; i < message.constraints.length; ++i) {
                            let error = $root.clutch.topology.v1.Constraint.verify(message.constraints[i]);
                            if (error)
                                return "constraints." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a MetadataQuery message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.MetadataQuery} MetadataQuery
                 */
                MetadataQuery.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.MetadataQuery)
                        return object;
                    let message = new $root.clutch.topology.v1.MetadataQuery();
                    if (object.name != null)
                        message.name = String(object.name);
                    if (object.params != null) {
                        if (typeof object.params !== "object")
                            throw TypeError(".clutch.topology.v1.MetadataQuery.params: object expected");
                        message.params = $root.google.protobuf.Struct.fromObject(object.params);
                    }
                    switch (object.aggregation) {
                    case "UNSPECIFIED":
                    case 0:
                        message.aggregation = 0;
                        break;
                    case "SUM":
                    case 1:
                        message.aggregation = 1;
                        break;
                    case "AVERAGE":
                    case 2:
                        message.aggregation = 2;
                        break;
                    case "MEDIAN":
                    case 3:
                        message.aggregation = 3;
                        break;
                    case "MODE":
                    case 4:
                        message.aggregation = 4;
                        break;
                    case "MIN":
                    case 5:
                        message.aggregation = 5;
                        break;
                    case "MAX":
                    case 6:
                        message.aggregation = 6;
                        break;
                    case "COUNT":
                    case 7:
                        message.aggregation = 7;
                        break;
                    }
                    if (object.constraints) {
                        if (!Array.isArray(object.constraints))
                            throw TypeError(".clutch.topology.v1.MetadataQuery.constraints: array expected");
                        message.constraints = [];
                        for (let i = 0; i < object.constraints.length; ++i) {
                            if (typeof object.constraints[i] !== "object")
                                throw TypeError(".clutch.topology.v1.MetadataQuery.constraints: object expected");
                            message.constraints[i] = $root.clutch.topology.v1.Constraint.fromObject(object.constraints[i]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a MetadataQuery message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @static
                 * @param {clutch.topology.v1.MetadataQuery} message MetadataQuery
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                MetadataQuery.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.constraints = [];
                    if (options.defaults) {
                        object.name = "";
                        object.params = null;
                        object.aggregation = options.enums === String ? "UNSPECIFIED" : 0;
                    }
                    if (message.name != null && message.hasOwnProperty("name"))
                        object.name = message.name;
                    if (message.params != null && message.hasOwnProperty("params"))
                        object.params = $root.google.protobuf.Struct.toObject(message.params, options);
                    if (message.aggregation != null && message.hasOwnProperty("aggregation"))
                        object.aggregation = options.enums === String ? $root.clutch.topology.v1.MetadataQuery.Aggregation[message.aggregation] : message.aggregation;
                    if (message.constraints && message.constraints.length) {
                        object.constraints = [];
                        for (let j = 0; j < message.constraints.length; ++j)
                            object.constraints[j] = $root.clutch.topology.v1.Constraint.toObject(message.constraints[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this MetadataQuery to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.MetadataQuery
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                MetadataQuery.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                /**
                 * Aggregation enum.
                 * @name clutch.topology.v1.MetadataQuery.Aggregation
                 * @enum {number}
                 * @property {number} UNSPECIFIED=0 UNSPECIFIED value
                 * @property {number} SUM=1 SUM value
                 * @property {number} AVERAGE=2 AVERAGE value
                 * @property {number} MEDIAN=3 MEDIAN value
                 * @property {number} MODE=4 MODE value
                 * @property {number} MIN=5 MIN value
                 * @property {number} MAX=6 MAX value
                 * @property {number} COUNT=7 COUNT value
                 */
                MetadataQuery.Aggregation = (function() {
                    const valuesById = {}, values = Object.create(valuesById);
                    values[valuesById[0] = "UNSPECIFIED"] = 0;
                    values[valuesById[1] = "SUM"] = 1;
                    values[valuesById[2] = "AVERAGE"] = 2;
                    values[valuesById[3] = "MEDIAN"] = 3;
                    values[valuesById[4] = "MODE"] = 4;
                    values[valuesById[5] = "MIN"] = 5;
                    values[valuesById[6] = "MAX"] = 6;
                    values[valuesById[7] = "COUNT"] = 7;
                    return values;
                })();

                return MetadataQuery;
            })();

            v1.Query = (function() {

                /**
                 * Properties of a Query.
                 * @memberof clutch.topology.v1
                 * @interface IQuery
                 * @property {Array.<clutch.topology.v1.IFeatureQuery>|null} [features] Query features
                 * @property {Array.<clutch.topology.v1.IMetadataQuery>|null} [nodeMetadata] Query nodeMetadata
                 * @property {Array.<clutch.topology.v1.IMetadataQuery>|null} [edgeMetadata] Query edgeMetadata
                 * @property {number|null} [sourceDepth] Query sourceDepth
                 * @property {number|null} [targetDepth] Query targetDepth
                 */

                /**
                 * Constructs a new Query.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a Query.
                 * @implements IQuery
                 * @constructor
                 * @param {clutch.topology.v1.IQuery=} [properties] Properties to set
                 */
                function Query(properties) {
                    this.features = [];
                    this.nodeMetadata = [];
                    this.edgeMetadata = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Query features.
                 * @member {Array.<clutch.topology.v1.IFeatureQuery>} features
                 * @memberof clutch.topology.v1.Query
                 * @instance
                 */
                Query.prototype.features = $util.emptyArray;

                /**
                 * Query nodeMetadata.
                 * @member {Array.<clutch.topology.v1.IMetadataQuery>} nodeMetadata
                 * @memberof clutch.topology.v1.Query
                 * @instance
                 */
                Query.prototype.nodeMetadata = $util.emptyArray;

                /**
                 * Query edgeMetadata.
                 * @member {Array.<clutch.topology.v1.IMetadataQuery>} edgeMetadata
                 * @memberof clutch.topology.v1.Query
                 * @instance
                 */
                Query.prototype.edgeMetadata = $util.emptyArray;

                /**
                 * Query sourceDepth.
                 * @member {number} sourceDepth
                 * @memberof clutch.topology.v1.Query
                 * @instance
                 */
                Query.prototype.sourceDepth = 0;

                /**
                 * Query targetDepth.
                 * @member {number} targetDepth
                 * @memberof clutch.topology.v1.Query
                 * @instance
                 */
                Query.prototype.targetDepth = 0;

                /**
                 * Verifies a Query message.
                 * @function verify
                 * @memberof clutch.topology.v1.Query
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Query.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.features != null && message.hasOwnProperty("features")) {
                        if (!Array.isArray(message.features))
                            return "features: array expected";
                        for (let i = 0; i < message.features.length; ++i) {
                            let error = $root.clutch.topology.v1.FeatureQuery.verify(message.features[i]);
                            if (error)
                                return "features." + error;
                        }
                    }
                    if (message.nodeMetadata != null && message.hasOwnProperty("nodeMetadata")) {
                        if (!Array.isArray(message.nodeMetadata))
                            return "nodeMetadata: array expected";
                        for (let i = 0; i < message.nodeMetadata.length; ++i) {
                            let error = $root.clutch.topology.v1.MetadataQuery.verify(message.nodeMetadata[i]);
                            if (error)
                                return "nodeMetadata." + error;
                        }
                    }
                    if (message.edgeMetadata != null && message.hasOwnProperty("edgeMetadata")) {
                        if (!Array.isArray(message.edgeMetadata))
                            return "edgeMetadata: array expected";
                        for (let i = 0; i < message.edgeMetadata.length; ++i) {
                            let error = $root.clutch.topology.v1.MetadataQuery.verify(message.edgeMetadata[i]);
                            if (error)
                                return "edgeMetadata." + error;
                        }
                    }
                    if (message.sourceDepth != null && message.hasOwnProperty("sourceDepth"))
                        if (!$util.isInteger(message.sourceDepth))
                            return "sourceDepth: integer expected";
                    if (message.targetDepth != null && message.hasOwnProperty("targetDepth"))
                        if (!$util.isInteger(message.targetDepth))
                            return "targetDepth: integer expected";
                    return null;
                };

                /**
                 * Creates a Query message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.Query
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.Query} Query
                 */
                Query.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.Query)
                        return object;
                    let message = new $root.clutch.topology.v1.Query();
                    if (object.features) {
                        if (!Array.isArray(object.features))
                            throw TypeError(".clutch.topology.v1.Query.features: array expected");
                        message.features = [];
                        for (let i = 0; i < object.features.length; ++i) {
                            if (typeof object.features[i] !== "object")
                                throw TypeError(".clutch.topology.v1.Query.features: object expected");
                            message.features[i] = $root.clutch.topology.v1.FeatureQuery.fromObject(object.features[i]);
                        }
                    }
                    if (object.nodeMetadata) {
                        if (!Array.isArray(object.nodeMetadata))
                            throw TypeError(".clutch.topology.v1.Query.nodeMetadata: array expected");
                        message.nodeMetadata = [];
                        for (let i = 0; i < object.nodeMetadata.length; ++i) {
                            if (typeof object.nodeMetadata[i] !== "object")
                                throw TypeError(".clutch.topology.v1.Query.nodeMetadata: object expected");
                            message.nodeMetadata[i] = $root.clutch.topology.v1.MetadataQuery.fromObject(object.nodeMetadata[i]);
                        }
                    }
                    if (object.edgeMetadata) {
                        if (!Array.isArray(object.edgeMetadata))
                            throw TypeError(".clutch.topology.v1.Query.edgeMetadata: array expected");
                        message.edgeMetadata = [];
                        for (let i = 0; i < object.edgeMetadata.length; ++i) {
                            if (typeof object.edgeMetadata[i] !== "object")
                                throw TypeError(".clutch.topology.v1.Query.edgeMetadata: object expected");
                            message.edgeMetadata[i] = $root.clutch.topology.v1.MetadataQuery.fromObject(object.edgeMetadata[i]);
                        }
                    }
                    if (object.sourceDepth != null)
                        message.sourceDepth = object.sourceDepth >>> 0;
                    if (object.targetDepth != null)
                        message.targetDepth = object.targetDepth >>> 0;
                    return message;
                };

                /**
                 * Creates a plain object from a Query message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.Query
                 * @static
                 * @param {clutch.topology.v1.Query} message Query
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Query.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.features = [];
                        object.nodeMetadata = [];
                        object.edgeMetadata = [];
                    }
                    if (options.defaults) {
                        object.sourceDepth = 0;
                        object.targetDepth = 0;
                    }
                    if (message.features && message.features.length) {
                        object.features = [];
                        for (let j = 0; j < message.features.length; ++j)
                            object.features[j] = $root.clutch.topology.v1.FeatureQuery.toObject(message.features[j], options);
                    }
                    if (message.sourceDepth != null && message.hasOwnProperty("sourceDepth"))
                        object.sourceDepth = message.sourceDepth;
                    if (message.targetDepth != null && message.hasOwnProperty("targetDepth"))
                        object.targetDepth = message.targetDepth;
                    if (message.nodeMetadata && message.nodeMetadata.length) {
                        object.nodeMetadata = [];
                        for (let j = 0; j < message.nodeMetadata.length; ++j)
                            object.nodeMetadata[j] = $root.clutch.topology.v1.MetadataQuery.toObject(message.nodeMetadata[j], options);
                    }
                    if (message.edgeMetadata && message.edgeMetadata.length) {
                        object.edgeMetadata = [];
                        for (let j = 0; j < message.edgeMetadata.length; ++j)
                            object.edgeMetadata[j] = $root.clutch.topology.v1.MetadataQuery.toObject(message.edgeMetadata[j], options);
                    }
                    return object;
                };

                /**
                 * Converts this Query to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.Query
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Query.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Query;
            })();

            v1.QueryResult = (function() {

                /**
                 * Properties of a QueryResult.
                 * @memberof clutch.topology.v1
                 * @interface IQueryResult
                 * @property {google.rpc.IStatus|null} [status] QueryResult status
                 * @property {clutch.topology.v1.IQuery|null} [query] QueryResult query
                 * @property {Array.<string>|null} [matchedNodeIds] QueryResult matchedNodeIds
                 * @property {Object.<string,clutch.topology.v1.INode>|null} [nodes] QueryResult nodes
                 * @property {Object.<string,clutch.topology.v1.IEdge>|null} [edges] QueryResult edges
                 */

                /**
                 * Constructs a new QueryResult.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a QueryResult.
                 * @implements IQueryResult
                 * @constructor
                 * @param {clutch.topology.v1.IQueryResult=} [properties] Properties to set
                 */
                function QueryResult(properties) {
                    this.matchedNodeIds = [];
                    this.nodes = {};
                    this.edges = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * QueryResult status.
                 * @member {google.rpc.IStatus|null|undefined} status
                 * @memberof clutch.topology.v1.QueryResult
                 * @instance
                 */
                QueryResult.prototype.status = null;

                /**
                 * QueryResult query.
                 * @member {clutch.topology.v1.IQuery|null|undefined} query
                 * @memberof clutch.topology.v1.QueryResult
                 * @instance
                 */
                QueryResult.prototype.query = null;

                /**
                 * QueryResult matchedNodeIds.
                 * @member {Array.<string>} matchedNodeIds
                 * @memberof clutch.topology.v1.QueryResult
                 * @instance
                 */
                QueryResult.prototype.matchedNodeIds = $util.emptyArray;

                /**
                 * QueryResult nodes.
                 * @member {Object.<string,clutch.topology.v1.INode>} nodes
                 * @memberof clutch.topology.v1.QueryResult
                 * @instance
                 */
                QueryResult.prototype.nodes = $util.emptyObject;

                /**
                 * QueryResult edges.
                 * @member {Object.<string,clutch.topology.v1.IEdge>} edges
                 * @memberof clutch.topology.v1.QueryResult
                 * @instance
                 */
                QueryResult.prototype.edges = $util.emptyObject;

                /**
                 * Verifies a QueryResult message.
                 * @function verify
                 * @memberof clutch.topology.v1.QueryResult
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                QueryResult.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.status != null && message.hasOwnProperty("status")) {
                        let error = $root.google.rpc.Status.verify(message.status);
                        if (error)
                            return "status." + error;
                    }
                    if (message.query != null && message.hasOwnProperty("query")) {
                        let error = $root.clutch.topology.v1.Query.verify(message.query);
                        if (error)
                            return "query." + error;
                    }
                    if (message.matchedNodeIds != null && message.hasOwnProperty("matchedNodeIds")) {
                        if (!Array.isArray(message.matchedNodeIds))
                            return "matchedNodeIds: array expected";
                        for (let i = 0; i < message.matchedNodeIds.length; ++i)
                            if (!$util.isString(message.matchedNodeIds[i]))
                                return "matchedNodeIds: string[] expected";
                    }
                    if (message.nodes != null && message.hasOwnProperty("nodes")) {
                        if (!$util.isObject(message.nodes))
                            return "nodes: object expected";
                        let key = Object.keys(message.nodes);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.clutch.topology.v1.Node.verify(message.nodes[key[i]]);
                            if (error)
                                return "nodes." + error;
                        }
                    }
                    if (message.edges != null && message.hasOwnProperty("edges")) {
                        if (!$util.isObject(message.edges))
                            return "edges: object expected";
                        let key = Object.keys(message.edges);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.clutch.topology.v1.Edge.verify(message.edges[key[i]]);
                            if (error)
                                return "edges." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a QueryResult message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.QueryResult
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.QueryResult} QueryResult
                 */
                QueryResult.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.QueryResult)
                        return object;
                    let message = new $root.clutch.topology.v1.QueryResult();
                    if (object.status != null) {
                        if (typeof object.status !== "object")
                            throw TypeError(".clutch.topology.v1.QueryResult.status: object expected");
                        message.status = $root.google.rpc.Status.fromObject(object.status);
                    }
                    if (object.query != null) {
                        if (typeof object.query !== "object")
                            throw TypeError(".clutch.topology.v1.QueryResult.query: object expected");
                        message.query = $root.clutch.topology.v1.Query.fromObject(object.query);
                    }
                    if (object.matchedNodeIds) {
                        if (!Array.isArray(object.matchedNodeIds))
                            throw TypeError(".clutch.topology.v1.QueryResult.matchedNodeIds: array expected");
                        message.matchedNodeIds = [];
                        for (let i = 0; i < object.matchedNodeIds.length; ++i)
                            message.matchedNodeIds[i] = String(object.matchedNodeIds[i]);
                    }
                    if (object.nodes) {
                        if (typeof object.nodes !== "object")
                            throw TypeError(".clutch.topology.v1.QueryResult.nodes: object expected");
                        message.nodes = {};
                        for (let keys = Object.keys(object.nodes), i = 0; i < keys.length; ++i) {
                            if (typeof object.nodes[keys[i]] !== "object")
                                throw TypeError(".clutch.topology.v1.QueryResult.nodes: object expected");
                            message.nodes[keys[i]] = $root.clutch.topology.v1.Node.fromObject(object.nodes[keys[i]]);
                        }
                    }
                    if (object.edges) {
                        if (typeof object.edges !== "object")
                            throw TypeError(".clutch.topology.v1.QueryResult.edges: object expected");
                        message.edges = {};
                        for (let keys = Object.keys(object.edges), i = 0; i < keys.length; ++i) {
                            if (typeof object.edges[keys[i]] !== "object")
                                throw TypeError(".clutch.topology.v1.QueryResult.edges: object expected");
                            message.edges[keys[i]] = $root.clutch.topology.v1.Edge.fromObject(object.edges[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a QueryResult message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.QueryResult
                 * @static
                 * @param {clutch.topology.v1.QueryResult} message QueryResult
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                QueryResult.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.matchedNodeIds = [];
                    if (options.objects || options.defaults) {
                        object.nodes = {};
                        object.edges = {};
                    }
                    if (options.defaults) {
                        object.status = null;
                        object.query = null;
                    }
                    if (message.status != null && message.hasOwnProperty("status"))
                        object.status = $root.google.rpc.Status.toObject(message.status, options);
                    if (message.query != null && message.hasOwnProperty("query"))
                        object.query = $root.clutch.topology.v1.Query.toObject(message.query, options);
                    if (message.matchedNodeIds && message.matchedNodeIds.length) {
                        object.matchedNodeIds = [];
                        for (let j = 0; j < message.matchedNodeIds.length; ++j)
                            object.matchedNodeIds[j] = message.matchedNodeIds[j];
                    }
                    let keys2;
                    if (message.nodes && (keys2 = Object.keys(message.nodes)).length) {
                        object.nodes = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.nodes[keys2[j]] = $root.clutch.topology.v1.Node.toObject(message.nodes[keys2[j]], options);
                    }
                    if (message.edges && (keys2 = Object.keys(message.edges)).length) {
                        object.edges = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.edges[keys2[j]] = $root.clutch.topology.v1.Edge.toObject(message.edges[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Converts this QueryResult to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.QueryResult
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                QueryResult.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return QueryResult;
            })();

            v1.Node = (function() {

                /**
                 * Properties of a Node.
                 * @memberof clutch.topology.v1
                 * @interface INode
                 * @property {string|null} [id] Node id
                 * @property {Object.<string,string>|null} [features] Node features
                 * @property {Object.<string,google.protobuf.IValue>|null} [metadata] Node metadata
                 */

                /**
                 * Constructs a new Node.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents a Node.
                 * @implements INode
                 * @constructor
                 * @param {clutch.topology.v1.INode=} [properties] Properties to set
                 */
                function Node(properties) {
                    this.features = {};
                    this.metadata = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Node id.
                 * @member {string} id
                 * @memberof clutch.topology.v1.Node
                 * @instance
                 */
                Node.prototype.id = "";

                /**
                 * Node features.
                 * @member {Object.<string,string>} features
                 * @memberof clutch.topology.v1.Node
                 * @instance
                 */
                Node.prototype.features = $util.emptyObject;

                /**
                 * Node metadata.
                 * @member {Object.<string,google.protobuf.IValue>} metadata
                 * @memberof clutch.topology.v1.Node
                 * @instance
                 */
                Node.prototype.metadata = $util.emptyObject;

                /**
                 * Verifies a Node message.
                 * @function verify
                 * @memberof clutch.topology.v1.Node
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Node.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.features != null && message.hasOwnProperty("features")) {
                        if (!$util.isObject(message.features))
                            return "features: object expected";
                        let key = Object.keys(message.features);
                        for (let i = 0; i < key.length; ++i)
                            if (!$util.isString(message.features[key[i]]))
                                return "features: string{k:string} expected";
                    }
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        if (!$util.isObject(message.metadata))
                            return "metadata: object expected";
                        let key = Object.keys(message.metadata);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.google.protobuf.Value.verify(message.metadata[key[i]]);
                            if (error)
                                return "metadata." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates a Node message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.Node
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.Node} Node
                 */
                Node.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.Node)
                        return object;
                    let message = new $root.clutch.topology.v1.Node();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.features) {
                        if (typeof object.features !== "object")
                            throw TypeError(".clutch.topology.v1.Node.features: object expected");
                        message.features = {};
                        for (let keys = Object.keys(object.features), i = 0; i < keys.length; ++i)
                            message.features[keys[i]] = String(object.features[keys[i]]);
                    }
                    if (object.metadata) {
                        if (typeof object.metadata !== "object")
                            throw TypeError(".clutch.topology.v1.Node.metadata: object expected");
                        message.metadata = {};
                        for (let keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i) {
                            if (typeof object.metadata[keys[i]] !== "object")
                                throw TypeError(".clutch.topology.v1.Node.metadata: object expected");
                            message.metadata[keys[i]] = $root.google.protobuf.Value.fromObject(object.metadata[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Node message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.Node
                 * @static
                 * @param {clutch.topology.v1.Node} message Node
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Node.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults) {
                        object.features = {};
                        object.metadata = {};
                    }
                    if (options.defaults)
                        object.id = "";
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    let keys2;
                    if (message.features && (keys2 = Object.keys(message.features)).length) {
                        object.features = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.features[keys2[j]] = message.features[keys2[j]];
                    }
                    if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                        object.metadata = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.metadata[keys2[j]] = $root.google.protobuf.Value.toObject(message.metadata[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Converts this Node to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.Node
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Node.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Node;
            })();

            v1.Edge = (function() {

                /**
                 * Properties of an Edge.
                 * @memberof clutch.topology.v1
                 * @interface IEdge
                 * @property {string|null} [id] Edge id
                 * @property {string|null} [sourceNodeId] Edge sourceNodeId
                 * @property {string|null} [targetNodeId] Edge targetNodeId
                 * @property {Object.<string,google.protobuf.IValue>|null} [metadata] Edge metadata
                 */

                /**
                 * Constructs a new Edge.
                 * @memberof clutch.topology.v1
                 * @classdesc Represents an Edge.
                 * @implements IEdge
                 * @constructor
                 * @param {clutch.topology.v1.IEdge=} [properties] Properties to set
                 */
                function Edge(properties) {
                    this.metadata = {};
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Edge id.
                 * @member {string} id
                 * @memberof clutch.topology.v1.Edge
                 * @instance
                 */
                Edge.prototype.id = "";

                /**
                 * Edge sourceNodeId.
                 * @member {string} sourceNodeId
                 * @memberof clutch.topology.v1.Edge
                 * @instance
                 */
                Edge.prototype.sourceNodeId = "";

                /**
                 * Edge targetNodeId.
                 * @member {string} targetNodeId
                 * @memberof clutch.topology.v1.Edge
                 * @instance
                 */
                Edge.prototype.targetNodeId = "";

                /**
                 * Edge metadata.
                 * @member {Object.<string,google.protobuf.IValue>} metadata
                 * @memberof clutch.topology.v1.Edge
                 * @instance
                 */
                Edge.prototype.metadata = $util.emptyObject;

                /**
                 * Verifies an Edge message.
                 * @function verify
                 * @memberof clutch.topology.v1.Edge
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Edge.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.id != null && message.hasOwnProperty("id"))
                        if (!$util.isString(message.id))
                            return "id: string expected";
                    if (message.sourceNodeId != null && message.hasOwnProperty("sourceNodeId"))
                        if (!$util.isString(message.sourceNodeId))
                            return "sourceNodeId: string expected";
                    if (message.targetNodeId != null && message.hasOwnProperty("targetNodeId"))
                        if (!$util.isString(message.targetNodeId))
                            return "targetNodeId: string expected";
                    if (message.metadata != null && message.hasOwnProperty("metadata")) {
                        if (!$util.isObject(message.metadata))
                            return "metadata: object expected";
                        let key = Object.keys(message.metadata);
                        for (let i = 0; i < key.length; ++i) {
                            let error = $root.google.protobuf.Value.verify(message.metadata[key[i]]);
                            if (error)
                                return "metadata." + error;
                        }
                    }
                    return null;
                };

                /**
                 * Creates an Edge message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof clutch.topology.v1.Edge
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {clutch.topology.v1.Edge} Edge
                 */
                Edge.fromObject = function fromObject(object) {
                    if (object instanceof $root.clutch.topology.v1.Edge)
                        return object;
                    let message = new $root.clutch.topology.v1.Edge();
                    if (object.id != null)
                        message.id = String(object.id);
                    if (object.sourceNodeId != null)
                        message.sourceNodeId = String(object.sourceNodeId);
                    if (object.targetNodeId != null)
                        message.targetNodeId = String(object.targetNodeId);
                    if (object.metadata) {
                        if (typeof object.metadata !== "object")
                            throw TypeError(".clutch.topology.v1.Edge.metadata: object expected");
                        message.metadata = {};
                        for (let keys = Object.keys(object.metadata), i = 0; i < keys.length; ++i) {
                            if (typeof object.metadata[keys[i]] !== "object")
                                throw TypeError(".clutch.topology.v1.Edge.metadata: object expected");
                            message.metadata[keys[i]] = $root.google.protobuf.Value.fromObject(object.metadata[keys[i]]);
                        }
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an Edge message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof clutch.topology.v1.Edge
                 * @static
                 * @param {clutch.topology.v1.Edge} message Edge
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Edge.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.objects || options.defaults)
                        object.metadata = {};
                    if (options.defaults) {
                        object.id = "";
                        object.sourceNodeId = "";
                        object.targetNodeId = "";
                    }
                    if (message.id != null && message.hasOwnProperty("id"))
                        object.id = message.id;
                    if (message.sourceNodeId != null && message.hasOwnProperty("sourceNodeId"))
                        object.sourceNodeId = message.sourceNodeId;
                    if (message.targetNodeId != null && message.hasOwnProperty("targetNodeId"))
                        object.targetNodeId = message.targetNodeId;
                    let keys2;
                    if (message.metadata && (keys2 = Object.keys(message.metadata)).length) {
                        object.metadata = {};
                        for (let j = 0; j < keys2.length; ++j)
                            object.metadata[keys2[j]] = $root.google.protobuf.Value.toObject(message.metadata[keys2[j]], options);
                    }
                    return object;
                };

                /**
                 * Converts this Edge to JSON.
                 * @function toJSON
                 * @memberof clutch.topology.v1.Edge
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Edge.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Edge;
            })();

            return v1;
        })();

        return topology;
    })();

    return clutch;
})();

export const validate = $root.validate = (() => {

    /**
     * Namespace validate.
     * @exports validate
     * @namespace
     */
    const validate = {};

    validate.FieldRules = (function() {

        /**
         * Properties of a FieldRules.
         * @memberof validate
         * @interface IFieldRules
         * @property {validate.IMessageRules|null} [message] FieldRules message
         * @property {validate.IFloatRules|null} [float] FieldRules float
         * @property {validate.IDoubleRules|null} [double] FieldRules double
         * @property {validate.IInt32Rules|null} [int32] FieldRules int32
         * @property {validate.IInt64Rules|null} [int64] FieldRules int64
         * @property {validate.IUInt32Rules|null} [uint32] FieldRules uint32
         * @property {validate.IUInt64Rules|null} [uint64] FieldRules uint64
         * @property {validate.ISInt32Rules|null} [sint32] FieldRules sint32
         * @property {validate.ISInt64Rules|null} [sint64] FieldRules sint64
         * @property {validate.IFixed32Rules|null} [fixed32] FieldRules fixed32
         * @property {validate.IFixed64Rules|null} [fixed64] FieldRules fixed64
         * @property {validate.ISFixed32Rules|null} [sfixed32] FieldRules sfixed32
         * @property {validate.ISFixed64Rules|null} [sfixed64] FieldRules sfixed64
         * @property {validate.IBoolRules|null} [bool] FieldRules bool
         * @property {validate.IStringRules|null} [string] FieldRules string
         * @property {validate.IBytesRules|null} [bytes] FieldRules bytes
         * @property {validate.IEnumRules|null} ["enum"] FieldRules enum
         * @property {validate.IRepeatedRules|null} [repeated] FieldRules repeated
         * @property {validate.IMapRules|null} [map] FieldRules map
         * @property {validate.IAnyRules|null} [any] FieldRules any
         * @property {validate.IDurationRules|null} [duration] FieldRules duration
         * @property {validate.ITimestampRules|null} [timestamp] FieldRules timestamp
         */

        /**
         * Constructs a new FieldRules.
         * @memberof validate
         * @classdesc Represents a FieldRules.
         * @implements IFieldRules
         * @constructor
         * @param {validate.IFieldRules=} [properties] Properties to set
         */
        function FieldRules(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FieldRules message.
         * @member {validate.IMessageRules|null|undefined} message
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.message = null;

        /**
         * FieldRules float.
         * @member {validate.IFloatRules|null|undefined} float
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.float = null;

        /**
         * FieldRules double.
         * @member {validate.IDoubleRules|null|undefined} double
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.double = null;

        /**
         * FieldRules int32.
         * @member {validate.IInt32Rules|null|undefined} int32
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.int32 = null;

        /**
         * FieldRules int64.
         * @member {validate.IInt64Rules|null|undefined} int64
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.int64 = null;

        /**
         * FieldRules uint32.
         * @member {validate.IUInt32Rules|null|undefined} uint32
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.uint32 = null;

        /**
         * FieldRules uint64.
         * @member {validate.IUInt64Rules|null|undefined} uint64
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.uint64 = null;

        /**
         * FieldRules sint32.
         * @member {validate.ISInt32Rules|null|undefined} sint32
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.sint32 = null;

        /**
         * FieldRules sint64.
         * @member {validate.ISInt64Rules|null|undefined} sint64
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.sint64 = null;

        /**
         * FieldRules fixed32.
         * @member {validate.IFixed32Rules|null|undefined} fixed32
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.fixed32 = null;

        /**
         * FieldRules fixed64.
         * @member {validate.IFixed64Rules|null|undefined} fixed64
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.fixed64 = null;

        /**
         * FieldRules sfixed32.
         * @member {validate.ISFixed32Rules|null|undefined} sfixed32
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.sfixed32 = null;

        /**
         * FieldRules sfixed64.
         * @member {validate.ISFixed64Rules|null|undefined} sfixed64
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.sfixed64 = null;

        /**
         * FieldRules bool.
         * @member {validate.IBoolRules|null|undefined} bool
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.bool = null;

        /**
         * FieldRules string.
         * @member {validate.IStringRules|null|undefined} string
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.string = null;

        /**
         * FieldRules bytes.
         * @member {validate.IBytesRules|null|undefined} bytes
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.bytes = null;

        /**
         * FieldRules enum.
         * @member {validate.IEnumRules|null|undefined} enum
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype["enum"] = null;

        /**
         * FieldRules repeated.
         * @member {validate.IRepeatedRules|null|undefined} repeated
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.repeated = null;

        /**
         * FieldRules map.
         * @member {validate.IMapRules|null|undefined} map
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.map = null;

        /**
         * FieldRules any.
         * @member {validate.IAnyRules|null|undefined} any
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.any = null;

        /**
         * FieldRules duration.
         * @member {validate.IDurationRules|null|undefined} duration
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.duration = null;

        /**
         * FieldRules timestamp.
         * @member {validate.ITimestampRules|null|undefined} timestamp
         * @memberof validate.FieldRules
         * @instance
         */
        FieldRules.prototype.timestamp = null;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * FieldRules type.
         * @member {"float"|"double"|"int32"|"int64"|"uint32"|"uint64"|"sint32"|"sint64"|"fixed32"|"fixed64"|"sfixed32"|"sfixed64"|"bool"|"string"|"bytes"|"enum"|"repeated"|"map"|"any"|"duration"|"timestamp"|undefined} type
         * @memberof validate.FieldRules
         * @instance
         */
        Object.defineProperty(FieldRules.prototype, "type", {
            get: $util.oneOfGetter($oneOfFields = ["float", "double", "int32", "int64", "uint32", "uint64", "sint32", "sint64", "fixed32", "fixed64", "sfixed32", "sfixed64", "bool", "string", "bytes", "enum", "repeated", "map", "any", "duration", "timestamp"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Verifies a FieldRules message.
         * @function verify
         * @memberof validate.FieldRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FieldRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message.message != null && message.hasOwnProperty("message")) {
                let error = $root.validate.MessageRules.verify(message.message);
                if (error)
                    return "message." + error;
            }
            if (message.float != null && message.hasOwnProperty("float")) {
                properties.type = 1;
                {
                    let error = $root.validate.FloatRules.verify(message.float);
                    if (error)
                        return "float." + error;
                }
            }
            if (message.double != null && message.hasOwnProperty("double")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.DoubleRules.verify(message.double);
                    if (error)
                        return "double." + error;
                }
            }
            if (message.int32 != null && message.hasOwnProperty("int32")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.Int32Rules.verify(message.int32);
                    if (error)
                        return "int32." + error;
                }
            }
            if (message.int64 != null && message.hasOwnProperty("int64")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.Int64Rules.verify(message.int64);
                    if (error)
                        return "int64." + error;
                }
            }
            if (message.uint32 != null && message.hasOwnProperty("uint32")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.UInt32Rules.verify(message.uint32);
                    if (error)
                        return "uint32." + error;
                }
            }
            if (message.uint64 != null && message.hasOwnProperty("uint64")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.UInt64Rules.verify(message.uint64);
                    if (error)
                        return "uint64." + error;
                }
            }
            if (message.sint32 != null && message.hasOwnProperty("sint32")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.SInt32Rules.verify(message.sint32);
                    if (error)
                        return "sint32." + error;
                }
            }
            if (message.sint64 != null && message.hasOwnProperty("sint64")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.SInt64Rules.verify(message.sint64);
                    if (error)
                        return "sint64." + error;
                }
            }
            if (message.fixed32 != null && message.hasOwnProperty("fixed32")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.Fixed32Rules.verify(message.fixed32);
                    if (error)
                        return "fixed32." + error;
                }
            }
            if (message.fixed64 != null && message.hasOwnProperty("fixed64")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.Fixed64Rules.verify(message.fixed64);
                    if (error)
                        return "fixed64." + error;
                }
            }
            if (message.sfixed32 != null && message.hasOwnProperty("sfixed32")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.SFixed32Rules.verify(message.sfixed32);
                    if (error)
                        return "sfixed32." + error;
                }
            }
            if (message.sfixed64 != null && message.hasOwnProperty("sfixed64")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.SFixed64Rules.verify(message.sfixed64);
                    if (error)
                        return "sfixed64." + error;
                }
            }
            if (message.bool != null && message.hasOwnProperty("bool")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.BoolRules.verify(message.bool);
                    if (error)
                        return "bool." + error;
                }
            }
            if (message.string != null && message.hasOwnProperty("string")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.StringRules.verify(message.string);
                    if (error)
                        return "string." + error;
                }
            }
            if (message.bytes != null && message.hasOwnProperty("bytes")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.BytesRules.verify(message.bytes);
                    if (error)
                        return "bytes." + error;
                }
            }
            if (message["enum"] != null && message.hasOwnProperty("enum")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.EnumRules.verify(message["enum"]);
                    if (error)
                        return "enum." + error;
                }
            }
            if (message.repeated != null && message.hasOwnProperty("repeated")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.RepeatedRules.verify(message.repeated);
                    if (error)
                        return "repeated." + error;
                }
            }
            if (message.map != null && message.hasOwnProperty("map")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.MapRules.verify(message.map);
                    if (error)
                        return "map." + error;
                }
            }
            if (message.any != null && message.hasOwnProperty("any")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.AnyRules.verify(message.any);
                    if (error)
                        return "any." + error;
                }
            }
            if (message.duration != null && message.hasOwnProperty("duration")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.DurationRules.verify(message.duration);
                    if (error)
                        return "duration." + error;
                }
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                if (properties.type === 1)
                    return "type: multiple values";
                properties.type = 1;
                {
                    let error = $root.validate.TimestampRules.verify(message.timestamp);
                    if (error)
                        return "timestamp." + error;
                }
            }
            return null;
        };

        /**
         * Creates a FieldRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.FieldRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.FieldRules} FieldRules
         */
        FieldRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.FieldRules)
                return object;
            let message = new $root.validate.FieldRules();
            if (object.message != null) {
                if (typeof object.message !== "object")
                    throw TypeError(".validate.FieldRules.message: object expected");
                message.message = $root.validate.MessageRules.fromObject(object.message);
            }
            if (object.float != null) {
                if (typeof object.float !== "object")
                    throw TypeError(".validate.FieldRules.float: object expected");
                message.float = $root.validate.FloatRules.fromObject(object.float);
            }
            if (object.double != null) {
                if (typeof object.double !== "object")
                    throw TypeError(".validate.FieldRules.double: object expected");
                message.double = $root.validate.DoubleRules.fromObject(object.double);
            }
            if (object.int32 != null) {
                if (typeof object.int32 !== "object")
                    throw TypeError(".validate.FieldRules.int32: object expected");
                message.int32 = $root.validate.Int32Rules.fromObject(object.int32);
            }
            if (object.int64 != null) {
                if (typeof object.int64 !== "object")
                    throw TypeError(".validate.FieldRules.int64: object expected");
                message.int64 = $root.validate.Int64Rules.fromObject(object.int64);
            }
            if (object.uint32 != null) {
                if (typeof object.uint32 !== "object")
                    throw TypeError(".validate.FieldRules.uint32: object expected");
                message.uint32 = $root.validate.UInt32Rules.fromObject(object.uint32);
            }
            if (object.uint64 != null) {
                if (typeof object.uint64 !== "object")
                    throw TypeError(".validate.FieldRules.uint64: object expected");
                message.uint64 = $root.validate.UInt64Rules.fromObject(object.uint64);
            }
            if (object.sint32 != null) {
                if (typeof object.sint32 !== "object")
                    throw TypeError(".validate.FieldRules.sint32: object expected");
                message.sint32 = $root.validate.SInt32Rules.fromObject(object.sint32);
            }
            if (object.sint64 != null) {
                if (typeof object.sint64 !== "object")
                    throw TypeError(".validate.FieldRules.sint64: object expected");
                message.sint64 = $root.validate.SInt64Rules.fromObject(object.sint64);
            }
            if (object.fixed32 != null) {
                if (typeof object.fixed32 !== "object")
                    throw TypeError(".validate.FieldRules.fixed32: object expected");
                message.fixed32 = $root.validate.Fixed32Rules.fromObject(object.fixed32);
            }
            if (object.fixed64 != null) {
                if (typeof object.fixed64 !== "object")
                    throw TypeError(".validate.FieldRules.fixed64: object expected");
                message.fixed64 = $root.validate.Fixed64Rules.fromObject(object.fixed64);
            }
            if (object.sfixed32 != null) {
                if (typeof object.sfixed32 !== "object")
                    throw TypeError(".validate.FieldRules.sfixed32: object expected");
                message.sfixed32 = $root.validate.SFixed32Rules.fromObject(object.sfixed32);
            }
            if (object.sfixed64 != null) {
                if (typeof object.sfixed64 !== "object")
                    throw TypeError(".validate.FieldRules.sfixed64: object expected");
                message.sfixed64 = $root.validate.SFixed64Rules.fromObject(object.sfixed64);
            }
            if (object.bool != null) {
                if (typeof object.bool !== "object")
                    throw TypeError(".validate.FieldRules.bool: object expected");
                message.bool = $root.validate.BoolRules.fromObject(object.bool);
            }
            if (object.string != null) {
                if (typeof object.string !== "object")
                    throw TypeError(".validate.FieldRules.string: object expected");
                message.string = $root.validate.StringRules.fromObject(object.string);
            }
            if (object.bytes != null) {
                if (typeof object.bytes !== "object")
                    throw TypeError(".validate.FieldRules.bytes: object expected");
                message.bytes = $root.validate.BytesRules.fromObject(object.bytes);
            }
            if (object["enum"] != null) {
                if (typeof object["enum"] !== "object")
                    throw TypeError(".validate.FieldRules.enum: object expected");
                message["enum"] = $root.validate.EnumRules.fromObject(object["enum"]);
            }
            if (object.repeated != null) {
                if (typeof object.repeated !== "object")
                    throw TypeError(".validate.FieldRules.repeated: object expected");
                message.repeated = $root.validate.RepeatedRules.fromObject(object.repeated);
            }
            if (object.map != null) {
                if (typeof object.map !== "object")
                    throw TypeError(".validate.FieldRules.map: object expected");
                message.map = $root.validate.MapRules.fromObject(object.map);
            }
            if (object.any != null) {
                if (typeof object.any !== "object")
                    throw TypeError(".validate.FieldRules.any: object expected");
                message.any = $root.validate.AnyRules.fromObject(object.any);
            }
            if (object.duration != null) {
                if (typeof object.duration !== "object")
                    throw TypeError(".validate.FieldRules.duration: object expected");
                message.duration = $root.validate.DurationRules.fromObject(object.duration);
            }
            if (object.timestamp != null) {
                if (typeof object.timestamp !== "object")
                    throw TypeError(".validate.FieldRules.timestamp: object expected");
                message.timestamp = $root.validate.TimestampRules.fromObject(object.timestamp);
            }
            return message;
        };

        /**
         * Creates a plain object from a FieldRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.FieldRules
         * @static
         * @param {validate.FieldRules} message FieldRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FieldRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object.message = null;
            if (message.float != null && message.hasOwnProperty("float")) {
                object.float = $root.validate.FloatRules.toObject(message.float, options);
                if (options.oneofs)
                    object.type = "float";
            }
            if (message.double != null && message.hasOwnProperty("double")) {
                object.double = $root.validate.DoubleRules.toObject(message.double, options);
                if (options.oneofs)
                    object.type = "double";
            }
            if (message.int32 != null && message.hasOwnProperty("int32")) {
                object.int32 = $root.validate.Int32Rules.toObject(message.int32, options);
                if (options.oneofs)
                    object.type = "int32";
            }
            if (message.int64 != null && message.hasOwnProperty("int64")) {
                object.int64 = $root.validate.Int64Rules.toObject(message.int64, options);
                if (options.oneofs)
                    object.type = "int64";
            }
            if (message.uint32 != null && message.hasOwnProperty("uint32")) {
                object.uint32 = $root.validate.UInt32Rules.toObject(message.uint32, options);
                if (options.oneofs)
                    object.type = "uint32";
            }
            if (message.uint64 != null && message.hasOwnProperty("uint64")) {
                object.uint64 = $root.validate.UInt64Rules.toObject(message.uint64, options);
                if (options.oneofs)
                    object.type = "uint64";
            }
            if (message.sint32 != null && message.hasOwnProperty("sint32")) {
                object.sint32 = $root.validate.SInt32Rules.toObject(message.sint32, options);
                if (options.oneofs)
                    object.type = "sint32";
            }
            if (message.sint64 != null && message.hasOwnProperty("sint64")) {
                object.sint64 = $root.validate.SInt64Rules.toObject(message.sint64, options);
                if (options.oneofs)
                    object.type = "sint64";
            }
            if (message.fixed32 != null && message.hasOwnProperty("fixed32")) {
                object.fixed32 = $root.validate.Fixed32Rules.toObject(message.fixed32, options);
                if (options.oneofs)
                    object.type = "fixed32";
            }
            if (message.fixed64 != null && message.hasOwnProperty("fixed64")) {
                object.fixed64 = $root.validate.Fixed64Rules.toObject(message.fixed64, options);
                if (options.oneofs)
                    object.type = "fixed64";
            }
            if (message.sfixed32 != null && message.hasOwnProperty("sfixed32")) {
                object.sfixed32 = $root.validate.SFixed32Rules.toObject(message.sfixed32, options);
                if (options.oneofs)
                    object.type = "sfixed32";
            }
            if (message.sfixed64 != null && message.hasOwnProperty("sfixed64")) {
                object.sfixed64 = $root.validate.SFixed64Rules.toObject(message.sfixed64, options);
                if (options.oneofs)
                    object.type = "sfixed64";
            }
            if (message.bool != null && message.hasOwnProperty("bool")) {
                object.bool = $root.validate.BoolRules.toObject(message.bool, options);
                if (options.oneofs)
                    object.type = "bool";
            }
            if (message.string != null && message.hasOwnProperty("string")) {
                object.string = $root.validate.StringRules.toObject(message.string, options);
                if (options.oneofs)
                    object.type = "string";
            }
            if (message.bytes != null && message.hasOwnProperty("bytes")) {
                object.bytes = $root.validate.BytesRules.toObject(message.bytes, options);
                if (options.oneofs)
                    object.type = "bytes";
            }
            if (message["enum"] != null && message.hasOwnProperty("enum")) {
                object["enum"] = $root.validate.EnumRules.toObject(message["enum"], options);
                if (options.oneofs)
                    object.type = "enum";
            }
            if (message.message != null && message.hasOwnProperty("message"))
                object.message = $root.validate.MessageRules.toObject(message.message, options);
            if (message.repeated != null && message.hasOwnProperty("repeated")) {
                object.repeated = $root.validate.RepeatedRules.toObject(message.repeated, options);
                if (options.oneofs)
                    object.type = "repeated";
            }
            if (message.map != null && message.hasOwnProperty("map")) {
                object.map = $root.validate.MapRules.toObject(message.map, options);
                if (options.oneofs)
                    object.type = "map";
            }
            if (message.any != null && message.hasOwnProperty("any")) {
                object.any = $root.validate.AnyRules.toObject(message.any, options);
                if (options.oneofs)
                    object.type = "any";
            }
            if (message.duration != null && message.hasOwnProperty("duration")) {
                object.duration = $root.validate.DurationRules.toObject(message.duration, options);
                if (options.oneofs)
                    object.type = "duration";
            }
            if (message.timestamp != null && message.hasOwnProperty("timestamp")) {
                object.timestamp = $root.validate.TimestampRules.toObject(message.timestamp, options);
                if (options.oneofs)
                    object.type = "timestamp";
            }
            return object;
        };

        /**
         * Converts this FieldRules to JSON.
         * @function toJSON
         * @memberof validate.FieldRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FieldRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FieldRules;
    })();

    validate.FloatRules = (function() {

        /**
         * Properties of a FloatRules.
         * @memberof validate
         * @interface IFloatRules
         * @property {number|null} ["const"] FloatRules const
         * @property {number|null} [lt] FloatRules lt
         * @property {number|null} [lte] FloatRules lte
         * @property {number|null} [gt] FloatRules gt
         * @property {number|null} [gte] FloatRules gte
         * @property {Array.<number>|null} ["in"] FloatRules in
         * @property {Array.<number>|null} [notIn] FloatRules notIn
         */

        /**
         * Constructs a new FloatRules.
         * @memberof validate
         * @classdesc Represents a FloatRules.
         * @implements IFloatRules
         * @constructor
         * @param {validate.IFloatRules=} [properties] Properties to set
         */
        function FloatRules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * FloatRules const.
         * @member {number} const
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype["const"] = 0;

        /**
         * FloatRules lt.
         * @member {number} lt
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype.lt = 0;

        /**
         * FloatRules lte.
         * @member {number} lte
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype.lte = 0;

        /**
         * FloatRules gt.
         * @member {number} gt
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype.gt = 0;

        /**
         * FloatRules gte.
         * @member {number} gte
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype.gte = 0;

        /**
         * FloatRules in.
         * @member {Array.<number>} in
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype["in"] = $util.emptyArray;

        /**
         * FloatRules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.FloatRules
         * @instance
         */
        FloatRules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies a FloatRules message.
         * @function verify
         * @memberof validate.FloatRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        FloatRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] !== "number")
                    return "const: number expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (typeof message.lt !== "number")
                    return "lt: number expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (typeof message.lte !== "number")
                    return "lte: number expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (typeof message.gt !== "number")
                    return "gt: number expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (typeof message.gte !== "number")
                    return "gte: number expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (typeof message["in"][i] !== "number")
                        return "in: number[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (typeof message.notIn[i] !== "number")
                        return "notIn: number[] expected";
            }
            return null;
        };

        /**
         * Creates a FloatRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.FloatRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.FloatRules} FloatRules
         */
        FloatRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.FloatRules)
                return object;
            let message = new $root.validate.FloatRules();
            if (object["const"] != null)
                message["const"] = Number(object["const"]);
            if (object.lt != null)
                message.lt = Number(object.lt);
            if (object.lte != null)
                message.lte = Number(object.lte);
            if (object.gt != null)
                message.gt = Number(object.gt);
            if (object.gte != null)
                message.gte = Number(object.gte);
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.FloatRules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = Number(object["in"][i]);
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.FloatRules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = Number(object.notIn[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a FloatRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.FloatRules
         * @static
         * @param {validate.FloatRules} message FloatRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        FloatRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.lt = 0;
                object.lte = 0;
                object.gt = 0;
                object.gte = 0;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = options.json && !isFinite(message["const"]) ? String(message["const"]) : message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = options.json && !isFinite(message.lt) ? String(message.lt) : message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = options.json && !isFinite(message.lte) ? String(message.lte) : message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = options.json && !isFinite(message.gt) ? String(message.gt) : message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = options.json && !isFinite(message.gte) ? String(message.gte) : message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = options.json && !isFinite(message["in"][j]) ? String(message["in"][j]) : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = options.json && !isFinite(message.notIn[j]) ? String(message.notIn[j]) : message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this FloatRules to JSON.
         * @function toJSON
         * @memberof validate.FloatRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        FloatRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return FloatRules;
    })();

    validate.DoubleRules = (function() {

        /**
         * Properties of a DoubleRules.
         * @memberof validate
         * @interface IDoubleRules
         * @property {number|null} ["const"] DoubleRules const
         * @property {number|null} [lt] DoubleRules lt
         * @property {number|null} [lte] DoubleRules lte
         * @property {number|null} [gt] DoubleRules gt
         * @property {number|null} [gte] DoubleRules gte
         * @property {Array.<number>|null} ["in"] DoubleRules in
         * @property {Array.<number>|null} [notIn] DoubleRules notIn
         */

        /**
         * Constructs a new DoubleRules.
         * @memberof validate
         * @classdesc Represents a DoubleRules.
         * @implements IDoubleRules
         * @constructor
         * @param {validate.IDoubleRules=} [properties] Properties to set
         */
        function DoubleRules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DoubleRules const.
         * @member {number} const
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype["const"] = 0;

        /**
         * DoubleRules lt.
         * @member {number} lt
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype.lt = 0;

        /**
         * DoubleRules lte.
         * @member {number} lte
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype.lte = 0;

        /**
         * DoubleRules gt.
         * @member {number} gt
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype.gt = 0;

        /**
         * DoubleRules gte.
         * @member {number} gte
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype.gte = 0;

        /**
         * DoubleRules in.
         * @member {Array.<number>} in
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype["in"] = $util.emptyArray;

        /**
         * DoubleRules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.DoubleRules
         * @instance
         */
        DoubleRules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies a DoubleRules message.
         * @function verify
         * @memberof validate.DoubleRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DoubleRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] !== "number")
                    return "const: number expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (typeof message.lt !== "number")
                    return "lt: number expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (typeof message.lte !== "number")
                    return "lte: number expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (typeof message.gt !== "number")
                    return "gt: number expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (typeof message.gte !== "number")
                    return "gte: number expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (typeof message["in"][i] !== "number")
                        return "in: number[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (typeof message.notIn[i] !== "number")
                        return "notIn: number[] expected";
            }
            return null;
        };

        /**
         * Creates a DoubleRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.DoubleRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.DoubleRules} DoubleRules
         */
        DoubleRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.DoubleRules)
                return object;
            let message = new $root.validate.DoubleRules();
            if (object["const"] != null)
                message["const"] = Number(object["const"]);
            if (object.lt != null)
                message.lt = Number(object.lt);
            if (object.lte != null)
                message.lte = Number(object.lte);
            if (object.gt != null)
                message.gt = Number(object.gt);
            if (object.gte != null)
                message.gte = Number(object.gte);
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.DoubleRules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = Number(object["in"][i]);
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.DoubleRules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = Number(object.notIn[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from a DoubleRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.DoubleRules
         * @static
         * @param {validate.DoubleRules} message DoubleRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DoubleRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.lt = 0;
                object.lte = 0;
                object.gt = 0;
                object.gte = 0;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = options.json && !isFinite(message["const"]) ? String(message["const"]) : message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = options.json && !isFinite(message.lt) ? String(message.lt) : message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = options.json && !isFinite(message.lte) ? String(message.lte) : message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = options.json && !isFinite(message.gt) ? String(message.gt) : message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = options.json && !isFinite(message.gte) ? String(message.gte) : message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = options.json && !isFinite(message["in"][j]) ? String(message["in"][j]) : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = options.json && !isFinite(message.notIn[j]) ? String(message.notIn[j]) : message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this DoubleRules to JSON.
         * @function toJSON
         * @memberof validate.DoubleRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DoubleRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DoubleRules;
    })();

    validate.Int32Rules = (function() {

        /**
         * Properties of an Int32Rules.
         * @memberof validate
         * @interface IInt32Rules
         * @property {number|null} ["const"] Int32Rules const
         * @property {number|null} [lt] Int32Rules lt
         * @property {number|null} [lte] Int32Rules lte
         * @property {number|null} [gt] Int32Rules gt
         * @property {number|null} [gte] Int32Rules gte
         * @property {Array.<number>|null} ["in"] Int32Rules in
         * @property {Array.<number>|null} [notIn] Int32Rules notIn
         */

        /**
         * Constructs a new Int32Rules.
         * @memberof validate
         * @classdesc Represents an Int32Rules.
         * @implements IInt32Rules
         * @constructor
         * @param {validate.IInt32Rules=} [properties] Properties to set
         */
        function Int32Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Int32Rules const.
         * @member {number} const
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype["const"] = 0;

        /**
         * Int32Rules lt.
         * @member {number} lt
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype.lt = 0;

        /**
         * Int32Rules lte.
         * @member {number} lte
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype.lte = 0;

        /**
         * Int32Rules gt.
         * @member {number} gt
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype.gt = 0;

        /**
         * Int32Rules gte.
         * @member {number} gte
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype.gte = 0;

        /**
         * Int32Rules in.
         * @member {Array.<number>} in
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype["in"] = $util.emptyArray;

        /**
         * Int32Rules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.Int32Rules
         * @instance
         */
        Int32Rules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies an Int32Rules message.
         * @function verify
         * @memberof validate.Int32Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Int32Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]))
                    return "const: integer expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt))
                    return "lt: integer expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte))
                    return "lte: integer expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt))
                    return "gt: integer expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte))
                    return "gte: integer expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]))
                        return "in: integer[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]))
                        return "notIn: integer[] expected";
            }
            return null;
        };

        /**
         * Creates an Int32Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.Int32Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.Int32Rules} Int32Rules
         */
        Int32Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.Int32Rules)
                return object;
            let message = new $root.validate.Int32Rules();
            if (object["const"] != null)
                message["const"] = object["const"] | 0;
            if (object.lt != null)
                message.lt = object.lt | 0;
            if (object.lte != null)
                message.lte = object.lte | 0;
            if (object.gt != null)
                message.gt = object.gt | 0;
            if (object.gte != null)
                message.gte = object.gte | 0;
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.Int32Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = object["in"][i] | 0;
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.Int32Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = object.notIn[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from an Int32Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.Int32Rules
         * @static
         * @param {validate.Int32Rules} message Int32Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Int32Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.lt = 0;
                object.lte = 0;
                object.gt = 0;
                object.gte = 0;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this Int32Rules to JSON.
         * @function toJSON
         * @memberof validate.Int32Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Int32Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Int32Rules;
    })();

    validate.Int64Rules = (function() {

        /**
         * Properties of an Int64Rules.
         * @memberof validate
         * @interface IInt64Rules
         * @property {number|Long|null} ["const"] Int64Rules const
         * @property {number|Long|null} [lt] Int64Rules lt
         * @property {number|Long|null} [lte] Int64Rules lte
         * @property {number|Long|null} [gt] Int64Rules gt
         * @property {number|Long|null} [gte] Int64Rules gte
         * @property {Array.<number|Long>|null} ["in"] Int64Rules in
         * @property {Array.<number|Long>|null} [notIn] Int64Rules notIn
         */

        /**
         * Constructs a new Int64Rules.
         * @memberof validate
         * @classdesc Represents an Int64Rules.
         * @implements IInt64Rules
         * @constructor
         * @param {validate.IInt64Rules=} [properties] Properties to set
         */
        function Int64Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Int64Rules const.
         * @member {number|Long} const
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype["const"] = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Int64Rules lt.
         * @member {number|Long} lt
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype.lt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Int64Rules lte.
         * @member {number|Long} lte
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype.lte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Int64Rules gt.
         * @member {number|Long} gt
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype.gt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Int64Rules gte.
         * @member {number|Long} gte
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype.gte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Int64Rules in.
         * @member {Array.<number|Long>} in
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype["in"] = $util.emptyArray;

        /**
         * Int64Rules notIn.
         * @member {Array.<number|Long>} notIn
         * @memberof validate.Int64Rules
         * @instance
         */
        Int64Rules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies an Int64Rules message.
         * @function verify
         * @memberof validate.Int64Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Int64Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]) && !(message["const"] && $util.isInteger(message["const"].low) && $util.isInteger(message["const"].high)))
                    return "const: integer|Long expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt) && !(message.lt && $util.isInteger(message.lt.low) && $util.isInteger(message.lt.high)))
                    return "lt: integer|Long expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte) && !(message.lte && $util.isInteger(message.lte.low) && $util.isInteger(message.lte.high)))
                    return "lte: integer|Long expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt) && !(message.gt && $util.isInteger(message.gt.low) && $util.isInteger(message.gt.high)))
                    return "gt: integer|Long expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte) && !(message.gte && $util.isInteger(message.gte.low) && $util.isInteger(message.gte.high)))
                    return "gte: integer|Long expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]) && !(message["in"][i] && $util.isInteger(message["in"][i].low) && $util.isInteger(message["in"][i].high)))
                        return "in: integer|Long[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]) && !(message.notIn[i] && $util.isInteger(message.notIn[i].low) && $util.isInteger(message.notIn[i].high)))
                        return "notIn: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates an Int64Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.Int64Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.Int64Rules} Int64Rules
         */
        Int64Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.Int64Rules)
                return object;
            let message = new $root.validate.Int64Rules();
            if (object["const"] != null)
                if ($util.Long)
                    (message["const"] = $util.Long.fromValue(object["const"])).unsigned = false;
                else if (typeof object["const"] === "string")
                    message["const"] = parseInt(object["const"], 10);
                else if (typeof object["const"] === "number")
                    message["const"] = object["const"];
                else if (typeof object["const"] === "object")
                    message["const"] = new $util.LongBits(object["const"].low >>> 0, object["const"].high >>> 0).toNumber();
            if (object.lt != null)
                if ($util.Long)
                    (message.lt = $util.Long.fromValue(object.lt)).unsigned = false;
                else if (typeof object.lt === "string")
                    message.lt = parseInt(object.lt, 10);
                else if (typeof object.lt === "number")
                    message.lt = object.lt;
                else if (typeof object.lt === "object")
                    message.lt = new $util.LongBits(object.lt.low >>> 0, object.lt.high >>> 0).toNumber();
            if (object.lte != null)
                if ($util.Long)
                    (message.lte = $util.Long.fromValue(object.lte)).unsigned = false;
                else if (typeof object.lte === "string")
                    message.lte = parseInt(object.lte, 10);
                else if (typeof object.lte === "number")
                    message.lte = object.lte;
                else if (typeof object.lte === "object")
                    message.lte = new $util.LongBits(object.lte.low >>> 0, object.lte.high >>> 0).toNumber();
            if (object.gt != null)
                if ($util.Long)
                    (message.gt = $util.Long.fromValue(object.gt)).unsigned = false;
                else if (typeof object.gt === "string")
                    message.gt = parseInt(object.gt, 10);
                else if (typeof object.gt === "number")
                    message.gt = object.gt;
                else if (typeof object.gt === "object")
                    message.gt = new $util.LongBits(object.gt.low >>> 0, object.gt.high >>> 0).toNumber();
            if (object.gte != null)
                if ($util.Long)
                    (message.gte = $util.Long.fromValue(object.gte)).unsigned = false;
                else if (typeof object.gte === "string")
                    message.gte = parseInt(object.gte, 10);
                else if (typeof object.gte === "number")
                    message.gte = object.gte;
                else if (typeof object.gte === "object")
                    message.gte = new $util.LongBits(object.gte.low >>> 0, object.gte.high >>> 0).toNumber();
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.Int64Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    if ($util.Long)
                        (message["in"][i] = $util.Long.fromValue(object["in"][i])).unsigned = false;
                    else if (typeof object["in"][i] === "string")
                        message["in"][i] = parseInt(object["in"][i], 10);
                    else if (typeof object["in"][i] === "number")
                        message["in"][i] = object["in"][i];
                    else if (typeof object["in"][i] === "object")
                        message["in"][i] = new $util.LongBits(object["in"][i].low >>> 0, object["in"][i].high >>> 0).toNumber();
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.Int64Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    if ($util.Long)
                        (message.notIn[i] = $util.Long.fromValue(object.notIn[i])).unsigned = false;
                    else if (typeof object.notIn[i] === "string")
                        message.notIn[i] = parseInt(object.notIn[i], 10);
                    else if (typeof object.notIn[i] === "number")
                        message.notIn[i] = object.notIn[i];
                    else if (typeof object.notIn[i] === "object")
                        message.notIn[i] = new $util.LongBits(object.notIn[i].low >>> 0, object.notIn[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from an Int64Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.Int64Rules
         * @static
         * @param {validate.Int64Rules} message Int64Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Int64Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object["const"] = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object["const"] = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lte = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gte = options.longs === String ? "0" : 0;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] === "number")
                    object["const"] = options.longs === String ? String(message["const"]) : message["const"];
                else
                    object["const"] = options.longs === String ? $util.Long.prototype.toString.call(message["const"]) : options.longs === Number ? new $util.LongBits(message["const"].low >>> 0, message["const"].high >>> 0).toNumber() : message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (typeof message.lt === "number")
                    object.lt = options.longs === String ? String(message.lt) : message.lt;
                else
                    object.lt = options.longs === String ? $util.Long.prototype.toString.call(message.lt) : options.longs === Number ? new $util.LongBits(message.lt.low >>> 0, message.lt.high >>> 0).toNumber() : message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (typeof message.lte === "number")
                    object.lte = options.longs === String ? String(message.lte) : message.lte;
                else
                    object.lte = options.longs === String ? $util.Long.prototype.toString.call(message.lte) : options.longs === Number ? new $util.LongBits(message.lte.low >>> 0, message.lte.high >>> 0).toNumber() : message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (typeof message.gt === "number")
                    object.gt = options.longs === String ? String(message.gt) : message.gt;
                else
                    object.gt = options.longs === String ? $util.Long.prototype.toString.call(message.gt) : options.longs === Number ? new $util.LongBits(message.gt.low >>> 0, message.gt.high >>> 0).toNumber() : message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (typeof message.gte === "number")
                    object.gte = options.longs === String ? String(message.gte) : message.gte;
                else
                    object.gte = options.longs === String ? $util.Long.prototype.toString.call(message.gte) : options.longs === Number ? new $util.LongBits(message.gte.low >>> 0, message.gte.high >>> 0).toNumber() : message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    if (typeof message["in"][j] === "number")
                        object["in"][j] = options.longs === String ? String(message["in"][j]) : message["in"][j];
                    else
                        object["in"][j] = options.longs === String ? $util.Long.prototype.toString.call(message["in"][j]) : options.longs === Number ? new $util.LongBits(message["in"][j].low >>> 0, message["in"][j].high >>> 0).toNumber() : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    if (typeof message.notIn[j] === "number")
                        object.notIn[j] = options.longs === String ? String(message.notIn[j]) : message.notIn[j];
                    else
                        object.notIn[j] = options.longs === String ? $util.Long.prototype.toString.call(message.notIn[j]) : options.longs === Number ? new $util.LongBits(message.notIn[j].low >>> 0, message.notIn[j].high >>> 0).toNumber() : message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this Int64Rules to JSON.
         * @function toJSON
         * @memberof validate.Int64Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Int64Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Int64Rules;
    })();

    validate.UInt32Rules = (function() {

        /**
         * Properties of a UInt32Rules.
         * @memberof validate
         * @interface IUInt32Rules
         * @property {number|null} ["const"] UInt32Rules const
         * @property {number|null} [lt] UInt32Rules lt
         * @property {number|null} [lte] UInt32Rules lte
         * @property {number|null} [gt] UInt32Rules gt
         * @property {number|null} [gte] UInt32Rules gte
         * @property {Array.<number>|null} ["in"] UInt32Rules in
         * @property {Array.<number>|null} [notIn] UInt32Rules notIn
         */

        /**
         * Constructs a new UInt32Rules.
         * @memberof validate
         * @classdesc Represents a UInt32Rules.
         * @implements IUInt32Rules
         * @constructor
         * @param {validate.IUInt32Rules=} [properties] Properties to set
         */
        function UInt32Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UInt32Rules const.
         * @member {number} const
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype["const"] = 0;

        /**
         * UInt32Rules lt.
         * @member {number} lt
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype.lt = 0;

        /**
         * UInt32Rules lte.
         * @member {number} lte
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype.lte = 0;

        /**
         * UInt32Rules gt.
         * @member {number} gt
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype.gt = 0;

        /**
         * UInt32Rules gte.
         * @member {number} gte
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype.gte = 0;

        /**
         * UInt32Rules in.
         * @member {Array.<number>} in
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype["in"] = $util.emptyArray;

        /**
         * UInt32Rules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.UInt32Rules
         * @instance
         */
        UInt32Rules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies a UInt32Rules message.
         * @function verify
         * @memberof validate.UInt32Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UInt32Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]))
                    return "const: integer expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt))
                    return "lt: integer expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte))
                    return "lte: integer expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt))
                    return "gt: integer expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte))
                    return "gte: integer expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]))
                        return "in: integer[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]))
                        return "notIn: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a UInt32Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.UInt32Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.UInt32Rules} UInt32Rules
         */
        UInt32Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.UInt32Rules)
                return object;
            let message = new $root.validate.UInt32Rules();
            if (object["const"] != null)
                message["const"] = object["const"] >>> 0;
            if (object.lt != null)
                message.lt = object.lt >>> 0;
            if (object.lte != null)
                message.lte = object.lte >>> 0;
            if (object.gt != null)
                message.gt = object.gt >>> 0;
            if (object.gte != null)
                message.gte = object.gte >>> 0;
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.UInt32Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = object["in"][i] >>> 0;
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.UInt32Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = object.notIn[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a UInt32Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.UInt32Rules
         * @static
         * @param {validate.UInt32Rules} message UInt32Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UInt32Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.lt = 0;
                object.lte = 0;
                object.gt = 0;
                object.gte = 0;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this UInt32Rules to JSON.
         * @function toJSON
         * @memberof validate.UInt32Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UInt32Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UInt32Rules;
    })();

    validate.UInt64Rules = (function() {

        /**
         * Properties of a UInt64Rules.
         * @memberof validate
         * @interface IUInt64Rules
         * @property {number|Long|null} ["const"] UInt64Rules const
         * @property {number|Long|null} [lt] UInt64Rules lt
         * @property {number|Long|null} [lte] UInt64Rules lte
         * @property {number|Long|null} [gt] UInt64Rules gt
         * @property {number|Long|null} [gte] UInt64Rules gte
         * @property {Array.<number|Long>|null} ["in"] UInt64Rules in
         * @property {Array.<number|Long>|null} [notIn] UInt64Rules notIn
         */

        /**
         * Constructs a new UInt64Rules.
         * @memberof validate
         * @classdesc Represents a UInt64Rules.
         * @implements IUInt64Rules
         * @constructor
         * @param {validate.IUInt64Rules=} [properties] Properties to set
         */
        function UInt64Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * UInt64Rules const.
         * @member {number|Long} const
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype["const"] = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UInt64Rules lt.
         * @member {number|Long} lt
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype.lt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UInt64Rules lte.
         * @member {number|Long} lte
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype.lte = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UInt64Rules gt.
         * @member {number|Long} gt
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype.gt = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UInt64Rules gte.
         * @member {number|Long} gte
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype.gte = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * UInt64Rules in.
         * @member {Array.<number|Long>} in
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype["in"] = $util.emptyArray;

        /**
         * UInt64Rules notIn.
         * @member {Array.<number|Long>} notIn
         * @memberof validate.UInt64Rules
         * @instance
         */
        UInt64Rules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies a UInt64Rules message.
         * @function verify
         * @memberof validate.UInt64Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        UInt64Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]) && !(message["const"] && $util.isInteger(message["const"].low) && $util.isInteger(message["const"].high)))
                    return "const: integer|Long expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt) && !(message.lt && $util.isInteger(message.lt.low) && $util.isInteger(message.lt.high)))
                    return "lt: integer|Long expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte) && !(message.lte && $util.isInteger(message.lte.low) && $util.isInteger(message.lte.high)))
                    return "lte: integer|Long expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt) && !(message.gt && $util.isInteger(message.gt.low) && $util.isInteger(message.gt.high)))
                    return "gt: integer|Long expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte) && !(message.gte && $util.isInteger(message.gte.low) && $util.isInteger(message.gte.high)))
                    return "gte: integer|Long expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]) && !(message["in"][i] && $util.isInteger(message["in"][i].low) && $util.isInteger(message["in"][i].high)))
                        return "in: integer|Long[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]) && !(message.notIn[i] && $util.isInteger(message.notIn[i].low) && $util.isInteger(message.notIn[i].high)))
                        return "notIn: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a UInt64Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.UInt64Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.UInt64Rules} UInt64Rules
         */
        UInt64Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.UInt64Rules)
                return object;
            let message = new $root.validate.UInt64Rules();
            if (object["const"] != null)
                if ($util.Long)
                    (message["const"] = $util.Long.fromValue(object["const"])).unsigned = true;
                else if (typeof object["const"] === "string")
                    message["const"] = parseInt(object["const"], 10);
                else if (typeof object["const"] === "number")
                    message["const"] = object["const"];
                else if (typeof object["const"] === "object")
                    message["const"] = new $util.LongBits(object["const"].low >>> 0, object["const"].high >>> 0).toNumber(true);
            if (object.lt != null)
                if ($util.Long)
                    (message.lt = $util.Long.fromValue(object.lt)).unsigned = true;
                else if (typeof object.lt === "string")
                    message.lt = parseInt(object.lt, 10);
                else if (typeof object.lt === "number")
                    message.lt = object.lt;
                else if (typeof object.lt === "object")
                    message.lt = new $util.LongBits(object.lt.low >>> 0, object.lt.high >>> 0).toNumber(true);
            if (object.lte != null)
                if ($util.Long)
                    (message.lte = $util.Long.fromValue(object.lte)).unsigned = true;
                else if (typeof object.lte === "string")
                    message.lte = parseInt(object.lte, 10);
                else if (typeof object.lte === "number")
                    message.lte = object.lte;
                else if (typeof object.lte === "object")
                    message.lte = new $util.LongBits(object.lte.low >>> 0, object.lte.high >>> 0).toNumber(true);
            if (object.gt != null)
                if ($util.Long)
                    (message.gt = $util.Long.fromValue(object.gt)).unsigned = true;
                else if (typeof object.gt === "string")
                    message.gt = parseInt(object.gt, 10);
                else if (typeof object.gt === "number")
                    message.gt = object.gt;
                else if (typeof object.gt === "object")
                    message.gt = new $util.LongBits(object.gt.low >>> 0, object.gt.high >>> 0).toNumber(true);
            if (object.gte != null)
                if ($util.Long)
                    (message.gte = $util.Long.fromValue(object.gte)).unsigned = true;
                else if (typeof object.gte === "string")
                    message.gte = parseInt(object.gte, 10);
                else if (typeof object.gte === "number")
                    message.gte = object.gte;
                else if (typeof object.gte === "object")
                    message.gte = new $util.LongBits(object.gte.low >>> 0, object.gte.high >>> 0).toNumber(true);
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.UInt64Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    if ($util.Long)
                        (message["in"][i] = $util.Long.fromValue(object["in"][i])).unsigned = true;
                    else if (typeof object["in"][i] === "string")
                        message["in"][i] = parseInt(object["in"][i], 10);
                    else if (typeof object["in"][i] === "number")
                        message["in"][i] = object["in"][i];
                    else if (typeof object["in"][i] === "object")
                        message["in"][i] = new $util.LongBits(object["in"][i].low >>> 0, object["in"][i].high >>> 0).toNumber(true);
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.UInt64Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    if ($util.Long)
                        (message.notIn[i] = $util.Long.fromValue(object.notIn[i])).unsigned = true;
                    else if (typeof object.notIn[i] === "string")
                        message.notIn[i] = parseInt(object.notIn[i], 10);
                    else if (typeof object.notIn[i] === "number")
                        message.notIn[i] = object.notIn[i];
                    else if (typeof object.notIn[i] === "object")
                        message.notIn[i] = new $util.LongBits(object.notIn[i].low >>> 0, object.notIn[i].high >>> 0).toNumber(true);
            }
            return message;
        };

        /**
         * Creates a plain object from a UInt64Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.UInt64Rules
         * @static
         * @param {validate.UInt64Rules} message UInt64Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        UInt64Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object["const"] = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object["const"] = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.lt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.lte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lte = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.gt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.gte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gte = options.longs === String ? "0" : 0;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] === "number")
                    object["const"] = options.longs === String ? String(message["const"]) : message["const"];
                else
                    object["const"] = options.longs === String ? $util.Long.prototype.toString.call(message["const"]) : options.longs === Number ? new $util.LongBits(message["const"].low >>> 0, message["const"].high >>> 0).toNumber(true) : message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (typeof message.lt === "number")
                    object.lt = options.longs === String ? String(message.lt) : message.lt;
                else
                    object.lt = options.longs === String ? $util.Long.prototype.toString.call(message.lt) : options.longs === Number ? new $util.LongBits(message.lt.low >>> 0, message.lt.high >>> 0).toNumber(true) : message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (typeof message.lte === "number")
                    object.lte = options.longs === String ? String(message.lte) : message.lte;
                else
                    object.lte = options.longs === String ? $util.Long.prototype.toString.call(message.lte) : options.longs === Number ? new $util.LongBits(message.lte.low >>> 0, message.lte.high >>> 0).toNumber(true) : message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (typeof message.gt === "number")
                    object.gt = options.longs === String ? String(message.gt) : message.gt;
                else
                    object.gt = options.longs === String ? $util.Long.prototype.toString.call(message.gt) : options.longs === Number ? new $util.LongBits(message.gt.low >>> 0, message.gt.high >>> 0).toNumber(true) : message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (typeof message.gte === "number")
                    object.gte = options.longs === String ? String(message.gte) : message.gte;
                else
                    object.gte = options.longs === String ? $util.Long.prototype.toString.call(message.gte) : options.longs === Number ? new $util.LongBits(message.gte.low >>> 0, message.gte.high >>> 0).toNumber(true) : message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    if (typeof message["in"][j] === "number")
                        object["in"][j] = options.longs === String ? String(message["in"][j]) : message["in"][j];
                    else
                        object["in"][j] = options.longs === String ? $util.Long.prototype.toString.call(message["in"][j]) : options.longs === Number ? new $util.LongBits(message["in"][j].low >>> 0, message["in"][j].high >>> 0).toNumber(true) : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    if (typeof message.notIn[j] === "number")
                        object.notIn[j] = options.longs === String ? String(message.notIn[j]) : message.notIn[j];
                    else
                        object.notIn[j] = options.longs === String ? $util.Long.prototype.toString.call(message.notIn[j]) : options.longs === Number ? new $util.LongBits(message.notIn[j].low >>> 0, message.notIn[j].high >>> 0).toNumber(true) : message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this UInt64Rules to JSON.
         * @function toJSON
         * @memberof validate.UInt64Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        UInt64Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return UInt64Rules;
    })();

    validate.SInt32Rules = (function() {

        /**
         * Properties of a SInt32Rules.
         * @memberof validate
         * @interface ISInt32Rules
         * @property {number|null} ["const"] SInt32Rules const
         * @property {number|null} [lt] SInt32Rules lt
         * @property {number|null} [lte] SInt32Rules lte
         * @property {number|null} [gt] SInt32Rules gt
         * @property {number|null} [gte] SInt32Rules gte
         * @property {Array.<number>|null} ["in"] SInt32Rules in
         * @property {Array.<number>|null} [notIn] SInt32Rules notIn
         */

        /**
         * Constructs a new SInt32Rules.
         * @memberof validate
         * @classdesc Represents a SInt32Rules.
         * @implements ISInt32Rules
         * @constructor
         * @param {validate.ISInt32Rules=} [properties] Properties to set
         */
        function SInt32Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SInt32Rules const.
         * @member {number} const
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype["const"] = 0;

        /**
         * SInt32Rules lt.
         * @member {number} lt
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype.lt = 0;

        /**
         * SInt32Rules lte.
         * @member {number} lte
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype.lte = 0;

        /**
         * SInt32Rules gt.
         * @member {number} gt
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype.gt = 0;

        /**
         * SInt32Rules gte.
         * @member {number} gte
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype.gte = 0;

        /**
         * SInt32Rules in.
         * @member {Array.<number>} in
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype["in"] = $util.emptyArray;

        /**
         * SInt32Rules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.SInt32Rules
         * @instance
         */
        SInt32Rules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies a SInt32Rules message.
         * @function verify
         * @memberof validate.SInt32Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SInt32Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]))
                    return "const: integer expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt))
                    return "lt: integer expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte))
                    return "lte: integer expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt))
                    return "gt: integer expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte))
                    return "gte: integer expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]))
                        return "in: integer[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]))
                        return "notIn: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a SInt32Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.SInt32Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.SInt32Rules} SInt32Rules
         */
        SInt32Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.SInt32Rules)
                return object;
            let message = new $root.validate.SInt32Rules();
            if (object["const"] != null)
                message["const"] = object["const"] | 0;
            if (object.lt != null)
                message.lt = object.lt | 0;
            if (object.lte != null)
                message.lte = object.lte | 0;
            if (object.gt != null)
                message.gt = object.gt | 0;
            if (object.gte != null)
                message.gte = object.gte | 0;
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.SInt32Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = object["in"][i] | 0;
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.SInt32Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = object.notIn[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a SInt32Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.SInt32Rules
         * @static
         * @param {validate.SInt32Rules} message SInt32Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SInt32Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.lt = 0;
                object.lte = 0;
                object.gt = 0;
                object.gte = 0;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this SInt32Rules to JSON.
         * @function toJSON
         * @memberof validate.SInt32Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SInt32Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SInt32Rules;
    })();

    validate.SInt64Rules = (function() {

        /**
         * Properties of a SInt64Rules.
         * @memberof validate
         * @interface ISInt64Rules
         * @property {number|Long|null} ["const"] SInt64Rules const
         * @property {number|Long|null} [lt] SInt64Rules lt
         * @property {number|Long|null} [lte] SInt64Rules lte
         * @property {number|Long|null} [gt] SInt64Rules gt
         * @property {number|Long|null} [gte] SInt64Rules gte
         * @property {Array.<number|Long>|null} ["in"] SInt64Rules in
         * @property {Array.<number|Long>|null} [notIn] SInt64Rules notIn
         */

        /**
         * Constructs a new SInt64Rules.
         * @memberof validate
         * @classdesc Represents a SInt64Rules.
         * @implements ISInt64Rules
         * @constructor
         * @param {validate.ISInt64Rules=} [properties] Properties to set
         */
        function SInt64Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SInt64Rules const.
         * @member {number|Long} const
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype["const"] = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SInt64Rules lt.
         * @member {number|Long} lt
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype.lt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SInt64Rules lte.
         * @member {number|Long} lte
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype.lte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SInt64Rules gt.
         * @member {number|Long} gt
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype.gt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SInt64Rules gte.
         * @member {number|Long} gte
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype.gte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SInt64Rules in.
         * @member {Array.<number|Long>} in
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype["in"] = $util.emptyArray;

        /**
         * SInt64Rules notIn.
         * @member {Array.<number|Long>} notIn
         * @memberof validate.SInt64Rules
         * @instance
         */
        SInt64Rules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies a SInt64Rules message.
         * @function verify
         * @memberof validate.SInt64Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SInt64Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]) && !(message["const"] && $util.isInteger(message["const"].low) && $util.isInteger(message["const"].high)))
                    return "const: integer|Long expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt) && !(message.lt && $util.isInteger(message.lt.low) && $util.isInteger(message.lt.high)))
                    return "lt: integer|Long expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte) && !(message.lte && $util.isInteger(message.lte.low) && $util.isInteger(message.lte.high)))
                    return "lte: integer|Long expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt) && !(message.gt && $util.isInteger(message.gt.low) && $util.isInteger(message.gt.high)))
                    return "gt: integer|Long expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte) && !(message.gte && $util.isInteger(message.gte.low) && $util.isInteger(message.gte.high)))
                    return "gte: integer|Long expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]) && !(message["in"][i] && $util.isInteger(message["in"][i].low) && $util.isInteger(message["in"][i].high)))
                        return "in: integer|Long[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]) && !(message.notIn[i] && $util.isInteger(message.notIn[i].low) && $util.isInteger(message.notIn[i].high)))
                        return "notIn: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a SInt64Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.SInt64Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.SInt64Rules} SInt64Rules
         */
        SInt64Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.SInt64Rules)
                return object;
            let message = new $root.validate.SInt64Rules();
            if (object["const"] != null)
                if ($util.Long)
                    (message["const"] = $util.Long.fromValue(object["const"])).unsigned = false;
                else if (typeof object["const"] === "string")
                    message["const"] = parseInt(object["const"], 10);
                else if (typeof object["const"] === "number")
                    message["const"] = object["const"];
                else if (typeof object["const"] === "object")
                    message["const"] = new $util.LongBits(object["const"].low >>> 0, object["const"].high >>> 0).toNumber();
            if (object.lt != null)
                if ($util.Long)
                    (message.lt = $util.Long.fromValue(object.lt)).unsigned = false;
                else if (typeof object.lt === "string")
                    message.lt = parseInt(object.lt, 10);
                else if (typeof object.lt === "number")
                    message.lt = object.lt;
                else if (typeof object.lt === "object")
                    message.lt = new $util.LongBits(object.lt.low >>> 0, object.lt.high >>> 0).toNumber();
            if (object.lte != null)
                if ($util.Long)
                    (message.lte = $util.Long.fromValue(object.lte)).unsigned = false;
                else if (typeof object.lte === "string")
                    message.lte = parseInt(object.lte, 10);
                else if (typeof object.lte === "number")
                    message.lte = object.lte;
                else if (typeof object.lte === "object")
                    message.lte = new $util.LongBits(object.lte.low >>> 0, object.lte.high >>> 0).toNumber();
            if (object.gt != null)
                if ($util.Long)
                    (message.gt = $util.Long.fromValue(object.gt)).unsigned = false;
                else if (typeof object.gt === "string")
                    message.gt = parseInt(object.gt, 10);
                else if (typeof object.gt === "number")
                    message.gt = object.gt;
                else if (typeof object.gt === "object")
                    message.gt = new $util.LongBits(object.gt.low >>> 0, object.gt.high >>> 0).toNumber();
            if (object.gte != null)
                if ($util.Long)
                    (message.gte = $util.Long.fromValue(object.gte)).unsigned = false;
                else if (typeof object.gte === "string")
                    message.gte = parseInt(object.gte, 10);
                else if (typeof object.gte === "number")
                    message.gte = object.gte;
                else if (typeof object.gte === "object")
                    message.gte = new $util.LongBits(object.gte.low >>> 0, object.gte.high >>> 0).toNumber();
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.SInt64Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    if ($util.Long)
                        (message["in"][i] = $util.Long.fromValue(object["in"][i])).unsigned = false;
                    else if (typeof object["in"][i] === "string")
                        message["in"][i] = parseInt(object["in"][i], 10);
                    else if (typeof object["in"][i] === "number")
                        message["in"][i] = object["in"][i];
                    else if (typeof object["in"][i] === "object")
                        message["in"][i] = new $util.LongBits(object["in"][i].low >>> 0, object["in"][i].high >>> 0).toNumber();
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.SInt64Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    if ($util.Long)
                        (message.notIn[i] = $util.Long.fromValue(object.notIn[i])).unsigned = false;
                    else if (typeof object.notIn[i] === "string")
                        message.notIn[i] = parseInt(object.notIn[i], 10);
                    else if (typeof object.notIn[i] === "number")
                        message.notIn[i] = object.notIn[i];
                    else if (typeof object.notIn[i] === "object")
                        message.notIn[i] = new $util.LongBits(object.notIn[i].low >>> 0, object.notIn[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a SInt64Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.SInt64Rules
         * @static
         * @param {validate.SInt64Rules} message SInt64Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SInt64Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object["const"] = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object["const"] = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lte = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gte = options.longs === String ? "0" : 0;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] === "number")
                    object["const"] = options.longs === String ? String(message["const"]) : message["const"];
                else
                    object["const"] = options.longs === String ? $util.Long.prototype.toString.call(message["const"]) : options.longs === Number ? new $util.LongBits(message["const"].low >>> 0, message["const"].high >>> 0).toNumber() : message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (typeof message.lt === "number")
                    object.lt = options.longs === String ? String(message.lt) : message.lt;
                else
                    object.lt = options.longs === String ? $util.Long.prototype.toString.call(message.lt) : options.longs === Number ? new $util.LongBits(message.lt.low >>> 0, message.lt.high >>> 0).toNumber() : message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (typeof message.lte === "number")
                    object.lte = options.longs === String ? String(message.lte) : message.lte;
                else
                    object.lte = options.longs === String ? $util.Long.prototype.toString.call(message.lte) : options.longs === Number ? new $util.LongBits(message.lte.low >>> 0, message.lte.high >>> 0).toNumber() : message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (typeof message.gt === "number")
                    object.gt = options.longs === String ? String(message.gt) : message.gt;
                else
                    object.gt = options.longs === String ? $util.Long.prototype.toString.call(message.gt) : options.longs === Number ? new $util.LongBits(message.gt.low >>> 0, message.gt.high >>> 0).toNumber() : message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (typeof message.gte === "number")
                    object.gte = options.longs === String ? String(message.gte) : message.gte;
                else
                    object.gte = options.longs === String ? $util.Long.prototype.toString.call(message.gte) : options.longs === Number ? new $util.LongBits(message.gte.low >>> 0, message.gte.high >>> 0).toNumber() : message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    if (typeof message["in"][j] === "number")
                        object["in"][j] = options.longs === String ? String(message["in"][j]) : message["in"][j];
                    else
                        object["in"][j] = options.longs === String ? $util.Long.prototype.toString.call(message["in"][j]) : options.longs === Number ? new $util.LongBits(message["in"][j].low >>> 0, message["in"][j].high >>> 0).toNumber() : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    if (typeof message.notIn[j] === "number")
                        object.notIn[j] = options.longs === String ? String(message.notIn[j]) : message.notIn[j];
                    else
                        object.notIn[j] = options.longs === String ? $util.Long.prototype.toString.call(message.notIn[j]) : options.longs === Number ? new $util.LongBits(message.notIn[j].low >>> 0, message.notIn[j].high >>> 0).toNumber() : message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this SInt64Rules to JSON.
         * @function toJSON
         * @memberof validate.SInt64Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SInt64Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SInt64Rules;
    })();

    validate.Fixed32Rules = (function() {

        /**
         * Properties of a Fixed32Rules.
         * @memberof validate
         * @interface IFixed32Rules
         * @property {number|null} ["const"] Fixed32Rules const
         * @property {number|null} [lt] Fixed32Rules lt
         * @property {number|null} [lte] Fixed32Rules lte
         * @property {number|null} [gt] Fixed32Rules gt
         * @property {number|null} [gte] Fixed32Rules gte
         * @property {Array.<number>|null} ["in"] Fixed32Rules in
         * @property {Array.<number>|null} [notIn] Fixed32Rules notIn
         */

        /**
         * Constructs a new Fixed32Rules.
         * @memberof validate
         * @classdesc Represents a Fixed32Rules.
         * @implements IFixed32Rules
         * @constructor
         * @param {validate.IFixed32Rules=} [properties] Properties to set
         */
        function Fixed32Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Fixed32Rules const.
         * @member {number} const
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype["const"] = 0;

        /**
         * Fixed32Rules lt.
         * @member {number} lt
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype.lt = 0;

        /**
         * Fixed32Rules lte.
         * @member {number} lte
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype.lte = 0;

        /**
         * Fixed32Rules gt.
         * @member {number} gt
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype.gt = 0;

        /**
         * Fixed32Rules gte.
         * @member {number} gte
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype.gte = 0;

        /**
         * Fixed32Rules in.
         * @member {Array.<number>} in
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype["in"] = $util.emptyArray;

        /**
         * Fixed32Rules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.Fixed32Rules
         * @instance
         */
        Fixed32Rules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies a Fixed32Rules message.
         * @function verify
         * @memberof validate.Fixed32Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Fixed32Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]))
                    return "const: integer expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt))
                    return "lt: integer expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte))
                    return "lte: integer expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt))
                    return "gt: integer expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte))
                    return "gte: integer expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]))
                        return "in: integer[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]))
                        return "notIn: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a Fixed32Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.Fixed32Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.Fixed32Rules} Fixed32Rules
         */
        Fixed32Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.Fixed32Rules)
                return object;
            let message = new $root.validate.Fixed32Rules();
            if (object["const"] != null)
                message["const"] = object["const"] >>> 0;
            if (object.lt != null)
                message.lt = object.lt >>> 0;
            if (object.lte != null)
                message.lte = object.lte >>> 0;
            if (object.gt != null)
                message.gt = object.gt >>> 0;
            if (object.gte != null)
                message.gte = object.gte >>> 0;
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.Fixed32Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = object["in"][i] >>> 0;
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.Fixed32Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = object.notIn[i] >>> 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a Fixed32Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.Fixed32Rules
         * @static
         * @param {validate.Fixed32Rules} message Fixed32Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Fixed32Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.lt = 0;
                object.lte = 0;
                object.gt = 0;
                object.gte = 0;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this Fixed32Rules to JSON.
         * @function toJSON
         * @memberof validate.Fixed32Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Fixed32Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Fixed32Rules;
    })();

    validate.Fixed64Rules = (function() {

        /**
         * Properties of a Fixed64Rules.
         * @memberof validate
         * @interface IFixed64Rules
         * @property {number|Long|null} ["const"] Fixed64Rules const
         * @property {number|Long|null} [lt] Fixed64Rules lt
         * @property {number|Long|null} [lte] Fixed64Rules lte
         * @property {number|Long|null} [gt] Fixed64Rules gt
         * @property {number|Long|null} [gte] Fixed64Rules gte
         * @property {Array.<number|Long>|null} ["in"] Fixed64Rules in
         * @property {Array.<number|Long>|null} [notIn] Fixed64Rules notIn
         */

        /**
         * Constructs a new Fixed64Rules.
         * @memberof validate
         * @classdesc Represents a Fixed64Rules.
         * @implements IFixed64Rules
         * @constructor
         * @param {validate.IFixed64Rules=} [properties] Properties to set
         */
        function Fixed64Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * Fixed64Rules const.
         * @member {number|Long} const
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype["const"] = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fixed64Rules lt.
         * @member {number|Long} lt
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype.lt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fixed64Rules lte.
         * @member {number|Long} lte
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype.lte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fixed64Rules gt.
         * @member {number|Long} gt
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype.gt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fixed64Rules gte.
         * @member {number|Long} gte
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype.gte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * Fixed64Rules in.
         * @member {Array.<number|Long>} in
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype["in"] = $util.emptyArray;

        /**
         * Fixed64Rules notIn.
         * @member {Array.<number|Long>} notIn
         * @memberof validate.Fixed64Rules
         * @instance
         */
        Fixed64Rules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies a Fixed64Rules message.
         * @function verify
         * @memberof validate.Fixed64Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        Fixed64Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]) && !(message["const"] && $util.isInteger(message["const"].low) && $util.isInteger(message["const"].high)))
                    return "const: integer|Long expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt) && !(message.lt && $util.isInteger(message.lt.low) && $util.isInteger(message.lt.high)))
                    return "lt: integer|Long expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte) && !(message.lte && $util.isInteger(message.lte.low) && $util.isInteger(message.lte.high)))
                    return "lte: integer|Long expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt) && !(message.gt && $util.isInteger(message.gt.low) && $util.isInteger(message.gt.high)))
                    return "gt: integer|Long expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte) && !(message.gte && $util.isInteger(message.gte.low) && $util.isInteger(message.gte.high)))
                    return "gte: integer|Long expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]) && !(message["in"][i] && $util.isInteger(message["in"][i].low) && $util.isInteger(message["in"][i].high)))
                        return "in: integer|Long[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]) && !(message.notIn[i] && $util.isInteger(message.notIn[i].low) && $util.isInteger(message.notIn[i].high)))
                        return "notIn: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a Fixed64Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.Fixed64Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.Fixed64Rules} Fixed64Rules
         */
        Fixed64Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.Fixed64Rules)
                return object;
            let message = new $root.validate.Fixed64Rules();
            if (object["const"] != null)
                if ($util.Long)
                    (message["const"] = $util.Long.fromValue(object["const"])).unsigned = false;
                else if (typeof object["const"] === "string")
                    message["const"] = parseInt(object["const"], 10);
                else if (typeof object["const"] === "number")
                    message["const"] = object["const"];
                else if (typeof object["const"] === "object")
                    message["const"] = new $util.LongBits(object["const"].low >>> 0, object["const"].high >>> 0).toNumber();
            if (object.lt != null)
                if ($util.Long)
                    (message.lt = $util.Long.fromValue(object.lt)).unsigned = false;
                else if (typeof object.lt === "string")
                    message.lt = parseInt(object.lt, 10);
                else if (typeof object.lt === "number")
                    message.lt = object.lt;
                else if (typeof object.lt === "object")
                    message.lt = new $util.LongBits(object.lt.low >>> 0, object.lt.high >>> 0).toNumber();
            if (object.lte != null)
                if ($util.Long)
                    (message.lte = $util.Long.fromValue(object.lte)).unsigned = false;
                else if (typeof object.lte === "string")
                    message.lte = parseInt(object.lte, 10);
                else if (typeof object.lte === "number")
                    message.lte = object.lte;
                else if (typeof object.lte === "object")
                    message.lte = new $util.LongBits(object.lte.low >>> 0, object.lte.high >>> 0).toNumber();
            if (object.gt != null)
                if ($util.Long)
                    (message.gt = $util.Long.fromValue(object.gt)).unsigned = false;
                else if (typeof object.gt === "string")
                    message.gt = parseInt(object.gt, 10);
                else if (typeof object.gt === "number")
                    message.gt = object.gt;
                else if (typeof object.gt === "object")
                    message.gt = new $util.LongBits(object.gt.low >>> 0, object.gt.high >>> 0).toNumber();
            if (object.gte != null)
                if ($util.Long)
                    (message.gte = $util.Long.fromValue(object.gte)).unsigned = false;
                else if (typeof object.gte === "string")
                    message.gte = parseInt(object.gte, 10);
                else if (typeof object.gte === "number")
                    message.gte = object.gte;
                else if (typeof object.gte === "object")
                    message.gte = new $util.LongBits(object.gte.low >>> 0, object.gte.high >>> 0).toNumber();
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.Fixed64Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    if ($util.Long)
                        (message["in"][i] = $util.Long.fromValue(object["in"][i])).unsigned = false;
                    else if (typeof object["in"][i] === "string")
                        message["in"][i] = parseInt(object["in"][i], 10);
                    else if (typeof object["in"][i] === "number")
                        message["in"][i] = object["in"][i];
                    else if (typeof object["in"][i] === "object")
                        message["in"][i] = new $util.LongBits(object["in"][i].low >>> 0, object["in"][i].high >>> 0).toNumber();
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.Fixed64Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    if ($util.Long)
                        (message.notIn[i] = $util.Long.fromValue(object.notIn[i])).unsigned = false;
                    else if (typeof object.notIn[i] === "string")
                        message.notIn[i] = parseInt(object.notIn[i], 10);
                    else if (typeof object.notIn[i] === "number")
                        message.notIn[i] = object.notIn[i];
                    else if (typeof object.notIn[i] === "object")
                        message.notIn[i] = new $util.LongBits(object.notIn[i].low >>> 0, object.notIn[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a Fixed64Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.Fixed64Rules
         * @static
         * @param {validate.Fixed64Rules} message Fixed64Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        Fixed64Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object["const"] = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object["const"] = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lte = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gte = options.longs === String ? "0" : 0;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] === "number")
                    object["const"] = options.longs === String ? String(message["const"]) : message["const"];
                else
                    object["const"] = options.longs === String ? $util.Long.prototype.toString.call(message["const"]) : options.longs === Number ? new $util.LongBits(message["const"].low >>> 0, message["const"].high >>> 0).toNumber() : message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (typeof message.lt === "number")
                    object.lt = options.longs === String ? String(message.lt) : message.lt;
                else
                    object.lt = options.longs === String ? $util.Long.prototype.toString.call(message.lt) : options.longs === Number ? new $util.LongBits(message.lt.low >>> 0, message.lt.high >>> 0).toNumber() : message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (typeof message.lte === "number")
                    object.lte = options.longs === String ? String(message.lte) : message.lte;
                else
                    object.lte = options.longs === String ? $util.Long.prototype.toString.call(message.lte) : options.longs === Number ? new $util.LongBits(message.lte.low >>> 0, message.lte.high >>> 0).toNumber() : message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (typeof message.gt === "number")
                    object.gt = options.longs === String ? String(message.gt) : message.gt;
                else
                    object.gt = options.longs === String ? $util.Long.prototype.toString.call(message.gt) : options.longs === Number ? new $util.LongBits(message.gt.low >>> 0, message.gt.high >>> 0).toNumber() : message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (typeof message.gte === "number")
                    object.gte = options.longs === String ? String(message.gte) : message.gte;
                else
                    object.gte = options.longs === String ? $util.Long.prototype.toString.call(message.gte) : options.longs === Number ? new $util.LongBits(message.gte.low >>> 0, message.gte.high >>> 0).toNumber() : message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    if (typeof message["in"][j] === "number")
                        object["in"][j] = options.longs === String ? String(message["in"][j]) : message["in"][j];
                    else
                        object["in"][j] = options.longs === String ? $util.Long.prototype.toString.call(message["in"][j]) : options.longs === Number ? new $util.LongBits(message["in"][j].low >>> 0, message["in"][j].high >>> 0).toNumber() : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    if (typeof message.notIn[j] === "number")
                        object.notIn[j] = options.longs === String ? String(message.notIn[j]) : message.notIn[j];
                    else
                        object.notIn[j] = options.longs === String ? $util.Long.prototype.toString.call(message.notIn[j]) : options.longs === Number ? new $util.LongBits(message.notIn[j].low >>> 0, message.notIn[j].high >>> 0).toNumber() : message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this Fixed64Rules to JSON.
         * @function toJSON
         * @memberof validate.Fixed64Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        Fixed64Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return Fixed64Rules;
    })();

    validate.SFixed32Rules = (function() {

        /**
         * Properties of a SFixed32Rules.
         * @memberof validate
         * @interface ISFixed32Rules
         * @property {number|null} ["const"] SFixed32Rules const
         * @property {number|null} [lt] SFixed32Rules lt
         * @property {number|null} [lte] SFixed32Rules lte
         * @property {number|null} [gt] SFixed32Rules gt
         * @property {number|null} [gte] SFixed32Rules gte
         * @property {Array.<number>|null} ["in"] SFixed32Rules in
         * @property {Array.<number>|null} [notIn] SFixed32Rules notIn
         */

        /**
         * Constructs a new SFixed32Rules.
         * @memberof validate
         * @classdesc Represents a SFixed32Rules.
         * @implements ISFixed32Rules
         * @constructor
         * @param {validate.ISFixed32Rules=} [properties] Properties to set
         */
        function SFixed32Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SFixed32Rules const.
         * @member {number} const
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype["const"] = 0;

        /**
         * SFixed32Rules lt.
         * @member {number} lt
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype.lt = 0;

        /**
         * SFixed32Rules lte.
         * @member {number} lte
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype.lte = 0;

        /**
         * SFixed32Rules gt.
         * @member {number} gt
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype.gt = 0;

        /**
         * SFixed32Rules gte.
         * @member {number} gte
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype.gte = 0;

        /**
         * SFixed32Rules in.
         * @member {Array.<number>} in
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype["in"] = $util.emptyArray;

        /**
         * SFixed32Rules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.SFixed32Rules
         * @instance
         */
        SFixed32Rules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies a SFixed32Rules message.
         * @function verify
         * @memberof validate.SFixed32Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SFixed32Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]))
                    return "const: integer expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt))
                    return "lt: integer expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte))
                    return "lte: integer expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt))
                    return "gt: integer expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte))
                    return "gte: integer expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]))
                        return "in: integer[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]))
                        return "notIn: integer[] expected";
            }
            return null;
        };

        /**
         * Creates a SFixed32Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.SFixed32Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.SFixed32Rules} SFixed32Rules
         */
        SFixed32Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.SFixed32Rules)
                return object;
            let message = new $root.validate.SFixed32Rules();
            if (object["const"] != null)
                message["const"] = object["const"] | 0;
            if (object.lt != null)
                message.lt = object.lt | 0;
            if (object.lte != null)
                message.lte = object.lte | 0;
            if (object.gt != null)
                message.gt = object.gt | 0;
            if (object.gte != null)
                message.gte = object.gte | 0;
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.SFixed32Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = object["in"][i] | 0;
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.SFixed32Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = object.notIn[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from a SFixed32Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.SFixed32Rules
         * @static
         * @param {validate.SFixed32Rules} message SFixed32Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SFixed32Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.lt = 0;
                object.lte = 0;
                object.gt = 0;
                object.gte = 0;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this SFixed32Rules to JSON.
         * @function toJSON
         * @memberof validate.SFixed32Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SFixed32Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SFixed32Rules;
    })();

    validate.SFixed64Rules = (function() {

        /**
         * Properties of a SFixed64Rules.
         * @memberof validate
         * @interface ISFixed64Rules
         * @property {number|Long|null} ["const"] SFixed64Rules const
         * @property {number|Long|null} [lt] SFixed64Rules lt
         * @property {number|Long|null} [lte] SFixed64Rules lte
         * @property {number|Long|null} [gt] SFixed64Rules gt
         * @property {number|Long|null} [gte] SFixed64Rules gte
         * @property {Array.<number|Long>|null} ["in"] SFixed64Rules in
         * @property {Array.<number|Long>|null} [notIn] SFixed64Rules notIn
         */

        /**
         * Constructs a new SFixed64Rules.
         * @memberof validate
         * @classdesc Represents a SFixed64Rules.
         * @implements ISFixed64Rules
         * @constructor
         * @param {validate.ISFixed64Rules=} [properties] Properties to set
         */
        function SFixed64Rules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * SFixed64Rules const.
         * @member {number|Long} const
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype["const"] = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SFixed64Rules lt.
         * @member {number|Long} lt
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype.lt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SFixed64Rules lte.
         * @member {number|Long} lte
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype.lte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SFixed64Rules gt.
         * @member {number|Long} gt
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype.gt = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SFixed64Rules gte.
         * @member {number|Long} gte
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype.gte = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

        /**
         * SFixed64Rules in.
         * @member {Array.<number|Long>} in
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype["in"] = $util.emptyArray;

        /**
         * SFixed64Rules notIn.
         * @member {Array.<number|Long>} notIn
         * @memberof validate.SFixed64Rules
         * @instance
         */
        SFixed64Rules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies a SFixed64Rules message.
         * @function verify
         * @memberof validate.SFixed64Rules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        SFixed64Rules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]) && !(message["const"] && $util.isInteger(message["const"].low) && $util.isInteger(message["const"].high)))
                    return "const: integer|Long expected";
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (!$util.isInteger(message.lt) && !(message.lt && $util.isInteger(message.lt.low) && $util.isInteger(message.lt.high)))
                    return "lt: integer|Long expected";
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (!$util.isInteger(message.lte) && !(message.lte && $util.isInteger(message.lte.low) && $util.isInteger(message.lte.high)))
                    return "lte: integer|Long expected";
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (!$util.isInteger(message.gt) && !(message.gt && $util.isInteger(message.gt.low) && $util.isInteger(message.gt.high)))
                    return "gt: integer|Long expected";
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (!$util.isInteger(message.gte) && !(message.gte && $util.isInteger(message.gte.low) && $util.isInteger(message.gte.high)))
                    return "gte: integer|Long expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]) && !(message["in"][i] && $util.isInteger(message["in"][i].low) && $util.isInteger(message["in"][i].high)))
                        return "in: integer|Long[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]) && !(message.notIn[i] && $util.isInteger(message.notIn[i].low) && $util.isInteger(message.notIn[i].high)))
                        return "notIn: integer|Long[] expected";
            }
            return null;
        };

        /**
         * Creates a SFixed64Rules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.SFixed64Rules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.SFixed64Rules} SFixed64Rules
         */
        SFixed64Rules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.SFixed64Rules)
                return object;
            let message = new $root.validate.SFixed64Rules();
            if (object["const"] != null)
                if ($util.Long)
                    (message["const"] = $util.Long.fromValue(object["const"])).unsigned = false;
                else if (typeof object["const"] === "string")
                    message["const"] = parseInt(object["const"], 10);
                else if (typeof object["const"] === "number")
                    message["const"] = object["const"];
                else if (typeof object["const"] === "object")
                    message["const"] = new $util.LongBits(object["const"].low >>> 0, object["const"].high >>> 0).toNumber();
            if (object.lt != null)
                if ($util.Long)
                    (message.lt = $util.Long.fromValue(object.lt)).unsigned = false;
                else if (typeof object.lt === "string")
                    message.lt = parseInt(object.lt, 10);
                else if (typeof object.lt === "number")
                    message.lt = object.lt;
                else if (typeof object.lt === "object")
                    message.lt = new $util.LongBits(object.lt.low >>> 0, object.lt.high >>> 0).toNumber();
            if (object.lte != null)
                if ($util.Long)
                    (message.lte = $util.Long.fromValue(object.lte)).unsigned = false;
                else if (typeof object.lte === "string")
                    message.lte = parseInt(object.lte, 10);
                else if (typeof object.lte === "number")
                    message.lte = object.lte;
                else if (typeof object.lte === "object")
                    message.lte = new $util.LongBits(object.lte.low >>> 0, object.lte.high >>> 0).toNumber();
            if (object.gt != null)
                if ($util.Long)
                    (message.gt = $util.Long.fromValue(object.gt)).unsigned = false;
                else if (typeof object.gt === "string")
                    message.gt = parseInt(object.gt, 10);
                else if (typeof object.gt === "number")
                    message.gt = object.gt;
                else if (typeof object.gt === "object")
                    message.gt = new $util.LongBits(object.gt.low >>> 0, object.gt.high >>> 0).toNumber();
            if (object.gte != null)
                if ($util.Long)
                    (message.gte = $util.Long.fromValue(object.gte)).unsigned = false;
                else if (typeof object.gte === "string")
                    message.gte = parseInt(object.gte, 10);
                else if (typeof object.gte === "number")
                    message.gte = object.gte;
                else if (typeof object.gte === "object")
                    message.gte = new $util.LongBits(object.gte.low >>> 0, object.gte.high >>> 0).toNumber();
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.SFixed64Rules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    if ($util.Long)
                        (message["in"][i] = $util.Long.fromValue(object["in"][i])).unsigned = false;
                    else if (typeof object["in"][i] === "string")
                        message["in"][i] = parseInt(object["in"][i], 10);
                    else if (typeof object["in"][i] === "number")
                        message["in"][i] = object["in"][i];
                    else if (typeof object["in"][i] === "object")
                        message["in"][i] = new $util.LongBits(object["in"][i].low >>> 0, object["in"][i].high >>> 0).toNumber();
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.SFixed64Rules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    if ($util.Long)
                        (message.notIn[i] = $util.Long.fromValue(object.notIn[i])).unsigned = false;
                    else if (typeof object.notIn[i] === "string")
                        message.notIn[i] = parseInt(object.notIn[i], 10);
                    else if (typeof object.notIn[i] === "number")
                        message.notIn[i] = object.notIn[i];
                    else if (typeof object.notIn[i] === "object")
                        message.notIn[i] = new $util.LongBits(object.notIn[i].low >>> 0, object.notIn[i].high >>> 0).toNumber();
            }
            return message;
        };

        /**
         * Creates a plain object from a SFixed64Rules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.SFixed64Rules
         * @static
         * @param {validate.SFixed64Rules} message SFixed64Rules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        SFixed64Rules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object["const"] = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object["const"] = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.lte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lte = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gt = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gt = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, false);
                    object.gte = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.gte = options.longs === String ? "0" : 0;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] === "number")
                    object["const"] = options.longs === String ? String(message["const"]) : message["const"];
                else
                    object["const"] = options.longs === String ? $util.Long.prototype.toString.call(message["const"]) : options.longs === Number ? new $util.LongBits(message["const"].low >>> 0, message["const"].high >>> 0).toNumber() : message["const"];
            if (message.lt != null && message.hasOwnProperty("lt"))
                if (typeof message.lt === "number")
                    object.lt = options.longs === String ? String(message.lt) : message.lt;
                else
                    object.lt = options.longs === String ? $util.Long.prototype.toString.call(message.lt) : options.longs === Number ? new $util.LongBits(message.lt.low >>> 0, message.lt.high >>> 0).toNumber() : message.lt;
            if (message.lte != null && message.hasOwnProperty("lte"))
                if (typeof message.lte === "number")
                    object.lte = options.longs === String ? String(message.lte) : message.lte;
                else
                    object.lte = options.longs === String ? $util.Long.prototype.toString.call(message.lte) : options.longs === Number ? new $util.LongBits(message.lte.low >>> 0, message.lte.high >>> 0).toNumber() : message.lte;
            if (message.gt != null && message.hasOwnProperty("gt"))
                if (typeof message.gt === "number")
                    object.gt = options.longs === String ? String(message.gt) : message.gt;
                else
                    object.gt = options.longs === String ? $util.Long.prototype.toString.call(message.gt) : options.longs === Number ? new $util.LongBits(message.gt.low >>> 0, message.gt.high >>> 0).toNumber() : message.gt;
            if (message.gte != null && message.hasOwnProperty("gte"))
                if (typeof message.gte === "number")
                    object.gte = options.longs === String ? String(message.gte) : message.gte;
                else
                    object.gte = options.longs === String ? $util.Long.prototype.toString.call(message.gte) : options.longs === Number ? new $util.LongBits(message.gte.low >>> 0, message.gte.high >>> 0).toNumber() : message.gte;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    if (typeof message["in"][j] === "number")
                        object["in"][j] = options.longs === String ? String(message["in"][j]) : message["in"][j];
                    else
                        object["in"][j] = options.longs === String ? $util.Long.prototype.toString.call(message["in"][j]) : options.longs === Number ? new $util.LongBits(message["in"][j].low >>> 0, message["in"][j].high >>> 0).toNumber() : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    if (typeof message.notIn[j] === "number")
                        object.notIn[j] = options.longs === String ? String(message.notIn[j]) : message.notIn[j];
                    else
                        object.notIn[j] = options.longs === String ? $util.Long.prototype.toString.call(message.notIn[j]) : options.longs === Number ? new $util.LongBits(message.notIn[j].low >>> 0, message.notIn[j].high >>> 0).toNumber() : message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this SFixed64Rules to JSON.
         * @function toJSON
         * @memberof validate.SFixed64Rules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        SFixed64Rules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return SFixed64Rules;
    })();

    validate.BoolRules = (function() {

        /**
         * Properties of a BoolRules.
         * @memberof validate
         * @interface IBoolRules
         * @property {boolean|null} ["const"] BoolRules const
         */

        /**
         * Constructs a new BoolRules.
         * @memberof validate
         * @classdesc Represents a BoolRules.
         * @implements IBoolRules
         * @constructor
         * @param {validate.IBoolRules=} [properties] Properties to set
         */
        function BoolRules(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BoolRules const.
         * @member {boolean} const
         * @memberof validate.BoolRules
         * @instance
         */
        BoolRules.prototype["const"] = false;

        /**
         * Verifies a BoolRules message.
         * @function verify
         * @memberof validate.BoolRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BoolRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (typeof message["const"] !== "boolean")
                    return "const: boolean expected";
            return null;
        };

        /**
         * Creates a BoolRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.BoolRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.BoolRules} BoolRules
         */
        BoolRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.BoolRules)
                return object;
            let message = new $root.validate.BoolRules();
            if (object["const"] != null)
                message["const"] = Boolean(object["const"]);
            return message;
        };

        /**
         * Creates a plain object from a BoolRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.BoolRules
         * @static
         * @param {validate.BoolRules} message BoolRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BoolRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults)
                object["const"] = false;
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            return object;
        };

        /**
         * Converts this BoolRules to JSON.
         * @function toJSON
         * @memberof validate.BoolRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BoolRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BoolRules;
    })();

    validate.StringRules = (function() {

        /**
         * Properties of a StringRules.
         * @memberof validate
         * @interface IStringRules
         * @property {string|null} ["const"] StringRules const
         * @property {number|Long|null} [len] StringRules len
         * @property {number|Long|null} [minLen] StringRules minLen
         * @property {number|Long|null} [maxLen] StringRules maxLen
         * @property {number|Long|null} [lenBytes] StringRules lenBytes
         * @property {number|Long|null} [minBytes] StringRules minBytes
         * @property {number|Long|null} [maxBytes] StringRules maxBytes
         * @property {string|null} [pattern] StringRules pattern
         * @property {string|null} [prefix] StringRules prefix
         * @property {string|null} [suffix] StringRules suffix
         * @property {string|null} [contains] StringRules contains
         * @property {string|null} [notContains] StringRules notContains
         * @property {Array.<string>|null} ["in"] StringRules in
         * @property {Array.<string>|null} [notIn] StringRules notIn
         * @property {boolean|null} [email] StringRules email
         * @property {boolean|null} [hostname] StringRules hostname
         * @property {boolean|null} [ip] StringRules ip
         * @property {boolean|null} [ipv4] StringRules ipv4
         * @property {boolean|null} [ipv6] StringRules ipv6
         * @property {boolean|null} [uri] StringRules uri
         * @property {boolean|null} [uriRef] StringRules uriRef
         * @property {boolean|null} [address] StringRules address
         * @property {boolean|null} [uuid] StringRules uuid
         * @property {validate.KnownRegex|null} [wellKnownRegex] StringRules wellKnownRegex
         * @property {boolean|null} [strict] StringRules strict
         */

        /**
         * Constructs a new StringRules.
         * @memberof validate
         * @classdesc Represents a StringRules.
         * @implements IStringRules
         * @constructor
         * @param {validate.IStringRules=} [properties] Properties to set
         */
        function StringRules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * StringRules const.
         * @member {string} const
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype["const"] = "";

        /**
         * StringRules len.
         * @member {number|Long} len
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.len = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StringRules minLen.
         * @member {number|Long} minLen
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.minLen = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StringRules maxLen.
         * @member {number|Long} maxLen
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.maxLen = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StringRules lenBytes.
         * @member {number|Long} lenBytes
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.lenBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StringRules minBytes.
         * @member {number|Long} minBytes
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.minBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StringRules maxBytes.
         * @member {number|Long} maxBytes
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.maxBytes = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * StringRules pattern.
         * @member {string} pattern
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.pattern = "";

        /**
         * StringRules prefix.
         * @member {string} prefix
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.prefix = "";

        /**
         * StringRules suffix.
         * @member {string} suffix
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.suffix = "";

        /**
         * StringRules contains.
         * @member {string} contains
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.contains = "";

        /**
         * StringRules notContains.
         * @member {string} notContains
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.notContains = "";

        /**
         * StringRules in.
         * @member {Array.<string>} in
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype["in"] = $util.emptyArray;

        /**
         * StringRules notIn.
         * @member {Array.<string>} notIn
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.notIn = $util.emptyArray;

        /**
         * StringRules email.
         * @member {boolean} email
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.email = false;

        /**
         * StringRules hostname.
         * @member {boolean} hostname
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.hostname = false;

        /**
         * StringRules ip.
         * @member {boolean} ip
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.ip = false;

        /**
         * StringRules ipv4.
         * @member {boolean} ipv4
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.ipv4 = false;

        /**
         * StringRules ipv6.
         * @member {boolean} ipv6
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.ipv6 = false;

        /**
         * StringRules uri.
         * @member {boolean} uri
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.uri = false;

        /**
         * StringRules uriRef.
         * @member {boolean} uriRef
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.uriRef = false;

        /**
         * StringRules address.
         * @member {boolean} address
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.address = false;

        /**
         * StringRules uuid.
         * @member {boolean} uuid
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.uuid = false;

        /**
         * StringRules wellKnownRegex.
         * @member {validate.KnownRegex} wellKnownRegex
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.wellKnownRegex = 0;

        /**
         * StringRules strict.
         * @member {boolean} strict
         * @memberof validate.StringRules
         * @instance
         */
        StringRules.prototype.strict = true;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * StringRules wellKnown.
         * @member {"email"|"hostname"|"ip"|"ipv4"|"ipv6"|"uri"|"uriRef"|"address"|"uuid"|"wellKnownRegex"|undefined} wellKnown
         * @memberof validate.StringRules
         * @instance
         */
        Object.defineProperty(StringRules.prototype, "wellKnown", {
            get: $util.oneOfGetter($oneOfFields = ["email", "hostname", "ip", "ipv4", "ipv6", "uri", "uriRef", "address", "uuid", "wellKnownRegex"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Verifies a StringRules message.
         * @function verify
         * @memberof validate.StringRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        StringRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isString(message["const"]))
                    return "const: string expected";
            if (message.len != null && message.hasOwnProperty("len"))
                if (!$util.isInteger(message.len) && !(message.len && $util.isInteger(message.len.low) && $util.isInteger(message.len.high)))
                    return "len: integer|Long expected";
            if (message.minLen != null && message.hasOwnProperty("minLen"))
                if (!$util.isInteger(message.minLen) && !(message.minLen && $util.isInteger(message.minLen.low) && $util.isInteger(message.minLen.high)))
                    return "minLen: integer|Long expected";
            if (message.maxLen != null && message.hasOwnProperty("maxLen"))
                if (!$util.isInteger(message.maxLen) && !(message.maxLen && $util.isInteger(message.maxLen.low) && $util.isInteger(message.maxLen.high)))
                    return "maxLen: integer|Long expected";
            if (message.lenBytes != null && message.hasOwnProperty("lenBytes"))
                if (!$util.isInteger(message.lenBytes) && !(message.lenBytes && $util.isInteger(message.lenBytes.low) && $util.isInteger(message.lenBytes.high)))
                    return "lenBytes: integer|Long expected";
            if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                if (!$util.isInteger(message.minBytes) && !(message.minBytes && $util.isInteger(message.minBytes.low) && $util.isInteger(message.minBytes.high)))
                    return "minBytes: integer|Long expected";
            if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                if (!$util.isInteger(message.maxBytes) && !(message.maxBytes && $util.isInteger(message.maxBytes.low) && $util.isInteger(message.maxBytes.high)))
                    return "maxBytes: integer|Long expected";
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                if (!$util.isString(message.pattern))
                    return "pattern: string expected";
            if (message.prefix != null && message.hasOwnProperty("prefix"))
                if (!$util.isString(message.prefix))
                    return "prefix: string expected";
            if (message.suffix != null && message.hasOwnProperty("suffix"))
                if (!$util.isString(message.suffix))
                    return "suffix: string expected";
            if (message.contains != null && message.hasOwnProperty("contains"))
                if (!$util.isString(message.contains))
                    return "contains: string expected";
            if (message.notContains != null && message.hasOwnProperty("notContains"))
                if (!$util.isString(message.notContains))
                    return "notContains: string expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isString(message["in"][i]))
                        return "in: string[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isString(message.notIn[i]))
                        return "notIn: string[] expected";
            }
            if (message.email != null && message.hasOwnProperty("email")) {
                properties.wellKnown = 1;
                if (typeof message.email !== "boolean")
                    return "email: boolean expected";
            }
            if (message.hostname != null && message.hasOwnProperty("hostname")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.hostname !== "boolean")
                    return "hostname: boolean expected";
            }
            if (message.ip != null && message.hasOwnProperty("ip")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.ip !== "boolean")
                    return "ip: boolean expected";
            }
            if (message.ipv4 != null && message.hasOwnProperty("ipv4")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.ipv4 !== "boolean")
                    return "ipv4: boolean expected";
            }
            if (message.ipv6 != null && message.hasOwnProperty("ipv6")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.ipv6 !== "boolean")
                    return "ipv6: boolean expected";
            }
            if (message.uri != null && message.hasOwnProperty("uri")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.uri !== "boolean")
                    return "uri: boolean expected";
            }
            if (message.uriRef != null && message.hasOwnProperty("uriRef")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.uriRef !== "boolean")
                    return "uriRef: boolean expected";
            }
            if (message.address != null && message.hasOwnProperty("address")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.address !== "boolean")
                    return "address: boolean expected";
            }
            if (message.uuid != null && message.hasOwnProperty("uuid")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.uuid !== "boolean")
                    return "uuid: boolean expected";
            }
            if (message.wellKnownRegex != null && message.hasOwnProperty("wellKnownRegex")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                switch (message.wellKnownRegex) {
                default:
                    return "wellKnownRegex: enum value expected";
                case 0:
                case 1:
                case 2:
                    break;
                }
            }
            if (message.strict != null && message.hasOwnProperty("strict"))
                if (typeof message.strict !== "boolean")
                    return "strict: boolean expected";
            return null;
        };

        /**
         * Creates a StringRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.StringRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.StringRules} StringRules
         */
        StringRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.StringRules)
                return object;
            let message = new $root.validate.StringRules();
            if (object["const"] != null)
                message["const"] = String(object["const"]);
            if (object.len != null)
                if ($util.Long)
                    (message.len = $util.Long.fromValue(object.len)).unsigned = true;
                else if (typeof object.len === "string")
                    message.len = parseInt(object.len, 10);
                else if (typeof object.len === "number")
                    message.len = object.len;
                else if (typeof object.len === "object")
                    message.len = new $util.LongBits(object.len.low >>> 0, object.len.high >>> 0).toNumber(true);
            if (object.minLen != null)
                if ($util.Long)
                    (message.minLen = $util.Long.fromValue(object.minLen)).unsigned = true;
                else if (typeof object.minLen === "string")
                    message.minLen = parseInt(object.minLen, 10);
                else if (typeof object.minLen === "number")
                    message.minLen = object.minLen;
                else if (typeof object.minLen === "object")
                    message.minLen = new $util.LongBits(object.minLen.low >>> 0, object.minLen.high >>> 0).toNumber(true);
            if (object.maxLen != null)
                if ($util.Long)
                    (message.maxLen = $util.Long.fromValue(object.maxLen)).unsigned = true;
                else if (typeof object.maxLen === "string")
                    message.maxLen = parseInt(object.maxLen, 10);
                else if (typeof object.maxLen === "number")
                    message.maxLen = object.maxLen;
                else if (typeof object.maxLen === "object")
                    message.maxLen = new $util.LongBits(object.maxLen.low >>> 0, object.maxLen.high >>> 0).toNumber(true);
            if (object.lenBytes != null)
                if ($util.Long)
                    (message.lenBytes = $util.Long.fromValue(object.lenBytes)).unsigned = true;
                else if (typeof object.lenBytes === "string")
                    message.lenBytes = parseInt(object.lenBytes, 10);
                else if (typeof object.lenBytes === "number")
                    message.lenBytes = object.lenBytes;
                else if (typeof object.lenBytes === "object")
                    message.lenBytes = new $util.LongBits(object.lenBytes.low >>> 0, object.lenBytes.high >>> 0).toNumber(true);
            if (object.minBytes != null)
                if ($util.Long)
                    (message.minBytes = $util.Long.fromValue(object.minBytes)).unsigned = true;
                else if (typeof object.minBytes === "string")
                    message.minBytes = parseInt(object.minBytes, 10);
                else if (typeof object.minBytes === "number")
                    message.minBytes = object.minBytes;
                else if (typeof object.minBytes === "object")
                    message.minBytes = new $util.LongBits(object.minBytes.low >>> 0, object.minBytes.high >>> 0).toNumber(true);
            if (object.maxBytes != null)
                if ($util.Long)
                    (message.maxBytes = $util.Long.fromValue(object.maxBytes)).unsigned = true;
                else if (typeof object.maxBytes === "string")
                    message.maxBytes = parseInt(object.maxBytes, 10);
                else if (typeof object.maxBytes === "number")
                    message.maxBytes = object.maxBytes;
                else if (typeof object.maxBytes === "object")
                    message.maxBytes = new $util.LongBits(object.maxBytes.low >>> 0, object.maxBytes.high >>> 0).toNumber(true);
            if (object.pattern != null)
                message.pattern = String(object.pattern);
            if (object.prefix != null)
                message.prefix = String(object.prefix);
            if (object.suffix != null)
                message.suffix = String(object.suffix);
            if (object.contains != null)
                message.contains = String(object.contains);
            if (object.notContains != null)
                message.notContains = String(object.notContains);
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.StringRules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = String(object["in"][i]);
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.StringRules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = String(object.notIn[i]);
            }
            if (object.email != null)
                message.email = Boolean(object.email);
            if (object.hostname != null)
                message.hostname = Boolean(object.hostname);
            if (object.ip != null)
                message.ip = Boolean(object.ip);
            if (object.ipv4 != null)
                message.ipv4 = Boolean(object.ipv4);
            if (object.ipv6 != null)
                message.ipv6 = Boolean(object.ipv6);
            if (object.uri != null)
                message.uri = Boolean(object.uri);
            if (object.uriRef != null)
                message.uriRef = Boolean(object.uriRef);
            if (object.address != null)
                message.address = Boolean(object.address);
            if (object.uuid != null)
                message.uuid = Boolean(object.uuid);
            switch (object.wellKnownRegex) {
            case "UNKNOWN":
            case 0:
                message.wellKnownRegex = 0;
                break;
            case "HTTP_HEADER_NAME":
            case 1:
                message.wellKnownRegex = 1;
                break;
            case "HTTP_HEADER_VALUE":
            case 2:
                message.wellKnownRegex = 2;
                break;
            }
            if (object.strict != null)
                message.strict = Boolean(object.strict);
            return message;
        };

        /**
         * Creates a plain object from a StringRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.StringRules
         * @static
         * @param {validate.StringRules} message StringRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        StringRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.minLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minLen = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxLen = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.minBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minBytes = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxBytes = options.longs === String ? "0" : 0;
                object.pattern = "";
                object.prefix = "";
                object.suffix = "";
                object.contains = "";
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.len = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.len = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.lenBytes = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.lenBytes = options.longs === String ? "0" : 0;
                object.notContains = "";
                object.strict = true;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            if (message.minLen != null && message.hasOwnProperty("minLen"))
                if (typeof message.minLen === "number")
                    object.minLen = options.longs === String ? String(message.minLen) : message.minLen;
                else
                    object.minLen = options.longs === String ? $util.Long.prototype.toString.call(message.minLen) : options.longs === Number ? new $util.LongBits(message.minLen.low >>> 0, message.minLen.high >>> 0).toNumber(true) : message.minLen;
            if (message.maxLen != null && message.hasOwnProperty("maxLen"))
                if (typeof message.maxLen === "number")
                    object.maxLen = options.longs === String ? String(message.maxLen) : message.maxLen;
                else
                    object.maxLen = options.longs === String ? $util.Long.prototype.toString.call(message.maxLen) : options.longs === Number ? new $util.LongBits(message.maxLen.low >>> 0, message.maxLen.high >>> 0).toNumber(true) : message.maxLen;
            if (message.minBytes != null && message.hasOwnProperty("minBytes"))
                if (typeof message.minBytes === "number")
                    object.minBytes = options.longs === String ? String(message.minBytes) : message.minBytes;
                else
                    object.minBytes = options.longs === String ? $util.Long.prototype.toString.call(message.minBytes) : options.longs === Number ? new $util.LongBits(message.minBytes.low >>> 0, message.minBytes.high >>> 0).toNumber(true) : message.minBytes;
            if (message.maxBytes != null && message.hasOwnProperty("maxBytes"))
                if (typeof message.maxBytes === "number")
                    object.maxBytes = options.longs === String ? String(message.maxBytes) : message.maxBytes;
                else
                    object.maxBytes = options.longs === String ? $util.Long.prototype.toString.call(message.maxBytes) : options.longs === Number ? new $util.LongBits(message.maxBytes.low >>> 0, message.maxBytes.high >>> 0).toNumber(true) : message.maxBytes;
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                object.pattern = message.pattern;
            if (message.prefix != null && message.hasOwnProperty("prefix"))
                object.prefix = message.prefix;
            if (message.suffix != null && message.hasOwnProperty("suffix"))
                object.suffix = message.suffix;
            if (message.contains != null && message.hasOwnProperty("contains"))
                object.contains = message.contains;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            if (message.email != null && message.hasOwnProperty("email")) {
                object.email = message.email;
                if (options.oneofs)
                    object.wellKnown = "email";
            }
            if (message.hostname != null && message.hasOwnProperty("hostname")) {
                object.hostname = message.hostname;
                if (options.oneofs)
                    object.wellKnown = "hostname";
            }
            if (message.ip != null && message.hasOwnProperty("ip")) {
                object.ip = message.ip;
                if (options.oneofs)
                    object.wellKnown = "ip";
            }
            if (message.ipv4 != null && message.hasOwnProperty("ipv4")) {
                object.ipv4 = message.ipv4;
                if (options.oneofs)
                    object.wellKnown = "ipv4";
            }
            if (message.ipv6 != null && message.hasOwnProperty("ipv6")) {
                object.ipv6 = message.ipv6;
                if (options.oneofs)
                    object.wellKnown = "ipv6";
            }
            if (message.uri != null && message.hasOwnProperty("uri")) {
                object.uri = message.uri;
                if (options.oneofs)
                    object.wellKnown = "uri";
            }
            if (message.uriRef != null && message.hasOwnProperty("uriRef")) {
                object.uriRef = message.uriRef;
                if (options.oneofs)
                    object.wellKnown = "uriRef";
            }
            if (message.len != null && message.hasOwnProperty("len"))
                if (typeof message.len === "number")
                    object.len = options.longs === String ? String(message.len) : message.len;
                else
                    object.len = options.longs === String ? $util.Long.prototype.toString.call(message.len) : options.longs === Number ? new $util.LongBits(message.len.low >>> 0, message.len.high >>> 0).toNumber(true) : message.len;
            if (message.lenBytes != null && message.hasOwnProperty("lenBytes"))
                if (typeof message.lenBytes === "number")
                    object.lenBytes = options.longs === String ? String(message.lenBytes) : message.lenBytes;
                else
                    object.lenBytes = options.longs === String ? $util.Long.prototype.toString.call(message.lenBytes) : options.longs === Number ? new $util.LongBits(message.lenBytes.low >>> 0, message.lenBytes.high >>> 0).toNumber(true) : message.lenBytes;
            if (message.address != null && message.hasOwnProperty("address")) {
                object.address = message.address;
                if (options.oneofs)
                    object.wellKnown = "address";
            }
            if (message.uuid != null && message.hasOwnProperty("uuid")) {
                object.uuid = message.uuid;
                if (options.oneofs)
                    object.wellKnown = "uuid";
            }
            if (message.notContains != null && message.hasOwnProperty("notContains"))
                object.notContains = message.notContains;
            if (message.wellKnownRegex != null && message.hasOwnProperty("wellKnownRegex")) {
                object.wellKnownRegex = options.enums === String ? $root.validate.KnownRegex[message.wellKnownRegex] : message.wellKnownRegex;
                if (options.oneofs)
                    object.wellKnown = "wellKnownRegex";
            }
            if (message.strict != null && message.hasOwnProperty("strict"))
                object.strict = message.strict;
            return object;
        };

        /**
         * Converts this StringRules to JSON.
         * @function toJSON
         * @memberof validate.StringRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        StringRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return StringRules;
    })();

    /**
     * KnownRegex enum.
     * @name validate.KnownRegex
     * @enum {number}
     * @property {number} UNKNOWN=0 UNKNOWN value
     * @property {number} HTTP_HEADER_NAME=1 HTTP_HEADER_NAME value
     * @property {number} HTTP_HEADER_VALUE=2 HTTP_HEADER_VALUE value
     */
    validate.KnownRegex = (function() {
        const valuesById = {}, values = Object.create(valuesById);
        values[valuesById[0] = "UNKNOWN"] = 0;
        values[valuesById[1] = "HTTP_HEADER_NAME"] = 1;
        values[valuesById[2] = "HTTP_HEADER_VALUE"] = 2;
        return values;
    })();

    validate.BytesRules = (function() {

        /**
         * Properties of a BytesRules.
         * @memberof validate
         * @interface IBytesRules
         * @property {Uint8Array|null} ["const"] BytesRules const
         * @property {number|Long|null} [len] BytesRules len
         * @property {number|Long|null} [minLen] BytesRules minLen
         * @property {number|Long|null} [maxLen] BytesRules maxLen
         * @property {string|null} [pattern] BytesRules pattern
         * @property {Uint8Array|null} [prefix] BytesRules prefix
         * @property {Uint8Array|null} [suffix] BytesRules suffix
         * @property {Uint8Array|null} [contains] BytesRules contains
         * @property {Array.<Uint8Array>|null} ["in"] BytesRules in
         * @property {Array.<Uint8Array>|null} [notIn] BytesRules notIn
         * @property {boolean|null} [ip] BytesRules ip
         * @property {boolean|null} [ipv4] BytesRules ipv4
         * @property {boolean|null} [ipv6] BytesRules ipv6
         */

        /**
         * Constructs a new BytesRules.
         * @memberof validate
         * @classdesc Represents a BytesRules.
         * @implements IBytesRules
         * @constructor
         * @param {validate.IBytesRules=} [properties] Properties to set
         */
        function BytesRules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * BytesRules const.
         * @member {Uint8Array} const
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype["const"] = $util.newBuffer([]);

        /**
         * BytesRules len.
         * @member {number|Long} len
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.len = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * BytesRules minLen.
         * @member {number|Long} minLen
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.minLen = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * BytesRules maxLen.
         * @member {number|Long} maxLen
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.maxLen = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * BytesRules pattern.
         * @member {string} pattern
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.pattern = "";

        /**
         * BytesRules prefix.
         * @member {Uint8Array} prefix
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.prefix = $util.newBuffer([]);

        /**
         * BytesRules suffix.
         * @member {Uint8Array} suffix
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.suffix = $util.newBuffer([]);

        /**
         * BytesRules contains.
         * @member {Uint8Array} contains
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.contains = $util.newBuffer([]);

        /**
         * BytesRules in.
         * @member {Array.<Uint8Array>} in
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype["in"] = $util.emptyArray;

        /**
         * BytesRules notIn.
         * @member {Array.<Uint8Array>} notIn
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.notIn = $util.emptyArray;

        /**
         * BytesRules ip.
         * @member {boolean} ip
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.ip = false;

        /**
         * BytesRules ipv4.
         * @member {boolean} ipv4
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.ipv4 = false;

        /**
         * BytesRules ipv6.
         * @member {boolean} ipv6
         * @memberof validate.BytesRules
         * @instance
         */
        BytesRules.prototype.ipv6 = false;

        // OneOf field names bound to virtual getters and setters
        let $oneOfFields;

        /**
         * BytesRules wellKnown.
         * @member {"ip"|"ipv4"|"ipv6"|undefined} wellKnown
         * @memberof validate.BytesRules
         * @instance
         */
        Object.defineProperty(BytesRules.prototype, "wellKnown", {
            get: $util.oneOfGetter($oneOfFields = ["ip", "ipv4", "ipv6"]),
            set: $util.oneOfSetter($oneOfFields)
        });

        /**
         * Verifies a BytesRules message.
         * @function verify
         * @memberof validate.BytesRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        BytesRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            let properties = {};
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!(message["const"] && typeof message["const"].length === "number" || $util.isString(message["const"])))
                    return "const: buffer expected";
            if (message.len != null && message.hasOwnProperty("len"))
                if (!$util.isInteger(message.len) && !(message.len && $util.isInteger(message.len.low) && $util.isInteger(message.len.high)))
                    return "len: integer|Long expected";
            if (message.minLen != null && message.hasOwnProperty("minLen"))
                if (!$util.isInteger(message.minLen) && !(message.minLen && $util.isInteger(message.minLen.low) && $util.isInteger(message.minLen.high)))
                    return "minLen: integer|Long expected";
            if (message.maxLen != null && message.hasOwnProperty("maxLen"))
                if (!$util.isInteger(message.maxLen) && !(message.maxLen && $util.isInteger(message.maxLen.low) && $util.isInteger(message.maxLen.high)))
                    return "maxLen: integer|Long expected";
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                if (!$util.isString(message.pattern))
                    return "pattern: string expected";
            if (message.prefix != null && message.hasOwnProperty("prefix"))
                if (!(message.prefix && typeof message.prefix.length === "number" || $util.isString(message.prefix)))
                    return "prefix: buffer expected";
            if (message.suffix != null && message.hasOwnProperty("suffix"))
                if (!(message.suffix && typeof message.suffix.length === "number" || $util.isString(message.suffix)))
                    return "suffix: buffer expected";
            if (message.contains != null && message.hasOwnProperty("contains"))
                if (!(message.contains && typeof message.contains.length === "number" || $util.isString(message.contains)))
                    return "contains: buffer expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!(message["in"][i] && typeof message["in"][i].length === "number" || $util.isString(message["in"][i])))
                        return "in: buffer[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!(message.notIn[i] && typeof message.notIn[i].length === "number" || $util.isString(message.notIn[i])))
                        return "notIn: buffer[] expected";
            }
            if (message.ip != null && message.hasOwnProperty("ip")) {
                properties.wellKnown = 1;
                if (typeof message.ip !== "boolean")
                    return "ip: boolean expected";
            }
            if (message.ipv4 != null && message.hasOwnProperty("ipv4")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.ipv4 !== "boolean")
                    return "ipv4: boolean expected";
            }
            if (message.ipv6 != null && message.hasOwnProperty("ipv6")) {
                if (properties.wellKnown === 1)
                    return "wellKnown: multiple values";
                properties.wellKnown = 1;
                if (typeof message.ipv6 !== "boolean")
                    return "ipv6: boolean expected";
            }
            return null;
        };

        /**
         * Creates a BytesRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.BytesRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.BytesRules} BytesRules
         */
        BytesRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.BytesRules)
                return object;
            let message = new $root.validate.BytesRules();
            if (object["const"] != null)
                if (typeof object["const"] === "string")
                    $util.base64.decode(object["const"], message["const"] = $util.newBuffer($util.base64.length(object["const"])), 0);
                else if (object["const"].length)
                    message["const"] = object["const"];
            if (object.len != null)
                if ($util.Long)
                    (message.len = $util.Long.fromValue(object.len)).unsigned = true;
                else if (typeof object.len === "string")
                    message.len = parseInt(object.len, 10);
                else if (typeof object.len === "number")
                    message.len = object.len;
                else if (typeof object.len === "object")
                    message.len = new $util.LongBits(object.len.low >>> 0, object.len.high >>> 0).toNumber(true);
            if (object.minLen != null)
                if ($util.Long)
                    (message.minLen = $util.Long.fromValue(object.minLen)).unsigned = true;
                else if (typeof object.minLen === "string")
                    message.minLen = parseInt(object.minLen, 10);
                else if (typeof object.minLen === "number")
                    message.minLen = object.minLen;
                else if (typeof object.minLen === "object")
                    message.minLen = new $util.LongBits(object.minLen.low >>> 0, object.minLen.high >>> 0).toNumber(true);
            if (object.maxLen != null)
                if ($util.Long)
                    (message.maxLen = $util.Long.fromValue(object.maxLen)).unsigned = true;
                else if (typeof object.maxLen === "string")
                    message.maxLen = parseInt(object.maxLen, 10);
                else if (typeof object.maxLen === "number")
                    message.maxLen = object.maxLen;
                else if (typeof object.maxLen === "object")
                    message.maxLen = new $util.LongBits(object.maxLen.low >>> 0, object.maxLen.high >>> 0).toNumber(true);
            if (object.pattern != null)
                message.pattern = String(object.pattern);
            if (object.prefix != null)
                if (typeof object.prefix === "string")
                    $util.base64.decode(object.prefix, message.prefix = $util.newBuffer($util.base64.length(object.prefix)), 0);
                else if (object.prefix.length)
                    message.prefix = object.prefix;
            if (object.suffix != null)
                if (typeof object.suffix === "string")
                    $util.base64.decode(object.suffix, message.suffix = $util.newBuffer($util.base64.length(object.suffix)), 0);
                else if (object.suffix.length)
                    message.suffix = object.suffix;
            if (object.contains != null)
                if (typeof object.contains === "string")
                    $util.base64.decode(object.contains, message.contains = $util.newBuffer($util.base64.length(object.contains)), 0);
                else if (object.contains.length)
                    message.contains = object.contains;
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.BytesRules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    if (typeof object["in"][i] === "string")
                        $util.base64.decode(object["in"][i], message["in"][i] = $util.newBuffer($util.base64.length(object["in"][i])), 0);
                    else if (object["in"][i].length)
                        message["in"][i] = object["in"][i];
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.BytesRules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    if (typeof object.notIn[i] === "string")
                        $util.base64.decode(object.notIn[i], message.notIn[i] = $util.newBuffer($util.base64.length(object.notIn[i])), 0);
                    else if (object.notIn[i].length)
                        message.notIn[i] = object.notIn[i];
            }
            if (object.ip != null)
                message.ip = Boolean(object.ip);
            if (object.ipv4 != null)
                message.ipv4 = Boolean(object.ipv4);
            if (object.ipv6 != null)
                message.ipv6 = Boolean(object.ipv6);
            return message;
        };

        /**
         * Creates a plain object from a BytesRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.BytesRules
         * @static
         * @param {validate.BytesRules} message BytesRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        BytesRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                if (options.bytes === String)
                    object["const"] = "";
                else {
                    object["const"] = [];
                    if (options.bytes !== Array)
                        object["const"] = $util.newBuffer(object["const"]);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.minLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minLen = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxLen = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxLen = options.longs === String ? "0" : 0;
                object.pattern = "";
                if (options.bytes === String)
                    object.prefix = "";
                else {
                    object.prefix = [];
                    if (options.bytes !== Array)
                        object.prefix = $util.newBuffer(object.prefix);
                }
                if (options.bytes === String)
                    object.suffix = "";
                else {
                    object.suffix = [];
                    if (options.bytes !== Array)
                        object.suffix = $util.newBuffer(object.suffix);
                }
                if (options.bytes === String)
                    object.contains = "";
                else {
                    object.contains = [];
                    if (options.bytes !== Array)
                        object.contains = $util.newBuffer(object.contains);
                }
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.len = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.len = options.longs === String ? "0" : 0;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = options.bytes === String ? $util.base64.encode(message["const"], 0, message["const"].length) : options.bytes === Array ? Array.prototype.slice.call(message["const"]) : message["const"];
            if (message.minLen != null && message.hasOwnProperty("minLen"))
                if (typeof message.minLen === "number")
                    object.minLen = options.longs === String ? String(message.minLen) : message.minLen;
                else
                    object.minLen = options.longs === String ? $util.Long.prototype.toString.call(message.minLen) : options.longs === Number ? new $util.LongBits(message.minLen.low >>> 0, message.minLen.high >>> 0).toNumber(true) : message.minLen;
            if (message.maxLen != null && message.hasOwnProperty("maxLen"))
                if (typeof message.maxLen === "number")
                    object.maxLen = options.longs === String ? String(message.maxLen) : message.maxLen;
                else
                    object.maxLen = options.longs === String ? $util.Long.prototype.toString.call(message.maxLen) : options.longs === Number ? new $util.LongBits(message.maxLen.low >>> 0, message.maxLen.high >>> 0).toNumber(true) : message.maxLen;
            if (message.pattern != null && message.hasOwnProperty("pattern"))
                object.pattern = message.pattern;
            if (message.prefix != null && message.hasOwnProperty("prefix"))
                object.prefix = options.bytes === String ? $util.base64.encode(message.prefix, 0, message.prefix.length) : options.bytes === Array ? Array.prototype.slice.call(message.prefix) : message.prefix;
            if (message.suffix != null && message.hasOwnProperty("suffix"))
                object.suffix = options.bytes === String ? $util.base64.encode(message.suffix, 0, message.suffix.length) : options.bytes === Array ? Array.prototype.slice.call(message.suffix) : message.suffix;
            if (message.contains != null && message.hasOwnProperty("contains"))
                object.contains = options.bytes === String ? $util.base64.encode(message.contains, 0, message.contains.length) : options.bytes === Array ? Array.prototype.slice.call(message.contains) : message.contains;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = options.bytes === String ? $util.base64.encode(message["in"][j], 0, message["in"][j].length) : options.bytes === Array ? Array.prototype.slice.call(message["in"][j]) : message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = options.bytes === String ? $util.base64.encode(message.notIn[j], 0, message.notIn[j].length) : options.bytes === Array ? Array.prototype.slice.call(message.notIn[j]) : message.notIn[j];
            }
            if (message.ip != null && message.hasOwnProperty("ip")) {
                object.ip = message.ip;
                if (options.oneofs)
                    object.wellKnown = "ip";
            }
            if (message.ipv4 != null && message.hasOwnProperty("ipv4")) {
                object.ipv4 = message.ipv4;
                if (options.oneofs)
                    object.wellKnown = "ipv4";
            }
            if (message.ipv6 != null && message.hasOwnProperty("ipv6")) {
                object.ipv6 = message.ipv6;
                if (options.oneofs)
                    object.wellKnown = "ipv6";
            }
            if (message.len != null && message.hasOwnProperty("len"))
                if (typeof message.len === "number")
                    object.len = options.longs === String ? String(message.len) : message.len;
                else
                    object.len = options.longs === String ? $util.Long.prototype.toString.call(message.len) : options.longs === Number ? new $util.LongBits(message.len.low >>> 0, message.len.high >>> 0).toNumber(true) : message.len;
            return object;
        };

        /**
         * Converts this BytesRules to JSON.
         * @function toJSON
         * @memberof validate.BytesRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        BytesRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return BytesRules;
    })();

    validate.EnumRules = (function() {

        /**
         * Properties of an EnumRules.
         * @memberof validate
         * @interface IEnumRules
         * @property {number|null} ["const"] EnumRules const
         * @property {boolean|null} [definedOnly] EnumRules definedOnly
         * @property {Array.<number>|null} ["in"] EnumRules in
         * @property {Array.<number>|null} [notIn] EnumRules notIn
         */

        /**
         * Constructs a new EnumRules.
         * @memberof validate
         * @classdesc Represents an EnumRules.
         * @implements IEnumRules
         * @constructor
         * @param {validate.IEnumRules=} [properties] Properties to set
         */
        function EnumRules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * EnumRules const.
         * @member {number} const
         * @memberof validate.EnumRules
         * @instance
         */
        EnumRules.prototype["const"] = 0;

        /**
         * EnumRules definedOnly.
         * @member {boolean} definedOnly
         * @memberof validate.EnumRules
         * @instance
         */
        EnumRules.prototype.definedOnly = false;

        /**
         * EnumRules in.
         * @member {Array.<number>} in
         * @memberof validate.EnumRules
         * @instance
         */
        EnumRules.prototype["in"] = $util.emptyArray;

        /**
         * EnumRules notIn.
         * @member {Array.<number>} notIn
         * @memberof validate.EnumRules
         * @instance
         */
        EnumRules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies an EnumRules message.
         * @function verify
         * @memberof validate.EnumRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        EnumRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message["const"] != null && message.hasOwnProperty("const"))
                if (!$util.isInteger(message["const"]))
                    return "const: integer expected";
            if (message.definedOnly != null && message.hasOwnProperty("definedOnly"))
                if (typeof message.definedOnly !== "boolean")
                    return "definedOnly: boolean expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isInteger(message["in"][i]))
                        return "in: integer[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isInteger(message.notIn[i]))
                        return "notIn: integer[] expected";
            }
            return null;
        };

        /**
         * Creates an EnumRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.EnumRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.EnumRules} EnumRules
         */
        EnumRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.EnumRules)
                return object;
            let message = new $root.validate.EnumRules();
            if (object["const"] != null)
                message["const"] = object["const"] | 0;
            if (object.definedOnly != null)
                message.definedOnly = Boolean(object.definedOnly);
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.EnumRules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = object["in"][i] | 0;
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.EnumRules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = object.notIn[i] | 0;
            }
            return message;
        };

        /**
         * Creates a plain object from an EnumRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.EnumRules
         * @static
         * @param {validate.EnumRules} message EnumRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        EnumRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object["const"] = 0;
                object.definedOnly = false;
            }
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = message["const"];
            if (message.definedOnly != null && message.hasOwnProperty("definedOnly"))
                object.definedOnly = message.definedOnly;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this EnumRules to JSON.
         * @function toJSON
         * @memberof validate.EnumRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        EnumRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return EnumRules;
    })();

    validate.MessageRules = (function() {

        /**
         * Properties of a MessageRules.
         * @memberof validate
         * @interface IMessageRules
         * @property {boolean|null} [skip] MessageRules skip
         * @property {boolean|null} [required] MessageRules required
         */

        /**
         * Constructs a new MessageRules.
         * @memberof validate
         * @classdesc Represents a MessageRules.
         * @implements IMessageRules
         * @constructor
         * @param {validate.IMessageRules=} [properties] Properties to set
         */
        function MessageRules(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MessageRules skip.
         * @member {boolean} skip
         * @memberof validate.MessageRules
         * @instance
         */
        MessageRules.prototype.skip = false;

        /**
         * MessageRules required.
         * @member {boolean} required
         * @memberof validate.MessageRules
         * @instance
         */
        MessageRules.prototype.required = false;

        /**
         * Verifies a MessageRules message.
         * @function verify
         * @memberof validate.MessageRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MessageRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.skip != null && message.hasOwnProperty("skip"))
                if (typeof message.skip !== "boolean")
                    return "skip: boolean expected";
            if (message.required != null && message.hasOwnProperty("required"))
                if (typeof message.required !== "boolean")
                    return "required: boolean expected";
            return null;
        };

        /**
         * Creates a MessageRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.MessageRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.MessageRules} MessageRules
         */
        MessageRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.MessageRules)
                return object;
            let message = new $root.validate.MessageRules();
            if (object.skip != null)
                message.skip = Boolean(object.skip);
            if (object.required != null)
                message.required = Boolean(object.required);
            return message;
        };

        /**
         * Creates a plain object from a MessageRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.MessageRules
         * @static
         * @param {validate.MessageRules} message MessageRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MessageRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.skip = false;
                object.required = false;
            }
            if (message.skip != null && message.hasOwnProperty("skip"))
                object.skip = message.skip;
            if (message.required != null && message.hasOwnProperty("required"))
                object.required = message.required;
            return object;
        };

        /**
         * Converts this MessageRules to JSON.
         * @function toJSON
         * @memberof validate.MessageRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MessageRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MessageRules;
    })();

    validate.RepeatedRules = (function() {

        /**
         * Properties of a RepeatedRules.
         * @memberof validate
         * @interface IRepeatedRules
         * @property {number|Long|null} [minItems] RepeatedRules minItems
         * @property {number|Long|null} [maxItems] RepeatedRules maxItems
         * @property {boolean|null} [unique] RepeatedRules unique
         * @property {validate.IFieldRules|null} [items] RepeatedRules items
         */

        /**
         * Constructs a new RepeatedRules.
         * @memberof validate
         * @classdesc Represents a RepeatedRules.
         * @implements IRepeatedRules
         * @constructor
         * @param {validate.IRepeatedRules=} [properties] Properties to set
         */
        function RepeatedRules(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * RepeatedRules minItems.
         * @member {number|Long} minItems
         * @memberof validate.RepeatedRules
         * @instance
         */
        RepeatedRules.prototype.minItems = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RepeatedRules maxItems.
         * @member {number|Long} maxItems
         * @memberof validate.RepeatedRules
         * @instance
         */
        RepeatedRules.prototype.maxItems = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * RepeatedRules unique.
         * @member {boolean} unique
         * @memberof validate.RepeatedRules
         * @instance
         */
        RepeatedRules.prototype.unique = false;

        /**
         * RepeatedRules items.
         * @member {validate.IFieldRules|null|undefined} items
         * @memberof validate.RepeatedRules
         * @instance
         */
        RepeatedRules.prototype.items = null;

        /**
         * Verifies a RepeatedRules message.
         * @function verify
         * @memberof validate.RepeatedRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        RepeatedRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.minItems != null && message.hasOwnProperty("minItems"))
                if (!$util.isInteger(message.minItems) && !(message.minItems && $util.isInteger(message.minItems.low) && $util.isInteger(message.minItems.high)))
                    return "minItems: integer|Long expected";
            if (message.maxItems != null && message.hasOwnProperty("maxItems"))
                if (!$util.isInteger(message.maxItems) && !(message.maxItems && $util.isInteger(message.maxItems.low) && $util.isInteger(message.maxItems.high)))
                    return "maxItems: integer|Long expected";
            if (message.unique != null && message.hasOwnProperty("unique"))
                if (typeof message.unique !== "boolean")
                    return "unique: boolean expected";
            if (message.items != null && message.hasOwnProperty("items")) {
                let error = $root.validate.FieldRules.verify(message.items);
                if (error)
                    return "items." + error;
            }
            return null;
        };

        /**
         * Creates a RepeatedRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.RepeatedRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.RepeatedRules} RepeatedRules
         */
        RepeatedRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.RepeatedRules)
                return object;
            let message = new $root.validate.RepeatedRules();
            if (object.minItems != null)
                if ($util.Long)
                    (message.minItems = $util.Long.fromValue(object.minItems)).unsigned = true;
                else if (typeof object.minItems === "string")
                    message.minItems = parseInt(object.minItems, 10);
                else if (typeof object.minItems === "number")
                    message.minItems = object.minItems;
                else if (typeof object.minItems === "object")
                    message.minItems = new $util.LongBits(object.minItems.low >>> 0, object.minItems.high >>> 0).toNumber(true);
            if (object.maxItems != null)
                if ($util.Long)
                    (message.maxItems = $util.Long.fromValue(object.maxItems)).unsigned = true;
                else if (typeof object.maxItems === "string")
                    message.maxItems = parseInt(object.maxItems, 10);
                else if (typeof object.maxItems === "number")
                    message.maxItems = object.maxItems;
                else if (typeof object.maxItems === "object")
                    message.maxItems = new $util.LongBits(object.maxItems.low >>> 0, object.maxItems.high >>> 0).toNumber(true);
            if (object.unique != null)
                message.unique = Boolean(object.unique);
            if (object.items != null) {
                if (typeof object.items !== "object")
                    throw TypeError(".validate.RepeatedRules.items: object expected");
                message.items = $root.validate.FieldRules.fromObject(object.items);
            }
            return message;
        };

        /**
         * Creates a plain object from a RepeatedRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.RepeatedRules
         * @static
         * @param {validate.RepeatedRules} message RepeatedRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        RepeatedRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.minItems = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minItems = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxItems = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxItems = options.longs === String ? "0" : 0;
                object.unique = false;
                object.items = null;
            }
            if (message.minItems != null && message.hasOwnProperty("minItems"))
                if (typeof message.minItems === "number")
                    object.minItems = options.longs === String ? String(message.minItems) : message.minItems;
                else
                    object.minItems = options.longs === String ? $util.Long.prototype.toString.call(message.minItems) : options.longs === Number ? new $util.LongBits(message.minItems.low >>> 0, message.minItems.high >>> 0).toNumber(true) : message.minItems;
            if (message.maxItems != null && message.hasOwnProperty("maxItems"))
                if (typeof message.maxItems === "number")
                    object.maxItems = options.longs === String ? String(message.maxItems) : message.maxItems;
                else
                    object.maxItems = options.longs === String ? $util.Long.prototype.toString.call(message.maxItems) : options.longs === Number ? new $util.LongBits(message.maxItems.low >>> 0, message.maxItems.high >>> 0).toNumber(true) : message.maxItems;
            if (message.unique != null && message.hasOwnProperty("unique"))
                object.unique = message.unique;
            if (message.items != null && message.hasOwnProperty("items"))
                object.items = $root.validate.FieldRules.toObject(message.items, options);
            return object;
        };

        /**
         * Converts this RepeatedRules to JSON.
         * @function toJSON
         * @memberof validate.RepeatedRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        RepeatedRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return RepeatedRules;
    })();

    validate.MapRules = (function() {

        /**
         * Properties of a MapRules.
         * @memberof validate
         * @interface IMapRules
         * @property {number|Long|null} [minPairs] MapRules minPairs
         * @property {number|Long|null} [maxPairs] MapRules maxPairs
         * @property {boolean|null} [noSparse] MapRules noSparse
         * @property {validate.IFieldRules|null} [keys] MapRules keys
         * @property {validate.IFieldRules|null} [values] MapRules values
         */

        /**
         * Constructs a new MapRules.
         * @memberof validate
         * @classdesc Represents a MapRules.
         * @implements IMapRules
         * @constructor
         * @param {validate.IMapRules=} [properties] Properties to set
         */
        function MapRules(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * MapRules minPairs.
         * @member {number|Long} minPairs
         * @memberof validate.MapRules
         * @instance
         */
        MapRules.prototype.minPairs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MapRules maxPairs.
         * @member {number|Long} maxPairs
         * @memberof validate.MapRules
         * @instance
         */
        MapRules.prototype.maxPairs = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

        /**
         * MapRules noSparse.
         * @member {boolean} noSparse
         * @memberof validate.MapRules
         * @instance
         */
        MapRules.prototype.noSparse = false;

        /**
         * MapRules keys.
         * @member {validate.IFieldRules|null|undefined} keys
         * @memberof validate.MapRules
         * @instance
         */
        MapRules.prototype.keys = null;

        /**
         * MapRules values.
         * @member {validate.IFieldRules|null|undefined} values
         * @memberof validate.MapRules
         * @instance
         */
        MapRules.prototype.values = null;

        /**
         * Verifies a MapRules message.
         * @function verify
         * @memberof validate.MapRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        MapRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.minPairs != null && message.hasOwnProperty("minPairs"))
                if (!$util.isInteger(message.minPairs) && !(message.minPairs && $util.isInteger(message.minPairs.low) && $util.isInteger(message.minPairs.high)))
                    return "minPairs: integer|Long expected";
            if (message.maxPairs != null && message.hasOwnProperty("maxPairs"))
                if (!$util.isInteger(message.maxPairs) && !(message.maxPairs && $util.isInteger(message.maxPairs.low) && $util.isInteger(message.maxPairs.high)))
                    return "maxPairs: integer|Long expected";
            if (message.noSparse != null && message.hasOwnProperty("noSparse"))
                if (typeof message.noSparse !== "boolean")
                    return "noSparse: boolean expected";
            if (message.keys != null && message.hasOwnProperty("keys")) {
                let error = $root.validate.FieldRules.verify(message.keys);
                if (error)
                    return "keys." + error;
            }
            if (message.values != null && message.hasOwnProperty("values")) {
                let error = $root.validate.FieldRules.verify(message.values);
                if (error)
                    return "values." + error;
            }
            return null;
        };

        /**
         * Creates a MapRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.MapRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.MapRules} MapRules
         */
        MapRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.MapRules)
                return object;
            let message = new $root.validate.MapRules();
            if (object.minPairs != null)
                if ($util.Long)
                    (message.minPairs = $util.Long.fromValue(object.minPairs)).unsigned = true;
                else if (typeof object.minPairs === "string")
                    message.minPairs = parseInt(object.minPairs, 10);
                else if (typeof object.minPairs === "number")
                    message.minPairs = object.minPairs;
                else if (typeof object.minPairs === "object")
                    message.minPairs = new $util.LongBits(object.minPairs.low >>> 0, object.minPairs.high >>> 0).toNumber(true);
            if (object.maxPairs != null)
                if ($util.Long)
                    (message.maxPairs = $util.Long.fromValue(object.maxPairs)).unsigned = true;
                else if (typeof object.maxPairs === "string")
                    message.maxPairs = parseInt(object.maxPairs, 10);
                else if (typeof object.maxPairs === "number")
                    message.maxPairs = object.maxPairs;
                else if (typeof object.maxPairs === "object")
                    message.maxPairs = new $util.LongBits(object.maxPairs.low >>> 0, object.maxPairs.high >>> 0).toNumber(true);
            if (object.noSparse != null)
                message.noSparse = Boolean(object.noSparse);
            if (object.keys != null) {
                if (typeof object.keys !== "object")
                    throw TypeError(".validate.MapRules.keys: object expected");
                message.keys = $root.validate.FieldRules.fromObject(object.keys);
            }
            if (object.values != null) {
                if (typeof object.values !== "object")
                    throw TypeError(".validate.MapRules.values: object expected");
                message.values = $root.validate.FieldRules.fromObject(object.values);
            }
            return message;
        };

        /**
         * Creates a plain object from a MapRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.MapRules
         * @static
         * @param {validate.MapRules} message MapRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        MapRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.minPairs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.minPairs = options.longs === String ? "0" : 0;
                if ($util.Long) {
                    let long = new $util.Long(0, 0, true);
                    object.maxPairs = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                } else
                    object.maxPairs = options.longs === String ? "0" : 0;
                object.noSparse = false;
                object.keys = null;
                object.values = null;
            }
            if (message.minPairs != null && message.hasOwnProperty("minPairs"))
                if (typeof message.minPairs === "number")
                    object.minPairs = options.longs === String ? String(message.minPairs) : message.minPairs;
                else
                    object.minPairs = options.longs === String ? $util.Long.prototype.toString.call(message.minPairs) : options.longs === Number ? new $util.LongBits(message.minPairs.low >>> 0, message.minPairs.high >>> 0).toNumber(true) : message.minPairs;
            if (message.maxPairs != null && message.hasOwnProperty("maxPairs"))
                if (typeof message.maxPairs === "number")
                    object.maxPairs = options.longs === String ? String(message.maxPairs) : message.maxPairs;
                else
                    object.maxPairs = options.longs === String ? $util.Long.prototype.toString.call(message.maxPairs) : options.longs === Number ? new $util.LongBits(message.maxPairs.low >>> 0, message.maxPairs.high >>> 0).toNumber(true) : message.maxPairs;
            if (message.noSparse != null && message.hasOwnProperty("noSparse"))
                object.noSparse = message.noSparse;
            if (message.keys != null && message.hasOwnProperty("keys"))
                object.keys = $root.validate.FieldRules.toObject(message.keys, options);
            if (message.values != null && message.hasOwnProperty("values"))
                object.values = $root.validate.FieldRules.toObject(message.values, options);
            return object;
        };

        /**
         * Converts this MapRules to JSON.
         * @function toJSON
         * @memberof validate.MapRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        MapRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return MapRules;
    })();

    validate.AnyRules = (function() {

        /**
         * Properties of an AnyRules.
         * @memberof validate
         * @interface IAnyRules
         * @property {boolean|null} [required] AnyRules required
         * @property {Array.<string>|null} ["in"] AnyRules in
         * @property {Array.<string>|null} [notIn] AnyRules notIn
         */

        /**
         * Constructs a new AnyRules.
         * @memberof validate
         * @classdesc Represents an AnyRules.
         * @implements IAnyRules
         * @constructor
         * @param {validate.IAnyRules=} [properties] Properties to set
         */
        function AnyRules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * AnyRules required.
         * @member {boolean} required
         * @memberof validate.AnyRules
         * @instance
         */
        AnyRules.prototype.required = false;

        /**
         * AnyRules in.
         * @member {Array.<string>} in
         * @memberof validate.AnyRules
         * @instance
         */
        AnyRules.prototype["in"] = $util.emptyArray;

        /**
         * AnyRules notIn.
         * @member {Array.<string>} notIn
         * @memberof validate.AnyRules
         * @instance
         */
        AnyRules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies an AnyRules message.
         * @function verify
         * @memberof validate.AnyRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        AnyRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.required != null && message.hasOwnProperty("required"))
                if (typeof message.required !== "boolean")
                    return "required: boolean expected";
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i)
                    if (!$util.isString(message["in"][i]))
                        return "in: string[] expected";
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i)
                    if (!$util.isString(message.notIn[i]))
                        return "notIn: string[] expected";
            }
            return null;
        };

        /**
         * Creates an AnyRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.AnyRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.AnyRules} AnyRules
         */
        AnyRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.AnyRules)
                return object;
            let message = new $root.validate.AnyRules();
            if (object.required != null)
                message.required = Boolean(object.required);
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.AnyRules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i)
                    message["in"][i] = String(object["in"][i]);
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.AnyRules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i)
                    message.notIn[i] = String(object.notIn[i]);
            }
            return message;
        };

        /**
         * Creates a plain object from an AnyRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.AnyRules
         * @static
         * @param {validate.AnyRules} message AnyRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        AnyRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults)
                object.required = false;
            if (message.required != null && message.hasOwnProperty("required"))
                object.required = message.required;
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = message["in"][j];
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = message.notIn[j];
            }
            return object;
        };

        /**
         * Converts this AnyRules to JSON.
         * @function toJSON
         * @memberof validate.AnyRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        AnyRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return AnyRules;
    })();

    validate.DurationRules = (function() {

        /**
         * Properties of a DurationRules.
         * @memberof validate
         * @interface IDurationRules
         * @property {boolean|null} [required] DurationRules required
         * @property {google.protobuf.IDuration|null} ["const"] DurationRules const
         * @property {google.protobuf.IDuration|null} [lt] DurationRules lt
         * @property {google.protobuf.IDuration|null} [lte] DurationRules lte
         * @property {google.protobuf.IDuration|null} [gt] DurationRules gt
         * @property {google.protobuf.IDuration|null} [gte] DurationRules gte
         * @property {Array.<google.protobuf.IDuration>|null} ["in"] DurationRules in
         * @property {Array.<google.protobuf.IDuration>|null} [notIn] DurationRules notIn
         */

        /**
         * Constructs a new DurationRules.
         * @memberof validate
         * @classdesc Represents a DurationRules.
         * @implements IDurationRules
         * @constructor
         * @param {validate.IDurationRules=} [properties] Properties to set
         */
        function DurationRules(properties) {
            this["in"] = [];
            this.notIn = [];
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * DurationRules required.
         * @member {boolean} required
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype.required = false;

        /**
         * DurationRules const.
         * @member {google.protobuf.IDuration|null|undefined} const
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype["const"] = null;

        /**
         * DurationRules lt.
         * @member {google.protobuf.IDuration|null|undefined} lt
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype.lt = null;

        /**
         * DurationRules lte.
         * @member {google.protobuf.IDuration|null|undefined} lte
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype.lte = null;

        /**
         * DurationRules gt.
         * @member {google.protobuf.IDuration|null|undefined} gt
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype.gt = null;

        /**
         * DurationRules gte.
         * @member {google.protobuf.IDuration|null|undefined} gte
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype.gte = null;

        /**
         * DurationRules in.
         * @member {Array.<google.protobuf.IDuration>} in
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype["in"] = $util.emptyArray;

        /**
         * DurationRules notIn.
         * @member {Array.<google.protobuf.IDuration>} notIn
         * @memberof validate.DurationRules
         * @instance
         */
        DurationRules.prototype.notIn = $util.emptyArray;

        /**
         * Verifies a DurationRules message.
         * @function verify
         * @memberof validate.DurationRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        DurationRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.required != null && message.hasOwnProperty("required"))
                if (typeof message.required !== "boolean")
                    return "required: boolean expected";
            if (message["const"] != null && message.hasOwnProperty("const")) {
                let error = $root.google.protobuf.Duration.verify(message["const"]);
                if (error)
                    return "const." + error;
            }
            if (message.lt != null && message.hasOwnProperty("lt")) {
                let error = $root.google.protobuf.Duration.verify(message.lt);
                if (error)
                    return "lt." + error;
            }
            if (message.lte != null && message.hasOwnProperty("lte")) {
                let error = $root.google.protobuf.Duration.verify(message.lte);
                if (error)
                    return "lte." + error;
            }
            if (message.gt != null && message.hasOwnProperty("gt")) {
                let error = $root.google.protobuf.Duration.verify(message.gt);
                if (error)
                    return "gt." + error;
            }
            if (message.gte != null && message.hasOwnProperty("gte")) {
                let error = $root.google.protobuf.Duration.verify(message.gte);
                if (error)
                    return "gte." + error;
            }
            if (message["in"] != null && message.hasOwnProperty("in")) {
                if (!Array.isArray(message["in"]))
                    return "in: array expected";
                for (let i = 0; i < message["in"].length; ++i) {
                    let error = $root.google.protobuf.Duration.verify(message["in"][i]);
                    if (error)
                        return "in." + error;
                }
            }
            if (message.notIn != null && message.hasOwnProperty("notIn")) {
                if (!Array.isArray(message.notIn))
                    return "notIn: array expected";
                for (let i = 0; i < message.notIn.length; ++i) {
                    let error = $root.google.protobuf.Duration.verify(message.notIn[i]);
                    if (error)
                        return "notIn." + error;
                }
            }
            return null;
        };

        /**
         * Creates a DurationRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.DurationRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.DurationRules} DurationRules
         */
        DurationRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.DurationRules)
                return object;
            let message = new $root.validate.DurationRules();
            if (object.required != null)
                message.required = Boolean(object.required);
            if (object["const"] != null) {
                if (typeof object["const"] !== "object")
                    throw TypeError(".validate.DurationRules.const: object expected");
                message["const"] = $root.google.protobuf.Duration.fromObject(object["const"]);
            }
            if (object.lt != null) {
                if (typeof object.lt !== "object")
                    throw TypeError(".validate.DurationRules.lt: object expected");
                message.lt = $root.google.protobuf.Duration.fromObject(object.lt);
            }
            if (object.lte != null) {
                if (typeof object.lte !== "object")
                    throw TypeError(".validate.DurationRules.lte: object expected");
                message.lte = $root.google.protobuf.Duration.fromObject(object.lte);
            }
            if (object.gt != null) {
                if (typeof object.gt !== "object")
                    throw TypeError(".validate.DurationRules.gt: object expected");
                message.gt = $root.google.protobuf.Duration.fromObject(object.gt);
            }
            if (object.gte != null) {
                if (typeof object.gte !== "object")
                    throw TypeError(".validate.DurationRules.gte: object expected");
                message.gte = $root.google.protobuf.Duration.fromObject(object.gte);
            }
            if (object["in"]) {
                if (!Array.isArray(object["in"]))
                    throw TypeError(".validate.DurationRules.in: array expected");
                message["in"] = [];
                for (let i = 0; i < object["in"].length; ++i) {
                    if (typeof object["in"][i] !== "object")
                        throw TypeError(".validate.DurationRules.in: object expected");
                    message["in"][i] = $root.google.protobuf.Duration.fromObject(object["in"][i]);
                }
            }
            if (object.notIn) {
                if (!Array.isArray(object.notIn))
                    throw TypeError(".validate.DurationRules.notIn: array expected");
                message.notIn = [];
                for (let i = 0; i < object.notIn.length; ++i) {
                    if (typeof object.notIn[i] !== "object")
                        throw TypeError(".validate.DurationRules.notIn: object expected");
                    message.notIn[i] = $root.google.protobuf.Duration.fromObject(object.notIn[i]);
                }
            }
            return message;
        };

        /**
         * Creates a plain object from a DurationRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.DurationRules
         * @static
         * @param {validate.DurationRules} message DurationRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        DurationRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.arrays || options.defaults) {
                object["in"] = [];
                object.notIn = [];
            }
            if (options.defaults) {
                object.required = false;
                object["const"] = null;
                object.lt = null;
                object.lte = null;
                object.gt = null;
                object.gte = null;
            }
            if (message.required != null && message.hasOwnProperty("required"))
                object.required = message.required;
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = $root.google.protobuf.Duration.toObject(message["const"], options);
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = $root.google.protobuf.Duration.toObject(message.lt, options);
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = $root.google.protobuf.Duration.toObject(message.lte, options);
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = $root.google.protobuf.Duration.toObject(message.gt, options);
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = $root.google.protobuf.Duration.toObject(message.gte, options);
            if (message["in"] && message["in"].length) {
                object["in"] = [];
                for (let j = 0; j < message["in"].length; ++j)
                    object["in"][j] = $root.google.protobuf.Duration.toObject(message["in"][j], options);
            }
            if (message.notIn && message.notIn.length) {
                object.notIn = [];
                for (let j = 0; j < message.notIn.length; ++j)
                    object.notIn[j] = $root.google.protobuf.Duration.toObject(message.notIn[j], options);
            }
            return object;
        };

        /**
         * Converts this DurationRules to JSON.
         * @function toJSON
         * @memberof validate.DurationRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        DurationRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return DurationRules;
    })();

    validate.TimestampRules = (function() {

        /**
         * Properties of a TimestampRules.
         * @memberof validate
         * @interface ITimestampRules
         * @property {boolean|null} [required] TimestampRules required
         * @property {google.protobuf.ITimestamp|null} ["const"] TimestampRules const
         * @property {google.protobuf.ITimestamp|null} [lt] TimestampRules lt
         * @property {google.protobuf.ITimestamp|null} [lte] TimestampRules lte
         * @property {google.protobuf.ITimestamp|null} [gt] TimestampRules gt
         * @property {google.protobuf.ITimestamp|null} [gte] TimestampRules gte
         * @property {boolean|null} [ltNow] TimestampRules ltNow
         * @property {boolean|null} [gtNow] TimestampRules gtNow
         * @property {google.protobuf.IDuration|null} [within] TimestampRules within
         */

        /**
         * Constructs a new TimestampRules.
         * @memberof validate
         * @classdesc Represents a TimestampRules.
         * @implements ITimestampRules
         * @constructor
         * @param {validate.ITimestampRules=} [properties] Properties to set
         */
        function TimestampRules(properties) {
            if (properties)
                for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                    if (properties[keys[i]] != null)
                        this[keys[i]] = properties[keys[i]];
        }

        /**
         * TimestampRules required.
         * @member {boolean} required
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.required = false;

        /**
         * TimestampRules const.
         * @member {google.protobuf.ITimestamp|null|undefined} const
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype["const"] = null;

        /**
         * TimestampRules lt.
         * @member {google.protobuf.ITimestamp|null|undefined} lt
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.lt = null;

        /**
         * TimestampRules lte.
         * @member {google.protobuf.ITimestamp|null|undefined} lte
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.lte = null;

        /**
         * TimestampRules gt.
         * @member {google.protobuf.ITimestamp|null|undefined} gt
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.gt = null;

        /**
         * TimestampRules gte.
         * @member {google.protobuf.ITimestamp|null|undefined} gte
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.gte = null;

        /**
         * TimestampRules ltNow.
         * @member {boolean} ltNow
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.ltNow = false;

        /**
         * TimestampRules gtNow.
         * @member {boolean} gtNow
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.gtNow = false;

        /**
         * TimestampRules within.
         * @member {google.protobuf.IDuration|null|undefined} within
         * @memberof validate.TimestampRules
         * @instance
         */
        TimestampRules.prototype.within = null;

        /**
         * Verifies a TimestampRules message.
         * @function verify
         * @memberof validate.TimestampRules
         * @static
         * @param {Object.<string,*>} message Plain object to verify
         * @returns {string|null} `null` if valid, otherwise the reason why it is not
         */
        TimestampRules.verify = function verify(message) {
            if (typeof message !== "object" || message === null)
                return "object expected";
            if (message.required != null && message.hasOwnProperty("required"))
                if (typeof message.required !== "boolean")
                    return "required: boolean expected";
            if (message["const"] != null && message.hasOwnProperty("const")) {
                let error = $root.google.protobuf.Timestamp.verify(message["const"]);
                if (error)
                    return "const." + error;
            }
            if (message.lt != null && message.hasOwnProperty("lt")) {
                let error = $root.google.protobuf.Timestamp.verify(message.lt);
                if (error)
                    return "lt." + error;
            }
            if (message.lte != null && message.hasOwnProperty("lte")) {
                let error = $root.google.protobuf.Timestamp.verify(message.lte);
                if (error)
                    return "lte." + error;
            }
            if (message.gt != null && message.hasOwnProperty("gt")) {
                let error = $root.google.protobuf.Timestamp.verify(message.gt);
                if (error)
                    return "gt." + error;
            }
            if (message.gte != null && message.hasOwnProperty("gte")) {
                let error = $root.google.protobuf.Timestamp.verify(message.gte);
                if (error)
                    return "gte." + error;
            }
            if (message.ltNow != null && message.hasOwnProperty("ltNow"))
                if (typeof message.ltNow !== "boolean")
                    return "ltNow: boolean expected";
            if (message.gtNow != null && message.hasOwnProperty("gtNow"))
                if (typeof message.gtNow !== "boolean")
                    return "gtNow: boolean expected";
            if (message.within != null && message.hasOwnProperty("within")) {
                let error = $root.google.protobuf.Duration.verify(message.within);
                if (error)
                    return "within." + error;
            }
            return null;
        };

        /**
         * Creates a TimestampRules message from a plain object. Also converts values to their respective internal types.
         * @function fromObject
         * @memberof validate.TimestampRules
         * @static
         * @param {Object.<string,*>} object Plain object
         * @returns {validate.TimestampRules} TimestampRules
         */
        TimestampRules.fromObject = function fromObject(object) {
            if (object instanceof $root.validate.TimestampRules)
                return object;
            let message = new $root.validate.TimestampRules();
            if (object.required != null)
                message.required = Boolean(object.required);
            if (object["const"] != null) {
                if (typeof object["const"] !== "object")
                    throw TypeError(".validate.TimestampRules.const: object expected");
                message["const"] = $root.google.protobuf.Timestamp.fromObject(object["const"]);
            }
            if (object.lt != null) {
                if (typeof object.lt !== "object")
                    throw TypeError(".validate.TimestampRules.lt: object expected");
                message.lt = $root.google.protobuf.Timestamp.fromObject(object.lt);
            }
            if (object.lte != null) {
                if (typeof object.lte !== "object")
                    throw TypeError(".validate.TimestampRules.lte: object expected");
                message.lte = $root.google.protobuf.Timestamp.fromObject(object.lte);
            }
            if (object.gt != null) {
                if (typeof object.gt !== "object")
                    throw TypeError(".validate.TimestampRules.gt: object expected");
                message.gt = $root.google.protobuf.Timestamp.fromObject(object.gt);
            }
            if (object.gte != null) {
                if (typeof object.gte !== "object")
                    throw TypeError(".validate.TimestampRules.gte: object expected");
                message.gte = $root.google.protobuf.Timestamp.fromObject(object.gte);
            }
            if (object.ltNow != null)
                message.ltNow = Boolean(object.ltNow);
            if (object.gtNow != null)
                message.gtNow = Boolean(object.gtNow);
            if (object.within != null) {
                if (typeof object.within !== "object")
                    throw TypeError(".validate.TimestampRules.within: object expected");
                message.within = $root.google.protobuf.Duration.fromObject(object.within);
            }
            return message;
        };

        /**
         * Creates a plain object from a TimestampRules message. Also converts values to other types if specified.
         * @function toObject
         * @memberof validate.TimestampRules
         * @static
         * @param {validate.TimestampRules} message TimestampRules
         * @param {$protobuf.IConversionOptions} [options] Conversion options
         * @returns {Object.<string,*>} Plain object
         */
        TimestampRules.toObject = function toObject(message, options) {
            if (!options)
                options = {};
            let object = {};
            if (options.defaults) {
                object.required = false;
                object["const"] = null;
                object.lt = null;
                object.lte = null;
                object.gt = null;
                object.gte = null;
                object.ltNow = false;
                object.gtNow = false;
                object.within = null;
            }
            if (message.required != null && message.hasOwnProperty("required"))
                object.required = message.required;
            if (message["const"] != null && message.hasOwnProperty("const"))
                object["const"] = $root.google.protobuf.Timestamp.toObject(message["const"], options);
            if (message.lt != null && message.hasOwnProperty("lt"))
                object.lt = $root.google.protobuf.Timestamp.toObject(message.lt, options);
            if (message.lte != null && message.hasOwnProperty("lte"))
                object.lte = $root.google.protobuf.Timestamp.toObject(message.lte, options);
            if (message.gt != null && message.hasOwnProperty("gt"))
                object.gt = $root.google.protobuf.Timestamp.toObject(message.gt, options);
            if (message.gte != null && message.hasOwnProperty("gte"))
                object.gte = $root.google.protobuf.Timestamp.toObject(message.gte, options);
            if (message.ltNow != null && message.hasOwnProperty("ltNow"))
                object.ltNow = message.ltNow;
            if (message.gtNow != null && message.hasOwnProperty("gtNow"))
                object.gtNow = message.gtNow;
            if (message.within != null && message.hasOwnProperty("within"))
                object.within = $root.google.protobuf.Duration.toObject(message.within, options);
            return object;
        };

        /**
         * Converts this TimestampRules to JSON.
         * @function toJSON
         * @memberof validate.TimestampRules
         * @instance
         * @returns {Object.<string,*>} JSON object
         */
        TimestampRules.prototype.toJSON = function toJSON() {
            return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
        };

        return TimestampRules;
    })();

    return validate;
})();

export const google = $root.google = (() => {

    /**
     * Namespace google.
     * @exports google
     * @namespace
     */
    const google = {};

    google.protobuf = (function() {

        /**
         * Namespace protobuf.
         * @memberof google
         * @namespace
         */
        const protobuf = {};

        protobuf.FileDescriptorSet = (function() {

            /**
             * Properties of a FileDescriptorSet.
             * @memberof google.protobuf
             * @interface IFileDescriptorSet
             * @property {Array.<google.protobuf.IFileDescriptorProto>|null} [file] FileDescriptorSet file
             */

            /**
             * Constructs a new FileDescriptorSet.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorSet.
             * @implements IFileDescriptorSet
             * @constructor
             * @param {google.protobuf.IFileDescriptorSet=} [properties] Properties to set
             */
            function FileDescriptorSet(properties) {
                this.file = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorSet file.
             * @member {Array.<google.protobuf.IFileDescriptorProto>} file
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             */
            FileDescriptorSet.prototype.file = $util.emptyArray;

            /**
             * Verifies a FileDescriptorSet message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorSet.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.file != null && message.hasOwnProperty("file")) {
                    if (!Array.isArray(message.file))
                        return "file: array expected";
                    for (let i = 0; i < message.file.length; ++i) {
                        let error = $root.google.protobuf.FileDescriptorProto.verify(message.file[i]);
                        if (error)
                            return "file." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileDescriptorSet message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorSet} FileDescriptorSet
             */
            FileDescriptorSet.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorSet)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorSet();
                if (object.file) {
                    if (!Array.isArray(object.file))
                        throw TypeError(".google.protobuf.FileDescriptorSet.file: array expected");
                    message.file = [];
                    for (let i = 0; i < object.file.length; ++i) {
                        if (typeof object.file[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorSet.file: object expected");
                        message.file[i] = $root.google.protobuf.FileDescriptorProto.fromObject(object.file[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorSet message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorSet
             * @static
             * @param {google.protobuf.FileDescriptorSet} message FileDescriptorSet
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorSet.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.file = [];
                if (message.file && message.file.length) {
                    object.file = [];
                    for (let j = 0; j < message.file.length; ++j)
                        object.file[j] = $root.google.protobuf.FileDescriptorProto.toObject(message.file[j], options);
                }
                return object;
            };

            /**
             * Converts this FileDescriptorSet to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorSet
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorSet.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorSet;
        })();

        protobuf.FileDescriptorProto = (function() {

            /**
             * Properties of a FileDescriptorProto.
             * @memberof google.protobuf
             * @interface IFileDescriptorProto
             * @property {string|null} [name] FileDescriptorProto name
             * @property {string|null} ["package"] FileDescriptorProto package
             * @property {Array.<string>|null} [dependency] FileDescriptorProto dependency
             * @property {Array.<number>|null} [publicDependency] FileDescriptorProto publicDependency
             * @property {Array.<number>|null} [weakDependency] FileDescriptorProto weakDependency
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [messageType] FileDescriptorProto messageType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] FileDescriptorProto enumType
             * @property {Array.<google.protobuf.IServiceDescriptorProto>|null} [service] FileDescriptorProto service
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] FileDescriptorProto extension
             * @property {google.protobuf.IFileOptions|null} [options] FileDescriptorProto options
             * @property {google.protobuf.ISourceCodeInfo|null} [sourceCodeInfo] FileDescriptorProto sourceCodeInfo
             * @property {string|null} [syntax] FileDescriptorProto syntax
             */

            /**
             * Constructs a new FileDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FileDescriptorProto.
             * @implements IFileDescriptorProto
             * @constructor
             * @param {google.protobuf.IFileDescriptorProto=} [properties] Properties to set
             */
            function FileDescriptorProto(properties) {
                this.dependency = [];
                this.publicDependency = [];
                this.weakDependency = [];
                this.messageType = [];
                this.enumType = [];
                this.service = [];
                this.extension = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.name = "";

            /**
             * FileDescriptorProto package.
             * @member {string} package
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype["package"] = "";

            /**
             * FileDescriptorProto dependency.
             * @member {Array.<string>} dependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.dependency = $util.emptyArray;

            /**
             * FileDescriptorProto publicDependency.
             * @member {Array.<number>} publicDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.publicDependency = $util.emptyArray;

            /**
             * FileDescriptorProto weakDependency.
             * @member {Array.<number>} weakDependency
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.weakDependency = $util.emptyArray;

            /**
             * FileDescriptorProto messageType.
             * @member {Array.<google.protobuf.IDescriptorProto>} messageType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.messageType = $util.emptyArray;

            /**
             * FileDescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * FileDescriptorProto service.
             * @member {Array.<google.protobuf.IServiceDescriptorProto>} service
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.service = $util.emptyArray;

            /**
             * FileDescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * FileDescriptorProto options.
             * @member {google.protobuf.IFileOptions|null|undefined} options
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.options = null;

            /**
             * FileDescriptorProto sourceCodeInfo.
             * @member {google.protobuf.ISourceCodeInfo|null|undefined} sourceCodeInfo
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.sourceCodeInfo = null;

            /**
             * FileDescriptorProto syntax.
             * @member {string} syntax
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             */
            FileDescriptorProto.prototype.syntax = "";

            /**
             * Verifies a FileDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message["package"] != null && message.hasOwnProperty("package"))
                    if (!$util.isString(message["package"]))
                        return "package: string expected";
                if (message.dependency != null && message.hasOwnProperty("dependency")) {
                    if (!Array.isArray(message.dependency))
                        return "dependency: array expected";
                    for (let i = 0; i < message.dependency.length; ++i)
                        if (!$util.isString(message.dependency[i]))
                            return "dependency: string[] expected";
                }
                if (message.publicDependency != null && message.hasOwnProperty("publicDependency")) {
                    if (!Array.isArray(message.publicDependency))
                        return "publicDependency: array expected";
                    for (let i = 0; i < message.publicDependency.length; ++i)
                        if (!$util.isInteger(message.publicDependency[i]))
                            return "publicDependency: integer[] expected";
                }
                if (message.weakDependency != null && message.hasOwnProperty("weakDependency")) {
                    if (!Array.isArray(message.weakDependency))
                        return "weakDependency: array expected";
                    for (let i = 0; i < message.weakDependency.length; ++i)
                        if (!$util.isInteger(message.weakDependency[i]))
                            return "weakDependency: integer[] expected";
                }
                if (message.messageType != null && message.hasOwnProperty("messageType")) {
                    if (!Array.isArray(message.messageType))
                        return "messageType: array expected";
                    for (let i = 0; i < message.messageType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.messageType[i]);
                        if (error)
                            return "messageType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.service != null && message.hasOwnProperty("service")) {
                    if (!Array.isArray(message.service))
                        return "service: array expected";
                    for (let i = 0; i < message.service.length; ++i) {
                        let error = $root.google.protobuf.ServiceDescriptorProto.verify(message.service[i]);
                        if (error)
                            return "service." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FileOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo")) {
                    let error = $root.google.protobuf.SourceCodeInfo.verify(message.sourceCodeInfo);
                    if (error)
                        return "sourceCodeInfo." + error;
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    if (!$util.isString(message.syntax))
                        return "syntax: string expected";
                return null;
            };

            /**
             * Creates a FileDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileDescriptorProto} FileDescriptorProto
             */
            FileDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FileDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object["package"] != null)
                    message["package"] = String(object["package"]);
                if (object.dependency) {
                    if (!Array.isArray(object.dependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.dependency: array expected");
                    message.dependency = [];
                    for (let i = 0; i < object.dependency.length; ++i)
                        message.dependency[i] = String(object.dependency[i]);
                }
                if (object.publicDependency) {
                    if (!Array.isArray(object.publicDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.publicDependency: array expected");
                    message.publicDependency = [];
                    for (let i = 0; i < object.publicDependency.length; ++i)
                        message.publicDependency[i] = object.publicDependency[i] | 0;
                }
                if (object.weakDependency) {
                    if (!Array.isArray(object.weakDependency))
                        throw TypeError(".google.protobuf.FileDescriptorProto.weakDependency: array expected");
                    message.weakDependency = [];
                    for (let i = 0; i < object.weakDependency.length; ++i)
                        message.weakDependency[i] = object.weakDependency[i] | 0;
                }
                if (object.messageType) {
                    if (!Array.isArray(object.messageType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.messageType: array expected");
                    message.messageType = [];
                    for (let i = 0; i < object.messageType.length; ++i) {
                        if (typeof object.messageType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.messageType: object expected");
                        message.messageType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.messageType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.FileDescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (let i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.service) {
                    if (!Array.isArray(object.service))
                        throw TypeError(".google.protobuf.FileDescriptorProto.service: array expected");
                    message.service = [];
                    for (let i = 0; i < object.service.length; ++i) {
                        if (typeof object.service[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.service: object expected");
                        message.service[i] = $root.google.protobuf.ServiceDescriptorProto.fromObject(object.service[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.FileDescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.FileDescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FileOptions.fromObject(object.options);
                }
                if (object.sourceCodeInfo != null) {
                    if (typeof object.sourceCodeInfo !== "object")
                        throw TypeError(".google.protobuf.FileDescriptorProto.sourceCodeInfo: object expected");
                    message.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.fromObject(object.sourceCodeInfo);
                }
                if (object.syntax != null)
                    message.syntax = String(object.syntax);
                return message;
            };

            /**
             * Creates a plain object from a FileDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileDescriptorProto
             * @static
             * @param {google.protobuf.FileDescriptorProto} message FileDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.dependency = [];
                    object.messageType = [];
                    object.enumType = [];
                    object.service = [];
                    object.extension = [];
                    object.publicDependency = [];
                    object.weakDependency = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object["package"] = "";
                    object.options = null;
                    object.sourceCodeInfo = null;
                    object.syntax = "";
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message["package"] != null && message.hasOwnProperty("package"))
                    object["package"] = message["package"];
                if (message.dependency && message.dependency.length) {
                    object.dependency = [];
                    for (let j = 0; j < message.dependency.length; ++j)
                        object.dependency[j] = message.dependency[j];
                }
                if (message.messageType && message.messageType.length) {
                    object.messageType = [];
                    for (let j = 0; j < message.messageType.length; ++j)
                        object.messageType[j] = $root.google.protobuf.DescriptorProto.toObject(message.messageType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (let j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.service && message.service.length) {
                    object.service = [];
                    for (let j = 0; j < message.service.length; ++j)
                        object.service[j] = $root.google.protobuf.ServiceDescriptorProto.toObject(message.service[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FileOptions.toObject(message.options, options);
                if (message.sourceCodeInfo != null && message.hasOwnProperty("sourceCodeInfo"))
                    object.sourceCodeInfo = $root.google.protobuf.SourceCodeInfo.toObject(message.sourceCodeInfo, options);
                if (message.publicDependency && message.publicDependency.length) {
                    object.publicDependency = [];
                    for (let j = 0; j < message.publicDependency.length; ++j)
                        object.publicDependency[j] = message.publicDependency[j];
                }
                if (message.weakDependency && message.weakDependency.length) {
                    object.weakDependency = [];
                    for (let j = 0; j < message.weakDependency.length; ++j)
                        object.weakDependency[j] = message.weakDependency[j];
                }
                if (message.syntax != null && message.hasOwnProperty("syntax"))
                    object.syntax = message.syntax;
                return object;
            };

            /**
             * Converts this FileDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FileDescriptorProto;
        })();

        protobuf.DescriptorProto = (function() {

            /**
             * Properties of a DescriptorProto.
             * @memberof google.protobuf
             * @interface IDescriptorProto
             * @property {string|null} [name] DescriptorProto name
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [field] DescriptorProto field
             * @property {Array.<google.protobuf.IFieldDescriptorProto>|null} [extension] DescriptorProto extension
             * @property {Array.<google.protobuf.IDescriptorProto>|null} [nestedType] DescriptorProto nestedType
             * @property {Array.<google.protobuf.IEnumDescriptorProto>|null} [enumType] DescriptorProto enumType
             * @property {Array.<google.protobuf.DescriptorProto.IExtensionRange>|null} [extensionRange] DescriptorProto extensionRange
             * @property {Array.<google.protobuf.IOneofDescriptorProto>|null} [oneofDecl] DescriptorProto oneofDecl
             * @property {google.protobuf.IMessageOptions|null} [options] DescriptorProto options
             * @property {Array.<google.protobuf.DescriptorProto.IReservedRange>|null} [reservedRange] DescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] DescriptorProto reservedName
             */

            /**
             * Constructs a new DescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a DescriptorProto.
             * @implements IDescriptorProto
             * @constructor
             * @param {google.protobuf.IDescriptorProto=} [properties] Properties to set
             */
            function DescriptorProto(properties) {
                this.field = [];
                this.extension = [];
                this.nestedType = [];
                this.enumType = [];
                this.extensionRange = [];
                this.oneofDecl = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.name = "";

            /**
             * DescriptorProto field.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} field
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.field = $util.emptyArray;

            /**
             * DescriptorProto extension.
             * @member {Array.<google.protobuf.IFieldDescriptorProto>} extension
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extension = $util.emptyArray;

            /**
             * DescriptorProto nestedType.
             * @member {Array.<google.protobuf.IDescriptorProto>} nestedType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.nestedType = $util.emptyArray;

            /**
             * DescriptorProto enumType.
             * @member {Array.<google.protobuf.IEnumDescriptorProto>} enumType
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.enumType = $util.emptyArray;

            /**
             * DescriptorProto extensionRange.
             * @member {Array.<google.protobuf.DescriptorProto.IExtensionRange>} extensionRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.extensionRange = $util.emptyArray;

            /**
             * DescriptorProto oneofDecl.
             * @member {Array.<google.protobuf.IOneofDescriptorProto>} oneofDecl
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.oneofDecl = $util.emptyArray;

            /**
             * DescriptorProto options.
             * @member {google.protobuf.IMessageOptions|null|undefined} options
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.options = null;

            /**
             * DescriptorProto reservedRange.
             * @member {Array.<google.protobuf.DescriptorProto.IReservedRange>} reservedRange
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * DescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.DescriptorProto
             * @instance
             */
            DescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Verifies a DescriptorProto message.
             * @function verify
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.field != null && message.hasOwnProperty("field")) {
                    if (!Array.isArray(message.field))
                        return "field: array expected";
                    for (let i = 0; i < message.field.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.field[i]);
                        if (error)
                            return "field." + error;
                    }
                }
                if (message.extension != null && message.hasOwnProperty("extension")) {
                    if (!Array.isArray(message.extension))
                        return "extension: array expected";
                    for (let i = 0; i < message.extension.length; ++i) {
                        let error = $root.google.protobuf.FieldDescriptorProto.verify(message.extension[i]);
                        if (error)
                            return "extension." + error;
                    }
                }
                if (message.nestedType != null && message.hasOwnProperty("nestedType")) {
                    if (!Array.isArray(message.nestedType))
                        return "nestedType: array expected";
                    for (let i = 0; i < message.nestedType.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.verify(message.nestedType[i]);
                        if (error)
                            return "nestedType." + error;
                    }
                }
                if (message.enumType != null && message.hasOwnProperty("enumType")) {
                    if (!Array.isArray(message.enumType))
                        return "enumType: array expected";
                    for (let i = 0; i < message.enumType.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.verify(message.enumType[i]);
                        if (error)
                            return "enumType." + error;
                    }
                }
                if (message.extensionRange != null && message.hasOwnProperty("extensionRange")) {
                    if (!Array.isArray(message.extensionRange))
                        return "extensionRange: array expected";
                    for (let i = 0; i < message.extensionRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ExtensionRange.verify(message.extensionRange[i]);
                        if (error)
                            return "extensionRange." + error;
                    }
                }
                if (message.oneofDecl != null && message.hasOwnProperty("oneofDecl")) {
                    if (!Array.isArray(message.oneofDecl))
                        return "oneofDecl: array expected";
                    for (let i = 0; i < message.oneofDecl.length; ++i) {
                        let error = $root.google.protobuf.OneofDescriptorProto.verify(message.oneofDecl[i]);
                        if (error)
                            return "oneofDecl." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MessageOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (let i = 0; i < message.reservedRange.length; ++i) {
                        let error = $root.google.protobuf.DescriptorProto.ReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (let i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates a DescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DescriptorProto} DescriptorProto
             */
            DescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DescriptorProto)
                    return object;
                let message = new $root.google.protobuf.DescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.field) {
                    if (!Array.isArray(object.field))
                        throw TypeError(".google.protobuf.DescriptorProto.field: array expected");
                    message.field = [];
                    for (let i = 0; i < object.field.length; ++i) {
                        if (typeof object.field[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.field: object expected");
                        message.field[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.field[i]);
                    }
                }
                if (object.extension) {
                    if (!Array.isArray(object.extension))
                        throw TypeError(".google.protobuf.DescriptorProto.extension: array expected");
                    message.extension = [];
                    for (let i = 0; i < object.extension.length; ++i) {
                        if (typeof object.extension[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extension: object expected");
                        message.extension[i] = $root.google.protobuf.FieldDescriptorProto.fromObject(object.extension[i]);
                    }
                }
                if (object.nestedType) {
                    if (!Array.isArray(object.nestedType))
                        throw TypeError(".google.protobuf.DescriptorProto.nestedType: array expected");
                    message.nestedType = [];
                    for (let i = 0; i < object.nestedType.length; ++i) {
                        if (typeof object.nestedType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.nestedType: object expected");
                        message.nestedType[i] = $root.google.protobuf.DescriptorProto.fromObject(object.nestedType[i]);
                    }
                }
                if (object.enumType) {
                    if (!Array.isArray(object.enumType))
                        throw TypeError(".google.protobuf.DescriptorProto.enumType: array expected");
                    message.enumType = [];
                    for (let i = 0; i < object.enumType.length; ++i) {
                        if (typeof object.enumType[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.enumType: object expected");
                        message.enumType[i] = $root.google.protobuf.EnumDescriptorProto.fromObject(object.enumType[i]);
                    }
                }
                if (object.extensionRange) {
                    if (!Array.isArray(object.extensionRange))
                        throw TypeError(".google.protobuf.DescriptorProto.extensionRange: array expected");
                    message.extensionRange = [];
                    for (let i = 0; i < object.extensionRange.length; ++i) {
                        if (typeof object.extensionRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.extensionRange: object expected");
                        message.extensionRange[i] = $root.google.protobuf.DescriptorProto.ExtensionRange.fromObject(object.extensionRange[i]);
                    }
                }
                if (object.oneofDecl) {
                    if (!Array.isArray(object.oneofDecl))
                        throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: array expected");
                    message.oneofDecl = [];
                    for (let i = 0; i < object.oneofDecl.length; ++i) {
                        if (typeof object.oneofDecl[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.oneofDecl: object expected");
                        message.oneofDecl[i] = $root.google.protobuf.OneofDescriptorProto.fromObject(object.oneofDecl[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.DescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MessageOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (let i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.DescriptorProto.ReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.DescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (let i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from a DescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DescriptorProto
             * @static
             * @param {google.protobuf.DescriptorProto} message DescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.field = [];
                    object.nestedType = [];
                    object.enumType = [];
                    object.extensionRange = [];
                    object.extension = [];
                    object.oneofDecl = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.field && message.field.length) {
                    object.field = [];
                    for (let j = 0; j < message.field.length; ++j)
                        object.field[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.field[j], options);
                }
                if (message.nestedType && message.nestedType.length) {
                    object.nestedType = [];
                    for (let j = 0; j < message.nestedType.length; ++j)
                        object.nestedType[j] = $root.google.protobuf.DescriptorProto.toObject(message.nestedType[j], options);
                }
                if (message.enumType && message.enumType.length) {
                    object.enumType = [];
                    for (let j = 0; j < message.enumType.length; ++j)
                        object.enumType[j] = $root.google.protobuf.EnumDescriptorProto.toObject(message.enumType[j], options);
                }
                if (message.extensionRange && message.extensionRange.length) {
                    object.extensionRange = [];
                    for (let j = 0; j < message.extensionRange.length; ++j)
                        object.extensionRange[j] = $root.google.protobuf.DescriptorProto.ExtensionRange.toObject(message.extensionRange[j], options);
                }
                if (message.extension && message.extension.length) {
                    object.extension = [];
                    for (let j = 0; j < message.extension.length; ++j)
                        object.extension[j] = $root.google.protobuf.FieldDescriptorProto.toObject(message.extension[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MessageOptions.toObject(message.options, options);
                if (message.oneofDecl && message.oneofDecl.length) {
                    object.oneofDecl = [];
                    for (let j = 0; j < message.oneofDecl.length; ++j)
                        object.oneofDecl[j] = $root.google.protobuf.OneofDescriptorProto.toObject(message.oneofDecl[j], options);
                }
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (let j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.DescriptorProto.ReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (let j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Converts this DescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.DescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            DescriptorProto.ExtensionRange = (function() {

                /**
                 * Properties of an ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IExtensionRange
                 * @property {number|null} [start] ExtensionRange start
                 * @property {number|null} [end] ExtensionRange end
                 * @property {google.protobuf.IExtensionRangeOptions|null} [options] ExtensionRange options
                 */

                /**
                 * Constructs a new ExtensionRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents an ExtensionRange.
                 * @implements IExtensionRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IExtensionRange=} [properties] Properties to set
                 */
                function ExtensionRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ExtensionRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.start = 0;

                /**
                 * ExtensionRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.end = 0;

                /**
                 * ExtensionRange options.
                 * @member {google.protobuf.IExtensionRangeOptions|null|undefined} options
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 */
                ExtensionRange.prototype.options = null;

                /**
                 * Verifies an ExtensionRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ExtensionRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    if (message.options != null && message.hasOwnProperty("options")) {
                        let error = $root.google.protobuf.ExtensionRangeOptions.verify(message.options);
                        if (error)
                            return "options." + error;
                    }
                    return null;
                };

                /**
                 * Creates an ExtensionRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ExtensionRange} ExtensionRange
                 */
                ExtensionRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ExtensionRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ExtensionRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    if (object.options != null) {
                        if (typeof object.options !== "object")
                            throw TypeError(".google.protobuf.DescriptorProto.ExtensionRange.options: object expected");
                        message.options = $root.google.protobuf.ExtensionRangeOptions.fromObject(object.options);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from an ExtensionRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ExtensionRange} message ExtensionRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ExtensionRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                        object.options = null;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    if (message.options != null && message.hasOwnProperty("options"))
                        object.options = $root.google.protobuf.ExtensionRangeOptions.toObject(message.options, options);
                    return object;
                };

                /**
                 * Converts this ExtensionRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ExtensionRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ExtensionRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ExtensionRange;
            })();

            DescriptorProto.ReservedRange = (function() {

                /**
                 * Properties of a ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @interface IReservedRange
                 * @property {number|null} [start] ReservedRange start
                 * @property {number|null} [end] ReservedRange end
                 */

                /**
                 * Constructs a new ReservedRange.
                 * @memberof google.protobuf.DescriptorProto
                 * @classdesc Represents a ReservedRange.
                 * @implements IReservedRange
                 * @constructor
                 * @param {google.protobuf.DescriptorProto.IReservedRange=} [properties] Properties to set
                 */
                function ReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * ReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.start = 0;

                /**
                 * ReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 */
                ReservedRange.prototype.end = 0;

                /**
                 * Verifies a ReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                ReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates a ReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.DescriptorProto.ReservedRange} ReservedRange
                 */
                ReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.DescriptorProto.ReservedRange)
                        return object;
                    let message = new $root.google.protobuf.DescriptorProto.ReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from a ReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @static
                 * @param {google.protobuf.DescriptorProto.ReservedRange} message ReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                ReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this ReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.DescriptorProto.ReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                ReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return ReservedRange;
            })();

            return DescriptorProto;
        })();

        protobuf.ExtensionRangeOptions = (function() {

            /**
             * Properties of an ExtensionRangeOptions.
             * @memberof google.protobuf
             * @interface IExtensionRangeOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ExtensionRangeOptions uninterpretedOption
             */

            /**
             * Constructs a new ExtensionRangeOptions.
             * @memberof google.protobuf
             * @classdesc Represents an ExtensionRangeOptions.
             * @implements IExtensionRangeOptions
             * @constructor
             * @param {google.protobuf.IExtensionRangeOptions=} [properties] Properties to set
             */
            function ExtensionRangeOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ExtensionRangeOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ExtensionRangeOptions
             * @instance
             */
            ExtensionRangeOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Verifies an ExtensionRangeOptions message.
             * @function verify
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ExtensionRangeOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an ExtensionRangeOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ExtensionRangeOptions} ExtensionRangeOptions
             */
            ExtensionRangeOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ExtensionRangeOptions)
                    return object;
                let message = new $root.google.protobuf.ExtensionRangeOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ExtensionRangeOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ExtensionRangeOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an ExtensionRangeOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ExtensionRangeOptions
             * @static
             * @param {google.protobuf.ExtensionRangeOptions} message ExtensionRangeOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ExtensionRangeOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ExtensionRangeOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ExtensionRangeOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ExtensionRangeOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ExtensionRangeOptions;
        })();

        protobuf.FieldDescriptorProto = (function() {

            /**
             * Properties of a FieldDescriptorProto.
             * @memberof google.protobuf
             * @interface IFieldDescriptorProto
             * @property {string|null} [name] FieldDescriptorProto name
             * @property {number|null} [number] FieldDescriptorProto number
             * @property {google.protobuf.FieldDescriptorProto.Label|null} [label] FieldDescriptorProto label
             * @property {google.protobuf.FieldDescriptorProto.Type|null} [type] FieldDescriptorProto type
             * @property {string|null} [typeName] FieldDescriptorProto typeName
             * @property {string|null} [extendee] FieldDescriptorProto extendee
             * @property {string|null} [defaultValue] FieldDescriptorProto defaultValue
             * @property {number|null} [oneofIndex] FieldDescriptorProto oneofIndex
             * @property {string|null} [jsonName] FieldDescriptorProto jsonName
             * @property {google.protobuf.IFieldOptions|null} [options] FieldDescriptorProto options
             * @property {boolean|null} [proto3Optional] FieldDescriptorProto proto3Optional
             */

            /**
             * Constructs a new FieldDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a FieldDescriptorProto.
             * @implements IFieldDescriptorProto
             * @constructor
             * @param {google.protobuf.IFieldDescriptorProto=} [properties] Properties to set
             */
            function FieldDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.name = "";

            /**
             * FieldDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.number = 0;

            /**
             * FieldDescriptorProto label.
             * @member {google.protobuf.FieldDescriptorProto.Label} label
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.label = 1;

            /**
             * FieldDescriptorProto type.
             * @member {google.protobuf.FieldDescriptorProto.Type} type
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.type = 1;

            /**
             * FieldDescriptorProto typeName.
             * @member {string} typeName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.typeName = "";

            /**
             * FieldDescriptorProto extendee.
             * @member {string} extendee
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.extendee = "";

            /**
             * FieldDescriptorProto defaultValue.
             * @member {string} defaultValue
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.defaultValue = "";

            /**
             * FieldDescriptorProto oneofIndex.
             * @member {number} oneofIndex
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.oneofIndex = 0;

            /**
             * FieldDescriptorProto jsonName.
             * @member {string} jsonName
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.jsonName = "";

            /**
             * FieldDescriptorProto options.
             * @member {google.protobuf.IFieldOptions|null|undefined} options
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.options = null;

            /**
             * FieldDescriptorProto proto3Optional.
             * @member {boolean} proto3Optional
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             */
            FieldDescriptorProto.prototype.proto3Optional = false;

            /**
             * Verifies a FieldDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.label != null && message.hasOwnProperty("label"))
                    switch (message.label) {
                    default:
                        return "label: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.type != null && message.hasOwnProperty("type"))
                    switch (message.type) {
                    default:
                        return "type: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 8:
                    case 9:
                    case 10:
                    case 11:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 16:
                    case 17:
                    case 18:
                        break;
                    }
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    if (!$util.isString(message.typeName))
                        return "typeName: string expected";
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    if (!$util.isString(message.extendee))
                        return "extendee: string expected";
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    if (!$util.isString(message.defaultValue))
                        return "defaultValue: string expected";
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    if (!$util.isInteger(message.oneofIndex))
                        return "oneofIndex: integer expected";
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    if (!$util.isString(message.jsonName))
                        return "jsonName: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.FieldOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.proto3Optional != null && message.hasOwnProperty("proto3Optional"))
                    if (typeof message.proto3Optional !== "boolean")
                        return "proto3Optional: boolean expected";
                return null;
            };

            /**
             * Creates a FieldDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldDescriptorProto} FieldDescriptorProto
             */
            FieldDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.FieldDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                switch (object.label) {
                case "LABEL_OPTIONAL":
                case 1:
                    message.label = 1;
                    break;
                case "LABEL_REQUIRED":
                case 2:
                    message.label = 2;
                    break;
                case "LABEL_REPEATED":
                case 3:
                    message.label = 3;
                    break;
                }
                switch (object.type) {
                case "TYPE_DOUBLE":
                case 1:
                    message.type = 1;
                    break;
                case "TYPE_FLOAT":
                case 2:
                    message.type = 2;
                    break;
                case "TYPE_INT64":
                case 3:
                    message.type = 3;
                    break;
                case "TYPE_UINT64":
                case 4:
                    message.type = 4;
                    break;
                case "TYPE_INT32":
                case 5:
                    message.type = 5;
                    break;
                case "TYPE_FIXED64":
                case 6:
                    message.type = 6;
                    break;
                case "TYPE_FIXED32":
                case 7:
                    message.type = 7;
                    break;
                case "TYPE_BOOL":
                case 8:
                    message.type = 8;
                    break;
                case "TYPE_STRING":
                case 9:
                    message.type = 9;
                    break;
                case "TYPE_GROUP":
                case 10:
                    message.type = 10;
                    break;
                case "TYPE_MESSAGE":
                case 11:
                    message.type = 11;
                    break;
                case "TYPE_BYTES":
                case 12:
                    message.type = 12;
                    break;
                case "TYPE_UINT32":
                case 13:
                    message.type = 13;
                    break;
                case "TYPE_ENUM":
                case 14:
                    message.type = 14;
                    break;
                case "TYPE_SFIXED32":
                case 15:
                    message.type = 15;
                    break;
                case "TYPE_SFIXED64":
                case 16:
                    message.type = 16;
                    break;
                case "TYPE_SINT32":
                case 17:
                    message.type = 17;
                    break;
                case "TYPE_SINT64":
                case 18:
                    message.type = 18;
                    break;
                }
                if (object.typeName != null)
                    message.typeName = String(object.typeName);
                if (object.extendee != null)
                    message.extendee = String(object.extendee);
                if (object.defaultValue != null)
                    message.defaultValue = String(object.defaultValue);
                if (object.oneofIndex != null)
                    message.oneofIndex = object.oneofIndex | 0;
                if (object.jsonName != null)
                    message.jsonName = String(object.jsonName);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.FieldDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.FieldOptions.fromObject(object.options);
                }
                if (object.proto3Optional != null)
                    message.proto3Optional = Boolean(object.proto3Optional);
                return message;
            };

            /**
             * Creates a plain object from a FieldDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldDescriptorProto
             * @static
             * @param {google.protobuf.FieldDescriptorProto} message FieldDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.extendee = "";
                    object.number = 0;
                    object.label = options.enums === String ? "LABEL_OPTIONAL" : 1;
                    object.type = options.enums === String ? "TYPE_DOUBLE" : 1;
                    object.typeName = "";
                    object.defaultValue = "";
                    object.options = null;
                    object.oneofIndex = 0;
                    object.jsonName = "";
                    object.proto3Optional = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.extendee != null && message.hasOwnProperty("extendee"))
                    object.extendee = message.extendee;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.label != null && message.hasOwnProperty("label"))
                    object.label = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Label[message.label] : message.label;
                if (message.type != null && message.hasOwnProperty("type"))
                    object.type = options.enums === String ? $root.google.protobuf.FieldDescriptorProto.Type[message.type] : message.type;
                if (message.typeName != null && message.hasOwnProperty("typeName"))
                    object.typeName = message.typeName;
                if (message.defaultValue != null && message.hasOwnProperty("defaultValue"))
                    object.defaultValue = message.defaultValue;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.FieldOptions.toObject(message.options, options);
                if (message.oneofIndex != null && message.hasOwnProperty("oneofIndex"))
                    object.oneofIndex = message.oneofIndex;
                if (message.jsonName != null && message.hasOwnProperty("jsonName"))
                    object.jsonName = message.jsonName;
                if (message.proto3Optional != null && message.hasOwnProperty("proto3Optional"))
                    object.proto3Optional = message.proto3Optional;
                return object;
            };

            /**
             * Converts this FieldDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * Type enum.
             * @name google.protobuf.FieldDescriptorProto.Type
             * @enum {number}
             * @property {number} TYPE_DOUBLE=1 TYPE_DOUBLE value
             * @property {number} TYPE_FLOAT=2 TYPE_FLOAT value
             * @property {number} TYPE_INT64=3 TYPE_INT64 value
             * @property {number} TYPE_UINT64=4 TYPE_UINT64 value
             * @property {number} TYPE_INT32=5 TYPE_INT32 value
             * @property {number} TYPE_FIXED64=6 TYPE_FIXED64 value
             * @property {number} TYPE_FIXED32=7 TYPE_FIXED32 value
             * @property {number} TYPE_BOOL=8 TYPE_BOOL value
             * @property {number} TYPE_STRING=9 TYPE_STRING value
             * @property {number} TYPE_GROUP=10 TYPE_GROUP value
             * @property {number} TYPE_MESSAGE=11 TYPE_MESSAGE value
             * @property {number} TYPE_BYTES=12 TYPE_BYTES value
             * @property {number} TYPE_UINT32=13 TYPE_UINT32 value
             * @property {number} TYPE_ENUM=14 TYPE_ENUM value
             * @property {number} TYPE_SFIXED32=15 TYPE_SFIXED32 value
             * @property {number} TYPE_SFIXED64=16 TYPE_SFIXED64 value
             * @property {number} TYPE_SINT32=17 TYPE_SINT32 value
             * @property {number} TYPE_SINT64=18 TYPE_SINT64 value
             */
            FieldDescriptorProto.Type = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "TYPE_DOUBLE"] = 1;
                values[valuesById[2] = "TYPE_FLOAT"] = 2;
                values[valuesById[3] = "TYPE_INT64"] = 3;
                values[valuesById[4] = "TYPE_UINT64"] = 4;
                values[valuesById[5] = "TYPE_INT32"] = 5;
                values[valuesById[6] = "TYPE_FIXED64"] = 6;
                values[valuesById[7] = "TYPE_FIXED32"] = 7;
                values[valuesById[8] = "TYPE_BOOL"] = 8;
                values[valuesById[9] = "TYPE_STRING"] = 9;
                values[valuesById[10] = "TYPE_GROUP"] = 10;
                values[valuesById[11] = "TYPE_MESSAGE"] = 11;
                values[valuesById[12] = "TYPE_BYTES"] = 12;
                values[valuesById[13] = "TYPE_UINT32"] = 13;
                values[valuesById[14] = "TYPE_ENUM"] = 14;
                values[valuesById[15] = "TYPE_SFIXED32"] = 15;
                values[valuesById[16] = "TYPE_SFIXED64"] = 16;
                values[valuesById[17] = "TYPE_SINT32"] = 17;
                values[valuesById[18] = "TYPE_SINT64"] = 18;
                return values;
            })();

            /**
             * Label enum.
             * @name google.protobuf.FieldDescriptorProto.Label
             * @enum {number}
             * @property {number} LABEL_OPTIONAL=1 LABEL_OPTIONAL value
             * @property {number} LABEL_REQUIRED=2 LABEL_REQUIRED value
             * @property {number} LABEL_REPEATED=3 LABEL_REPEATED value
             */
            FieldDescriptorProto.Label = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "LABEL_OPTIONAL"] = 1;
                values[valuesById[2] = "LABEL_REQUIRED"] = 2;
                values[valuesById[3] = "LABEL_REPEATED"] = 3;
                return values;
            })();

            return FieldDescriptorProto;
        })();

        protobuf.OneofDescriptorProto = (function() {

            /**
             * Properties of an OneofDescriptorProto.
             * @memberof google.protobuf
             * @interface IOneofDescriptorProto
             * @property {string|null} [name] OneofDescriptorProto name
             * @property {google.protobuf.IOneofOptions|null} [options] OneofDescriptorProto options
             */

            /**
             * Constructs a new OneofDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an OneofDescriptorProto.
             * @implements IOneofDescriptorProto
             * @constructor
             * @param {google.protobuf.IOneofDescriptorProto=} [properties] Properties to set
             */
            function OneofDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.name = "";

            /**
             * OneofDescriptorProto options.
             * @member {google.protobuf.IOneofOptions|null|undefined} options
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             */
            OneofDescriptorProto.prototype.options = null;

            /**
             * Verifies an OneofDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.OneofOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an OneofDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofDescriptorProto} OneofDescriptorProto
             */
            OneofDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.OneofDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.OneofDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.OneofOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an OneofDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofDescriptorProto
             * @static
             * @param {google.protobuf.OneofDescriptorProto} message OneofDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.OneofOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this OneofDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofDescriptorProto;
        })();

        protobuf.EnumDescriptorProto = (function() {

            /**
             * Properties of an EnumDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumDescriptorProto
             * @property {string|null} [name] EnumDescriptorProto name
             * @property {Array.<google.protobuf.IEnumValueDescriptorProto>|null} [value] EnumDescriptorProto value
             * @property {google.protobuf.IEnumOptions|null} [options] EnumDescriptorProto options
             * @property {Array.<google.protobuf.EnumDescriptorProto.IEnumReservedRange>|null} [reservedRange] EnumDescriptorProto reservedRange
             * @property {Array.<string>|null} [reservedName] EnumDescriptorProto reservedName
             */

            /**
             * Constructs a new EnumDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumDescriptorProto.
             * @implements IEnumDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumDescriptorProto=} [properties] Properties to set
             */
            function EnumDescriptorProto(properties) {
                this.value = [];
                this.reservedRange = [];
                this.reservedName = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.name = "";

            /**
             * EnumDescriptorProto value.
             * @member {Array.<google.protobuf.IEnumValueDescriptorProto>} value
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.value = $util.emptyArray;

            /**
             * EnumDescriptorProto options.
             * @member {google.protobuf.IEnumOptions|null|undefined} options
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.options = null;

            /**
             * EnumDescriptorProto reservedRange.
             * @member {Array.<google.protobuf.EnumDescriptorProto.IEnumReservedRange>} reservedRange
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.reservedRange = $util.emptyArray;

            /**
             * EnumDescriptorProto reservedName.
             * @member {Array.<string>} reservedName
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             */
            EnumDescriptorProto.prototype.reservedName = $util.emptyArray;

            /**
             * Verifies an EnumDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.value != null && message.hasOwnProperty("value")) {
                    if (!Array.isArray(message.value))
                        return "value: array expected";
                    for (let i = 0; i < message.value.length; ++i) {
                        let error = $root.google.protobuf.EnumValueDescriptorProto.verify(message.value[i]);
                        if (error)
                            return "value." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.reservedRange != null && message.hasOwnProperty("reservedRange")) {
                    if (!Array.isArray(message.reservedRange))
                        return "reservedRange: array expected";
                    for (let i = 0; i < message.reservedRange.length; ++i) {
                        let error = $root.google.protobuf.EnumDescriptorProto.EnumReservedRange.verify(message.reservedRange[i]);
                        if (error)
                            return "reservedRange." + error;
                    }
                }
                if (message.reservedName != null && message.hasOwnProperty("reservedName")) {
                    if (!Array.isArray(message.reservedName))
                        return "reservedName: array expected";
                    for (let i = 0; i < message.reservedName.length; ++i)
                        if (!$util.isString(message.reservedName[i]))
                            return "reservedName: string[] expected";
                }
                return null;
            };

            /**
             * Creates an EnumDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumDescriptorProto} EnumDescriptorProto
             */
            EnumDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.value) {
                    if (!Array.isArray(object.value))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.value: array expected");
                    message.value = [];
                    for (let i = 0; i < object.value.length; ++i) {
                        if (typeof object.value[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.value: object expected");
                        message.value[i] = $root.google.protobuf.EnumValueDescriptorProto.fromObject(object.value[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumOptions.fromObject(object.options);
                }
                if (object.reservedRange) {
                    if (!Array.isArray(object.reservedRange))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.reservedRange: array expected");
                    message.reservedRange = [];
                    for (let i = 0; i < object.reservedRange.length; ++i) {
                        if (typeof object.reservedRange[i] !== "object")
                            throw TypeError(".google.protobuf.EnumDescriptorProto.reservedRange: object expected");
                        message.reservedRange[i] = $root.google.protobuf.EnumDescriptorProto.EnumReservedRange.fromObject(object.reservedRange[i]);
                    }
                }
                if (object.reservedName) {
                    if (!Array.isArray(object.reservedName))
                        throw TypeError(".google.protobuf.EnumDescriptorProto.reservedName: array expected");
                    message.reservedName = [];
                    for (let i = 0; i < object.reservedName.length; ++i)
                        message.reservedName[i] = String(object.reservedName[i]);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumDescriptorProto
             * @static
             * @param {google.protobuf.EnumDescriptorProto} message EnumDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults) {
                    object.value = [];
                    object.reservedRange = [];
                    object.reservedName = [];
                }
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.value && message.value.length) {
                    object.value = [];
                    for (let j = 0; j < message.value.length; ++j)
                        object.value[j] = $root.google.protobuf.EnumValueDescriptorProto.toObject(message.value[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumOptions.toObject(message.options, options);
                if (message.reservedRange && message.reservedRange.length) {
                    object.reservedRange = [];
                    for (let j = 0; j < message.reservedRange.length; ++j)
                        object.reservedRange[j] = $root.google.protobuf.EnumDescriptorProto.EnumReservedRange.toObject(message.reservedRange[j], options);
                }
                if (message.reservedName && message.reservedName.length) {
                    object.reservedName = [];
                    for (let j = 0; j < message.reservedName.length; ++j)
                        object.reservedName[j] = message.reservedName[j];
                }
                return object;
            };

            /**
             * Converts this EnumDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            EnumDescriptorProto.EnumReservedRange = (function() {

                /**
                 * Properties of an EnumReservedRange.
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @interface IEnumReservedRange
                 * @property {number|null} [start] EnumReservedRange start
                 * @property {number|null} [end] EnumReservedRange end
                 */

                /**
                 * Constructs a new EnumReservedRange.
                 * @memberof google.protobuf.EnumDescriptorProto
                 * @classdesc Represents an EnumReservedRange.
                 * @implements IEnumReservedRange
                 * @constructor
                 * @param {google.protobuf.EnumDescriptorProto.IEnumReservedRange=} [properties] Properties to set
                 */
                function EnumReservedRange(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * EnumReservedRange start.
                 * @member {number} start
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @instance
                 */
                EnumReservedRange.prototype.start = 0;

                /**
                 * EnumReservedRange end.
                 * @member {number} end
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @instance
                 */
                EnumReservedRange.prototype.end = 0;

                /**
                 * Verifies an EnumReservedRange message.
                 * @function verify
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                EnumReservedRange.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.start != null && message.hasOwnProperty("start"))
                        if (!$util.isInteger(message.start))
                            return "start: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an EnumReservedRange message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.EnumDescriptorProto.EnumReservedRange} EnumReservedRange
                 */
                EnumReservedRange.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.EnumDescriptorProto.EnumReservedRange)
                        return object;
                    let message = new $root.google.protobuf.EnumDescriptorProto.EnumReservedRange();
                    if (object.start != null)
                        message.start = object.start | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an EnumReservedRange message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @static
                 * @param {google.protobuf.EnumDescriptorProto.EnumReservedRange} message EnumReservedRange
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                EnumReservedRange.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.start = 0;
                        object.end = 0;
                    }
                    if (message.start != null && message.hasOwnProperty("start"))
                        object.start = message.start;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this EnumReservedRange to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.EnumDescriptorProto.EnumReservedRange
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                EnumReservedRange.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return EnumReservedRange;
            })();

            return EnumDescriptorProto;
        })();

        protobuf.EnumValueDescriptorProto = (function() {

            /**
             * Properties of an EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @interface IEnumValueDescriptorProto
             * @property {string|null} [name] EnumValueDescriptorProto name
             * @property {number|null} [number] EnumValueDescriptorProto number
             * @property {google.protobuf.IEnumValueOptions|null} [options] EnumValueDescriptorProto options
             */

            /**
             * Constructs a new EnumValueDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueDescriptorProto.
             * @implements IEnumValueDescriptorProto
             * @constructor
             * @param {google.protobuf.IEnumValueDescriptorProto=} [properties] Properties to set
             */
            function EnumValueDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.name = "";

            /**
             * EnumValueDescriptorProto number.
             * @member {number} number
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.number = 0;

            /**
             * EnumValueDescriptorProto options.
             * @member {google.protobuf.IEnumValueOptions|null|undefined} options
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             */
            EnumValueDescriptorProto.prototype.options = null;

            /**
             * Verifies an EnumValueDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.number != null && message.hasOwnProperty("number"))
                    if (!$util.isInteger(message.number))
                        return "number: integer expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.EnumValueOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates an EnumValueDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueDescriptorProto} EnumValueDescriptorProto
             */
            EnumValueDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.EnumValueDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.number != null)
                    message.number = object.number | 0;
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.EnumValueDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.EnumValueOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @static
             * @param {google.protobuf.EnumValueDescriptorProto} message EnumValueDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.number = 0;
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.number != null && message.hasOwnProperty("number"))
                    object.number = message.number;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.EnumValueOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this EnumValueDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueDescriptorProto;
        })();

        protobuf.ServiceDescriptorProto = (function() {

            /**
             * Properties of a ServiceDescriptorProto.
             * @memberof google.protobuf
             * @interface IServiceDescriptorProto
             * @property {string|null} [name] ServiceDescriptorProto name
             * @property {Array.<google.protobuf.IMethodDescriptorProto>|null} [method] ServiceDescriptorProto method
             * @property {google.protobuf.IServiceOptions|null} [options] ServiceDescriptorProto options
             */

            /**
             * Constructs a new ServiceDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceDescriptorProto.
             * @implements IServiceDescriptorProto
             * @constructor
             * @param {google.protobuf.IServiceDescriptorProto=} [properties] Properties to set
             */
            function ServiceDescriptorProto(properties) {
                this.method = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.name = "";

            /**
             * ServiceDescriptorProto method.
             * @member {Array.<google.protobuf.IMethodDescriptorProto>} method
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.method = $util.emptyArray;

            /**
             * ServiceDescriptorProto options.
             * @member {google.protobuf.IServiceOptions|null|undefined} options
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             */
            ServiceDescriptorProto.prototype.options = null;

            /**
             * Verifies a ServiceDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.method != null && message.hasOwnProperty("method")) {
                    if (!Array.isArray(message.method))
                        return "method: array expected";
                    for (let i = 0; i < message.method.length; ++i) {
                        let error = $root.google.protobuf.MethodDescriptorProto.verify(message.method[i]);
                        if (error)
                            return "method." + error;
                    }
                }
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.ServiceOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                return null;
            };

            /**
             * Creates a ServiceDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceDescriptorProto} ServiceDescriptorProto
             */
            ServiceDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.ServiceDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.method) {
                    if (!Array.isArray(object.method))
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.method: array expected");
                    message.method = [];
                    for (let i = 0; i < object.method.length; ++i) {
                        if (typeof object.method[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceDescriptorProto.method: object expected");
                        message.method[i] = $root.google.protobuf.MethodDescriptorProto.fromObject(object.method[i]);
                    }
                }
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.ServiceDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.ServiceOptions.fromObject(object.options);
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceDescriptorProto
             * @static
             * @param {google.protobuf.ServiceDescriptorProto} message ServiceDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.method = [];
                if (options.defaults) {
                    object.name = "";
                    object.options = null;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.method && message.method.length) {
                    object.method = [];
                    for (let j = 0; j < message.method.length; ++j)
                        object.method[j] = $root.google.protobuf.MethodDescriptorProto.toObject(message.method[j], options);
                }
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.ServiceOptions.toObject(message.options, options);
                return object;
            };

            /**
             * Converts this ServiceDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceDescriptorProto;
        })();

        protobuf.MethodDescriptorProto = (function() {

            /**
             * Properties of a MethodDescriptorProto.
             * @memberof google.protobuf
             * @interface IMethodDescriptorProto
             * @property {string|null} [name] MethodDescriptorProto name
             * @property {string|null} [inputType] MethodDescriptorProto inputType
             * @property {string|null} [outputType] MethodDescriptorProto outputType
             * @property {google.protobuf.IMethodOptions|null} [options] MethodDescriptorProto options
             * @property {boolean|null} [clientStreaming] MethodDescriptorProto clientStreaming
             * @property {boolean|null} [serverStreaming] MethodDescriptorProto serverStreaming
             */

            /**
             * Constructs a new MethodDescriptorProto.
             * @memberof google.protobuf
             * @classdesc Represents a MethodDescriptorProto.
             * @implements IMethodDescriptorProto
             * @constructor
             * @param {google.protobuf.IMethodDescriptorProto=} [properties] Properties to set
             */
            function MethodDescriptorProto(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodDescriptorProto name.
             * @member {string} name
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.name = "";

            /**
             * MethodDescriptorProto inputType.
             * @member {string} inputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.inputType = "";

            /**
             * MethodDescriptorProto outputType.
             * @member {string} outputType
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.outputType = "";

            /**
             * MethodDescriptorProto options.
             * @member {google.protobuf.IMethodOptions|null|undefined} options
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.options = null;

            /**
             * MethodDescriptorProto clientStreaming.
             * @member {boolean} clientStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.clientStreaming = false;

            /**
             * MethodDescriptorProto serverStreaming.
             * @member {boolean} serverStreaming
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             */
            MethodDescriptorProto.prototype.serverStreaming = false;

            /**
             * Verifies a MethodDescriptorProto message.
             * @function verify
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodDescriptorProto.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name"))
                    if (!$util.isString(message.name))
                        return "name: string expected";
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    if (!$util.isString(message.inputType))
                        return "inputType: string expected";
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    if (!$util.isString(message.outputType))
                        return "outputType: string expected";
                if (message.options != null && message.hasOwnProperty("options")) {
                    let error = $root.google.protobuf.MethodOptions.verify(message.options);
                    if (error)
                        return "options." + error;
                }
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    if (typeof message.clientStreaming !== "boolean")
                        return "clientStreaming: boolean expected";
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    if (typeof message.serverStreaming !== "boolean")
                        return "serverStreaming: boolean expected";
                return null;
            };

            /**
             * Creates a MethodDescriptorProto message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodDescriptorProto} MethodDescriptorProto
             */
            MethodDescriptorProto.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodDescriptorProto)
                    return object;
                let message = new $root.google.protobuf.MethodDescriptorProto();
                if (object.name != null)
                    message.name = String(object.name);
                if (object.inputType != null)
                    message.inputType = String(object.inputType);
                if (object.outputType != null)
                    message.outputType = String(object.outputType);
                if (object.options != null) {
                    if (typeof object.options !== "object")
                        throw TypeError(".google.protobuf.MethodDescriptorProto.options: object expected");
                    message.options = $root.google.protobuf.MethodOptions.fromObject(object.options);
                }
                if (object.clientStreaming != null)
                    message.clientStreaming = Boolean(object.clientStreaming);
                if (object.serverStreaming != null)
                    message.serverStreaming = Boolean(object.serverStreaming);
                return message;
            };

            /**
             * Creates a plain object from a MethodDescriptorProto message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodDescriptorProto
             * @static
             * @param {google.protobuf.MethodDescriptorProto} message MethodDescriptorProto
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodDescriptorProto.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.name = "";
                    object.inputType = "";
                    object.outputType = "";
                    object.options = null;
                    object.clientStreaming = false;
                    object.serverStreaming = false;
                }
                if (message.name != null && message.hasOwnProperty("name"))
                    object.name = message.name;
                if (message.inputType != null && message.hasOwnProperty("inputType"))
                    object.inputType = message.inputType;
                if (message.outputType != null && message.hasOwnProperty("outputType"))
                    object.outputType = message.outputType;
                if (message.options != null && message.hasOwnProperty("options"))
                    object.options = $root.google.protobuf.MethodOptions.toObject(message.options, options);
                if (message.clientStreaming != null && message.hasOwnProperty("clientStreaming"))
                    object.clientStreaming = message.clientStreaming;
                if (message.serverStreaming != null && message.hasOwnProperty("serverStreaming"))
                    object.serverStreaming = message.serverStreaming;
                return object;
            };

            /**
             * Converts this MethodDescriptorProto to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodDescriptorProto
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodDescriptorProto.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MethodDescriptorProto;
        })();

        protobuf.FileOptions = (function() {

            /**
             * Properties of a FileOptions.
             * @memberof google.protobuf
             * @interface IFileOptions
             * @property {string|null} [javaPackage] FileOptions javaPackage
             * @property {string|null} [javaOuterClassname] FileOptions javaOuterClassname
             * @property {boolean|null} [javaMultipleFiles] FileOptions javaMultipleFiles
             * @property {boolean|null} [javaGenerateEqualsAndHash] FileOptions javaGenerateEqualsAndHash
             * @property {boolean|null} [javaStringCheckUtf8] FileOptions javaStringCheckUtf8
             * @property {google.protobuf.FileOptions.OptimizeMode|null} [optimizeFor] FileOptions optimizeFor
             * @property {string|null} [goPackage] FileOptions goPackage
             * @property {boolean|null} [ccGenericServices] FileOptions ccGenericServices
             * @property {boolean|null} [javaGenericServices] FileOptions javaGenericServices
             * @property {boolean|null} [pyGenericServices] FileOptions pyGenericServices
             * @property {boolean|null} [phpGenericServices] FileOptions phpGenericServices
             * @property {boolean|null} [deprecated] FileOptions deprecated
             * @property {boolean|null} [ccEnableArenas] FileOptions ccEnableArenas
             * @property {string|null} [objcClassPrefix] FileOptions objcClassPrefix
             * @property {string|null} [csharpNamespace] FileOptions csharpNamespace
             * @property {string|null} [swiftPrefix] FileOptions swiftPrefix
             * @property {string|null} [phpClassPrefix] FileOptions phpClassPrefix
             * @property {string|null} [phpNamespace] FileOptions phpNamespace
             * @property {string|null} [phpMetadataNamespace] FileOptions phpMetadataNamespace
             * @property {string|null} [rubyPackage] FileOptions rubyPackage
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FileOptions uninterpretedOption
             */

            /**
             * Constructs a new FileOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FileOptions.
             * @implements IFileOptions
             * @constructor
             * @param {google.protobuf.IFileOptions=} [properties] Properties to set
             */
            function FileOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FileOptions javaPackage.
             * @member {string} javaPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaPackage = "";

            /**
             * FileOptions javaOuterClassname.
             * @member {string} javaOuterClassname
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaOuterClassname = "";

            /**
             * FileOptions javaMultipleFiles.
             * @member {boolean} javaMultipleFiles
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaMultipleFiles = false;

            /**
             * FileOptions javaGenerateEqualsAndHash.
             * @member {boolean} javaGenerateEqualsAndHash
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenerateEqualsAndHash = false;

            /**
             * FileOptions javaStringCheckUtf8.
             * @member {boolean} javaStringCheckUtf8
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaStringCheckUtf8 = false;

            /**
             * FileOptions optimizeFor.
             * @member {google.protobuf.FileOptions.OptimizeMode} optimizeFor
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.optimizeFor = 1;

            /**
             * FileOptions goPackage.
             * @member {string} goPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.goPackage = "";

            /**
             * FileOptions ccGenericServices.
             * @member {boolean} ccGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccGenericServices = false;

            /**
             * FileOptions javaGenericServices.
             * @member {boolean} javaGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.javaGenericServices = false;

            /**
             * FileOptions pyGenericServices.
             * @member {boolean} pyGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.pyGenericServices = false;

            /**
             * FileOptions phpGenericServices.
             * @member {boolean} phpGenericServices
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.phpGenericServices = false;

            /**
             * FileOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.deprecated = false;

            /**
             * FileOptions ccEnableArenas.
             * @member {boolean} ccEnableArenas
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.ccEnableArenas = true;

            /**
             * FileOptions objcClassPrefix.
             * @member {string} objcClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.objcClassPrefix = "";

            /**
             * FileOptions csharpNamespace.
             * @member {string} csharpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.csharpNamespace = "";

            /**
             * FileOptions swiftPrefix.
             * @member {string} swiftPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.swiftPrefix = "";

            /**
             * FileOptions phpClassPrefix.
             * @member {string} phpClassPrefix
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.phpClassPrefix = "";

            /**
             * FileOptions phpNamespace.
             * @member {string} phpNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.phpNamespace = "";

            /**
             * FileOptions phpMetadataNamespace.
             * @member {string} phpMetadataNamespace
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.phpMetadataNamespace = "";

            /**
             * FileOptions rubyPackage.
             * @member {string} rubyPackage
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.rubyPackage = "";

            /**
             * FileOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FileOptions
             * @instance
             */
            FileOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Verifies a FileOptions message.
             * @function verify
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FileOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    if (!$util.isString(message.javaPackage))
                        return "javaPackage: string expected";
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    if (!$util.isString(message.javaOuterClassname))
                        return "javaOuterClassname: string expected";
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    if (typeof message.javaMultipleFiles !== "boolean")
                        return "javaMultipleFiles: boolean expected";
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    if (typeof message.javaGenerateEqualsAndHash !== "boolean")
                        return "javaGenerateEqualsAndHash: boolean expected";
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    if (typeof message.javaStringCheckUtf8 !== "boolean")
                        return "javaStringCheckUtf8: boolean expected";
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    switch (message.optimizeFor) {
                    default:
                        return "optimizeFor: enum value expected";
                    case 1:
                    case 2:
                    case 3:
                        break;
                    }
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    if (!$util.isString(message.goPackage))
                        return "goPackage: string expected";
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    if (typeof message.ccGenericServices !== "boolean")
                        return "ccGenericServices: boolean expected";
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    if (typeof message.javaGenericServices !== "boolean")
                        return "javaGenericServices: boolean expected";
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    if (typeof message.pyGenericServices !== "boolean")
                        return "pyGenericServices: boolean expected";
                if (message.phpGenericServices != null && message.hasOwnProperty("phpGenericServices"))
                    if (typeof message.phpGenericServices !== "boolean")
                        return "phpGenericServices: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    if (typeof message.ccEnableArenas !== "boolean")
                        return "ccEnableArenas: boolean expected";
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    if (!$util.isString(message.objcClassPrefix))
                        return "objcClassPrefix: string expected";
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    if (!$util.isString(message.csharpNamespace))
                        return "csharpNamespace: string expected";
                if (message.swiftPrefix != null && message.hasOwnProperty("swiftPrefix"))
                    if (!$util.isString(message.swiftPrefix))
                        return "swiftPrefix: string expected";
                if (message.phpClassPrefix != null && message.hasOwnProperty("phpClassPrefix"))
                    if (!$util.isString(message.phpClassPrefix))
                        return "phpClassPrefix: string expected";
                if (message.phpNamespace != null && message.hasOwnProperty("phpNamespace"))
                    if (!$util.isString(message.phpNamespace))
                        return "phpNamespace: string expected";
                if (message.phpMetadataNamespace != null && message.hasOwnProperty("phpMetadataNamespace"))
                    if (!$util.isString(message.phpMetadataNamespace))
                        return "phpMetadataNamespace: string expected";
                if (message.rubyPackage != null && message.hasOwnProperty("rubyPackage"))
                    if (!$util.isString(message.rubyPackage))
                        return "rubyPackage: string expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a FileOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FileOptions} FileOptions
             */
            FileOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FileOptions)
                    return object;
                let message = new $root.google.protobuf.FileOptions();
                if (object.javaPackage != null)
                    message.javaPackage = String(object.javaPackage);
                if (object.javaOuterClassname != null)
                    message.javaOuterClassname = String(object.javaOuterClassname);
                if (object.javaMultipleFiles != null)
                    message.javaMultipleFiles = Boolean(object.javaMultipleFiles);
                if (object.javaGenerateEqualsAndHash != null)
                    message.javaGenerateEqualsAndHash = Boolean(object.javaGenerateEqualsAndHash);
                if (object.javaStringCheckUtf8 != null)
                    message.javaStringCheckUtf8 = Boolean(object.javaStringCheckUtf8);
                switch (object.optimizeFor) {
                case "SPEED":
                case 1:
                    message.optimizeFor = 1;
                    break;
                case "CODE_SIZE":
                case 2:
                    message.optimizeFor = 2;
                    break;
                case "LITE_RUNTIME":
                case 3:
                    message.optimizeFor = 3;
                    break;
                }
                if (object.goPackage != null)
                    message.goPackage = String(object.goPackage);
                if (object.ccGenericServices != null)
                    message.ccGenericServices = Boolean(object.ccGenericServices);
                if (object.javaGenericServices != null)
                    message.javaGenericServices = Boolean(object.javaGenericServices);
                if (object.pyGenericServices != null)
                    message.pyGenericServices = Boolean(object.pyGenericServices);
                if (object.phpGenericServices != null)
                    message.phpGenericServices = Boolean(object.phpGenericServices);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.ccEnableArenas != null)
                    message.ccEnableArenas = Boolean(object.ccEnableArenas);
                if (object.objcClassPrefix != null)
                    message.objcClassPrefix = String(object.objcClassPrefix);
                if (object.csharpNamespace != null)
                    message.csharpNamespace = String(object.csharpNamespace);
                if (object.swiftPrefix != null)
                    message.swiftPrefix = String(object.swiftPrefix);
                if (object.phpClassPrefix != null)
                    message.phpClassPrefix = String(object.phpClassPrefix);
                if (object.phpNamespace != null)
                    message.phpNamespace = String(object.phpNamespace);
                if (object.phpMetadataNamespace != null)
                    message.phpMetadataNamespace = String(object.phpMetadataNamespace);
                if (object.rubyPackage != null)
                    message.rubyPackage = String(object.rubyPackage);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FileOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a FileOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FileOptions
             * @static
             * @param {google.protobuf.FileOptions} message FileOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FileOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.javaPackage = "";
                    object.javaOuterClassname = "";
                    object.optimizeFor = options.enums === String ? "SPEED" : 1;
                    object.javaMultipleFiles = false;
                    object.goPackage = "";
                    object.ccGenericServices = false;
                    object.javaGenericServices = false;
                    object.pyGenericServices = false;
                    object.javaGenerateEqualsAndHash = false;
                    object.deprecated = false;
                    object.javaStringCheckUtf8 = false;
                    object.ccEnableArenas = true;
                    object.objcClassPrefix = "";
                    object.csharpNamespace = "";
                    object.swiftPrefix = "";
                    object.phpClassPrefix = "";
                    object.phpNamespace = "";
                    object.phpGenericServices = false;
                    object.phpMetadataNamespace = "";
                    object.rubyPackage = "";
                }
                if (message.javaPackage != null && message.hasOwnProperty("javaPackage"))
                    object.javaPackage = message.javaPackage;
                if (message.javaOuterClassname != null && message.hasOwnProperty("javaOuterClassname"))
                    object.javaOuterClassname = message.javaOuterClassname;
                if (message.optimizeFor != null && message.hasOwnProperty("optimizeFor"))
                    object.optimizeFor = options.enums === String ? $root.google.protobuf.FileOptions.OptimizeMode[message.optimizeFor] : message.optimizeFor;
                if (message.javaMultipleFiles != null && message.hasOwnProperty("javaMultipleFiles"))
                    object.javaMultipleFiles = message.javaMultipleFiles;
                if (message.goPackage != null && message.hasOwnProperty("goPackage"))
                    object.goPackage = message.goPackage;
                if (message.ccGenericServices != null && message.hasOwnProperty("ccGenericServices"))
                    object.ccGenericServices = message.ccGenericServices;
                if (message.javaGenericServices != null && message.hasOwnProperty("javaGenericServices"))
                    object.javaGenericServices = message.javaGenericServices;
                if (message.pyGenericServices != null && message.hasOwnProperty("pyGenericServices"))
                    object.pyGenericServices = message.pyGenericServices;
                if (message.javaGenerateEqualsAndHash != null && message.hasOwnProperty("javaGenerateEqualsAndHash"))
                    object.javaGenerateEqualsAndHash = message.javaGenerateEqualsAndHash;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.javaStringCheckUtf8 != null && message.hasOwnProperty("javaStringCheckUtf8"))
                    object.javaStringCheckUtf8 = message.javaStringCheckUtf8;
                if (message.ccEnableArenas != null && message.hasOwnProperty("ccEnableArenas"))
                    object.ccEnableArenas = message.ccEnableArenas;
                if (message.objcClassPrefix != null && message.hasOwnProperty("objcClassPrefix"))
                    object.objcClassPrefix = message.objcClassPrefix;
                if (message.csharpNamespace != null && message.hasOwnProperty("csharpNamespace"))
                    object.csharpNamespace = message.csharpNamespace;
                if (message.swiftPrefix != null && message.hasOwnProperty("swiftPrefix"))
                    object.swiftPrefix = message.swiftPrefix;
                if (message.phpClassPrefix != null && message.hasOwnProperty("phpClassPrefix"))
                    object.phpClassPrefix = message.phpClassPrefix;
                if (message.phpNamespace != null && message.hasOwnProperty("phpNamespace"))
                    object.phpNamespace = message.phpNamespace;
                if (message.phpGenericServices != null && message.hasOwnProperty("phpGenericServices"))
                    object.phpGenericServices = message.phpGenericServices;
                if (message.phpMetadataNamespace != null && message.hasOwnProperty("phpMetadataNamespace"))
                    object.phpMetadataNamespace = message.phpMetadataNamespace;
                if (message.rubyPackage != null && message.hasOwnProperty("rubyPackage"))
                    object.rubyPackage = message.rubyPackage;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this FileOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FileOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FileOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * OptimizeMode enum.
             * @name google.protobuf.FileOptions.OptimizeMode
             * @enum {number}
             * @property {number} SPEED=1 SPEED value
             * @property {number} CODE_SIZE=2 CODE_SIZE value
             * @property {number} LITE_RUNTIME=3 LITE_RUNTIME value
             */
            FileOptions.OptimizeMode = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[1] = "SPEED"] = 1;
                values[valuesById[2] = "CODE_SIZE"] = 2;
                values[valuesById[3] = "LITE_RUNTIME"] = 3;
                return values;
            })();

            return FileOptions;
        })();

        protobuf.MessageOptions = (function() {

            /**
             * Properties of a MessageOptions.
             * @memberof google.protobuf
             * @interface IMessageOptions
             * @property {boolean|null} [messageSetWireFormat] MessageOptions messageSetWireFormat
             * @property {boolean|null} [noStandardDescriptorAccessor] MessageOptions noStandardDescriptorAccessor
             * @property {boolean|null} [deprecated] MessageOptions deprecated
             * @property {boolean|null} [mapEntry] MessageOptions mapEntry
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MessageOptions uninterpretedOption
             * @property {clutch.api.v1.IReference|null} [".clutch.api.v1.reference"] MessageOptions .clutch.api.v1.reference
             * @property {clutch.api.v1.IIdentifier|null} [".clutch.api.v1.id"] MessageOptions .clutch.api.v1.id
             * @property {boolean|null} [".validate.disabled"] MessageOptions .validate.disabled
             * @property {clutch.resolver.v1.ISchemaMetadata|null} [".clutch.resolver.v1.schema"] MessageOptions .clutch.resolver.v1.schema
             */

            /**
             * Constructs a new MessageOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MessageOptions.
             * @implements IMessageOptions
             * @constructor
             * @param {google.protobuf.IMessageOptions=} [properties] Properties to set
             */
            function MessageOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MessageOptions messageSetWireFormat.
             * @member {boolean} messageSetWireFormat
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.messageSetWireFormat = false;

            /**
             * MessageOptions noStandardDescriptorAccessor.
             * @member {boolean} noStandardDescriptorAccessor
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.noStandardDescriptorAccessor = false;

            /**
             * MessageOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.deprecated = false;

            /**
             * MessageOptions mapEntry.
             * @member {boolean} mapEntry
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.mapEntry = false;

            /**
             * MessageOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * MessageOptions .clutch.api.v1.reference.
             * @member {clutch.api.v1.IReference|null|undefined} .clutch.api.v1.reference
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".clutch.api.v1.reference"] = null;

            /**
             * MessageOptions .clutch.api.v1.id.
             * @member {clutch.api.v1.IIdentifier|null|undefined} .clutch.api.v1.id
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".clutch.api.v1.id"] = null;

            /**
             * MessageOptions .validate.disabled.
             * @member {boolean} .validate.disabled
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".validate.disabled"] = false;

            /**
             * MessageOptions .clutch.resolver.v1.schema.
             * @member {clutch.resolver.v1.ISchemaMetadata|null|undefined} .clutch.resolver.v1.schema
             * @memberof google.protobuf.MessageOptions
             * @instance
             */
            MessageOptions.prototype[".clutch.resolver.v1.schema"] = null;

            /**
             * Verifies a MessageOptions message.
             * @function verify
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MessageOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    if (typeof message.messageSetWireFormat !== "boolean")
                        return "messageSetWireFormat: boolean expected";
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    if (typeof message.noStandardDescriptorAccessor !== "boolean")
                        return "noStandardDescriptorAccessor: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    if (typeof message.mapEntry !== "boolean")
                        return "mapEntry: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".clutch.api.v1.reference"] != null && message.hasOwnProperty(".clutch.api.v1.reference")) {
                    let error = $root.clutch.api.v1.Reference.verify(message[".clutch.api.v1.reference"]);
                    if (error)
                        return ".clutch.api.v1.reference." + error;
                }
                if (message[".clutch.api.v1.id"] != null && message.hasOwnProperty(".clutch.api.v1.id")) {
                    let error = $root.clutch.api.v1.Identifier.verify(message[".clutch.api.v1.id"]);
                    if (error)
                        return ".clutch.api.v1.id." + error;
                }
                if (message[".validate.disabled"] != null && message.hasOwnProperty(".validate.disabled"))
                    if (typeof message[".validate.disabled"] !== "boolean")
                        return ".validate.disabled: boolean expected";
                if (message[".clutch.resolver.v1.schema"] != null && message.hasOwnProperty(".clutch.resolver.v1.schema")) {
                    let error = $root.clutch.resolver.v1.SchemaMetadata.verify(message[".clutch.resolver.v1.schema"]);
                    if (error)
                        return ".clutch.resolver.v1.schema." + error;
                }
                return null;
            };

            /**
             * Creates a MessageOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MessageOptions} MessageOptions
             */
            MessageOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MessageOptions)
                    return object;
                let message = new $root.google.protobuf.MessageOptions();
                if (object.messageSetWireFormat != null)
                    message.messageSetWireFormat = Boolean(object.messageSetWireFormat);
                if (object.noStandardDescriptorAccessor != null)
                    message.noStandardDescriptorAccessor = Boolean(object.noStandardDescriptorAccessor);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.mapEntry != null)
                    message.mapEntry = Boolean(object.mapEntry);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MessageOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".clutch.api.v1.reference"] != null) {
                    if (typeof object[".clutch.api.v1.reference"] !== "object")
                        throw TypeError(".google.protobuf.MessageOptions..clutch.api.v1.reference: object expected");
                    message[".clutch.api.v1.reference"] = $root.clutch.api.v1.Reference.fromObject(object[".clutch.api.v1.reference"]);
                }
                if (object[".clutch.api.v1.id"] != null) {
                    if (typeof object[".clutch.api.v1.id"] !== "object")
                        throw TypeError(".google.protobuf.MessageOptions..clutch.api.v1.id: object expected");
                    message[".clutch.api.v1.id"] = $root.clutch.api.v1.Identifier.fromObject(object[".clutch.api.v1.id"]);
                }
                if (object[".validate.disabled"] != null)
                    message[".validate.disabled"] = Boolean(object[".validate.disabled"]);
                if (object[".clutch.resolver.v1.schema"] != null) {
                    if (typeof object[".clutch.resolver.v1.schema"] !== "object")
                        throw TypeError(".google.protobuf.MessageOptions..clutch.resolver.v1.schema: object expected");
                    message[".clutch.resolver.v1.schema"] = $root.clutch.resolver.v1.SchemaMetadata.fromObject(object[".clutch.resolver.v1.schema"]);
                }
                return message;
            };

            /**
             * Creates a plain object from a MessageOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MessageOptions
             * @static
             * @param {google.protobuf.MessageOptions} message MessageOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MessageOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.messageSetWireFormat = false;
                    object.noStandardDescriptorAccessor = false;
                    object.deprecated = false;
                    object.mapEntry = false;
                    object[".validate.disabled"] = false;
                    object[".clutch.api.v1.reference"] = null;
                    object[".clutch.api.v1.id"] = null;
                    object[".clutch.resolver.v1.schema"] = null;
                }
                if (message.messageSetWireFormat != null && message.hasOwnProperty("messageSetWireFormat"))
                    object.messageSetWireFormat = message.messageSetWireFormat;
                if (message.noStandardDescriptorAccessor != null && message.hasOwnProperty("noStandardDescriptorAccessor"))
                    object.noStandardDescriptorAccessor = message.noStandardDescriptorAccessor;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.mapEntry != null && message.hasOwnProperty("mapEntry"))
                    object.mapEntry = message.mapEntry;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".validate.disabled"] != null && message.hasOwnProperty(".validate.disabled"))
                    object[".validate.disabled"] = message[".validate.disabled"];
                if (message[".clutch.api.v1.reference"] != null && message.hasOwnProperty(".clutch.api.v1.reference"))
                    object[".clutch.api.v1.reference"] = $root.clutch.api.v1.Reference.toObject(message[".clutch.api.v1.reference"], options);
                if (message[".clutch.api.v1.id"] != null && message.hasOwnProperty(".clutch.api.v1.id"))
                    object[".clutch.api.v1.id"] = $root.clutch.api.v1.Identifier.toObject(message[".clutch.api.v1.id"], options);
                if (message[".clutch.resolver.v1.schema"] != null && message.hasOwnProperty(".clutch.resolver.v1.schema"))
                    object[".clutch.resolver.v1.schema"] = $root.clutch.resolver.v1.SchemaMetadata.toObject(message[".clutch.resolver.v1.schema"], options);
                return object;
            };

            /**
             * Converts this MessageOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MessageOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MessageOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return MessageOptions;
        })();

        protobuf.FieldOptions = (function() {

            /**
             * Properties of a FieldOptions.
             * @memberof google.protobuf
             * @interface IFieldOptions
             * @property {google.protobuf.FieldOptions.CType|null} [ctype] FieldOptions ctype
             * @property {boolean|null} [packed] FieldOptions packed
             * @property {google.protobuf.FieldOptions.JSType|null} [jstype] FieldOptions jstype
             * @property {boolean|null} [lazy] FieldOptions lazy
             * @property {boolean|null} [deprecated] FieldOptions deprecated
             * @property {boolean|null} [weak] FieldOptions weak
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] FieldOptions uninterpretedOption
             * @property {validate.IFieldRules|null} [".validate.rules"] FieldOptions .validate.rules
             * @property {clutch.resolver.v1.IFieldMetadata|null} [".clutch.resolver.v1.schemaField"] FieldOptions .clutch.resolver.v1.schemaField
             */

            /**
             * Constructs a new FieldOptions.
             * @memberof google.protobuf
             * @classdesc Represents a FieldOptions.
             * @implements IFieldOptions
             * @constructor
             * @param {google.protobuf.IFieldOptions=} [properties] Properties to set
             */
            function FieldOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FieldOptions ctype.
             * @member {google.protobuf.FieldOptions.CType} ctype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.ctype = 0;

            /**
             * FieldOptions packed.
             * @member {boolean} packed
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.packed = false;

            /**
             * FieldOptions jstype.
             * @member {google.protobuf.FieldOptions.JSType} jstype
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.jstype = 0;

            /**
             * FieldOptions lazy.
             * @member {boolean} lazy
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.lazy = false;

            /**
             * FieldOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.deprecated = false;

            /**
             * FieldOptions weak.
             * @member {boolean} weak
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.weak = false;

            /**
             * FieldOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * FieldOptions .validate.rules.
             * @member {validate.IFieldRules|null|undefined} .validate.rules
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".validate.rules"] = null;

            /**
             * FieldOptions .clutch.resolver.v1.schemaField.
             * @member {clutch.resolver.v1.IFieldMetadata|null|undefined} .clutch.resolver.v1.schemaField
             * @memberof google.protobuf.FieldOptions
             * @instance
             */
            FieldOptions.prototype[".clutch.resolver.v1.schemaField"] = null;

            /**
             * Verifies a FieldOptions message.
             * @function verify
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FieldOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    switch (message.ctype) {
                    default:
                        return "ctype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.packed != null && message.hasOwnProperty("packed"))
                    if (typeof message.packed !== "boolean")
                        return "packed: boolean expected";
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    switch (message.jstype) {
                    default:
                        return "jstype: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    if (typeof message.lazy !== "boolean")
                        return "lazy: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.weak != null && message.hasOwnProperty("weak"))
                    if (typeof message.weak !== "boolean")
                        return "weak: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".validate.rules"] != null && message.hasOwnProperty(".validate.rules")) {
                    let error = $root.validate.FieldRules.verify(message[".validate.rules"]);
                    if (error)
                        return ".validate.rules." + error;
                }
                if (message[".clutch.resolver.v1.schemaField"] != null && message.hasOwnProperty(".clutch.resolver.v1.schemaField")) {
                    let error = $root.clutch.resolver.v1.FieldMetadata.verify(message[".clutch.resolver.v1.schemaField"]);
                    if (error)
                        return ".clutch.resolver.v1.schemaField." + error;
                }
                return null;
            };

            /**
             * Creates a FieldOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FieldOptions} FieldOptions
             */
            FieldOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FieldOptions)
                    return object;
                let message = new $root.google.protobuf.FieldOptions();
                switch (object.ctype) {
                case "STRING":
                case 0:
                    message.ctype = 0;
                    break;
                case "CORD":
                case 1:
                    message.ctype = 1;
                    break;
                case "STRING_PIECE":
                case 2:
                    message.ctype = 2;
                    break;
                }
                if (object.packed != null)
                    message.packed = Boolean(object.packed);
                switch (object.jstype) {
                case "JS_NORMAL":
                case 0:
                    message.jstype = 0;
                    break;
                case "JS_STRING":
                case 1:
                    message.jstype = 1;
                    break;
                case "JS_NUMBER":
                case 2:
                    message.jstype = 2;
                    break;
                }
                if (object.lazy != null)
                    message.lazy = Boolean(object.lazy);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.weak != null)
                    message.weak = Boolean(object.weak);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.FieldOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".validate.rules"] != null) {
                    if (typeof object[".validate.rules"] !== "object")
                        throw TypeError(".google.protobuf.FieldOptions..validate.rules: object expected");
                    message[".validate.rules"] = $root.validate.FieldRules.fromObject(object[".validate.rules"]);
                }
                if (object[".clutch.resolver.v1.schemaField"] != null) {
                    if (typeof object[".clutch.resolver.v1.schemaField"] !== "object")
                        throw TypeError(".google.protobuf.FieldOptions..clutch.resolver.v1.schemaField: object expected");
                    message[".clutch.resolver.v1.schemaField"] = $root.clutch.resolver.v1.FieldMetadata.fromObject(object[".clutch.resolver.v1.schemaField"]);
                }
                return message;
            };

            /**
             * Creates a plain object from a FieldOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FieldOptions
             * @static
             * @param {google.protobuf.FieldOptions} message FieldOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FieldOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.ctype = options.enums === String ? "STRING" : 0;
                    object.packed = false;
                    object.deprecated = false;
                    object.lazy = false;
                    object.jstype = options.enums === String ? "JS_NORMAL" : 0;
                    object.weak = false;
                    object[".validate.rules"] = null;
                    object[".clutch.resolver.v1.schemaField"] = null;
                }
                if (message.ctype != null && message.hasOwnProperty("ctype"))
                    object.ctype = options.enums === String ? $root.google.protobuf.FieldOptions.CType[message.ctype] : message.ctype;
                if (message.packed != null && message.hasOwnProperty("packed"))
                    object.packed = message.packed;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.lazy != null && message.hasOwnProperty("lazy"))
                    object.lazy = message.lazy;
                if (message.jstype != null && message.hasOwnProperty("jstype"))
                    object.jstype = options.enums === String ? $root.google.protobuf.FieldOptions.JSType[message.jstype] : message.jstype;
                if (message.weak != null && message.hasOwnProperty("weak"))
                    object.weak = message.weak;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".validate.rules"] != null && message.hasOwnProperty(".validate.rules"))
                    object[".validate.rules"] = $root.validate.FieldRules.toObject(message[".validate.rules"], options);
                if (message[".clutch.resolver.v1.schemaField"] != null && message.hasOwnProperty(".clutch.resolver.v1.schemaField"))
                    object[".clutch.resolver.v1.schemaField"] = $root.clutch.resolver.v1.FieldMetadata.toObject(message[".clutch.resolver.v1.schemaField"], options);
                return object;
            };

            /**
             * Converts this FieldOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.FieldOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FieldOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * CType enum.
             * @name google.protobuf.FieldOptions.CType
             * @enum {number}
             * @property {number} STRING=0 STRING value
             * @property {number} CORD=1 CORD value
             * @property {number} STRING_PIECE=2 STRING_PIECE value
             */
            FieldOptions.CType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "STRING"] = 0;
                values[valuesById[1] = "CORD"] = 1;
                values[valuesById[2] = "STRING_PIECE"] = 2;
                return values;
            })();

            /**
             * JSType enum.
             * @name google.protobuf.FieldOptions.JSType
             * @enum {number}
             * @property {number} JS_NORMAL=0 JS_NORMAL value
             * @property {number} JS_STRING=1 JS_STRING value
             * @property {number} JS_NUMBER=2 JS_NUMBER value
             */
            FieldOptions.JSType = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "JS_NORMAL"] = 0;
                values[valuesById[1] = "JS_STRING"] = 1;
                values[valuesById[2] = "JS_NUMBER"] = 2;
                return values;
            })();

            return FieldOptions;
        })();

        protobuf.OneofOptions = (function() {

            /**
             * Properties of an OneofOptions.
             * @memberof google.protobuf
             * @interface IOneofOptions
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] OneofOptions uninterpretedOption
             * @property {boolean|null} [".validate.required"] OneofOptions .validate.required
             */

            /**
             * Constructs a new OneofOptions.
             * @memberof google.protobuf
             * @classdesc Represents an OneofOptions.
             * @implements IOneofOptions
             * @constructor
             * @param {google.protobuf.IOneofOptions=} [properties] Properties to set
             */
            function OneofOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * OneofOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * OneofOptions .validate.required.
             * @member {boolean} .validate.required
             * @memberof google.protobuf.OneofOptions
             * @instance
             */
            OneofOptions.prototype[".validate.required"] = false;

            /**
             * Verifies an OneofOptions message.
             * @function verify
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            OneofOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".validate.required"] != null && message.hasOwnProperty(".validate.required"))
                    if (typeof message[".validate.required"] !== "boolean")
                        return ".validate.required: boolean expected";
                return null;
            };

            /**
             * Creates an OneofOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.OneofOptions} OneofOptions
             */
            OneofOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.OneofOptions)
                    return object;
                let message = new $root.google.protobuf.OneofOptions();
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.OneofOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".validate.required"] != null)
                    message[".validate.required"] = Boolean(object[".validate.required"]);
                return message;
            };

            /**
             * Creates a plain object from an OneofOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.OneofOptions
             * @static
             * @param {google.protobuf.OneofOptions} message OneofOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            OneofOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object[".validate.required"] = false;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".validate.required"] != null && message.hasOwnProperty(".validate.required"))
                    object[".validate.required"] = message[".validate.required"];
                return object;
            };

            /**
             * Converts this OneofOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.OneofOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            OneofOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return OneofOptions;
        })();

        protobuf.EnumOptions = (function() {

            /**
             * Properties of an EnumOptions.
             * @memberof google.protobuf
             * @interface IEnumOptions
             * @property {boolean|null} [allowAlias] EnumOptions allowAlias
             * @property {boolean|null} [deprecated] EnumOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumOptions.
             * @implements IEnumOptions
             * @constructor
             * @param {google.protobuf.IEnumOptions=} [properties] Properties to set
             */
            function EnumOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumOptions allowAlias.
             * @member {boolean} allowAlias
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.allowAlias = false;

            /**
             * EnumOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.deprecated = false;

            /**
             * EnumOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumOptions
             * @instance
             */
            EnumOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Verifies an EnumOptions message.
             * @function verify
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    if (typeof message.allowAlias !== "boolean")
                        return "allowAlias: boolean expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumOptions} EnumOptions
             */
            EnumOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumOptions)
                    return object;
                let message = new $root.google.protobuf.EnumOptions();
                if (object.allowAlias != null)
                    message.allowAlias = Boolean(object.allowAlias);
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumOptions
             * @static
             * @param {google.protobuf.EnumOptions} message EnumOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.allowAlias = false;
                    object.deprecated = false;
                }
                if (message.allowAlias != null && message.hasOwnProperty("allowAlias"))
                    object.allowAlias = message.allowAlias;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumOptions;
        })();

        protobuf.EnumValueOptions = (function() {

            /**
             * Properties of an EnumValueOptions.
             * @memberof google.protobuf
             * @interface IEnumValueOptions
             * @property {boolean|null} [deprecated] EnumValueOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] EnumValueOptions uninterpretedOption
             */

            /**
             * Constructs a new EnumValueOptions.
             * @memberof google.protobuf
             * @classdesc Represents an EnumValueOptions.
             * @implements IEnumValueOptions
             * @constructor
             * @param {google.protobuf.IEnumValueOptions=} [properties] Properties to set
             */
            function EnumValueOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * EnumValueOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.deprecated = false;

            /**
             * EnumValueOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             */
            EnumValueOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Verifies an EnumValueOptions message.
             * @function verify
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            EnumValueOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates an EnumValueOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.EnumValueOptions} EnumValueOptions
             */
            EnumValueOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.EnumValueOptions)
                    return object;
                let message = new $root.google.protobuf.EnumValueOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.EnumValueOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from an EnumValueOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.EnumValueOptions
             * @static
             * @param {google.protobuf.EnumValueOptions} message EnumValueOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            EnumValueOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this EnumValueOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.EnumValueOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            EnumValueOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return EnumValueOptions;
        })();

        protobuf.ServiceOptions = (function() {

            /**
             * Properties of a ServiceOptions.
             * @memberof google.protobuf
             * @interface IServiceOptions
             * @property {boolean|null} [deprecated] ServiceOptions deprecated
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] ServiceOptions uninterpretedOption
             */

            /**
             * Constructs a new ServiceOptions.
             * @memberof google.protobuf
             * @classdesc Represents a ServiceOptions.
             * @implements IServiceOptions
             * @constructor
             * @param {google.protobuf.IServiceOptions=} [properties] Properties to set
             */
            function ServiceOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ServiceOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.deprecated = false;

            /**
             * ServiceOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.ServiceOptions
             * @instance
             */
            ServiceOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * Verifies a ServiceOptions message.
             * @function verify
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ServiceOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ServiceOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ServiceOptions} ServiceOptions
             */
            ServiceOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ServiceOptions)
                    return object;
                let message = new $root.google.protobuf.ServiceOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.ServiceOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ServiceOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ServiceOptions
             * @static
             * @param {google.protobuf.ServiceOptions} message ServiceOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ServiceOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults)
                    object.deprecated = false;
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                return object;
            };

            /**
             * Converts this ServiceOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.ServiceOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ServiceOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ServiceOptions;
        })();

        protobuf.MethodOptions = (function() {

            /**
             * Properties of a MethodOptions.
             * @memberof google.protobuf
             * @interface IMethodOptions
             * @property {boolean|null} [deprecated] MethodOptions deprecated
             * @property {google.protobuf.MethodOptions.IdempotencyLevel|null} [idempotencyLevel] MethodOptions idempotencyLevel
             * @property {Array.<google.protobuf.IUninterpretedOption>|null} [uninterpretedOption] MethodOptions uninterpretedOption
             * @property {clutch.api.v1.IAction|null} [".clutch.api.v1.action"] MethodOptions .clutch.api.v1.action
             * @property {google.api.IHttpRule|null} [".google.api.http"] MethodOptions .google.api.http
             */

            /**
             * Constructs a new MethodOptions.
             * @memberof google.protobuf
             * @classdesc Represents a MethodOptions.
             * @implements IMethodOptions
             * @constructor
             * @param {google.protobuf.IMethodOptions=} [properties] Properties to set
             */
            function MethodOptions(properties) {
                this.uninterpretedOption = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * MethodOptions deprecated.
             * @member {boolean} deprecated
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.deprecated = false;

            /**
             * MethodOptions idempotencyLevel.
             * @member {google.protobuf.MethodOptions.IdempotencyLevel} idempotencyLevel
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.idempotencyLevel = 0;

            /**
             * MethodOptions uninterpretedOption.
             * @member {Array.<google.protobuf.IUninterpretedOption>} uninterpretedOption
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype.uninterpretedOption = $util.emptyArray;

            /**
             * MethodOptions .clutch.api.v1.action.
             * @member {clutch.api.v1.IAction|null|undefined} .clutch.api.v1.action
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype[".clutch.api.v1.action"] = null;

            /**
             * MethodOptions .google.api.http.
             * @member {google.api.IHttpRule|null|undefined} .google.api.http
             * @memberof google.protobuf.MethodOptions
             * @instance
             */
            MethodOptions.prototype[".google.api.http"] = null;

            /**
             * Verifies a MethodOptions message.
             * @function verify
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            MethodOptions.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    if (typeof message.deprecated !== "boolean")
                        return "deprecated: boolean expected";
                if (message.idempotencyLevel != null && message.hasOwnProperty("idempotencyLevel"))
                    switch (message.idempotencyLevel) {
                    default:
                        return "idempotencyLevel: enum value expected";
                    case 0:
                    case 1:
                    case 2:
                        break;
                    }
                if (message.uninterpretedOption != null && message.hasOwnProperty("uninterpretedOption")) {
                    if (!Array.isArray(message.uninterpretedOption))
                        return "uninterpretedOption: array expected";
                    for (let i = 0; i < message.uninterpretedOption.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.verify(message.uninterpretedOption[i]);
                        if (error)
                            return "uninterpretedOption." + error;
                    }
                }
                if (message[".clutch.api.v1.action"] != null && message.hasOwnProperty(".clutch.api.v1.action")) {
                    let error = $root.clutch.api.v1.Action.verify(message[".clutch.api.v1.action"]);
                    if (error)
                        return ".clutch.api.v1.action." + error;
                }
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http")) {
                    let error = $root.google.api.HttpRule.verify(message[".google.api.http"]);
                    if (error)
                        return ".google.api.http." + error;
                }
                return null;
            };

            /**
             * Creates a MethodOptions message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.MethodOptions} MethodOptions
             */
            MethodOptions.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.MethodOptions)
                    return object;
                let message = new $root.google.protobuf.MethodOptions();
                if (object.deprecated != null)
                    message.deprecated = Boolean(object.deprecated);
                switch (object.idempotencyLevel) {
                case "IDEMPOTENCY_UNKNOWN":
                case 0:
                    message.idempotencyLevel = 0;
                    break;
                case "NO_SIDE_EFFECTS":
                case 1:
                    message.idempotencyLevel = 1;
                    break;
                case "IDEMPOTENT":
                case 2:
                    message.idempotencyLevel = 2;
                    break;
                }
                if (object.uninterpretedOption) {
                    if (!Array.isArray(object.uninterpretedOption))
                        throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: array expected");
                    message.uninterpretedOption = [];
                    for (let i = 0; i < object.uninterpretedOption.length; ++i) {
                        if (typeof object.uninterpretedOption[i] !== "object")
                            throw TypeError(".google.protobuf.MethodOptions.uninterpretedOption: object expected");
                        message.uninterpretedOption[i] = $root.google.protobuf.UninterpretedOption.fromObject(object.uninterpretedOption[i]);
                    }
                }
                if (object[".clutch.api.v1.action"] != null) {
                    if (typeof object[".clutch.api.v1.action"] !== "object")
                        throw TypeError(".google.protobuf.MethodOptions..clutch.api.v1.action: object expected");
                    message[".clutch.api.v1.action"] = $root.clutch.api.v1.Action.fromObject(object[".clutch.api.v1.action"]);
                }
                if (object[".google.api.http"] != null) {
                    if (typeof object[".google.api.http"] !== "object")
                        throw TypeError(".google.protobuf.MethodOptions..google.api.http: object expected");
                    message[".google.api.http"] = $root.google.api.HttpRule.fromObject(object[".google.api.http"]);
                }
                return message;
            };

            /**
             * Creates a plain object from a MethodOptions message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.MethodOptions
             * @static
             * @param {google.protobuf.MethodOptions} message MethodOptions
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            MethodOptions.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.uninterpretedOption = [];
                if (options.defaults) {
                    object.deprecated = false;
                    object.idempotencyLevel = options.enums === String ? "IDEMPOTENCY_UNKNOWN" : 0;
                    object[".clutch.api.v1.action"] = null;
                    object[".google.api.http"] = null;
                }
                if (message.deprecated != null && message.hasOwnProperty("deprecated"))
                    object.deprecated = message.deprecated;
                if (message.idempotencyLevel != null && message.hasOwnProperty("idempotencyLevel"))
                    object.idempotencyLevel = options.enums === String ? $root.google.protobuf.MethodOptions.IdempotencyLevel[message.idempotencyLevel] : message.idempotencyLevel;
                if (message.uninterpretedOption && message.uninterpretedOption.length) {
                    object.uninterpretedOption = [];
                    for (let j = 0; j < message.uninterpretedOption.length; ++j)
                        object.uninterpretedOption[j] = $root.google.protobuf.UninterpretedOption.toObject(message.uninterpretedOption[j], options);
                }
                if (message[".clutch.api.v1.action"] != null && message.hasOwnProperty(".clutch.api.v1.action"))
                    object[".clutch.api.v1.action"] = $root.clutch.api.v1.Action.toObject(message[".clutch.api.v1.action"], options);
                if (message[".google.api.http"] != null && message.hasOwnProperty(".google.api.http"))
                    object[".google.api.http"] = $root.google.api.HttpRule.toObject(message[".google.api.http"], options);
                return object;
            };

            /**
             * Converts this MethodOptions to JSON.
             * @function toJSON
             * @memberof google.protobuf.MethodOptions
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            MethodOptions.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            /**
             * IdempotencyLevel enum.
             * @name google.protobuf.MethodOptions.IdempotencyLevel
             * @enum {number}
             * @property {number} IDEMPOTENCY_UNKNOWN=0 IDEMPOTENCY_UNKNOWN value
             * @property {number} NO_SIDE_EFFECTS=1 NO_SIDE_EFFECTS value
             * @property {number} IDEMPOTENT=2 IDEMPOTENT value
             */
            MethodOptions.IdempotencyLevel = (function() {
                const valuesById = {}, values = Object.create(valuesById);
                values[valuesById[0] = "IDEMPOTENCY_UNKNOWN"] = 0;
                values[valuesById[1] = "NO_SIDE_EFFECTS"] = 1;
                values[valuesById[2] = "IDEMPOTENT"] = 2;
                return values;
            })();

            return MethodOptions;
        })();

        protobuf.UninterpretedOption = (function() {

            /**
             * Properties of an UninterpretedOption.
             * @memberof google.protobuf
             * @interface IUninterpretedOption
             * @property {Array.<google.protobuf.UninterpretedOption.INamePart>|null} [name] UninterpretedOption name
             * @property {string|null} [identifierValue] UninterpretedOption identifierValue
             * @property {number|Long|null} [positiveIntValue] UninterpretedOption positiveIntValue
             * @property {number|Long|null} [negativeIntValue] UninterpretedOption negativeIntValue
             * @property {number|null} [doubleValue] UninterpretedOption doubleValue
             * @property {Uint8Array|null} [stringValue] UninterpretedOption stringValue
             * @property {string|null} [aggregateValue] UninterpretedOption aggregateValue
             */

            /**
             * Constructs a new UninterpretedOption.
             * @memberof google.protobuf
             * @classdesc Represents an UninterpretedOption.
             * @implements IUninterpretedOption
             * @constructor
             * @param {google.protobuf.IUninterpretedOption=} [properties] Properties to set
             */
            function UninterpretedOption(properties) {
                this.name = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UninterpretedOption name.
             * @member {Array.<google.protobuf.UninterpretedOption.INamePart>} name
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.name = $util.emptyArray;

            /**
             * UninterpretedOption identifierValue.
             * @member {string} identifierValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.identifierValue = "";

            /**
             * UninterpretedOption positiveIntValue.
             * @member {number|Long} positiveIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.positiveIntValue = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * UninterpretedOption negativeIntValue.
             * @member {number|Long} negativeIntValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.negativeIntValue = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * UninterpretedOption doubleValue.
             * @member {number} doubleValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.doubleValue = 0;

            /**
             * UninterpretedOption stringValue.
             * @member {Uint8Array} stringValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.stringValue = $util.newBuffer([]);

            /**
             * UninterpretedOption aggregateValue.
             * @member {string} aggregateValue
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             */
            UninterpretedOption.prototype.aggregateValue = "";

            /**
             * Verifies an UninterpretedOption message.
             * @function verify
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UninterpretedOption.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.name != null && message.hasOwnProperty("name")) {
                    if (!Array.isArray(message.name))
                        return "name: array expected";
                    for (let i = 0; i < message.name.length; ++i) {
                        let error = $root.google.protobuf.UninterpretedOption.NamePart.verify(message.name[i]);
                        if (error)
                            return "name." + error;
                    }
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    if (!$util.isString(message.identifierValue))
                        return "identifierValue: string expected";
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (!$util.isInteger(message.positiveIntValue) && !(message.positiveIntValue && $util.isInteger(message.positiveIntValue.low) && $util.isInteger(message.positiveIntValue.high)))
                        return "positiveIntValue: integer|Long expected";
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (!$util.isInteger(message.negativeIntValue) && !(message.negativeIntValue && $util.isInteger(message.negativeIntValue.low) && $util.isInteger(message.negativeIntValue.high)))
                        return "negativeIntValue: integer|Long expected";
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    if (typeof message.doubleValue !== "number")
                        return "doubleValue: number expected";
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    if (!(message.stringValue && typeof message.stringValue.length === "number" || $util.isString(message.stringValue)))
                        return "stringValue: buffer expected";
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    if (!$util.isString(message.aggregateValue))
                        return "aggregateValue: string expected";
                return null;
            };

            /**
             * Creates an UninterpretedOption message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UninterpretedOption} UninterpretedOption
             */
            UninterpretedOption.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UninterpretedOption)
                    return object;
                let message = new $root.google.protobuf.UninterpretedOption();
                if (object.name) {
                    if (!Array.isArray(object.name))
                        throw TypeError(".google.protobuf.UninterpretedOption.name: array expected");
                    message.name = [];
                    for (let i = 0; i < object.name.length; ++i) {
                        if (typeof object.name[i] !== "object")
                            throw TypeError(".google.protobuf.UninterpretedOption.name: object expected");
                        message.name[i] = $root.google.protobuf.UninterpretedOption.NamePart.fromObject(object.name[i]);
                    }
                }
                if (object.identifierValue != null)
                    message.identifierValue = String(object.identifierValue);
                if (object.positiveIntValue != null)
                    if ($util.Long)
                        (message.positiveIntValue = $util.Long.fromValue(object.positiveIntValue)).unsigned = true;
                    else if (typeof object.positiveIntValue === "string")
                        message.positiveIntValue = parseInt(object.positiveIntValue, 10);
                    else if (typeof object.positiveIntValue === "number")
                        message.positiveIntValue = object.positiveIntValue;
                    else if (typeof object.positiveIntValue === "object")
                        message.positiveIntValue = new $util.LongBits(object.positiveIntValue.low >>> 0, object.positiveIntValue.high >>> 0).toNumber(true);
                if (object.negativeIntValue != null)
                    if ($util.Long)
                        (message.negativeIntValue = $util.Long.fromValue(object.negativeIntValue)).unsigned = false;
                    else if (typeof object.negativeIntValue === "string")
                        message.negativeIntValue = parseInt(object.negativeIntValue, 10);
                    else if (typeof object.negativeIntValue === "number")
                        message.negativeIntValue = object.negativeIntValue;
                    else if (typeof object.negativeIntValue === "object")
                        message.negativeIntValue = new $util.LongBits(object.negativeIntValue.low >>> 0, object.negativeIntValue.high >>> 0).toNumber();
                if (object.doubleValue != null)
                    message.doubleValue = Number(object.doubleValue);
                if (object.stringValue != null)
                    if (typeof object.stringValue === "string")
                        $util.base64.decode(object.stringValue, message.stringValue = $util.newBuffer($util.base64.length(object.stringValue)), 0);
                    else if (object.stringValue.length)
                        message.stringValue = object.stringValue;
                if (object.aggregateValue != null)
                    message.aggregateValue = String(object.aggregateValue);
                return message;
            };

            /**
             * Creates a plain object from an UninterpretedOption message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UninterpretedOption
             * @static
             * @param {google.protobuf.UninterpretedOption} message UninterpretedOption
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UninterpretedOption.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.name = [];
                if (options.defaults) {
                    object.identifierValue = "";
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.positiveIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.positiveIntValue = options.longs === String ? "0" : 0;
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.negativeIntValue = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.negativeIntValue = options.longs === String ? "0" : 0;
                    object.doubleValue = 0;
                    if (options.bytes === String)
                        object.stringValue = "";
                    else {
                        object.stringValue = [];
                        if (options.bytes !== Array)
                            object.stringValue = $util.newBuffer(object.stringValue);
                    }
                    object.aggregateValue = "";
                }
                if (message.name && message.name.length) {
                    object.name = [];
                    for (let j = 0; j < message.name.length; ++j)
                        object.name[j] = $root.google.protobuf.UninterpretedOption.NamePart.toObject(message.name[j], options);
                }
                if (message.identifierValue != null && message.hasOwnProperty("identifierValue"))
                    object.identifierValue = message.identifierValue;
                if (message.positiveIntValue != null && message.hasOwnProperty("positiveIntValue"))
                    if (typeof message.positiveIntValue === "number")
                        object.positiveIntValue = options.longs === String ? String(message.positiveIntValue) : message.positiveIntValue;
                    else
                        object.positiveIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.positiveIntValue) : options.longs === Number ? new $util.LongBits(message.positiveIntValue.low >>> 0, message.positiveIntValue.high >>> 0).toNumber(true) : message.positiveIntValue;
                if (message.negativeIntValue != null && message.hasOwnProperty("negativeIntValue"))
                    if (typeof message.negativeIntValue === "number")
                        object.negativeIntValue = options.longs === String ? String(message.negativeIntValue) : message.negativeIntValue;
                    else
                        object.negativeIntValue = options.longs === String ? $util.Long.prototype.toString.call(message.negativeIntValue) : options.longs === Number ? new $util.LongBits(message.negativeIntValue.low >>> 0, message.negativeIntValue.high >>> 0).toNumber() : message.negativeIntValue;
                if (message.doubleValue != null && message.hasOwnProperty("doubleValue"))
                    object.doubleValue = options.json && !isFinite(message.doubleValue) ? String(message.doubleValue) : message.doubleValue;
                if (message.stringValue != null && message.hasOwnProperty("stringValue"))
                    object.stringValue = options.bytes === String ? $util.base64.encode(message.stringValue, 0, message.stringValue.length) : options.bytes === Array ? Array.prototype.slice.call(message.stringValue) : message.stringValue;
                if (message.aggregateValue != null && message.hasOwnProperty("aggregateValue"))
                    object.aggregateValue = message.aggregateValue;
                return object;
            };

            /**
             * Converts this UninterpretedOption to JSON.
             * @function toJSON
             * @memberof google.protobuf.UninterpretedOption
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UninterpretedOption.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            UninterpretedOption.NamePart = (function() {

                /**
                 * Properties of a NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @interface INamePart
                 * @property {string} namePart NamePart namePart
                 * @property {boolean} isExtension NamePart isExtension
                 */

                /**
                 * Constructs a new NamePart.
                 * @memberof google.protobuf.UninterpretedOption
                 * @classdesc Represents a NamePart.
                 * @implements INamePart
                 * @constructor
                 * @param {google.protobuf.UninterpretedOption.INamePart=} [properties] Properties to set
                 */
                function NamePart(properties) {
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * NamePart namePart.
                 * @member {string} namePart
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.namePart = "";

                /**
                 * NamePart isExtension.
                 * @member {boolean} isExtension
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 */
                NamePart.prototype.isExtension = false;

                /**
                 * Verifies a NamePart message.
                 * @function verify
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                NamePart.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (!$util.isString(message.namePart))
                        return "namePart: string expected";
                    if (typeof message.isExtension !== "boolean")
                        return "isExtension: boolean expected";
                    return null;
                };

                /**
                 * Creates a NamePart message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.UninterpretedOption.NamePart} NamePart
                 */
                NamePart.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.UninterpretedOption.NamePart)
                        return object;
                    let message = new $root.google.protobuf.UninterpretedOption.NamePart();
                    if (object.namePart != null)
                        message.namePart = String(object.namePart);
                    if (object.isExtension != null)
                        message.isExtension = Boolean(object.isExtension);
                    return message;
                };

                /**
                 * Creates a plain object from a NamePart message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @static
                 * @param {google.protobuf.UninterpretedOption.NamePart} message NamePart
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                NamePart.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.defaults) {
                        object.namePart = "";
                        object.isExtension = false;
                    }
                    if (message.namePart != null && message.hasOwnProperty("namePart"))
                        object.namePart = message.namePart;
                    if (message.isExtension != null && message.hasOwnProperty("isExtension"))
                        object.isExtension = message.isExtension;
                    return object;
                };

                /**
                 * Converts this NamePart to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.UninterpretedOption.NamePart
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                NamePart.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return NamePart;
            })();

            return UninterpretedOption;
        })();

        protobuf.SourceCodeInfo = (function() {

            /**
             * Properties of a SourceCodeInfo.
             * @memberof google.protobuf
             * @interface ISourceCodeInfo
             * @property {Array.<google.protobuf.SourceCodeInfo.ILocation>|null} [location] SourceCodeInfo location
             */

            /**
             * Constructs a new SourceCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a SourceCodeInfo.
             * @implements ISourceCodeInfo
             * @constructor
             * @param {google.protobuf.ISourceCodeInfo=} [properties] Properties to set
             */
            function SourceCodeInfo(properties) {
                this.location = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * SourceCodeInfo location.
             * @member {Array.<google.protobuf.SourceCodeInfo.ILocation>} location
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             */
            SourceCodeInfo.prototype.location = $util.emptyArray;

            /**
             * Verifies a SourceCodeInfo message.
             * @function verify
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            SourceCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.location != null && message.hasOwnProperty("location")) {
                    if (!Array.isArray(message.location))
                        return "location: array expected";
                    for (let i = 0; i < message.location.length; ++i) {
                        let error = $root.google.protobuf.SourceCodeInfo.Location.verify(message.location[i]);
                        if (error)
                            return "location." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a SourceCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.SourceCodeInfo} SourceCodeInfo
             */
            SourceCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.SourceCodeInfo)
                    return object;
                let message = new $root.google.protobuf.SourceCodeInfo();
                if (object.location) {
                    if (!Array.isArray(object.location))
                        throw TypeError(".google.protobuf.SourceCodeInfo.location: array expected");
                    message.location = [];
                    for (let i = 0; i < object.location.length; ++i) {
                        if (typeof object.location[i] !== "object")
                            throw TypeError(".google.protobuf.SourceCodeInfo.location: object expected");
                        message.location[i] = $root.google.protobuf.SourceCodeInfo.Location.fromObject(object.location[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a SourceCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.SourceCodeInfo
             * @static
             * @param {google.protobuf.SourceCodeInfo} message SourceCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            SourceCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.location = [];
                if (message.location && message.location.length) {
                    object.location = [];
                    for (let j = 0; j < message.location.length; ++j)
                        object.location[j] = $root.google.protobuf.SourceCodeInfo.Location.toObject(message.location[j], options);
                }
                return object;
            };

            /**
             * Converts this SourceCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.SourceCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            SourceCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            SourceCodeInfo.Location = (function() {

                /**
                 * Properties of a Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @interface ILocation
                 * @property {Array.<number>|null} [path] Location path
                 * @property {Array.<number>|null} [span] Location span
                 * @property {string|null} [leadingComments] Location leadingComments
                 * @property {string|null} [trailingComments] Location trailingComments
                 * @property {Array.<string>|null} [leadingDetachedComments] Location leadingDetachedComments
                 */

                /**
                 * Constructs a new Location.
                 * @memberof google.protobuf.SourceCodeInfo
                 * @classdesc Represents a Location.
                 * @implements ILocation
                 * @constructor
                 * @param {google.protobuf.SourceCodeInfo.ILocation=} [properties] Properties to set
                 */
                function Location(properties) {
                    this.path = [];
                    this.span = [];
                    this.leadingDetachedComments = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Location path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.path = $util.emptyArray;

                /**
                 * Location span.
                 * @member {Array.<number>} span
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.span = $util.emptyArray;

                /**
                 * Location leadingComments.
                 * @member {string} leadingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingComments = "";

                /**
                 * Location trailingComments.
                 * @member {string} trailingComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.trailingComments = "";

                /**
                 * Location leadingDetachedComments.
                 * @member {Array.<string>} leadingDetachedComments
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 */
                Location.prototype.leadingDetachedComments = $util.emptyArray;

                /**
                 * Verifies a Location message.
                 * @function verify
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Location.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.span != null && message.hasOwnProperty("span")) {
                        if (!Array.isArray(message.span))
                            return "span: array expected";
                        for (let i = 0; i < message.span.length; ++i)
                            if (!$util.isInteger(message.span[i]))
                                return "span: integer[] expected";
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        if (!$util.isString(message.leadingComments))
                            return "leadingComments: string expected";
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        if (!$util.isString(message.trailingComments))
                            return "trailingComments: string expected";
                    if (message.leadingDetachedComments != null && message.hasOwnProperty("leadingDetachedComments")) {
                        if (!Array.isArray(message.leadingDetachedComments))
                            return "leadingDetachedComments: array expected";
                        for (let i = 0; i < message.leadingDetachedComments.length; ++i)
                            if (!$util.isString(message.leadingDetachedComments[i]))
                                return "leadingDetachedComments: string[] expected";
                    }
                    return null;
                };

                /**
                 * Creates a Location message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.SourceCodeInfo.Location} Location
                 */
                Location.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.SourceCodeInfo.Location)
                        return object;
                    let message = new $root.google.protobuf.SourceCodeInfo.Location();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.span) {
                        if (!Array.isArray(object.span))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.span: array expected");
                        message.span = [];
                        for (let i = 0; i < object.span.length; ++i)
                            message.span[i] = object.span[i] | 0;
                    }
                    if (object.leadingComments != null)
                        message.leadingComments = String(object.leadingComments);
                    if (object.trailingComments != null)
                        message.trailingComments = String(object.trailingComments);
                    if (object.leadingDetachedComments) {
                        if (!Array.isArray(object.leadingDetachedComments))
                            throw TypeError(".google.protobuf.SourceCodeInfo.Location.leadingDetachedComments: array expected");
                        message.leadingDetachedComments = [];
                        for (let i = 0; i < object.leadingDetachedComments.length; ++i)
                            message.leadingDetachedComments[i] = String(object.leadingDetachedComments[i]);
                    }
                    return message;
                };

                /**
                 * Creates a plain object from a Location message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @static
                 * @param {google.protobuf.SourceCodeInfo.Location} message Location
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Location.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults) {
                        object.path = [];
                        object.span = [];
                        object.leadingDetachedComments = [];
                    }
                    if (options.defaults) {
                        object.leadingComments = "";
                        object.trailingComments = "";
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.span && message.span.length) {
                        object.span = [];
                        for (let j = 0; j < message.span.length; ++j)
                            object.span[j] = message.span[j];
                    }
                    if (message.leadingComments != null && message.hasOwnProperty("leadingComments"))
                        object.leadingComments = message.leadingComments;
                    if (message.trailingComments != null && message.hasOwnProperty("trailingComments"))
                        object.trailingComments = message.trailingComments;
                    if (message.leadingDetachedComments && message.leadingDetachedComments.length) {
                        object.leadingDetachedComments = [];
                        for (let j = 0; j < message.leadingDetachedComments.length; ++j)
                            object.leadingDetachedComments[j] = message.leadingDetachedComments[j];
                    }
                    return object;
                };

                /**
                 * Converts this Location to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.SourceCodeInfo.Location
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Location.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Location;
            })();

            return SourceCodeInfo;
        })();

        protobuf.GeneratedCodeInfo = (function() {

            /**
             * Properties of a GeneratedCodeInfo.
             * @memberof google.protobuf
             * @interface IGeneratedCodeInfo
             * @property {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>|null} [annotation] GeneratedCodeInfo annotation
             */

            /**
             * Constructs a new GeneratedCodeInfo.
             * @memberof google.protobuf
             * @classdesc Represents a GeneratedCodeInfo.
             * @implements IGeneratedCodeInfo
             * @constructor
             * @param {google.protobuf.IGeneratedCodeInfo=} [properties] Properties to set
             */
            function GeneratedCodeInfo(properties) {
                this.annotation = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * GeneratedCodeInfo annotation.
             * @member {Array.<google.protobuf.GeneratedCodeInfo.IAnnotation>} annotation
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             */
            GeneratedCodeInfo.prototype.annotation = $util.emptyArray;

            /**
             * Verifies a GeneratedCodeInfo message.
             * @function verify
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            GeneratedCodeInfo.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.annotation != null && message.hasOwnProperty("annotation")) {
                    if (!Array.isArray(message.annotation))
                        return "annotation: array expected";
                    for (let i = 0; i < message.annotation.length; ++i) {
                        let error = $root.google.protobuf.GeneratedCodeInfo.Annotation.verify(message.annotation[i]);
                        if (error)
                            return "annotation." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a GeneratedCodeInfo message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.GeneratedCodeInfo} GeneratedCodeInfo
             */
            GeneratedCodeInfo.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.GeneratedCodeInfo)
                    return object;
                let message = new $root.google.protobuf.GeneratedCodeInfo();
                if (object.annotation) {
                    if (!Array.isArray(object.annotation))
                        throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: array expected");
                    message.annotation = [];
                    for (let i = 0; i < object.annotation.length; ++i) {
                        if (typeof object.annotation[i] !== "object")
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.annotation: object expected");
                        message.annotation[i] = $root.google.protobuf.GeneratedCodeInfo.Annotation.fromObject(object.annotation[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a GeneratedCodeInfo message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.GeneratedCodeInfo
             * @static
             * @param {google.protobuf.GeneratedCodeInfo} message GeneratedCodeInfo
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            GeneratedCodeInfo.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.annotation = [];
                if (message.annotation && message.annotation.length) {
                    object.annotation = [];
                    for (let j = 0; j < message.annotation.length; ++j)
                        object.annotation[j] = $root.google.protobuf.GeneratedCodeInfo.Annotation.toObject(message.annotation[j], options);
                }
                return object;
            };

            /**
             * Converts this GeneratedCodeInfo to JSON.
             * @function toJSON
             * @memberof google.protobuf.GeneratedCodeInfo
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            GeneratedCodeInfo.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            GeneratedCodeInfo.Annotation = (function() {

                /**
                 * Properties of an Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @interface IAnnotation
                 * @property {Array.<number>|null} [path] Annotation path
                 * @property {string|null} [sourceFile] Annotation sourceFile
                 * @property {number|null} [begin] Annotation begin
                 * @property {number|null} [end] Annotation end
                 */

                /**
                 * Constructs a new Annotation.
                 * @memberof google.protobuf.GeneratedCodeInfo
                 * @classdesc Represents an Annotation.
                 * @implements IAnnotation
                 * @constructor
                 * @param {google.protobuf.GeneratedCodeInfo.IAnnotation=} [properties] Properties to set
                 */
                function Annotation(properties) {
                    this.path = [];
                    if (properties)
                        for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                            if (properties[keys[i]] != null)
                                this[keys[i]] = properties[keys[i]];
                }

                /**
                 * Annotation path.
                 * @member {Array.<number>} path
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.path = $util.emptyArray;

                /**
                 * Annotation sourceFile.
                 * @member {string} sourceFile
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.sourceFile = "";

                /**
                 * Annotation begin.
                 * @member {number} begin
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.begin = 0;

                /**
                 * Annotation end.
                 * @member {number} end
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 */
                Annotation.prototype.end = 0;

                /**
                 * Verifies an Annotation message.
                 * @function verify
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} message Plain object to verify
                 * @returns {string|null} `null` if valid, otherwise the reason why it is not
                 */
                Annotation.verify = function verify(message) {
                    if (typeof message !== "object" || message === null)
                        return "object expected";
                    if (message.path != null && message.hasOwnProperty("path")) {
                        if (!Array.isArray(message.path))
                            return "path: array expected";
                        for (let i = 0; i < message.path.length; ++i)
                            if (!$util.isInteger(message.path[i]))
                                return "path: integer[] expected";
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        if (!$util.isString(message.sourceFile))
                            return "sourceFile: string expected";
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        if (!$util.isInteger(message.begin))
                            return "begin: integer expected";
                    if (message.end != null && message.hasOwnProperty("end"))
                        if (!$util.isInteger(message.end))
                            return "end: integer expected";
                    return null;
                };

                /**
                 * Creates an Annotation message from a plain object. Also converts values to their respective internal types.
                 * @function fromObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {Object.<string,*>} object Plain object
                 * @returns {google.protobuf.GeneratedCodeInfo.Annotation} Annotation
                 */
                Annotation.fromObject = function fromObject(object) {
                    if (object instanceof $root.google.protobuf.GeneratedCodeInfo.Annotation)
                        return object;
                    let message = new $root.google.protobuf.GeneratedCodeInfo.Annotation();
                    if (object.path) {
                        if (!Array.isArray(object.path))
                            throw TypeError(".google.protobuf.GeneratedCodeInfo.Annotation.path: array expected");
                        message.path = [];
                        for (let i = 0; i < object.path.length; ++i)
                            message.path[i] = object.path[i] | 0;
                    }
                    if (object.sourceFile != null)
                        message.sourceFile = String(object.sourceFile);
                    if (object.begin != null)
                        message.begin = object.begin | 0;
                    if (object.end != null)
                        message.end = object.end | 0;
                    return message;
                };

                /**
                 * Creates a plain object from an Annotation message. Also converts values to other types if specified.
                 * @function toObject
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @static
                 * @param {google.protobuf.GeneratedCodeInfo.Annotation} message Annotation
                 * @param {$protobuf.IConversionOptions} [options] Conversion options
                 * @returns {Object.<string,*>} Plain object
                 */
                Annotation.toObject = function toObject(message, options) {
                    if (!options)
                        options = {};
                    let object = {};
                    if (options.arrays || options.defaults)
                        object.path = [];
                    if (options.defaults) {
                        object.sourceFile = "";
                        object.begin = 0;
                        object.end = 0;
                    }
                    if (message.path && message.path.length) {
                        object.path = [];
                        for (let j = 0; j < message.path.length; ++j)
                            object.path[j] = message.path[j];
                    }
                    if (message.sourceFile != null && message.hasOwnProperty("sourceFile"))
                        object.sourceFile = message.sourceFile;
                    if (message.begin != null && message.hasOwnProperty("begin"))
                        object.begin = message.begin;
                    if (message.end != null && message.hasOwnProperty("end"))
                        object.end = message.end;
                    return object;
                };

                /**
                 * Converts this Annotation to JSON.
                 * @function toJSON
                 * @memberof google.protobuf.GeneratedCodeInfo.Annotation
                 * @instance
                 * @returns {Object.<string,*>} JSON object
                 */
                Annotation.prototype.toJSON = function toJSON() {
                    return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
                };

                return Annotation;
            })();

            return GeneratedCodeInfo;
        })();

        protobuf.Duration = (function() {

            /**
             * Properties of a Duration.
             * @memberof google.protobuf
             * @interface IDuration
             * @property {number|Long|null} [seconds] Duration seconds
             * @property {number|null} [nanos] Duration nanos
             */

            /**
             * Constructs a new Duration.
             * @memberof google.protobuf
             * @classdesc Represents a Duration.
             * @implements IDuration
             * @constructor
             * @param {google.protobuf.IDuration=} [properties] Properties to set
             */
            function Duration(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Duration seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Duration nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Duration
             * @instance
             */
            Duration.prototype.nanos = 0;

            /**
             * Verifies a Duration message.
             * @function verify
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Duration.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Duration message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Duration} Duration
             */
            Duration.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Duration)
                    return object;
                let message = new $root.google.protobuf.Duration();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Duration message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Duration
             * @static
             * @param {google.protobuf.Duration} message Duration
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Duration.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Duration to JSON.
             * @function toJSON
             * @memberof google.protobuf.Duration
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Duration.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Duration;
        })();

        protobuf.Timestamp = (function() {

            /**
             * Properties of a Timestamp.
             * @memberof google.protobuf
             * @interface ITimestamp
             * @property {number|Long|null} [seconds] Timestamp seconds
             * @property {number|null} [nanos] Timestamp nanos
             */

            /**
             * Constructs a new Timestamp.
             * @memberof google.protobuf
             * @classdesc Represents a Timestamp.
             * @implements ITimestamp
             * @constructor
             * @param {google.protobuf.ITimestamp=} [properties] Properties to set
             */
            function Timestamp(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Timestamp seconds.
             * @member {number|Long} seconds
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.seconds = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Timestamp nanos.
             * @member {number} nanos
             * @memberof google.protobuf.Timestamp
             * @instance
             */
            Timestamp.prototype.nanos = 0;

            /**
             * Verifies a Timestamp message.
             * @function verify
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Timestamp.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (!$util.isInteger(message.seconds) && !(message.seconds && $util.isInteger(message.seconds.low) && $util.isInteger(message.seconds.high)))
                        return "seconds: integer|Long expected";
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    if (!$util.isInteger(message.nanos))
                        return "nanos: integer expected";
                return null;
            };

            /**
             * Creates a Timestamp message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Timestamp} Timestamp
             */
            Timestamp.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Timestamp)
                    return object;
                let message = new $root.google.protobuf.Timestamp();
                if (object.seconds != null)
                    if ($util.Long)
                        (message.seconds = $util.Long.fromValue(object.seconds)).unsigned = false;
                    else if (typeof object.seconds === "string")
                        message.seconds = parseInt(object.seconds, 10);
                    else if (typeof object.seconds === "number")
                        message.seconds = object.seconds;
                    else if (typeof object.seconds === "object")
                        message.seconds = new $util.LongBits(object.seconds.low >>> 0, object.seconds.high >>> 0).toNumber();
                if (object.nanos != null)
                    message.nanos = object.nanos | 0;
                return message;
            };

            /**
             * Creates a plain object from a Timestamp message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Timestamp
             * @static
             * @param {google.protobuf.Timestamp} message Timestamp
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Timestamp.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.seconds = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.seconds = options.longs === String ? "0" : 0;
                    object.nanos = 0;
                }
                if (message.seconds != null && message.hasOwnProperty("seconds"))
                    if (typeof message.seconds === "number")
                        object.seconds = options.longs === String ? String(message.seconds) : message.seconds;
                    else
                        object.seconds = options.longs === String ? $util.Long.prototype.toString.call(message.seconds) : options.longs === Number ? new $util.LongBits(message.seconds.low >>> 0, message.seconds.high >>> 0).toNumber() : message.seconds;
                if (message.nanos != null && message.hasOwnProperty("nanos"))
                    object.nanos = message.nanos;
                return object;
            };

            /**
             * Converts this Timestamp to JSON.
             * @function toJSON
             * @memberof google.protobuf.Timestamp
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Timestamp.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Timestamp;
        })();

        protobuf.Any = (function() {

            /**
             * Properties of an Any.
             * @memberof google.protobuf
             * @interface IAny
             * @property {string|null} [type_url] Any type_url
             * @property {Uint8Array|null} [value] Any value
             */

            /**
             * Constructs a new Any.
             * @memberof google.protobuf
             * @classdesc Represents an Any.
             * @implements IAny
             * @constructor
             * @param {google.protobuf.IAny=} [properties] Properties to set
             */
            function Any(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Any type_url.
             * @member {string} type_url
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.type_url = "";

            /**
             * Any value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.Any
             * @instance
             */
            Any.prototype.value = $util.newBuffer([]);

            /**
             * Verifies an Any message.
             * @function verify
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Any.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    if (!$util.isString(message.type_url))
                        return "type_url: string expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates an Any message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Any
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Any} Any
             */
            Any.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Any)
                    return object;
                let message = new $root.google.protobuf.Any();
                if (object.type_url != null)
                    message.type_url = String(object.type_url);
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from an Any message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Any
             * @static
             * @param {google.protobuf.Any} message Any
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Any.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.type_url = "";
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                }
                if (message.type_url != null && message.hasOwnProperty("type_url"))
                    object.type_url = message.type_url;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this Any to JSON.
             * @function toJSON
             * @memberof google.protobuf.Any
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Any.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Any;
        })();

        protobuf.Struct = (function() {

            /**
             * Properties of a Struct.
             * @memberof google.protobuf
             * @interface IStruct
             * @property {Object.<string,google.protobuf.IValue>|null} [fields] Struct fields
             */

            /**
             * Constructs a new Struct.
             * @memberof google.protobuf
             * @classdesc Represents a Struct.
             * @implements IStruct
             * @constructor
             * @param {google.protobuf.IStruct=} [properties] Properties to set
             */
            function Struct(properties) {
                this.fields = {};
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Struct fields.
             * @member {Object.<string,google.protobuf.IValue>} fields
             * @memberof google.protobuf.Struct
             * @instance
             */
            Struct.prototype.fields = $util.emptyObject;

            /**
             * Verifies a Struct message.
             * @function verify
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Struct.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.fields != null && message.hasOwnProperty("fields")) {
                    if (!$util.isObject(message.fields))
                        return "fields: object expected";
                    let key = Object.keys(message.fields);
                    for (let i = 0; i < key.length; ++i) {
                        let error = $root.google.protobuf.Value.verify(message.fields[key[i]]);
                        if (error)
                            return "fields." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Struct message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Struct} Struct
             */
            Struct.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Struct)
                    return object;
                let message = new $root.google.protobuf.Struct();
                if (object.fields) {
                    if (typeof object.fields !== "object")
                        throw TypeError(".google.protobuf.Struct.fields: object expected");
                    message.fields = {};
                    for (let keys = Object.keys(object.fields), i = 0; i < keys.length; ++i) {
                        if (typeof object.fields[keys[i]] !== "object")
                            throw TypeError(".google.protobuf.Struct.fields: object expected");
                        message.fields[keys[i]] = $root.google.protobuf.Value.fromObject(object.fields[keys[i]]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Struct message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Struct
             * @static
             * @param {google.protobuf.Struct} message Struct
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Struct.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.objects || options.defaults)
                    object.fields = {};
                let keys2;
                if (message.fields && (keys2 = Object.keys(message.fields)).length) {
                    object.fields = {};
                    for (let j = 0; j < keys2.length; ++j)
                        object.fields[keys2[j]] = $root.google.protobuf.Value.toObject(message.fields[keys2[j]], options);
                }
                return object;
            };

            /**
             * Converts this Struct to JSON.
             * @function toJSON
             * @memberof google.protobuf.Struct
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Struct.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Struct;
        })();

        protobuf.Value = (function() {

            /**
             * Properties of a Value.
             * @memberof google.protobuf
             * @interface IValue
             * @property {google.protobuf.NullValue|null} [nullValue] Value nullValue
             * @property {number|null} [numberValue] Value numberValue
             * @property {string|null} [stringValue] Value stringValue
             * @property {boolean|null} [boolValue] Value boolValue
             * @property {google.protobuf.IStruct|null} [structValue] Value structValue
             * @property {google.protobuf.IListValue|null} [listValue] Value listValue
             */

            /**
             * Constructs a new Value.
             * @memberof google.protobuf
             * @classdesc Represents a Value.
             * @implements IValue
             * @constructor
             * @param {google.protobuf.IValue=} [properties] Properties to set
             */
            function Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Value nullValue.
             * @member {google.protobuf.NullValue} nullValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.nullValue = 0;

            /**
             * Value numberValue.
             * @member {number} numberValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.numberValue = 0;

            /**
             * Value stringValue.
             * @member {string} stringValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.stringValue = "";

            /**
             * Value boolValue.
             * @member {boolean} boolValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.boolValue = false;

            /**
             * Value structValue.
             * @member {google.protobuf.IStruct|null|undefined} structValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.structValue = null;

            /**
             * Value listValue.
             * @member {google.protobuf.IListValue|null|undefined} listValue
             * @memberof google.protobuf.Value
             * @instance
             */
            Value.prototype.listValue = null;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * Value kind.
             * @member {"nullValue"|"numberValue"|"stringValue"|"boolValue"|"structValue"|"listValue"|undefined} kind
             * @memberof google.protobuf.Value
             * @instance
             */
            Object.defineProperty(Value.prototype, "kind", {
                get: $util.oneOfGetter($oneOfFields = ["nullValue", "numberValue", "stringValue", "boolValue", "structValue", "listValue"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Verifies a Value message.
             * @function verify
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    properties.kind = 1;
                    switch (message.nullValue) {
                    default:
                        return "nullValue: enum value expected";
                    case 0:
                        break;
                    }
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.numberValue !== "number")
                        return "numberValue: number expected";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (!$util.isString(message.stringValue))
                        return "stringValue: string expected";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    if (typeof message.boolValue !== "boolean")
                        return "boolValue: boolean expected";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        let error = $root.google.protobuf.Struct.verify(message.structValue);
                        if (error)
                            return "structValue." + error;
                    }
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    if (properties.kind === 1)
                        return "kind: multiple values";
                    properties.kind = 1;
                    {
                        let error = $root.google.protobuf.ListValue.verify(message.listValue);
                        if (error)
                            return "listValue." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Value} Value
             */
            Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Value)
                    return object;
                let message = new $root.google.protobuf.Value();
                switch (object.nullValue) {
                case "NULL_VALUE":
                case 0:
                    message.nullValue = 0;
                    break;
                }
                if (object.numberValue != null)
                    message.numberValue = Number(object.numberValue);
                if (object.stringValue != null)
                    message.stringValue = String(object.stringValue);
                if (object.boolValue != null)
                    message.boolValue = Boolean(object.boolValue);
                if (object.structValue != null) {
                    if (typeof object.structValue !== "object")
                        throw TypeError(".google.protobuf.Value.structValue: object expected");
                    message.structValue = $root.google.protobuf.Struct.fromObject(object.structValue);
                }
                if (object.listValue != null) {
                    if (typeof object.listValue !== "object")
                        throw TypeError(".google.protobuf.Value.listValue: object expected");
                    message.listValue = $root.google.protobuf.ListValue.fromObject(object.listValue);
                }
                return message;
            };

            /**
             * Creates a plain object from a Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Value
             * @static
             * @param {google.protobuf.Value} message Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (message.nullValue != null && message.hasOwnProperty("nullValue")) {
                    object.nullValue = options.enums === String ? $root.google.protobuf.NullValue[message.nullValue] : message.nullValue;
                    if (options.oneofs)
                        object.kind = "nullValue";
                }
                if (message.numberValue != null && message.hasOwnProperty("numberValue")) {
                    object.numberValue = options.json && !isFinite(message.numberValue) ? String(message.numberValue) : message.numberValue;
                    if (options.oneofs)
                        object.kind = "numberValue";
                }
                if (message.stringValue != null && message.hasOwnProperty("stringValue")) {
                    object.stringValue = message.stringValue;
                    if (options.oneofs)
                        object.kind = "stringValue";
                }
                if (message.boolValue != null && message.hasOwnProperty("boolValue")) {
                    object.boolValue = message.boolValue;
                    if (options.oneofs)
                        object.kind = "boolValue";
                }
                if (message.structValue != null && message.hasOwnProperty("structValue")) {
                    object.structValue = $root.google.protobuf.Struct.toObject(message.structValue, options);
                    if (options.oneofs)
                        object.kind = "structValue";
                }
                if (message.listValue != null && message.hasOwnProperty("listValue")) {
                    object.listValue = $root.google.protobuf.ListValue.toObject(message.listValue, options);
                    if (options.oneofs)
                        object.kind = "listValue";
                }
                return object;
            };

            /**
             * Converts this Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Value;
        })();

        /**
         * NullValue enum.
         * @name google.protobuf.NullValue
         * @enum {number}
         * @property {number} NULL_VALUE=0 NULL_VALUE value
         */
        protobuf.NullValue = (function() {
            const valuesById = {}, values = Object.create(valuesById);
            values[valuesById[0] = "NULL_VALUE"] = 0;
            return values;
        })();

        protobuf.ListValue = (function() {

            /**
             * Properties of a ListValue.
             * @memberof google.protobuf
             * @interface IListValue
             * @property {Array.<google.protobuf.IValue>|null} [values] ListValue values
             */

            /**
             * Constructs a new ListValue.
             * @memberof google.protobuf
             * @classdesc Represents a ListValue.
             * @implements IListValue
             * @constructor
             * @param {google.protobuf.IListValue=} [properties] Properties to set
             */
            function ListValue(properties) {
                this.values = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * ListValue values.
             * @member {Array.<google.protobuf.IValue>} values
             * @memberof google.protobuf.ListValue
             * @instance
             */
            ListValue.prototype.values = $util.emptyArray;

            /**
             * Verifies a ListValue message.
             * @function verify
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            ListValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.values != null && message.hasOwnProperty("values")) {
                    if (!Array.isArray(message.values))
                        return "values: array expected";
                    for (let i = 0; i < message.values.length; ++i) {
                        let error = $root.google.protobuf.Value.verify(message.values[i]);
                        if (error)
                            return "values." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a ListValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.ListValue} ListValue
             */
            ListValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.ListValue)
                    return object;
                let message = new $root.google.protobuf.ListValue();
                if (object.values) {
                    if (!Array.isArray(object.values))
                        throw TypeError(".google.protobuf.ListValue.values: array expected");
                    message.values = [];
                    for (let i = 0; i < object.values.length; ++i) {
                        if (typeof object.values[i] !== "object")
                            throw TypeError(".google.protobuf.ListValue.values: object expected");
                        message.values[i] = $root.google.protobuf.Value.fromObject(object.values[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a ListValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.ListValue
             * @static
             * @param {google.protobuf.ListValue} message ListValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            ListValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.values = [];
                if (message.values && message.values.length) {
                    object.values = [];
                    for (let j = 0; j < message.values.length; ++j)
                        object.values[j] = $root.google.protobuf.Value.toObject(message.values[j], options);
                }
                return object;
            };

            /**
             * Converts this ListValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.ListValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            ListValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return ListValue;
        })();

        protobuf.DoubleValue = (function() {

            /**
             * Properties of a DoubleValue.
             * @memberof google.protobuf
             * @interface IDoubleValue
             * @property {number|null} [value] DoubleValue value
             */

            /**
             * Constructs a new DoubleValue.
             * @memberof google.protobuf
             * @classdesc Represents a DoubleValue.
             * @implements IDoubleValue
             * @constructor
             * @param {google.protobuf.IDoubleValue=} [properties] Properties to set
             */
            function DoubleValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * DoubleValue value.
             * @member {number} value
             * @memberof google.protobuf.DoubleValue
             * @instance
             */
            DoubleValue.prototype.value = 0;

            /**
             * Verifies a DoubleValue message.
             * @function verify
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            DoubleValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a DoubleValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.DoubleValue} DoubleValue
             */
            DoubleValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.DoubleValue)
                    return object;
                let message = new $root.google.protobuf.DoubleValue();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a DoubleValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.DoubleValue
             * @static
             * @param {google.protobuf.DoubleValue} message DoubleValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            DoubleValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this DoubleValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.DoubleValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            DoubleValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return DoubleValue;
        })();

        protobuf.FloatValue = (function() {

            /**
             * Properties of a FloatValue.
             * @memberof google.protobuf
             * @interface IFloatValue
             * @property {number|null} [value] FloatValue value
             */

            /**
             * Constructs a new FloatValue.
             * @memberof google.protobuf
             * @classdesc Represents a FloatValue.
             * @implements IFloatValue
             * @constructor
             * @param {google.protobuf.IFloatValue=} [properties] Properties to set
             */
            function FloatValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * FloatValue value.
             * @member {number} value
             * @memberof google.protobuf.FloatValue
             * @instance
             */
            FloatValue.prototype.value = 0;

            /**
             * Verifies a FloatValue message.
             * @function verify
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            FloatValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "number")
                        return "value: number expected";
                return null;
            };

            /**
             * Creates a FloatValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.FloatValue} FloatValue
             */
            FloatValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.FloatValue)
                    return object;
                let message = new $root.google.protobuf.FloatValue();
                if (object.value != null)
                    message.value = Number(object.value);
                return message;
            };

            /**
             * Creates a plain object from a FloatValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.FloatValue
             * @static
             * @param {google.protobuf.FloatValue} message FloatValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            FloatValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.json && !isFinite(message.value) ? String(message.value) : message.value;
                return object;
            };

            /**
             * Converts this FloatValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.FloatValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            FloatValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return FloatValue;
        })();

        protobuf.Int64Value = (function() {

            /**
             * Properties of an Int64Value.
             * @memberof google.protobuf
             * @interface IInt64Value
             * @property {number|Long|null} [value] Int64Value value
             */

            /**
             * Constructs a new Int64Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int64Value.
             * @implements IInt64Value
             * @constructor
             * @param {google.protobuf.IInt64Value=} [properties] Properties to set
             */
            function Int64Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Int64Value value.
             * @member {number|Long} value
             * @memberof google.protobuf.Int64Value
             * @instance
             */
            Int64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,false) : 0;

            /**
             * Verifies an Int64Value message.
             * @function verify
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Int64Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates an Int64Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Int64Value} Int64Value
             */
            Int64Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Int64Value)
                    return object;
                let message = new $root.google.protobuf.Int64Value();
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = false;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber();
                return message;
            };

            /**
             * Creates a plain object from an Int64Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Int64Value
             * @static
             * @param {google.protobuf.Int64Value} message Int64Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Int64Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, false);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber() : message.value;
                return object;
            };

            /**
             * Converts this Int64Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Int64Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Int64Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Int64Value;
        })();

        protobuf.UInt64Value = (function() {

            /**
             * Properties of a UInt64Value.
             * @memberof google.protobuf
             * @interface IUInt64Value
             * @property {number|Long|null} [value] UInt64Value value
             */

            /**
             * Constructs a new UInt64Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt64Value.
             * @implements IUInt64Value
             * @constructor
             * @param {google.protobuf.IUInt64Value=} [properties] Properties to set
             */
            function UInt64Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UInt64Value value.
             * @member {number|Long} value
             * @memberof google.protobuf.UInt64Value
             * @instance
             */
            UInt64Value.prototype.value = $util.Long ? $util.Long.fromBits(0,0,true) : 0;

            /**
             * Verifies a UInt64Value message.
             * @function verify
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UInt64Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value) && !(message.value && $util.isInteger(message.value.low) && $util.isInteger(message.value.high)))
                        return "value: integer|Long expected";
                return null;
            };

            /**
             * Creates a UInt64Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UInt64Value} UInt64Value
             */
            UInt64Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UInt64Value)
                    return object;
                let message = new $root.google.protobuf.UInt64Value();
                if (object.value != null)
                    if ($util.Long)
                        (message.value = $util.Long.fromValue(object.value)).unsigned = true;
                    else if (typeof object.value === "string")
                        message.value = parseInt(object.value, 10);
                    else if (typeof object.value === "number")
                        message.value = object.value;
                    else if (typeof object.value === "object")
                        message.value = new $util.LongBits(object.value.low >>> 0, object.value.high >>> 0).toNumber(true);
                return message;
            };

            /**
             * Creates a plain object from a UInt64Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UInt64Value
             * @static
             * @param {google.protobuf.UInt64Value} message UInt64Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UInt64Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if ($util.Long) {
                        let long = new $util.Long(0, 0, true);
                        object.value = options.longs === String ? long.toString() : options.longs === Number ? long.toNumber() : long;
                    } else
                        object.value = options.longs === String ? "0" : 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value === "number")
                        object.value = options.longs === String ? String(message.value) : message.value;
                    else
                        object.value = options.longs === String ? $util.Long.prototype.toString.call(message.value) : options.longs === Number ? new $util.LongBits(message.value.low >>> 0, message.value.high >>> 0).toNumber(true) : message.value;
                return object;
            };

            /**
             * Converts this UInt64Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.UInt64Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UInt64Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UInt64Value;
        })();

        protobuf.Int32Value = (function() {

            /**
             * Properties of an Int32Value.
             * @memberof google.protobuf
             * @interface IInt32Value
             * @property {number|null} [value] Int32Value value
             */

            /**
             * Constructs a new Int32Value.
             * @memberof google.protobuf
             * @classdesc Represents an Int32Value.
             * @implements IInt32Value
             * @constructor
             * @param {google.protobuf.IInt32Value=} [properties] Properties to set
             */
            function Int32Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Int32Value value.
             * @member {number} value
             * @memberof google.protobuf.Int32Value
             * @instance
             */
            Int32Value.prototype.value = 0;

            /**
             * Verifies an Int32Value message.
             * @function verify
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Int32Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates an Int32Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.Int32Value} Int32Value
             */
            Int32Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.Int32Value)
                    return object;
                let message = new $root.google.protobuf.Int32Value();
                if (object.value != null)
                    message.value = object.value | 0;
                return message;
            };

            /**
             * Creates a plain object from an Int32Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.Int32Value
             * @static
             * @param {google.protobuf.Int32Value} message Int32Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Int32Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this Int32Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.Int32Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Int32Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Int32Value;
        })();

        protobuf.UInt32Value = (function() {

            /**
             * Properties of a UInt32Value.
             * @memberof google.protobuf
             * @interface IUInt32Value
             * @property {number|null} [value] UInt32Value value
             */

            /**
             * Constructs a new UInt32Value.
             * @memberof google.protobuf
             * @classdesc Represents a UInt32Value.
             * @implements IUInt32Value
             * @constructor
             * @param {google.protobuf.IUInt32Value=} [properties] Properties to set
             */
            function UInt32Value(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * UInt32Value value.
             * @member {number} value
             * @memberof google.protobuf.UInt32Value
             * @instance
             */
            UInt32Value.prototype.value = 0;

            /**
             * Verifies a UInt32Value message.
             * @function verify
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            UInt32Value.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isInteger(message.value))
                        return "value: integer expected";
                return null;
            };

            /**
             * Creates a UInt32Value message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.UInt32Value} UInt32Value
             */
            UInt32Value.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.UInt32Value)
                    return object;
                let message = new $root.google.protobuf.UInt32Value();
                if (object.value != null)
                    message.value = object.value >>> 0;
                return message;
            };

            /**
             * Creates a plain object from a UInt32Value message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.UInt32Value
             * @static
             * @param {google.protobuf.UInt32Value} message UInt32Value
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            UInt32Value.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = 0;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this UInt32Value to JSON.
             * @function toJSON
             * @memberof google.protobuf.UInt32Value
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            UInt32Value.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return UInt32Value;
        })();

        protobuf.BoolValue = (function() {

            /**
             * Properties of a BoolValue.
             * @memberof google.protobuf
             * @interface IBoolValue
             * @property {boolean|null} [value] BoolValue value
             */

            /**
             * Constructs a new BoolValue.
             * @memberof google.protobuf
             * @classdesc Represents a BoolValue.
             * @implements IBoolValue
             * @constructor
             * @param {google.protobuf.IBoolValue=} [properties] Properties to set
             */
            function BoolValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BoolValue value.
             * @member {boolean} value
             * @memberof google.protobuf.BoolValue
             * @instance
             */
            BoolValue.prototype.value = false;

            /**
             * Verifies a BoolValue message.
             * @function verify
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BoolValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (typeof message.value !== "boolean")
                        return "value: boolean expected";
                return null;
            };

            /**
             * Creates a BoolValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.BoolValue} BoolValue
             */
            BoolValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.BoolValue)
                    return object;
                let message = new $root.google.protobuf.BoolValue();
                if (object.value != null)
                    message.value = Boolean(object.value);
                return message;
            };

            /**
             * Creates a plain object from a BoolValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.BoolValue
             * @static
             * @param {google.protobuf.BoolValue} message BoolValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BoolValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = false;
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this BoolValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.BoolValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BoolValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BoolValue;
        })();

        protobuf.StringValue = (function() {

            /**
             * Properties of a StringValue.
             * @memberof google.protobuf
             * @interface IStringValue
             * @property {string|null} [value] StringValue value
             */

            /**
             * Constructs a new StringValue.
             * @memberof google.protobuf
             * @classdesc Represents a StringValue.
             * @implements IStringValue
             * @constructor
             * @param {google.protobuf.IStringValue=} [properties] Properties to set
             */
            function StringValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * StringValue value.
             * @member {string} value
             * @memberof google.protobuf.StringValue
             * @instance
             */
            StringValue.prototype.value = "";

            /**
             * Verifies a StringValue message.
             * @function verify
             * @memberof google.protobuf.StringValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            StringValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!$util.isString(message.value))
                        return "value: string expected";
                return null;
            };

            /**
             * Creates a StringValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.StringValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.StringValue} StringValue
             */
            StringValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.StringValue)
                    return object;
                let message = new $root.google.protobuf.StringValue();
                if (object.value != null)
                    message.value = String(object.value);
                return message;
            };

            /**
             * Creates a plain object from a StringValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.StringValue
             * @static
             * @param {google.protobuf.StringValue} message StringValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            StringValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    object.value = "";
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = message.value;
                return object;
            };

            /**
             * Converts this StringValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.StringValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            StringValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return StringValue;
        })();

        protobuf.BytesValue = (function() {

            /**
             * Properties of a BytesValue.
             * @memberof google.protobuf
             * @interface IBytesValue
             * @property {Uint8Array|null} [value] BytesValue value
             */

            /**
             * Constructs a new BytesValue.
             * @memberof google.protobuf
             * @classdesc Represents a BytesValue.
             * @implements IBytesValue
             * @constructor
             * @param {google.protobuf.IBytesValue=} [properties] Properties to set
             */
            function BytesValue(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * BytesValue value.
             * @member {Uint8Array} value
             * @memberof google.protobuf.BytesValue
             * @instance
             */
            BytesValue.prototype.value = $util.newBuffer([]);

            /**
             * Verifies a BytesValue message.
             * @function verify
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            BytesValue.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.value != null && message.hasOwnProperty("value"))
                    if (!(message.value && typeof message.value.length === "number" || $util.isString(message.value)))
                        return "value: buffer expected";
                return null;
            };

            /**
             * Creates a BytesValue message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.protobuf.BytesValue} BytesValue
             */
            BytesValue.fromObject = function fromObject(object) {
                if (object instanceof $root.google.protobuf.BytesValue)
                    return object;
                let message = new $root.google.protobuf.BytesValue();
                if (object.value != null)
                    if (typeof object.value === "string")
                        $util.base64.decode(object.value, message.value = $util.newBuffer($util.base64.length(object.value)), 0);
                    else if (object.value.length)
                        message.value = object.value;
                return message;
            };

            /**
             * Creates a plain object from a BytesValue message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.protobuf.BytesValue
             * @static
             * @param {google.protobuf.BytesValue} message BytesValue
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            BytesValue.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults)
                    if (options.bytes === String)
                        object.value = "";
                    else {
                        object.value = [];
                        if (options.bytes !== Array)
                            object.value = $util.newBuffer(object.value);
                    }
                if (message.value != null && message.hasOwnProperty("value"))
                    object.value = options.bytes === String ? $util.base64.encode(message.value, 0, message.value.length) : options.bytes === Array ? Array.prototype.slice.call(message.value) : message.value;
                return object;
            };

            /**
             * Converts this BytesValue to JSON.
             * @function toJSON
             * @memberof google.protobuf.BytesValue
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            BytesValue.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return BytesValue;
        })();

        return protobuf;
    })();

    google.api = (function() {

        /**
         * Namespace api.
         * @memberof google
         * @namespace
         */
        const api = {};

        api.Http = (function() {

            /**
             * Properties of a Http.
             * @memberof google.api
             * @interface IHttp
             * @property {Array.<google.api.IHttpRule>|null} [rules] Http rules
             * @property {boolean|null} [fullyDecodeReservedExpansion] Http fullyDecodeReservedExpansion
             */

            /**
             * Constructs a new Http.
             * @memberof google.api
             * @classdesc Represents a Http.
             * @implements IHttp
             * @constructor
             * @param {google.api.IHttp=} [properties] Properties to set
             */
            function Http(properties) {
                this.rules = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Http rules.
             * @member {Array.<google.api.IHttpRule>} rules
             * @memberof google.api.Http
             * @instance
             */
            Http.prototype.rules = $util.emptyArray;

            /**
             * Http fullyDecodeReservedExpansion.
             * @member {boolean} fullyDecodeReservedExpansion
             * @memberof google.api.Http
             * @instance
             */
            Http.prototype.fullyDecodeReservedExpansion = false;

            /**
             * Verifies a Http message.
             * @function verify
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Http.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.rules != null && message.hasOwnProperty("rules")) {
                    if (!Array.isArray(message.rules))
                        return "rules: array expected";
                    for (let i = 0; i < message.rules.length; ++i) {
                        let error = $root.google.api.HttpRule.verify(message.rules[i]);
                        if (error)
                            return "rules." + error;
                    }
                }
                if (message.fullyDecodeReservedExpansion != null && message.hasOwnProperty("fullyDecodeReservedExpansion"))
                    if (typeof message.fullyDecodeReservedExpansion !== "boolean")
                        return "fullyDecodeReservedExpansion: boolean expected";
                return null;
            };

            /**
             * Creates a Http message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.Http
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.Http} Http
             */
            Http.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.Http)
                    return object;
                let message = new $root.google.api.Http();
                if (object.rules) {
                    if (!Array.isArray(object.rules))
                        throw TypeError(".google.api.Http.rules: array expected");
                    message.rules = [];
                    for (let i = 0; i < object.rules.length; ++i) {
                        if (typeof object.rules[i] !== "object")
                            throw TypeError(".google.api.Http.rules: object expected");
                        message.rules[i] = $root.google.api.HttpRule.fromObject(object.rules[i]);
                    }
                }
                if (object.fullyDecodeReservedExpansion != null)
                    message.fullyDecodeReservedExpansion = Boolean(object.fullyDecodeReservedExpansion);
                return message;
            };

            /**
             * Creates a plain object from a Http message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.Http
             * @static
             * @param {google.api.Http} message Http
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Http.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.rules = [];
                if (options.defaults)
                    object.fullyDecodeReservedExpansion = false;
                if (message.rules && message.rules.length) {
                    object.rules = [];
                    for (let j = 0; j < message.rules.length; ++j)
                        object.rules[j] = $root.google.api.HttpRule.toObject(message.rules[j], options);
                }
                if (message.fullyDecodeReservedExpansion != null && message.hasOwnProperty("fullyDecodeReservedExpansion"))
                    object.fullyDecodeReservedExpansion = message.fullyDecodeReservedExpansion;
                return object;
            };

            /**
             * Converts this Http to JSON.
             * @function toJSON
             * @memberof google.api.Http
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Http.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Http;
        })();

        api.HttpRule = (function() {

            /**
             * Properties of a HttpRule.
             * @memberof google.api
             * @interface IHttpRule
             * @property {string|null} [selector] HttpRule selector
             * @property {string|null} [get] HttpRule get
             * @property {string|null} [put] HttpRule put
             * @property {string|null} [post] HttpRule post
             * @property {string|null} ["delete"] HttpRule delete
             * @property {string|null} [patch] HttpRule patch
             * @property {google.api.ICustomHttpPattern|null} [custom] HttpRule custom
             * @property {string|null} [body] HttpRule body
             * @property {string|null} [responseBody] HttpRule responseBody
             * @property {Array.<google.api.IHttpRule>|null} [additionalBindings] HttpRule additionalBindings
             */

            /**
             * Constructs a new HttpRule.
             * @memberof google.api
             * @classdesc Represents a HttpRule.
             * @implements IHttpRule
             * @constructor
             * @param {google.api.IHttpRule=} [properties] Properties to set
             */
            function HttpRule(properties) {
                this.additionalBindings = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * HttpRule selector.
             * @member {string} selector
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.selector = "";

            /**
             * HttpRule get.
             * @member {string} get
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.get = "";

            /**
             * HttpRule put.
             * @member {string} put
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.put = "";

            /**
             * HttpRule post.
             * @member {string} post
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.post = "";

            /**
             * HttpRule delete.
             * @member {string} delete
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype["delete"] = "";

            /**
             * HttpRule patch.
             * @member {string} patch
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.patch = "";

            /**
             * HttpRule custom.
             * @member {google.api.ICustomHttpPattern|null|undefined} custom
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.custom = null;

            /**
             * HttpRule body.
             * @member {string} body
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.body = "";

            /**
             * HttpRule responseBody.
             * @member {string} responseBody
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.responseBody = "";

            /**
             * HttpRule additionalBindings.
             * @member {Array.<google.api.IHttpRule>} additionalBindings
             * @memberof google.api.HttpRule
             * @instance
             */
            HttpRule.prototype.additionalBindings = $util.emptyArray;

            // OneOf field names bound to virtual getters and setters
            let $oneOfFields;

            /**
             * HttpRule pattern.
             * @member {"get"|"put"|"post"|"delete"|"patch"|"custom"|undefined} pattern
             * @memberof google.api.HttpRule
             * @instance
             */
            Object.defineProperty(HttpRule.prototype, "pattern", {
                get: $util.oneOfGetter($oneOfFields = ["get", "put", "post", "delete", "patch", "custom"]),
                set: $util.oneOfSetter($oneOfFields)
            });

            /**
             * Verifies a HttpRule message.
             * @function verify
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            HttpRule.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                let properties = {};
                if (message.selector != null && message.hasOwnProperty("selector"))
                    if (!$util.isString(message.selector))
                        return "selector: string expected";
                if (message.get != null && message.hasOwnProperty("get")) {
                    properties.pattern = 1;
                    if (!$util.isString(message.get))
                        return "get: string expected";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.put))
                        return "put: string expected";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.post))
                        return "post: string expected";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message["delete"]))
                        return "delete: string expected";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    if (!$util.isString(message.patch))
                        return "patch: string expected";
                }
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    if (properties.pattern === 1)
                        return "pattern: multiple values";
                    properties.pattern = 1;
                    {
                        let error = $root.google.api.CustomHttpPattern.verify(message.custom);
                        if (error)
                            return "custom." + error;
                    }
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    if (!$util.isString(message.body))
                        return "body: string expected";
                if (message.responseBody != null && message.hasOwnProperty("responseBody"))
                    if (!$util.isString(message.responseBody))
                        return "responseBody: string expected";
                if (message.additionalBindings != null && message.hasOwnProperty("additionalBindings")) {
                    if (!Array.isArray(message.additionalBindings))
                        return "additionalBindings: array expected";
                    for (let i = 0; i < message.additionalBindings.length; ++i) {
                        let error = $root.google.api.HttpRule.verify(message.additionalBindings[i]);
                        if (error)
                            return "additionalBindings." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a HttpRule message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.HttpRule
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.HttpRule} HttpRule
             */
            HttpRule.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.HttpRule)
                    return object;
                let message = new $root.google.api.HttpRule();
                if (object.selector != null)
                    message.selector = String(object.selector);
                if (object.get != null)
                    message.get = String(object.get);
                if (object.put != null)
                    message.put = String(object.put);
                if (object.post != null)
                    message.post = String(object.post);
                if (object["delete"] != null)
                    message["delete"] = String(object["delete"]);
                if (object.patch != null)
                    message.patch = String(object.patch);
                if (object.custom != null) {
                    if (typeof object.custom !== "object")
                        throw TypeError(".google.api.HttpRule.custom: object expected");
                    message.custom = $root.google.api.CustomHttpPattern.fromObject(object.custom);
                }
                if (object.body != null)
                    message.body = String(object.body);
                if (object.responseBody != null)
                    message.responseBody = String(object.responseBody);
                if (object.additionalBindings) {
                    if (!Array.isArray(object.additionalBindings))
                        throw TypeError(".google.api.HttpRule.additionalBindings: array expected");
                    message.additionalBindings = [];
                    for (let i = 0; i < object.additionalBindings.length; ++i) {
                        if (typeof object.additionalBindings[i] !== "object")
                            throw TypeError(".google.api.HttpRule.additionalBindings: object expected");
                        message.additionalBindings[i] = $root.google.api.HttpRule.fromObject(object.additionalBindings[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a HttpRule message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.HttpRule
             * @static
             * @param {google.api.HttpRule} message HttpRule
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            HttpRule.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.additionalBindings = [];
                if (options.defaults) {
                    object.selector = "";
                    object.body = "";
                    object.responseBody = "";
                }
                if (message.selector != null && message.hasOwnProperty("selector"))
                    object.selector = message.selector;
                if (message.get != null && message.hasOwnProperty("get")) {
                    object.get = message.get;
                    if (options.oneofs)
                        object.pattern = "get";
                }
                if (message.put != null && message.hasOwnProperty("put")) {
                    object.put = message.put;
                    if (options.oneofs)
                        object.pattern = "put";
                }
                if (message.post != null && message.hasOwnProperty("post")) {
                    object.post = message.post;
                    if (options.oneofs)
                        object.pattern = "post";
                }
                if (message["delete"] != null && message.hasOwnProperty("delete")) {
                    object["delete"] = message["delete"];
                    if (options.oneofs)
                        object.pattern = "delete";
                }
                if (message.patch != null && message.hasOwnProperty("patch")) {
                    object.patch = message.patch;
                    if (options.oneofs)
                        object.pattern = "patch";
                }
                if (message.body != null && message.hasOwnProperty("body"))
                    object.body = message.body;
                if (message.custom != null && message.hasOwnProperty("custom")) {
                    object.custom = $root.google.api.CustomHttpPattern.toObject(message.custom, options);
                    if (options.oneofs)
                        object.pattern = "custom";
                }
                if (message.additionalBindings && message.additionalBindings.length) {
                    object.additionalBindings = [];
                    for (let j = 0; j < message.additionalBindings.length; ++j)
                        object.additionalBindings[j] = $root.google.api.HttpRule.toObject(message.additionalBindings[j], options);
                }
                if (message.responseBody != null && message.hasOwnProperty("responseBody"))
                    object.responseBody = message.responseBody;
                return object;
            };

            /**
             * Converts this HttpRule to JSON.
             * @function toJSON
             * @memberof google.api.HttpRule
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            HttpRule.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return HttpRule;
        })();

        api.CustomHttpPattern = (function() {

            /**
             * Properties of a CustomHttpPattern.
             * @memberof google.api
             * @interface ICustomHttpPattern
             * @property {string|null} [kind] CustomHttpPattern kind
             * @property {string|null} [path] CustomHttpPattern path
             */

            /**
             * Constructs a new CustomHttpPattern.
             * @memberof google.api
             * @classdesc Represents a CustomHttpPattern.
             * @implements ICustomHttpPattern
             * @constructor
             * @param {google.api.ICustomHttpPattern=} [properties] Properties to set
             */
            function CustomHttpPattern(properties) {
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * CustomHttpPattern kind.
             * @member {string} kind
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.kind = "";

            /**
             * CustomHttpPattern path.
             * @member {string} path
             * @memberof google.api.CustomHttpPattern
             * @instance
             */
            CustomHttpPattern.prototype.path = "";

            /**
             * Verifies a CustomHttpPattern message.
             * @function verify
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            CustomHttpPattern.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.kind != null && message.hasOwnProperty("kind"))
                    if (!$util.isString(message.kind))
                        return "kind: string expected";
                if (message.path != null && message.hasOwnProperty("path"))
                    if (!$util.isString(message.path))
                        return "path: string expected";
                return null;
            };

            /**
             * Creates a CustomHttpPattern message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.api.CustomHttpPattern} CustomHttpPattern
             */
            CustomHttpPattern.fromObject = function fromObject(object) {
                if (object instanceof $root.google.api.CustomHttpPattern)
                    return object;
                let message = new $root.google.api.CustomHttpPattern();
                if (object.kind != null)
                    message.kind = String(object.kind);
                if (object.path != null)
                    message.path = String(object.path);
                return message;
            };

            /**
             * Creates a plain object from a CustomHttpPattern message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.api.CustomHttpPattern
             * @static
             * @param {google.api.CustomHttpPattern} message CustomHttpPattern
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            CustomHttpPattern.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.defaults) {
                    object.kind = "";
                    object.path = "";
                }
                if (message.kind != null && message.hasOwnProperty("kind"))
                    object.kind = message.kind;
                if (message.path != null && message.hasOwnProperty("path"))
                    object.path = message.path;
                return object;
            };

            /**
             * Converts this CustomHttpPattern to JSON.
             * @function toJSON
             * @memberof google.api.CustomHttpPattern
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            CustomHttpPattern.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return CustomHttpPattern;
        })();

        return api;
    })();

    google.rpc = (function() {

        /**
         * Namespace rpc.
         * @memberof google
         * @namespace
         */
        const rpc = {};

        rpc.Status = (function() {

            /**
             * Properties of a Status.
             * @memberof google.rpc
             * @interface IStatus
             * @property {number|null} [code] Status code
             * @property {string|null} [message] Status message
             * @property {Array.<google.protobuf.IAny>|null} [details] Status details
             */

            /**
             * Constructs a new Status.
             * @memberof google.rpc
             * @classdesc Represents a Status.
             * @implements IStatus
             * @constructor
             * @param {google.rpc.IStatus=} [properties] Properties to set
             */
            function Status(properties) {
                this.details = [];
                if (properties)
                    for (let keys = Object.keys(properties), i = 0; i < keys.length; ++i)
                        if (properties[keys[i]] != null)
                            this[keys[i]] = properties[keys[i]];
            }

            /**
             * Status code.
             * @member {number} code
             * @memberof google.rpc.Status
             * @instance
             */
            Status.prototype.code = 0;

            /**
             * Status message.
             * @member {string} message
             * @memberof google.rpc.Status
             * @instance
             */
            Status.prototype.message = "";

            /**
             * Status details.
             * @member {Array.<google.protobuf.IAny>} details
             * @memberof google.rpc.Status
             * @instance
             */
            Status.prototype.details = $util.emptyArray;

            /**
             * Verifies a Status message.
             * @function verify
             * @memberof google.rpc.Status
             * @static
             * @param {Object.<string,*>} message Plain object to verify
             * @returns {string|null} `null` if valid, otherwise the reason why it is not
             */
            Status.verify = function verify(message) {
                if (typeof message !== "object" || message === null)
                    return "object expected";
                if (message.code != null && message.hasOwnProperty("code"))
                    if (!$util.isInteger(message.code))
                        return "code: integer expected";
                if (message.message != null && message.hasOwnProperty("message"))
                    if (!$util.isString(message.message))
                        return "message: string expected";
                if (message.details != null && message.hasOwnProperty("details")) {
                    if (!Array.isArray(message.details))
                        return "details: array expected";
                    for (let i = 0; i < message.details.length; ++i) {
                        let error = $root.google.protobuf.Any.verify(message.details[i]);
                        if (error)
                            return "details." + error;
                    }
                }
                return null;
            };

            /**
             * Creates a Status message from a plain object. Also converts values to their respective internal types.
             * @function fromObject
             * @memberof google.rpc.Status
             * @static
             * @param {Object.<string,*>} object Plain object
             * @returns {google.rpc.Status} Status
             */
            Status.fromObject = function fromObject(object) {
                if (object instanceof $root.google.rpc.Status)
                    return object;
                let message = new $root.google.rpc.Status();
                if (object.code != null)
                    message.code = object.code | 0;
                if (object.message != null)
                    message.message = String(object.message);
                if (object.details) {
                    if (!Array.isArray(object.details))
                        throw TypeError(".google.rpc.Status.details: array expected");
                    message.details = [];
                    for (let i = 0; i < object.details.length; ++i) {
                        if (typeof object.details[i] !== "object")
                            throw TypeError(".google.rpc.Status.details: object expected");
                        message.details[i] = $root.google.protobuf.Any.fromObject(object.details[i]);
                    }
                }
                return message;
            };

            /**
             * Creates a plain object from a Status message. Also converts values to other types if specified.
             * @function toObject
             * @memberof google.rpc.Status
             * @static
             * @param {google.rpc.Status} message Status
             * @param {$protobuf.IConversionOptions} [options] Conversion options
             * @returns {Object.<string,*>} Plain object
             */
            Status.toObject = function toObject(message, options) {
                if (!options)
                    options = {};
                let object = {};
                if (options.arrays || options.defaults)
                    object.details = [];
                if (options.defaults) {
                    object.code = 0;
                    object.message = "";
                }
                if (message.code != null && message.hasOwnProperty("code"))
                    object.code = message.code;
                if (message.message != null && message.hasOwnProperty("message"))
                    object.message = message.message;
                if (message.details && message.details.length) {
                    object.details = [];
                    for (let j = 0; j < message.details.length; ++j)
                        object.details[j] = $root.google.protobuf.Any.toObject(message.details[j], options);
                }
                return object;
            };

            /**
             * Converts this Status to JSON.
             * @function toJSON
             * @memberof google.rpc.Status
             * @instance
             * @returns {Object.<string,*>} JSON object
             */
            Status.prototype.toJSON = function toJSON() {
                return this.constructor.toObject(this, $protobuf.util.toJSONOptions);
            };

            return Status;
        })();

        return rpc;
    })();

    return google;
})();

export { $root as default };
