// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: k8s/v1/k8s.proto

package k8sv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	structpb "google.golang.org/protobuf/types/known/structpb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}

	_ = structpb.NullValue(0)
)

// Validate checks the field values on DescribePodRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DescribePodRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DescribePodRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DescribePodRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DescribePodRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := DescribePodRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DescribePodRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DescribePodRequestMultiError(errors)
	}
	return nil
}

// DescribePodRequestMultiError is an error wrapping multiple validation errors
// returned by DescribePodRequest.Validate(true) if the designated constraints
// aren't met.
type DescribePodRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribePodRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribePodRequestMultiError) AllErrors() []error { return m }

// DescribePodRequestValidationError is the validation error returned by
// DescribePodRequest.Validate if the designated constraints aren't met.
type DescribePodRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribePodRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribePodRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribePodRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribePodRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribePodRequestValidationError) ErrorName() string {
	return "DescribePodRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DescribePodRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribePodRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribePodRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribePodRequestValidationError{}

// Validate checks the field values on DescribePodResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DescribePodResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DescribePodResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetPod()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = DescribePodResponseValidationError{
				field:  "Pod",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return DescribePodResponseMultiError(errors)
	}
	return nil
}

// DescribePodResponseMultiError is an error wrapping multiple validation
// errors returned by DescribePodResponse.Validate(true) if the designated
// constraints aren't met.
type DescribePodResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribePodResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribePodResponseMultiError) AllErrors() []error { return m }

// DescribePodResponseValidationError is the validation error returned by
// DescribePodResponse.Validate if the designated constraints aren't met.
type DescribePodResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribePodResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribePodResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribePodResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribePodResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribePodResponseValidationError) ErrorName() string {
	return "DescribePodResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DescribePodResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribePodResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribePodResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribePodResponseValidationError{}

// Validate checks the field values on Container with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// ContainerMultiError, or nil if none found. Otherwise, only the first error
// is returned, if any.
func (m *Container) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	// no validation rules for Image

	// no validation rules for State

	// no validation rules for Ready

	// no validation rules for RestartCount

	switch m.StateDetails.(type) {

	case *Container_StateWaiting:

		if v, ok := interface{}(m.GetStateWaiting()).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ContainerValidationError{
					field:  "StateWaiting",
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	case *Container_StateRunning:

		if v, ok := interface{}(m.GetStateRunning()).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ContainerValidationError{
					field:  "StateRunning",
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	case *Container_StateTerminated:

		if v, ok := interface{}(m.GetStateTerminated()).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ContainerValidationError{
					field:  "StateTerminated",
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ContainerMultiError(errors)
	}
	return nil
}

// ContainerMultiError is an error wrapping multiple validation errors returned
// by Container.Validate(true) if the designated constraints aren't met.
type ContainerMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ContainerMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ContainerMultiError) AllErrors() []error { return m }

// ContainerValidationError is the validation error returned by
// Container.Validate if the designated constraints aren't met.
type ContainerValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ContainerValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ContainerValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ContainerValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ContainerValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ContainerValidationError) ErrorName() string { return "ContainerValidationError" }

// Error satisfies the builtin error interface
func (e ContainerValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sContainer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ContainerValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ContainerValidationError{}

// Validate checks the field values on StateWaiting with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// StateWaitingMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *StateWaiting) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Reason

	// no validation rules for Message

	if len(errors) > 0 {
		return StateWaitingMultiError(errors)
	}
	return nil
}

// StateWaitingMultiError is an error wrapping multiple validation errors
// returned by StateWaiting.Validate(true) if the designated constraints
// aren't met.
type StateWaitingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StateWaitingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StateWaitingMultiError) AllErrors() []error { return m }

// StateWaitingValidationError is the validation error returned by
// StateWaiting.Validate if the designated constraints aren't met.
type StateWaitingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StateWaitingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StateWaitingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StateWaitingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StateWaitingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StateWaitingValidationError) ErrorName() string { return "StateWaitingValidationError" }

// Error satisfies the builtin error interface
func (e StateWaitingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStateWaiting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StateWaitingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StateWaitingValidationError{}

// Validate checks the field values on StateRunning with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// StateRunningMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *StateRunning) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetStartTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = StateRunningValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return StateRunningMultiError(errors)
	}
	return nil
}

// StateRunningMultiError is an error wrapping multiple validation errors
// returned by StateRunning.Validate(true) if the designated constraints
// aren't met.
type StateRunningMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StateRunningMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StateRunningMultiError) AllErrors() []error { return m }

// StateRunningValidationError is the validation error returned by
// StateRunning.Validate if the designated constraints aren't met.
type StateRunningValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StateRunningValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StateRunningValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StateRunningValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StateRunningValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StateRunningValidationError) ErrorName() string { return "StateRunningValidationError" }

// Error satisfies the builtin error interface
func (e StateRunningValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStateRunning.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StateRunningValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StateRunningValidationError{}

// Validate checks the field values on StateTerminated with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in StateTerminatedMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *StateTerminated) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Reason

	// no validation rules for Message

	// no validation rules for ExitCode

	// no validation rules for Signal

	if len(errors) > 0 {
		return StateTerminatedMultiError(errors)
	}
	return nil
}

// StateTerminatedMultiError is an error wrapping multiple validation errors
// returned by StateTerminated.Validate(true) if the designated constraints
// aren't met.
type StateTerminatedMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StateTerminatedMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StateTerminatedMultiError) AllErrors() []error { return m }

// StateTerminatedValidationError is the validation error returned by
// StateTerminated.Validate if the designated constraints aren't met.
type StateTerminatedValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StateTerminatedValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StateTerminatedValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StateTerminatedValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StateTerminatedValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StateTerminatedValidationError) ErrorName() string { return "StateTerminatedValidationError" }

// Error satisfies the builtin error interface
func (e StateTerminatedValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStateTerminated.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StateTerminatedValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StateTerminatedValidationError{}

// Validate checks the field values on PodCondition with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// PodConditionMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *PodCondition) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Status

	if len(errors) > 0 {
		return PodConditionMultiError(errors)
	}
	return nil
}

// PodConditionMultiError is an error wrapping multiple validation errors
// returned by PodCondition.Validate(true) if the designated constraints
// aren't met.
type PodConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PodConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PodConditionMultiError) AllErrors() []error { return m }

// PodConditionValidationError is the validation error returned by
// PodCondition.Validate if the designated constraints aren't met.
type PodConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PodConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PodConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PodConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PodConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PodConditionValidationError) ErrorName() string { return "PodConditionValidationError" }

// Error satisfies the builtin error interface
func (e PodConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPodCondition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PodConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PodConditionValidationError{}

// Validate checks the field values on Pod with the rules defined in the proto
// definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// PodMultiError, or nil if none found. Otherwise, only the first error is
// returned, if any.
func (m *Pod) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cluster

	// no validation rules for Namespace

	// no validation rules for Name

	for idx, item := range m.GetContainers() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = PodValidationError{
					field:  fmt.Sprintf("Containers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for NodeIp

	// no validation rules for PodIp

	// no validation rules for State

	if v, ok := interface{}(m.GetStartTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = PodValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	// no validation rules for Labels

	// no validation rules for Annotations

	// no validation rules for StateReason

	for idx, item := range m.GetPodConditions() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = PodValidationError{
					field:  fmt.Sprintf("PodConditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	for idx, item := range m.GetInitContainers() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = PodValidationError{
					field:  fmt.Sprintf("InitContainers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for Status

	if len(errors) > 0 {
		return PodMultiError(errors)
	}
	return nil
}

// PodMultiError is an error wrapping multiple validation errors returned by
// Pod.Validate(true) if the designated constraints aren't met.
type PodMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PodMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PodMultiError) AllErrors() []error { return m }

// PodValidationError is the validation error returned by Pod.Validate if the
// designated constraints aren't met.
type PodValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PodValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PodValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PodValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PodValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PodValidationError) ErrorName() string { return "PodValidationError" }

// Error satisfies the builtin error interface
func (e PodValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPod.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PodValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PodValidationError{}

// Validate checks the field values on ListOptions with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// ListOptionsMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *ListOptions) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Labels

	// no validation rules for SupplementalSelectorString

	if len(errors) > 0 {
		return ListOptionsMultiError(errors)
	}
	return nil
}

// ListOptionsMultiError is an error wrapping multiple validation errors
// returned by ListOptions.Validate(true) if the designated constraints aren't met.
type ListOptionsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListOptionsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListOptionsMultiError) AllErrors() []error { return m }

// ListOptionsValidationError is the validation error returned by
// ListOptions.Validate if the designated constraints aren't met.
type ListOptionsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListOptionsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListOptionsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListOptionsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListOptionsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListOptionsValidationError) ErrorName() string { return "ListOptionsValidationError" }

// Error satisfies the builtin error interface
func (e ListOptionsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListOptions.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListOptionsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListOptionsValidationError{}

// Validate checks the field values on ListPodsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in ListPodsRequestMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *ListPodsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := ListPodsRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := ListPodsRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := ListPodsRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOptions() == nil {
		err := ListPodsRequestValidationError{
			field:  "Options",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetOptions()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListPodsRequestValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return ListPodsRequestMultiError(errors)
	}
	return nil
}

// ListPodsRequestMultiError is an error wrapping multiple validation errors
// returned by ListPodsRequest.Validate(true) if the designated constraints
// aren't met.
type ListPodsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPodsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPodsRequestMultiError) AllErrors() []error { return m }

// ListPodsRequestValidationError is the validation error returned by
// ListPodsRequest.Validate if the designated constraints aren't met.
type ListPodsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPodsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPodsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPodsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPodsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPodsRequestValidationError) ErrorName() string { return "ListPodsRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListPodsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPodsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPodsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPodsRequestValidationError{}

// Validate checks the field values on ListPodsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in ListPodsResponseMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *ListPodsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPods() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListPodsResponseValidationError{
					field:  fmt.Sprintf("Pods[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListPodsResponseMultiError(errors)
	}
	return nil
}

// ListPodsResponseMultiError is an error wrapping multiple validation errors
// returned by ListPodsResponse.Validate(true) if the designated constraints
// aren't met.
type ListPodsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPodsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPodsResponseMultiError) AllErrors() []error { return m }

// ListPodsResponseValidationError is the validation error returned by
// ListPodsResponse.Validate if the designated constraints aren't met.
type ListPodsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPodsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPodsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPodsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPodsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPodsResponseValidationError) ErrorName() string { return "ListPodsResponseValidationError" }

// Error satisfies the builtin error interface
func (e ListPodsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPodsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPodsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPodsResponseValidationError{}

// Validate checks the field values on DeletePodRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in DeletePodRequestMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *DeletePodRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DeletePodRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DeletePodRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := DeletePodRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DeletePodRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeletePodRequestMultiError(errors)
	}
	return nil
}

// DeletePodRequestMultiError is an error wrapping multiple validation errors
// returned by DeletePodRequest.Validate(true) if the designated constraints
// aren't met.
type DeletePodRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePodRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePodRequestMultiError) AllErrors() []error { return m }

// DeletePodRequestValidationError is the validation error returned by
// DeletePodRequest.Validate if the designated constraints aren't met.
type DeletePodRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePodRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePodRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePodRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePodRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePodRequestValidationError) ErrorName() string { return "DeletePodRequestValidationError" }

// Error satisfies the builtin error interface
func (e DeletePodRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePodRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePodRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePodRequestValidationError{}

// Validate checks the field values on DeletePodResponse with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in DeletePodResponseMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *DeletePodResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeletePodResponseMultiError(errors)
	}
	return nil
}

// DeletePodResponseMultiError is an error wrapping multiple validation errors
// returned by DeletePodResponse.Validate(true) if the designated constraints
// aren't met.
type DeletePodResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePodResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePodResponseMultiError) AllErrors() []error { return m }

// DeletePodResponseValidationError is the validation error returned by
// DeletePodResponse.Validate if the designated constraints aren't met.
type DeletePodResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePodResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePodResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePodResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePodResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePodResponseValidationError) ErrorName() string {
	return "DeletePodResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePodResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePodResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePodResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePodResponseValidationError{}

// Validate checks the field values on UpdatePodRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in UpdatePodRequestMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *UpdatePodRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := UpdatePodRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := UpdatePodRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := UpdatePodRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := UpdatePodRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetExpectedObjectMetaFields()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = UpdatePodRequestValidationError{
				field:  "ExpectedObjectMetaFields",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetObjectMetaFields()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = UpdatePodRequestValidationError{
				field:  "ObjectMetaFields",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetRemoveObjectMetaFields()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = UpdatePodRequestValidationError{
				field:  "RemoveObjectMetaFields",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return UpdatePodRequestMultiError(errors)
	}
	return nil
}

// UpdatePodRequestMultiError is an error wrapping multiple validation errors
// returned by UpdatePodRequest.Validate(true) if the designated constraints
// aren't met.
type UpdatePodRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePodRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePodRequestMultiError) AllErrors() []error { return m }

// UpdatePodRequestValidationError is the validation error returned by
// UpdatePodRequest.Validate if the designated constraints aren't met.
type UpdatePodRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePodRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePodRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePodRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePodRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePodRequestValidationError) ErrorName() string { return "UpdatePodRequestValidationError" }

// Error satisfies the builtin error interface
func (e UpdatePodRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePodRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePodRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePodRequestValidationError{}

// Validate checks the field values on UpdatePodResponse with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in UpdatePodResponseMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *UpdatePodResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdatePodResponseMultiError(errors)
	}
	return nil
}

// UpdatePodResponseMultiError is an error wrapping multiple validation errors
// returned by UpdatePodResponse.Validate(true) if the designated constraints
// aren't met.
type UpdatePodResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePodResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePodResponseMultiError) AllErrors() []error { return m }

// UpdatePodResponseValidationError is the validation error returned by
// UpdatePodResponse.Validate if the designated constraints aren't met.
type UpdatePodResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePodResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePodResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePodResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePodResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePodResponseValidationError) ErrorName() string {
	return "UpdatePodResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePodResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePodResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePodResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePodResponseValidationError{}

// Validate checks the field values on HPA with the rules defined in the proto
// definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// HPAMultiError, or nil if none found. Otherwise, only the first error is
// returned, if any.
func (m *HPA) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cluster

	// no validation rules for Namespace

	// no validation rules for Name

	if v, ok := interface{}(m.GetSizing()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = HPAValidationError{
				field:  "Sizing",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	// no validation rules for Labels

	// no validation rules for Annotations

	if len(errors) > 0 {
		return HPAMultiError(errors)
	}
	return nil
}

// HPAMultiError is an error wrapping multiple validation errors returned by
// HPA.Validate(true) if the designated constraints aren't met.
type HPAMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HPAMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HPAMultiError) AllErrors() []error { return m }

// HPAValidationError is the validation error returned by HPA.Validate if the
// designated constraints aren't met.
type HPAValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HPAValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HPAValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HPAValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HPAValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HPAValidationError) ErrorName() string { return "HPAValidationError" }

// Error satisfies the builtin error interface
func (e HPAValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHPA.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HPAValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HPAValidationError{}

// Validate checks the field values on ResizeHPARequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in ResizeHPARequestMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *ResizeHPARequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := ResizeHPARequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := ResizeHPARequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := ResizeHPARequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := ResizeHPARequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSizing() == nil {
		err := ResizeHPARequestValidationError{
			field:  "Sizing",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetSizing()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ResizeHPARequestValidationError{
				field:  "Sizing",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return ResizeHPARequestMultiError(errors)
	}
	return nil
}

// ResizeHPARequestMultiError is an error wrapping multiple validation errors
// returned by ResizeHPARequest.Validate(true) if the designated constraints
// aren't met.
type ResizeHPARequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResizeHPARequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResizeHPARequestMultiError) AllErrors() []error { return m }

// ResizeHPARequestValidationError is the validation error returned by
// ResizeHPARequest.Validate if the designated constraints aren't met.
type ResizeHPARequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResizeHPARequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResizeHPARequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResizeHPARequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResizeHPARequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResizeHPARequestValidationError) ErrorName() string { return "ResizeHPARequestValidationError" }

// Error satisfies the builtin error interface
func (e ResizeHPARequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResizeHPARequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResizeHPARequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResizeHPARequestValidationError{}

// Validate checks the field values on ResizeHPAResponse with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in ResizeHPAResponseMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *ResizeHPAResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ResizeHPAResponseMultiError(errors)
	}
	return nil
}

// ResizeHPAResponseMultiError is an error wrapping multiple validation errors
// returned by ResizeHPAResponse.Validate(true) if the designated constraints
// aren't met.
type ResizeHPAResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResizeHPAResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResizeHPAResponseMultiError) AllErrors() []error { return m }

// ResizeHPAResponseValidationError is the validation error returned by
// ResizeHPAResponse.Validate if the designated constraints aren't met.
type ResizeHPAResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResizeHPAResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResizeHPAResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResizeHPAResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResizeHPAResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResizeHPAResponseValidationError) ErrorName() string {
	return "ResizeHPAResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ResizeHPAResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResizeHPAResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResizeHPAResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResizeHPAResponseValidationError{}

// Validate checks the field values on DeleteHPARequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in DeleteHPARequestMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *DeleteHPARequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DeleteHPARequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DeleteHPARequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := DeleteHPARequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DeleteHPARequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteHPARequestMultiError(errors)
	}
	return nil
}

// DeleteHPARequestMultiError is an error wrapping multiple validation errors
// returned by DeleteHPARequest.Validate(true) if the designated constraints
// aren't met.
type DeleteHPARequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteHPARequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteHPARequestMultiError) AllErrors() []error { return m }

// DeleteHPARequestValidationError is the validation error returned by
// DeleteHPARequest.Validate if the designated constraints aren't met.
type DeleteHPARequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteHPARequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteHPARequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteHPARequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteHPARequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteHPARequestValidationError) ErrorName() string { return "DeleteHPARequestValidationError" }

// Error satisfies the builtin error interface
func (e DeleteHPARequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteHPARequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteHPARequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteHPARequestValidationError{}

// Validate checks the field values on DeleteHPAResponse with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in DeleteHPAResponseMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *DeleteHPAResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteHPAResponseMultiError(errors)
	}
	return nil
}

// DeleteHPAResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteHPAResponse.Validate(true) if the designated constraints
// aren't met.
type DeleteHPAResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteHPAResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteHPAResponseMultiError) AllErrors() []error { return m }

// DeleteHPAResponseValidationError is the validation error returned by
// DeleteHPAResponse.Validate if the designated constraints aren't met.
type DeleteHPAResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteHPAResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteHPAResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteHPAResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteHPAResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteHPAResponseValidationError) ErrorName() string {
	return "DeleteHPAResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteHPAResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteHPAResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteHPAResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteHPAResponseValidationError{}

// Validate checks the field values on Deployment with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// DeploymentMultiError, or nil if none found. Otherwise, only the first error
// is returned, if any.
func (m *Deployment) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cluster

	// no validation rules for Namespace

	// no validation rules for Name

	// no validation rules for Labels

	// no validation rules for Annotations

	if v, ok := interface{}(m.GetDeploymentStatus()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = DeploymentValidationError{
				field:  "DeploymentStatus",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return DeploymentMultiError(errors)
	}
	return nil
}

// DeploymentMultiError is an error wrapping multiple validation errors
// returned by Deployment.Validate(true) if the designated constraints aren't met.
type DeploymentMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeploymentMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeploymentMultiError) AllErrors() []error { return m }

// DeploymentValidationError is the validation error returned by
// Deployment.Validate if the designated constraints aren't met.
type DeploymentValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeploymentValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeploymentValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeploymentValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeploymentValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeploymentValidationError) ErrorName() string { return "DeploymentValidationError" }

// Error satisfies the builtin error interface
func (e DeploymentValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeployment.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeploymentValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeploymentValidationError{}

// Validate checks the field values on DescribeDeploymentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DescribeDeploymentRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *DescribeDeploymentRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DescribeDeploymentRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DescribeDeploymentRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := DescribeDeploymentRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DescribeDeploymentRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DescribeDeploymentRequestMultiError(errors)
	}
	return nil
}

// DescribeDeploymentRequestMultiError is an error wrapping multiple validation
// errors returned by DescribeDeploymentRequest.Validate(true) if the
// designated constraints aren't met.
type DescribeDeploymentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribeDeploymentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribeDeploymentRequestMultiError) AllErrors() []error { return m }

// DescribeDeploymentRequestValidationError is the validation error returned by
// DescribeDeploymentRequest.Validate if the designated constraints aren't met.
type DescribeDeploymentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribeDeploymentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribeDeploymentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribeDeploymentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribeDeploymentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribeDeploymentRequestValidationError) ErrorName() string {
	return "DescribeDeploymentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DescribeDeploymentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribeDeploymentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribeDeploymentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribeDeploymentRequestValidationError{}

// Validate checks the field values on DescribeDeploymentResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DescribeDeploymentResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *DescribeDeploymentResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetDeployment()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = DescribeDeploymentResponseValidationError{
				field:  "Deployment",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return DescribeDeploymentResponseMultiError(errors)
	}
	return nil
}

// DescribeDeploymentResponseMultiError is an error wrapping multiple
// validation errors returned by DescribeDeploymentResponse.Validate(true) if
// the designated constraints aren't met.
type DescribeDeploymentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribeDeploymentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribeDeploymentResponseMultiError) AllErrors() []error { return m }

// DescribeDeploymentResponseValidationError is the validation error returned
// by DescribeDeploymentResponse.Validate if the designated constraints aren't met.
type DescribeDeploymentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribeDeploymentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribeDeploymentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribeDeploymentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribeDeploymentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribeDeploymentResponseValidationError) ErrorName() string {
	return "DescribeDeploymentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DescribeDeploymentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribeDeploymentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribeDeploymentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribeDeploymentResponseValidationError{}

// Validate checks the field values on ListDeploymentsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListDeploymentsRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListDeploymentsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := ListDeploymentsRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := ListDeploymentsRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := ListDeploymentsRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOptions() == nil {
		err := ListDeploymentsRequestValidationError{
			field:  "Options",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetOptions()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListDeploymentsRequestValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return ListDeploymentsRequestMultiError(errors)
	}
	return nil
}

// ListDeploymentsRequestMultiError is an error wrapping multiple validation
// errors returned by ListDeploymentsRequest.Validate(true) if the designated
// constraints aren't met.
type ListDeploymentsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDeploymentsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDeploymentsRequestMultiError) AllErrors() []error { return m }

// ListDeploymentsRequestValidationError is the validation error returned by
// ListDeploymentsRequest.Validate if the designated constraints aren't met.
type ListDeploymentsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDeploymentsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDeploymentsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDeploymentsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDeploymentsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDeploymentsRequestValidationError) ErrorName() string {
	return "ListDeploymentsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListDeploymentsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDeploymentsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDeploymentsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDeploymentsRequestValidationError{}

// Validate checks the field values on ListDeploymentsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListDeploymentsResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListDeploymentsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDeployments() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListDeploymentsResponseValidationError{
					field:  fmt.Sprintf("Deployments[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListDeploymentsResponseMultiError(errors)
	}
	return nil
}

// ListDeploymentsResponseMultiError is an error wrapping multiple validation
// errors returned by ListDeploymentsResponse.Validate(true) if the designated
// constraints aren't met.
type ListDeploymentsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListDeploymentsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListDeploymentsResponseMultiError) AllErrors() []error { return m }

// ListDeploymentsResponseValidationError is the validation error returned by
// ListDeploymentsResponse.Validate if the designated constraints aren't met.
type ListDeploymentsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListDeploymentsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListDeploymentsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListDeploymentsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListDeploymentsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListDeploymentsResponseValidationError) ErrorName() string {
	return "ListDeploymentsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListDeploymentsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListDeploymentsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListDeploymentsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListDeploymentsResponseValidationError{}

// Validate checks the field values on UpdateDeploymentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateDeploymentRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UpdateDeploymentRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := UpdateDeploymentRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := UpdateDeploymentRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := UpdateDeploymentRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := UpdateDeploymentRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetFields() == nil {
		err := UpdateDeploymentRequestValidationError{
			field:  "Fields",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetFields()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = UpdateDeploymentRequestValidationError{
				field:  "Fields",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return UpdateDeploymentRequestMultiError(errors)
	}
	return nil
}

// UpdateDeploymentRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateDeploymentRequest.Validate(true) if the designated
// constraints aren't met.
type UpdateDeploymentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeploymentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeploymentRequestMultiError) AllErrors() []error { return m }

// UpdateDeploymentRequestValidationError is the validation error returned by
// UpdateDeploymentRequest.Validate if the designated constraints aren't met.
type UpdateDeploymentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeploymentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeploymentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeploymentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeploymentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeploymentRequestValidationError) ErrorName() string {
	return "UpdateDeploymentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeploymentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeploymentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeploymentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeploymentRequestValidationError{}

// Validate checks the field values on UpdateDeploymentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateDeploymentResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UpdateDeploymentResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateDeploymentResponseMultiError(errors)
	}
	return nil
}

// UpdateDeploymentResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateDeploymentResponse.Validate(true) if the
// designated constraints aren't met.
type UpdateDeploymentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeploymentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeploymentResponseMultiError) AllErrors() []error { return m }

// UpdateDeploymentResponseValidationError is the validation error returned by
// UpdateDeploymentResponse.Validate if the designated constraints aren't met.
type UpdateDeploymentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeploymentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeploymentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeploymentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeploymentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeploymentResponseValidationError) ErrorName() string {
	return "UpdateDeploymentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeploymentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeploymentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeploymentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeploymentResponseValidationError{}

// Validate checks the field values on DeleteDeploymentRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DeleteDeploymentRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DeleteDeploymentRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DeleteDeploymentRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DeleteDeploymentRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := DeleteDeploymentRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DeleteDeploymentRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteDeploymentRequestMultiError(errors)
	}
	return nil
}

// DeleteDeploymentRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteDeploymentRequest.Validate(true) if the designated
// constraints aren't met.
type DeleteDeploymentRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDeploymentRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDeploymentRequestMultiError) AllErrors() []error { return m }

// DeleteDeploymentRequestValidationError is the validation error returned by
// DeleteDeploymentRequest.Validate if the designated constraints aren't met.
type DeleteDeploymentRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDeploymentRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDeploymentRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDeploymentRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDeploymentRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDeploymentRequestValidationError) ErrorName() string {
	return "DeleteDeploymentRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDeploymentRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDeploymentRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDeploymentRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDeploymentRequestValidationError{}

// Validate checks the field values on DeleteDeploymentResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DeleteDeploymentResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DeleteDeploymentResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteDeploymentResponseMultiError(errors)
	}
	return nil
}

// DeleteDeploymentResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteDeploymentResponse.Validate(true) if the
// designated constraints aren't met.
type DeleteDeploymentResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteDeploymentResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteDeploymentResponseMultiError) AllErrors() []error { return m }

// DeleteDeploymentResponseValidationError is the validation error returned by
// DeleteDeploymentResponse.Validate if the designated constraints aren't met.
type DeleteDeploymentResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteDeploymentResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteDeploymentResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteDeploymentResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteDeploymentResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteDeploymentResponseValidationError) ErrorName() string {
	return "DeleteDeploymentResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteDeploymentResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteDeploymentResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteDeploymentResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteDeploymentResponseValidationError{}

// Validate checks the field values on StatefulSet with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// StatefulSetMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *StatefulSet) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cluster

	// no validation rules for Namespace

	// no validation rules for Name

	// no validation rules for Labels

	// no validation rules for Annotations

	if len(errors) > 0 {
		return StatefulSetMultiError(errors)
	}
	return nil
}

// StatefulSetMultiError is an error wrapping multiple validation errors
// returned by StatefulSet.Validate(true) if the designated constraints aren't met.
type StatefulSetMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StatefulSetMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StatefulSetMultiError) AllErrors() []error { return m }

// StatefulSetValidationError is the validation error returned by
// StatefulSet.Validate if the designated constraints aren't met.
type StatefulSetValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StatefulSetValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StatefulSetValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StatefulSetValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StatefulSetValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StatefulSetValidationError) ErrorName() string { return "StatefulSetValidationError" }

// Error satisfies the builtin error interface
func (e StatefulSetValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStatefulSet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StatefulSetValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StatefulSetValidationError{}

// Validate checks the field values on DescribeStatefulSetRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DescribeStatefulSetRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *DescribeStatefulSetRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DescribeStatefulSetRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DescribeStatefulSetRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := DescribeStatefulSetRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DescribeStatefulSetRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DescribeStatefulSetRequestMultiError(errors)
	}
	return nil
}

// DescribeStatefulSetRequestMultiError is an error wrapping multiple
// validation errors returned by DescribeStatefulSetRequest.Validate(true) if
// the designated constraints aren't met.
type DescribeStatefulSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribeStatefulSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribeStatefulSetRequestMultiError) AllErrors() []error { return m }

// DescribeStatefulSetRequestValidationError is the validation error returned
// by DescribeStatefulSetRequest.Validate if the designated constraints aren't met.
type DescribeStatefulSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribeStatefulSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribeStatefulSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribeStatefulSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribeStatefulSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribeStatefulSetRequestValidationError) ErrorName() string {
	return "DescribeStatefulSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DescribeStatefulSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribeStatefulSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribeStatefulSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribeStatefulSetRequestValidationError{}

// Validate checks the field values on DescribeStatefulSetResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DescribeStatefulSetResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *DescribeStatefulSetResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetStatefulSet()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = DescribeStatefulSetResponseValidationError{
				field:  "StatefulSet",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return DescribeStatefulSetResponseMultiError(errors)
	}
	return nil
}

// DescribeStatefulSetResponseMultiError is an error wrapping multiple
// validation errors returned by DescribeStatefulSetResponse.Validate(true) if
// the designated constraints aren't met.
type DescribeStatefulSetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribeStatefulSetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribeStatefulSetResponseMultiError) AllErrors() []error { return m }

// DescribeStatefulSetResponseValidationError is the validation error returned
// by DescribeStatefulSetResponse.Validate if the designated constraints
// aren't met.
type DescribeStatefulSetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribeStatefulSetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribeStatefulSetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribeStatefulSetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribeStatefulSetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribeStatefulSetResponseValidationError) ErrorName() string {
	return "DescribeStatefulSetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DescribeStatefulSetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribeStatefulSetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribeStatefulSetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribeStatefulSetResponseValidationError{}

// Validate checks the field values on ListStatefulSetsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListStatefulSetsRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListStatefulSetsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := ListStatefulSetsRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := ListStatefulSetsRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := ListStatefulSetsRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOptions() == nil {
		err := ListStatefulSetsRequestValidationError{
			field:  "Options",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetOptions()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListStatefulSetsRequestValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return ListStatefulSetsRequestMultiError(errors)
	}
	return nil
}

// ListStatefulSetsRequestMultiError is an error wrapping multiple validation
// errors returned by ListStatefulSetsRequest.Validate(true) if the designated
// constraints aren't met.
type ListStatefulSetsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListStatefulSetsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListStatefulSetsRequestMultiError) AllErrors() []error { return m }

// ListStatefulSetsRequestValidationError is the validation error returned by
// ListStatefulSetsRequest.Validate if the designated constraints aren't met.
type ListStatefulSetsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListStatefulSetsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListStatefulSetsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListStatefulSetsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListStatefulSetsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListStatefulSetsRequestValidationError) ErrorName() string {
	return "ListStatefulSetsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListStatefulSetsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListStatefulSetsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListStatefulSetsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListStatefulSetsRequestValidationError{}

// Validate checks the field values on ListStatefulSetsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListStatefulSetsResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListStatefulSetsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetStatefulSets() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListStatefulSetsResponseValidationError{
					field:  fmt.Sprintf("StatefulSets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListStatefulSetsResponseMultiError(errors)
	}
	return nil
}

// ListStatefulSetsResponseMultiError is an error wrapping multiple validation
// errors returned by ListStatefulSetsResponse.Validate(true) if the
// designated constraints aren't met.
type ListStatefulSetsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListStatefulSetsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListStatefulSetsResponseMultiError) AllErrors() []error { return m }

// ListStatefulSetsResponseValidationError is the validation error returned by
// ListStatefulSetsResponse.Validate if the designated constraints aren't met.
type ListStatefulSetsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListStatefulSetsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListStatefulSetsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListStatefulSetsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListStatefulSetsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListStatefulSetsResponseValidationError) ErrorName() string {
	return "ListStatefulSetsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListStatefulSetsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListStatefulSetsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListStatefulSetsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListStatefulSetsResponseValidationError{}

// Validate checks the field values on DeleteStatefulSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DeleteStatefulSetRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DeleteStatefulSetRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DeleteStatefulSetRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DeleteStatefulSetRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := DeleteStatefulSetRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DeleteStatefulSetRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteStatefulSetRequestMultiError(errors)
	}
	return nil
}

// DeleteStatefulSetRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteStatefulSetRequest.Validate(true) if the
// designated constraints aren't met.
type DeleteStatefulSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteStatefulSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteStatefulSetRequestMultiError) AllErrors() []error { return m }

// DeleteStatefulSetRequestValidationError is the validation error returned by
// DeleteStatefulSetRequest.Validate if the designated constraints aren't met.
type DeleteStatefulSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteStatefulSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteStatefulSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteStatefulSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteStatefulSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteStatefulSetRequestValidationError) ErrorName() string {
	return "DeleteStatefulSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteStatefulSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteStatefulSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteStatefulSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteStatefulSetRequestValidationError{}

// Validate checks the field values on DeleteStatefulSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DeleteStatefulSetResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *DeleteStatefulSetResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteStatefulSetResponseMultiError(errors)
	}
	return nil
}

// DeleteStatefulSetResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteStatefulSetResponse.Validate(true) if the
// designated constraints aren't met.
type DeleteStatefulSetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteStatefulSetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteStatefulSetResponseMultiError) AllErrors() []error { return m }

// DeleteStatefulSetResponseValidationError is the validation error returned by
// DeleteStatefulSetResponse.Validate if the designated constraints aren't met.
type DeleteStatefulSetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteStatefulSetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteStatefulSetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteStatefulSetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteStatefulSetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteStatefulSetResponseValidationError) ErrorName() string {
	return "DeleteStatefulSetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteStatefulSetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteStatefulSetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteStatefulSetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteStatefulSetResponseValidationError{}

// Validate checks the field values on UpdateStatefulSetRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateStatefulSetRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UpdateStatefulSetRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := UpdateStatefulSetRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := UpdateStatefulSetRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := UpdateStatefulSetRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := UpdateStatefulSetRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetFields() == nil {
		err := UpdateStatefulSetRequestValidationError{
			field:  "Fields",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetFields()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = UpdateStatefulSetRequestValidationError{
				field:  "Fields",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return UpdateStatefulSetRequestMultiError(errors)
	}
	return nil
}

// UpdateStatefulSetRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateStatefulSetRequest.Validate(true) if the
// designated constraints aren't met.
type UpdateStatefulSetRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateStatefulSetRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateStatefulSetRequestMultiError) AllErrors() []error { return m }

// UpdateStatefulSetRequestValidationError is the validation error returned by
// UpdateStatefulSetRequest.Validate if the designated constraints aren't met.
type UpdateStatefulSetRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateStatefulSetRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateStatefulSetRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateStatefulSetRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateStatefulSetRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateStatefulSetRequestValidationError) ErrorName() string {
	return "UpdateStatefulSetRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateStatefulSetRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateStatefulSetRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateStatefulSetRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateStatefulSetRequestValidationError{}

// Validate checks the field values on UpdateStatefulSetResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateStatefulSetResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UpdateStatefulSetResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return UpdateStatefulSetResponseMultiError(errors)
	}
	return nil
}

// UpdateStatefulSetResponseMultiError is an error wrapping multiple validation
// errors returned by UpdateStatefulSetResponse.Validate(true) if the
// designated constraints aren't met.
type UpdateStatefulSetResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateStatefulSetResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateStatefulSetResponseMultiError) AllErrors() []error { return m }

// UpdateStatefulSetResponseValidationError is the validation error returned by
// UpdateStatefulSetResponse.Validate if the designated constraints aren't met.
type UpdateStatefulSetResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateStatefulSetResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateStatefulSetResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateStatefulSetResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateStatefulSetResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateStatefulSetResponseValidationError) ErrorName() string {
	return "UpdateStatefulSetResponseValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateStatefulSetResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateStatefulSetResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateStatefulSetResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateStatefulSetResponseValidationError{}

// Validate checks the field values on Service with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// ServiceMultiError, or nil if none found. Otherwise, only the first error is
// returned, if any.
func (m *Service) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cluster

	// no validation rules for Namespace

	// no validation rules for Name

	// no validation rules for Type

	// no validation rules for Labels

	// no validation rules for Annotations

	if len(errors) > 0 {
		return ServiceMultiError(errors)
	}
	return nil
}

// ServiceMultiError is an error wrapping multiple validation errors returned
// by Service.Validate(true) if the designated constraints aren't met.
type ServiceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ServiceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ServiceMultiError) AllErrors() []error { return m }

// ServiceValidationError is the validation error returned by Service.Validate
// if the designated constraints aren't met.
type ServiceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ServiceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ServiceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ServiceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ServiceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ServiceValidationError) ErrorName() string { return "ServiceValidationError" }

// Error satisfies the builtin error interface
func (e ServiceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sService.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ServiceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ServiceValidationError{}

// Validate checks the field values on DescribeServiceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DescribeServiceRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DescribeServiceRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DescribeServiceRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DescribeServiceRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := DescribeServiceRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DescribeServiceRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DescribeServiceRequestMultiError(errors)
	}
	return nil
}

// DescribeServiceRequestMultiError is an error wrapping multiple validation
// errors returned by DescribeServiceRequest.Validate(true) if the designated
// constraints aren't met.
type DescribeServiceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribeServiceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribeServiceRequestMultiError) AllErrors() []error { return m }

// DescribeServiceRequestValidationError is the validation error returned by
// DescribeServiceRequest.Validate if the designated constraints aren't met.
type DescribeServiceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribeServiceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribeServiceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribeServiceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribeServiceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribeServiceRequestValidationError) ErrorName() string {
	return "DescribeServiceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DescribeServiceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribeServiceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribeServiceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribeServiceRequestValidationError{}

// Validate checks the field values on DescribeServiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DescribeServiceResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DescribeServiceResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetService()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = DescribeServiceResponseValidationError{
				field:  "Service",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return DescribeServiceResponseMultiError(errors)
	}
	return nil
}

// DescribeServiceResponseMultiError is an error wrapping multiple validation
// errors returned by DescribeServiceResponse.Validate(true) if the designated
// constraints aren't met.
type DescribeServiceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribeServiceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribeServiceResponseMultiError) AllErrors() []error { return m }

// DescribeServiceResponseValidationError is the validation error returned by
// DescribeServiceResponse.Validate if the designated constraints aren't met.
type DescribeServiceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribeServiceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribeServiceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribeServiceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribeServiceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribeServiceResponseValidationError) ErrorName() string {
	return "DescribeServiceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DescribeServiceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribeServiceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribeServiceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribeServiceResponseValidationError{}

// Validate checks the field values on DeleteServiceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DeleteServiceRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DeleteServiceRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DeleteServiceRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DeleteServiceRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := DeleteServiceRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DeleteServiceRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteServiceRequestMultiError(errors)
	}
	return nil
}

// DeleteServiceRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteServiceRequest.Validate(true) if the designated
// constraints aren't met.
type DeleteServiceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteServiceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteServiceRequestMultiError) AllErrors() []error { return m }

// DeleteServiceRequestValidationError is the validation error returned by
// DeleteServiceRequest.Validate if the designated constraints aren't met.
type DeleteServiceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteServiceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteServiceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteServiceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteServiceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteServiceRequestValidationError) ErrorName() string {
	return "DeleteServiceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteServiceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteServiceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteServiceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteServiceRequestValidationError{}

// Validate checks the field values on DeleteServiceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DeleteServiceResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DeleteServiceResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteServiceResponseMultiError(errors)
	}
	return nil
}

// DeleteServiceResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteServiceResponse.Validate(true) if the designated
// constraints aren't met.
type DeleteServiceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteServiceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteServiceResponseMultiError) AllErrors() []error { return m }

// DeleteServiceResponseValidationError is the validation error returned by
// DeleteServiceResponse.Validate if the designated constraints aren't met.
type DeleteServiceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteServiceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteServiceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteServiceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteServiceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteServiceResponseValidationError) ErrorName() string {
	return "DeleteServiceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteServiceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteServiceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteServiceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteServiceResponseValidationError{}

// Validate checks the field values on CronJob with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// CronJobMultiError, or nil if none found. Otherwise, only the first error is
// returned, if any.
func (m *CronJob) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cluster

	// no validation rules for Namespace

	// no validation rules for Name

	// no validation rules for Schedule

	// no validation rules for Labels

	// no validation rules for Annotations

	// no validation rules for Suspend

	// no validation rules for NumActiveJobs

	// no validation rules for ConcurrencyPolicy

	if v, ok := interface{}(m.GetStartingDeadlineSeconds()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CronJobValidationError{
				field:  "StartingDeadlineSeconds",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return CronJobMultiError(errors)
	}
	return nil
}

// CronJobMultiError is an error wrapping multiple validation errors returned
// by CronJob.Validate(true) if the designated constraints aren't met.
type CronJobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CronJobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CronJobMultiError) AllErrors() []error { return m }

// CronJobValidationError is the validation error returned by CronJob.Validate
// if the designated constraints aren't met.
type CronJobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CronJobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CronJobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CronJobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CronJobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CronJobValidationError) ErrorName() string { return "CronJobValidationError" }

// Error satisfies the builtin error interface
func (e CronJobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCronJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CronJobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CronJobValidationError{}

// Validate checks the field values on DescribeCronJobRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DescribeCronJobRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DescribeCronJobRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DescribeCronJobRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DescribeCronJobRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := DescribeCronJobRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DescribeCronJobRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DescribeCronJobRequestMultiError(errors)
	}
	return nil
}

// DescribeCronJobRequestMultiError is an error wrapping multiple validation
// errors returned by DescribeCronJobRequest.Validate(true) if the designated
// constraints aren't met.
type DescribeCronJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribeCronJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribeCronJobRequestMultiError) AllErrors() []error { return m }

// DescribeCronJobRequestValidationError is the validation error returned by
// DescribeCronJobRequest.Validate if the designated constraints aren't met.
type DescribeCronJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribeCronJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribeCronJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribeCronJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribeCronJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribeCronJobRequestValidationError) ErrorName() string {
	return "DescribeCronJobRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DescribeCronJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribeCronJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribeCronJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribeCronJobRequestValidationError{}

// Validate checks the field values on DescribeCronJobResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DescribeCronJobResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DescribeCronJobResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetCronjob()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = DescribeCronJobResponseValidationError{
				field:  "Cronjob",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return DescribeCronJobResponseMultiError(errors)
	}
	return nil
}

// DescribeCronJobResponseMultiError is an error wrapping multiple validation
// errors returned by DescribeCronJobResponse.Validate(true) if the designated
// constraints aren't met.
type DescribeCronJobResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribeCronJobResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribeCronJobResponseMultiError) AllErrors() []error { return m }

// DescribeCronJobResponseValidationError is the validation error returned by
// DescribeCronJobResponse.Validate if the designated constraints aren't met.
type DescribeCronJobResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribeCronJobResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribeCronJobResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribeCronJobResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribeCronJobResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribeCronJobResponseValidationError) ErrorName() string {
	return "DescribeCronJobResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DescribeCronJobResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribeCronJobResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribeCronJobResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribeCronJobResponseValidationError{}

// Validate checks the field values on ListCronJobsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListCronJobsRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListCronJobsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := ListCronJobsRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := ListCronJobsRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := ListCronJobsRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOptions() == nil {
		err := ListCronJobsRequestValidationError{
			field:  "Options",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetOptions()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListCronJobsRequestValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return ListCronJobsRequestMultiError(errors)
	}
	return nil
}

// ListCronJobsRequestMultiError is an error wrapping multiple validation
// errors returned by ListCronJobsRequest.Validate(true) if the designated
// constraints aren't met.
type ListCronJobsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCronJobsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCronJobsRequestMultiError) AllErrors() []error { return m }

// ListCronJobsRequestValidationError is the validation error returned by
// ListCronJobsRequest.Validate if the designated constraints aren't met.
type ListCronJobsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCronJobsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCronJobsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCronJobsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCronJobsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCronJobsRequestValidationError) ErrorName() string {
	return "ListCronJobsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCronJobsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCronJobsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCronJobsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCronJobsRequestValidationError{}

// Validate checks the field values on ListCronJobsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListCronJobsResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListCronJobsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCronJobs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListCronJobsResponseValidationError{
					field:  fmt.Sprintf("CronJobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListCronJobsResponseMultiError(errors)
	}
	return nil
}

// ListCronJobsResponseMultiError is an error wrapping multiple validation
// errors returned by ListCronJobsResponse.Validate(true) if the designated
// constraints aren't met.
type ListCronJobsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCronJobsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCronJobsResponseMultiError) AllErrors() []error { return m }

// ListCronJobsResponseValidationError is the validation error returned by
// ListCronJobsResponse.Validate if the designated constraints aren't met.
type ListCronJobsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCronJobsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCronJobsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCronJobsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCronJobsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCronJobsResponseValidationError) ErrorName() string {
	return "ListCronJobsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCronJobsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCronJobsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCronJobsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCronJobsResponseValidationError{}

// Validate checks the field values on DeleteCronJobRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DeleteCronJobRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DeleteCronJobRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DeleteCronJobRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DeleteCronJobRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := DeleteCronJobRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DeleteCronJobRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteCronJobRequestMultiError(errors)
	}
	return nil
}

// DeleteCronJobRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteCronJobRequest.Validate(true) if the designated
// constraints aren't met.
type DeleteCronJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCronJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCronJobRequestMultiError) AllErrors() []error { return m }

// DeleteCronJobRequestValidationError is the validation error returned by
// DeleteCronJobRequest.Validate if the designated constraints aren't met.
type DeleteCronJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCronJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCronJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCronJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCronJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCronJobRequestValidationError) ErrorName() string {
	return "DeleteCronJobRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCronJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCronJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCronJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCronJobRequestValidationError{}

// Validate checks the field values on DeleteCronJobResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DeleteCronJobResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DeleteCronJobResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteCronJobResponseMultiError(errors)
	}
	return nil
}

// DeleteCronJobResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteCronJobResponse.Validate(true) if the designated
// constraints aren't met.
type DeleteCronJobResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteCronJobResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteCronJobResponseMultiError) AllErrors() []error { return m }

// DeleteCronJobResponseValidationError is the validation error returned by
// DeleteCronJobResponse.Validate if the designated constraints aren't met.
type DeleteCronJobResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteCronJobResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteCronJobResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteCronJobResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteCronJobResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteCronJobResponseValidationError) ErrorName() string {
	return "DeleteCronJobResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteCronJobResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteCronJobResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteCronJobResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteCronJobResponseValidationError{}

// Validate checks the field values on ConfigMap with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// ConfigMapMultiError, or nil if none found. Otherwise, only the first error
// is returned, if any.
func (m *ConfigMap) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cluster

	// no validation rules for Namespace

	// no validation rules for Name

	// no validation rules for Annotations

	// no validation rules for Labels

	// no validation rules for Data

	// no validation rules for BinaryData

	if len(errors) > 0 {
		return ConfigMapMultiError(errors)
	}
	return nil
}

// ConfigMapMultiError is an error wrapping multiple validation errors returned
// by ConfigMap.Validate(true) if the designated constraints aren't met.
type ConfigMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMapMultiError) AllErrors() []error { return m }

// ConfigMapValidationError is the validation error returned by
// ConfigMap.Validate if the designated constraints aren't met.
type ConfigMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigMapValidationError) ErrorName() string { return "ConfigMapValidationError" }

// Error satisfies the builtin error interface
func (e ConfigMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigMapValidationError{}

// Validate checks the field values on ListConfigMapsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListConfigMapsRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListConfigMapsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := ListConfigMapsRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := ListConfigMapsRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := ListConfigMapsRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOptions() == nil {
		err := ListConfigMapsRequestValidationError{
			field:  "Options",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetOptions()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListConfigMapsRequestValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return ListConfigMapsRequestMultiError(errors)
	}
	return nil
}

// ListConfigMapsRequestMultiError is an error wrapping multiple validation
// errors returned by ListConfigMapsRequest.Validate(true) if the designated
// constraints aren't met.
type ListConfigMapsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListConfigMapsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListConfigMapsRequestMultiError) AllErrors() []error { return m }

// ListConfigMapsRequestValidationError is the validation error returned by
// ListConfigMapsRequest.Validate if the designated constraints aren't met.
type ListConfigMapsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListConfigMapsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListConfigMapsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListConfigMapsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListConfigMapsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListConfigMapsRequestValidationError) ErrorName() string {
	return "ListConfigMapsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListConfigMapsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListConfigMapsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListConfigMapsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListConfigMapsRequestValidationError{}

// Validate checks the field values on ListConfigMapsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListConfigMapsResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListConfigMapsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConfigMaps() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListConfigMapsResponseValidationError{
					field:  fmt.Sprintf("ConfigMaps[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListConfigMapsResponseMultiError(errors)
	}
	return nil
}

// ListConfigMapsResponseMultiError is an error wrapping multiple validation
// errors returned by ListConfigMapsResponse.Validate(true) if the designated
// constraints aren't met.
type ListConfigMapsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListConfigMapsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListConfigMapsResponseMultiError) AllErrors() []error { return m }

// ListConfigMapsResponseValidationError is the validation error returned by
// ListConfigMapsResponse.Validate if the designated constraints aren't met.
type ListConfigMapsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListConfigMapsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListConfigMapsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListConfigMapsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListConfigMapsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListConfigMapsResponseValidationError) ErrorName() string {
	return "ListConfigMapsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListConfigMapsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListConfigMapsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListConfigMapsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListConfigMapsResponseValidationError{}

// Validate checks the field values on DescribeConfigMapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DescribeConfigMapRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DescribeConfigMapRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DescribeConfigMapRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DescribeConfigMapRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := DescribeConfigMapRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DescribeConfigMapRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DescribeConfigMapRequestMultiError(errors)
	}
	return nil
}

// DescribeConfigMapRequestMultiError is an error wrapping multiple validation
// errors returned by DescribeConfigMapRequest.Validate(true) if the
// designated constraints aren't met.
type DescribeConfigMapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribeConfigMapRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribeConfigMapRequestMultiError) AllErrors() []error { return m }

// DescribeConfigMapRequestValidationError is the validation error returned by
// DescribeConfigMapRequest.Validate if the designated constraints aren't met.
type DescribeConfigMapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribeConfigMapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribeConfigMapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribeConfigMapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribeConfigMapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribeConfigMapRequestValidationError) ErrorName() string {
	return "DescribeConfigMapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DescribeConfigMapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribeConfigMapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribeConfigMapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribeConfigMapRequestValidationError{}

// Validate checks the field values on DescribeConfigMapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DescribeConfigMapResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *DescribeConfigMapResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetConfigMap()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = DescribeConfigMapResponseValidationError{
				field:  "ConfigMap",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return DescribeConfigMapResponseMultiError(errors)
	}
	return nil
}

// DescribeConfigMapResponseMultiError is an error wrapping multiple validation
// errors returned by DescribeConfigMapResponse.Validate(true) if the
// designated constraints aren't met.
type DescribeConfigMapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribeConfigMapResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribeConfigMapResponseMultiError) AllErrors() []error { return m }

// DescribeConfigMapResponseValidationError is the validation error returned by
// DescribeConfigMapResponse.Validate if the designated constraints aren't met.
type DescribeConfigMapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribeConfigMapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribeConfigMapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribeConfigMapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribeConfigMapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribeConfigMapResponseValidationError) ErrorName() string {
	return "DescribeConfigMapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DescribeConfigMapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribeConfigMapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribeConfigMapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribeConfigMapResponseValidationError{}

// Validate checks the field values on DeleteConfigMapRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DeleteConfigMapRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DeleteConfigMapRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DeleteConfigMapRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DeleteConfigMapRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := DeleteConfigMapRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DeleteConfigMapRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteConfigMapRequestMultiError(errors)
	}
	return nil
}

// DeleteConfigMapRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteConfigMapRequest.Validate(true) if the designated
// constraints aren't met.
type DeleteConfigMapRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteConfigMapRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteConfigMapRequestMultiError) AllErrors() []error { return m }

// DeleteConfigMapRequestValidationError is the validation error returned by
// DeleteConfigMapRequest.Validate if the designated constraints aren't met.
type DeleteConfigMapRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteConfigMapRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteConfigMapRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteConfigMapRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteConfigMapRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteConfigMapRequestValidationError) ErrorName() string {
	return "DeleteConfigMapRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteConfigMapRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteConfigMapRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteConfigMapRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteConfigMapRequestValidationError{}

// Validate checks the field values on DeleteConfigMapResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DeleteConfigMapResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DeleteConfigMapResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteConfigMapResponseMultiError(errors)
	}
	return nil
}

// DeleteConfigMapResponseMultiError is an error wrapping multiple validation
// errors returned by DeleteConfigMapResponse.Validate(true) if the designated
// constraints aren't met.
type DeleteConfigMapResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteConfigMapResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteConfigMapResponseMultiError) AllErrors() []error { return m }

// DeleteConfigMapResponseValidationError is the validation error returned by
// DeleteConfigMapResponse.Validate if the designated constraints aren't met.
type DeleteConfigMapResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteConfigMapResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteConfigMapResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteConfigMapResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteConfigMapResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteConfigMapResponseValidationError) ErrorName() string {
	return "DeleteConfigMapResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteConfigMapResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteConfigMapResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteConfigMapResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteConfigMapResponseValidationError{}

// Validate checks the field values on Job with the rules defined in the proto
// definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// JobMultiError, or nil if none found. Otherwise, only the first error is
// returned, if any.
func (m *Job) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cluster

	// no validation rules for Namespace

	// no validation rules for Name

	// no validation rules for Annotations

	// no validation rules for Labels

	if len(errors) > 0 {
		return JobMultiError(errors)
	}
	return nil
}

// JobMultiError is an error wrapping multiple validation errors returned by
// Job.Validate(true) if the designated constraints aren't met.
type JobMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobMultiError) AllErrors() []error { return m }

// JobValidationError is the validation error returned by Job.Validate if the
// designated constraints aren't met.
type JobValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobValidationError) ErrorName() string { return "JobValidationError" }

// Error satisfies the builtin error interface
func (e JobValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJob.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobValidationError{}

// Validate checks the field values on ListJobsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in ListJobsRequestMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *ListJobsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := ListJobsRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := ListJobsRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := ListJobsRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetOptions() == nil {
		err := ListJobsRequestValidationError{
			field:  "Options",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetOptions()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListJobsRequestValidationError{
				field:  "Options",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return ListJobsRequestMultiError(errors)
	}
	return nil
}

// ListJobsRequestMultiError is an error wrapping multiple validation errors
// returned by ListJobsRequest.Validate(true) if the designated constraints
// aren't met.
type ListJobsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListJobsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListJobsRequestMultiError) AllErrors() []error { return m }

// ListJobsRequestValidationError is the validation error returned by
// ListJobsRequest.Validate if the designated constraints aren't met.
type ListJobsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListJobsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListJobsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListJobsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListJobsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListJobsRequestValidationError) ErrorName() string { return "ListJobsRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListJobsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListJobsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListJobsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListJobsRequestValidationError{}

// Validate checks the field values on ListJobsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in ListJobsResponseMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *ListJobsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetJobs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListJobsResponseValidationError{
					field:  fmt.Sprintf("Jobs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListJobsResponseMultiError(errors)
	}
	return nil
}

// ListJobsResponseMultiError is an error wrapping multiple validation errors
// returned by ListJobsResponse.Validate(true) if the designated constraints
// aren't met.
type ListJobsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListJobsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListJobsResponseMultiError) AllErrors() []error { return m }

// ListJobsResponseValidationError is the validation error returned by
// ListJobsResponse.Validate if the designated constraints aren't met.
type ListJobsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListJobsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListJobsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListJobsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListJobsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListJobsResponseValidationError) ErrorName() string { return "ListJobsResponseValidationError" }

// Error satisfies the builtin error interface
func (e ListJobsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListJobsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListJobsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListJobsResponseValidationError{}

// Validate checks the field values on DeleteJobRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in DeleteJobRequestMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *DeleteJobRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DeleteJobRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DeleteJobRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := DeleteJobRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DeleteJobRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteJobRequestMultiError(errors)
	}
	return nil
}

// DeleteJobRequestMultiError is an error wrapping multiple validation errors
// returned by DeleteJobRequest.Validate(true) if the designated constraints
// aren't met.
type DeleteJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteJobRequestMultiError) AllErrors() []error { return m }

// DeleteJobRequestValidationError is the validation error returned by
// DeleteJobRequest.Validate if the designated constraints aren't met.
type DeleteJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteJobRequestValidationError) ErrorName() string { return "DeleteJobRequestValidationError" }

// Error satisfies the builtin error interface
func (e DeleteJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteJobRequestValidationError{}

// Validate checks the field values on DeleteJobResponse with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in DeleteJobResponseMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *DeleteJobResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return DeleteJobResponseMultiError(errors)
	}
	return nil
}

// DeleteJobResponseMultiError is an error wrapping multiple validation errors
// returned by DeleteJobResponse.Validate(true) if the designated constraints
// aren't met.
type DeleteJobResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteJobResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteJobResponseMultiError) AllErrors() []error { return m }

// DeleteJobResponseValidationError is the validation error returned by
// DeleteJobResponse.Validate if the designated constraints aren't met.
type DeleteJobResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteJobResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteJobResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteJobResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteJobResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteJobResponseValidationError) ErrorName() string {
	return "DeleteJobResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteJobResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteJobResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteJobResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteJobResponseValidationError{}

// Validate checks the field values on JobConfig with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// JobConfigMultiError, or nil if none found. Otherwise, only the first error
// is returned, if any.
func (m *JobConfig) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetValue()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = JobConfigValidationError{
				field:  "Value",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return JobConfigMultiError(errors)
	}
	return nil
}

// JobConfigMultiError is an error wrapping multiple validation errors returned
// by JobConfig.Validate(true) if the designated constraints aren't met.
type JobConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JobConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JobConfigMultiError) AllErrors() []error { return m }

// JobConfigValidationError is the validation error returned by
// JobConfig.Validate if the designated constraints aren't met.
type JobConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JobConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JobConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JobConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JobConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JobConfigValidationError) ErrorName() string { return "JobConfigValidationError" }

// Error satisfies the builtin error interface
func (e JobConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJobConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JobConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JobConfigValidationError{}

// Validate checks the field values on CreateJobRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in CreateJobRequestMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *CreateJobRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := CreateJobRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := CreateJobRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetNamespace()) < 1 {
		err := CreateJobRequestValidationError{
			field:  "Namespace",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetJobConfig()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CreateJobRequestValidationError{
				field:  "JobConfig",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return CreateJobRequestMultiError(errors)
	}
	return nil
}

// CreateJobRequestMultiError is an error wrapping multiple validation errors
// returned by CreateJobRequest.Validate(true) if the designated constraints
// aren't met.
type CreateJobRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateJobRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateJobRequestMultiError) AllErrors() []error { return m }

// CreateJobRequestValidationError is the validation error returned by
// CreateJobRequest.Validate if the designated constraints aren't met.
type CreateJobRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateJobRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateJobRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateJobRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateJobRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateJobRequestValidationError) ErrorName() string { return "CreateJobRequestValidationError" }

// Error satisfies the builtin error interface
func (e CreateJobRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateJobRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateJobRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateJobRequestValidationError{}

// Validate checks the field values on CreateJobResponse with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in CreateJobResponseMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *CreateJobResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetJob()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CreateJobResponseValidationError{
				field:  "Job",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return CreateJobResponseMultiError(errors)
	}
	return nil
}

// CreateJobResponseMultiError is an error wrapping multiple validation errors
// returned by CreateJobResponse.Validate(true) if the designated constraints
// aren't met.
type CreateJobResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateJobResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateJobResponseMultiError) AllErrors() []error { return m }

// CreateJobResponseValidationError is the validation error returned by
// CreateJobResponse.Validate if the designated constraints aren't met.
type CreateJobResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateJobResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateJobResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateJobResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateJobResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateJobResponseValidationError) ErrorName() string {
	return "CreateJobResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateJobResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateJobResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateJobResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateJobResponseValidationError{}

// Validate checks the field values on Namespace with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// NamespaceMultiError, or nil if none found. Otherwise, only the first error
// is returned, if any.
func (m *Namespace) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Cluster

	// no validation rules for Name

	// no validation rules for Annotations

	// no validation rules for Labels

	if len(errors) > 0 {
		return NamespaceMultiError(errors)
	}
	return nil
}

// NamespaceMultiError is an error wrapping multiple validation errors returned
// by Namespace.Validate(true) if the designated constraints aren't met.
type NamespaceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NamespaceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NamespaceMultiError) AllErrors() []error { return m }

// NamespaceValidationError is the validation error returned by
// Namespace.Validate if the designated constraints aren't met.
type NamespaceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NamespaceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NamespaceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NamespaceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NamespaceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NamespaceValidationError) ErrorName() string { return "NamespaceValidationError" }

// Error satisfies the builtin error interface
func (e NamespaceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNamespace.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NamespaceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NamespaceValidationError{}

// Validate checks the field values on DescribeNamespaceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DescribeNamespaceRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DescribeNamespaceRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetClientset()) < 1 {
		err := DescribeNamespaceRequestValidationError{
			field:  "Clientset",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetCluster()) < 1 {
		err := DescribeNamespaceRequestValidationError{
			field:  "Cluster",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetName()) < 1 {
		err := DescribeNamespaceRequestValidationError{
			field:  "Name",
			reason: "value length must be at least 1 bytes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DescribeNamespaceRequestMultiError(errors)
	}
	return nil
}

// DescribeNamespaceRequestMultiError is an error wrapping multiple validation
// errors returned by DescribeNamespaceRequest.Validate(true) if the
// designated constraints aren't met.
type DescribeNamespaceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribeNamespaceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribeNamespaceRequestMultiError) AllErrors() []error { return m }

// DescribeNamespaceRequestValidationError is the validation error returned by
// DescribeNamespaceRequest.Validate if the designated constraints aren't met.
type DescribeNamespaceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribeNamespaceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribeNamespaceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribeNamespaceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribeNamespaceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribeNamespaceRequestValidationError) ErrorName() string {
	return "DescribeNamespaceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DescribeNamespaceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribeNamespaceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribeNamespaceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribeNamespaceRequestValidationError{}

// Validate checks the field values on DescribeNamespaceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DescribeNamespaceResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *DescribeNamespaceResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetNamespace()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = DescribeNamespaceResponseValidationError{
				field:  "Namespace",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return DescribeNamespaceResponseMultiError(errors)
	}
	return nil
}

// DescribeNamespaceResponseMultiError is an error wrapping multiple validation
// errors returned by DescribeNamespaceResponse.Validate(true) if the
// designated constraints aren't met.
type DescribeNamespaceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DescribeNamespaceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DescribeNamespaceResponseMultiError) AllErrors() []error { return m }

// DescribeNamespaceResponseValidationError is the validation error returned by
// DescribeNamespaceResponse.Validate if the designated constraints aren't met.
type DescribeNamespaceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DescribeNamespaceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DescribeNamespaceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DescribeNamespaceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DescribeNamespaceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DescribeNamespaceResponseValidationError) ErrorName() string {
	return "DescribeNamespaceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e DescribeNamespaceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDescribeNamespaceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DescribeNamespaceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DescribeNamespaceResponseValidationError{}

// Validate checks the field values on NullableString with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// NullableStringMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *NullableString) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	switch m.Kind.(type) {

	case *NullableString_Null:
		// no validation rules for Null

	case *NullableString_Value:
		// no validation rules for Value

	}

	if len(errors) > 0 {
		return NullableStringMultiError(errors)
	}
	return nil
}

// NullableStringMultiError is an error wrapping multiple validation errors
// returned by NullableString.Validate(true) if the designated constraints
// aren't met.
type NullableStringMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NullableStringMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NullableStringMultiError) AllErrors() []error { return m }

// NullableStringValidationError is the validation error returned by
// NullableString.Validate if the designated constraints aren't met.
type NullableStringValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NullableStringValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NullableStringValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NullableStringValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NullableStringValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NullableStringValidationError) ErrorName() string { return "NullableStringValidationError" }

// Error satisfies the builtin error interface
func (e NullableStringValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNullableString.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NullableStringValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NullableStringValidationError{}

// Validate checks the field values on ExpectedObjectMetaFields with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ExpectedObjectMetaFieldsMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ExpectedObjectMetaFields) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for key, val := range m.GetLabels() {
		_ = val

		if len(key) < 1 {
			err := ExpectedObjectMetaFieldsValidationError{
				field:  fmt.Sprintf("Labels[%v]", key),
				reason: "value length must be at least 1 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if v, ok := interface{}(val).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ExpectedObjectMetaFieldsValidationError{
					field:  fmt.Sprintf("Labels[%v]", key),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	for key, val := range m.GetAnnotations() {
		_ = val

		if len(key) < 1 {
			err := ExpectedObjectMetaFieldsValidationError{
				field:  fmt.Sprintf("Annotations[%v]", key),
				reason: "value length must be at least 1 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		if v, ok := interface{}(val).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ExpectedObjectMetaFieldsValidationError{
					field:  fmt.Sprintf("Annotations[%v]", key),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ExpectedObjectMetaFieldsMultiError(errors)
	}
	return nil
}

// ExpectedObjectMetaFieldsMultiError is an error wrapping multiple validation
// errors returned by ExpectedObjectMetaFields.Validate(true) if the
// designated constraints aren't met.
type ExpectedObjectMetaFieldsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExpectedObjectMetaFieldsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExpectedObjectMetaFieldsMultiError) AllErrors() []error { return m }

// ExpectedObjectMetaFieldsValidationError is the validation error returned by
// ExpectedObjectMetaFields.Validate if the designated constraints aren't met.
type ExpectedObjectMetaFieldsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExpectedObjectMetaFieldsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExpectedObjectMetaFieldsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExpectedObjectMetaFieldsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExpectedObjectMetaFieldsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExpectedObjectMetaFieldsValidationError) ErrorName() string {
	return "ExpectedObjectMetaFieldsValidationError"
}

// Error satisfies the builtin error interface
func (e ExpectedObjectMetaFieldsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExpectedObjectMetaFields.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExpectedObjectMetaFieldsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExpectedObjectMetaFieldsValidationError{}

// Validate checks the field values on ObjectMetaFields with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in ObjectMetaFieldsMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *ObjectMetaFields) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for key, val := range m.GetLabels() {
		_ = val

		if len(key) < 1 {
			err := ObjectMetaFieldsValidationError{
				field:  fmt.Sprintf("Labels[%v]", key),
				reason: "value length must be at least 1 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		// no validation rules for Labels[key]
	}

	for key, val := range m.GetAnnotations() {
		_ = val

		if len(key) < 1 {
			err := ObjectMetaFieldsValidationError{
				field:  fmt.Sprintf("Annotations[%v]", key),
				reason: "value length must be at least 1 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		// no validation rules for Annotations[key]
	}

	if len(errors) > 0 {
		return ObjectMetaFieldsMultiError(errors)
	}
	return nil
}

// ObjectMetaFieldsMultiError is an error wrapping multiple validation errors
// returned by ObjectMetaFields.Validate(true) if the designated constraints
// aren't met.
type ObjectMetaFieldsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ObjectMetaFieldsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ObjectMetaFieldsMultiError) AllErrors() []error { return m }

// ObjectMetaFieldsValidationError is the validation error returned by
// ObjectMetaFields.Validate if the designated constraints aren't met.
type ObjectMetaFieldsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ObjectMetaFieldsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ObjectMetaFieldsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ObjectMetaFieldsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ObjectMetaFieldsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ObjectMetaFieldsValidationError) ErrorName() string { return "ObjectMetaFieldsValidationError" }

// Error satisfies the builtin error interface
func (e ObjectMetaFieldsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sObjectMetaFields.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ObjectMetaFieldsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ObjectMetaFieldsValidationError{}

// Validate checks the field values on RemoveObjectMetaFields with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in RemoveObjectMetaFieldsMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *RemoveObjectMetaFields) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	_RemoveObjectMetaFields_Labels_Unique := make(map[string]struct{}, len(m.GetLabels()))

	for idx, item := range m.GetLabels() {
		_, _ = idx, item

		if _, exists := _RemoveObjectMetaFields_Labels_Unique[item]; exists {
			err := RemoveObjectMetaFieldsValidationError{
				field:  fmt.Sprintf("Labels[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_RemoveObjectMetaFields_Labels_Unique[item] = struct{}{}
		}

		// no validation rules for Labels[idx]
	}

	_RemoveObjectMetaFields_Annotations_Unique := make(map[string]struct{}, len(m.GetAnnotations()))

	for idx, item := range m.GetAnnotations() {
		_, _ = idx, item

		if _, exists := _RemoveObjectMetaFields_Annotations_Unique[item]; exists {
			err := RemoveObjectMetaFieldsValidationError{
				field:  fmt.Sprintf("Annotations[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_RemoveObjectMetaFields_Annotations_Unique[item] = struct{}{}
		}

		// no validation rules for Annotations[idx]
	}

	if len(errors) > 0 {
		return RemoveObjectMetaFieldsMultiError(errors)
	}
	return nil
}

// RemoveObjectMetaFieldsMultiError is an error wrapping multiple validation
// errors returned by RemoveObjectMetaFields.Validate(true) if the designated
// constraints aren't met.
type RemoveObjectMetaFieldsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RemoveObjectMetaFieldsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RemoveObjectMetaFieldsMultiError) AllErrors() []error { return m }

// RemoveObjectMetaFieldsValidationError is the validation error returned by
// RemoveObjectMetaFields.Validate if the designated constraints aren't met.
type RemoveObjectMetaFieldsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RemoveObjectMetaFieldsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RemoveObjectMetaFieldsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RemoveObjectMetaFieldsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RemoveObjectMetaFieldsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RemoveObjectMetaFieldsValidationError) ErrorName() string {
	return "RemoveObjectMetaFieldsValidationError"
}

// Error satisfies the builtin error interface
func (e RemoveObjectMetaFieldsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRemoveObjectMetaFields.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RemoveObjectMetaFieldsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RemoveObjectMetaFieldsValidationError{}

// Validate checks the field values on HPA_Sizing with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// HPA_SizingMultiError, or nil if none found. Otherwise, only the first error
// is returned, if any.
func (m *HPA_Sizing) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for MinReplicas

	// no validation rules for MaxReplicas

	// no validation rules for CurrentReplicas

	// no validation rules for DesiredReplicas

	if len(errors) > 0 {
		return HPA_SizingMultiError(errors)
	}
	return nil
}

// HPA_SizingMultiError is an error wrapping multiple validation errors
// returned by HPA_Sizing.Validate(true) if the designated constraints aren't met.
type HPA_SizingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HPA_SizingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HPA_SizingMultiError) AllErrors() []error { return m }

// HPA_SizingValidationError is the validation error returned by
// HPA_Sizing.Validate if the designated constraints aren't met.
type HPA_SizingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HPA_SizingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HPA_SizingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HPA_SizingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HPA_SizingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HPA_SizingValidationError) ErrorName() string { return "HPA_SizingValidationError" }

// Error satisfies the builtin error interface
func (e HPA_SizingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHPA_Sizing.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HPA_SizingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HPA_SizingValidationError{}

// Validate checks the field values on ResizeHPARequest_Sizing with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ResizeHPARequest_SizingMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ResizeHPARequest_Sizing) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Min

	// no validation rules for Max

	if len(errors) > 0 {
		return ResizeHPARequest_SizingMultiError(errors)
	}
	return nil
}

// ResizeHPARequest_SizingMultiError is an error wrapping multiple validation
// errors returned by ResizeHPARequest_Sizing.Validate(true) if the designated
// constraints aren't met.
type ResizeHPARequest_SizingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResizeHPARequest_SizingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResizeHPARequest_SizingMultiError) AllErrors() []error { return m }

// ResizeHPARequest_SizingValidationError is the validation error returned by
// ResizeHPARequest_Sizing.Validate if the designated constraints aren't met.
type ResizeHPARequest_SizingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResizeHPARequest_SizingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResizeHPARequest_SizingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResizeHPARequest_SizingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResizeHPARequest_SizingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResizeHPARequest_SizingValidationError) ErrorName() string {
	return "ResizeHPARequest_SizingValidationError"
}

// Error satisfies the builtin error interface
func (e ResizeHPARequest_SizingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResizeHPARequest_Sizing.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResizeHPARequest_SizingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResizeHPARequest_SizingValidationError{}

// Validate checks the field values on Deployment_DeploymentStatus with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in Deployment_DeploymentStatusMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *Deployment_DeploymentStatus) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Replicas

	// no validation rules for UpdatedReplicas

	// no validation rules for ReadyReplicas

	// no validation rules for AvailableReplicas

	// no validation rules for UnavailableReplicas

	for idx, item := range m.GetDeploymentConditions() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = Deployment_DeploymentStatusValidationError{
					field:  fmt.Sprintf("DeploymentConditions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return Deployment_DeploymentStatusMultiError(errors)
	}
	return nil
}

// Deployment_DeploymentStatusMultiError is an error wrapping multiple
// validation errors returned by Deployment_DeploymentStatus.Validate(true) if
// the designated constraints aren't met.
type Deployment_DeploymentStatusMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Deployment_DeploymentStatusMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Deployment_DeploymentStatusMultiError) AllErrors() []error { return m }

// Deployment_DeploymentStatusValidationError is the validation error returned
// by Deployment_DeploymentStatus.Validate if the designated constraints
// aren't met.
type Deployment_DeploymentStatusValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Deployment_DeploymentStatusValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Deployment_DeploymentStatusValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Deployment_DeploymentStatusValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Deployment_DeploymentStatusValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Deployment_DeploymentStatusValidationError) ErrorName() string {
	return "Deployment_DeploymentStatusValidationError"
}

// Error satisfies the builtin error interface
func (e Deployment_DeploymentStatusValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeployment_DeploymentStatus.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Deployment_DeploymentStatusValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Deployment_DeploymentStatusValidationError{}

// Validate checks the field values on Deployment_DeploymentStatus_Condition
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in
// Deployment_DeploymentStatus_ConditionMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *Deployment_DeploymentStatus_Condition) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for ConditionStatus

	// no validation rules for Reason

	// no validation rules for Message

	if len(errors) > 0 {
		return Deployment_DeploymentStatus_ConditionMultiError(errors)
	}
	return nil
}

// Deployment_DeploymentStatus_ConditionMultiError is an error wrapping
// multiple validation errors returned by
// Deployment_DeploymentStatus_Condition.Validate(true) if the designated
// constraints aren't met.
type Deployment_DeploymentStatus_ConditionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m Deployment_DeploymentStatus_ConditionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m Deployment_DeploymentStatus_ConditionMultiError) AllErrors() []error { return m }

// Deployment_DeploymentStatus_ConditionValidationError is the validation error
// returned by Deployment_DeploymentStatus_Condition.Validate if the
// designated constraints aren't met.
type Deployment_DeploymentStatus_ConditionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e Deployment_DeploymentStatus_ConditionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e Deployment_DeploymentStatus_ConditionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e Deployment_DeploymentStatus_ConditionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e Deployment_DeploymentStatus_ConditionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e Deployment_DeploymentStatus_ConditionValidationError) ErrorName() string {
	return "Deployment_DeploymentStatus_ConditionValidationError"
}

// Error satisfies the builtin error interface
func (e Deployment_DeploymentStatus_ConditionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeployment_DeploymentStatus_Condition.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = Deployment_DeploymentStatus_ConditionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = Deployment_DeploymentStatus_ConditionValidationError{}

// Validate checks the field values on UpdateDeploymentRequest_Fields with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateDeploymentRequest_FieldsMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UpdateDeploymentRequest_Fields) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for key, val := range m.GetLabels() {
		_ = val

		if len(key) < 1 {
			err := UpdateDeploymentRequest_FieldsValidationError{
				field:  fmt.Sprintf("Labels[%v]", key),
				reason: "value length must be at least 1 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		// no validation rules for Labels[key]
	}

	for key, val := range m.GetAnnotations() {
		_ = val

		if len(key) < 1 {
			err := UpdateDeploymentRequest_FieldsValidationError{
				field:  fmt.Sprintf("Annotations[%v]", key),
				reason: "value length must be at least 1 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		// no validation rules for Annotations[key]
	}

	if len(errors) > 0 {
		return UpdateDeploymentRequest_FieldsMultiError(errors)
	}
	return nil
}

// UpdateDeploymentRequest_FieldsMultiError is an error wrapping multiple
// validation errors returned by UpdateDeploymentRequest_Fields.Validate(true)
// if the designated constraints aren't met.
type UpdateDeploymentRequest_FieldsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDeploymentRequest_FieldsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDeploymentRequest_FieldsMultiError) AllErrors() []error { return m }

// UpdateDeploymentRequest_FieldsValidationError is the validation error
// returned by UpdateDeploymentRequest_Fields.Validate if the designated
// constraints aren't met.
type UpdateDeploymentRequest_FieldsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDeploymentRequest_FieldsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDeploymentRequest_FieldsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDeploymentRequest_FieldsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDeploymentRequest_FieldsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDeploymentRequest_FieldsValidationError) ErrorName() string {
	return "UpdateDeploymentRequest_FieldsValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDeploymentRequest_FieldsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDeploymentRequest_Fields.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDeploymentRequest_FieldsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDeploymentRequest_FieldsValidationError{}

// Validate checks the field values on UpdateStatefulSetRequest_Fields with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateStatefulSetRequest_FieldsMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UpdateStatefulSetRequest_Fields) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for key, val := range m.GetLabels() {
		_ = val

		if len(key) < 1 {
			err := UpdateStatefulSetRequest_FieldsValidationError{
				field:  fmt.Sprintf("Labels[%v]", key),
				reason: "value length must be at least 1 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		// no validation rules for Labels[key]
	}

	for key, val := range m.GetAnnotations() {
		_ = val

		if len(key) < 1 {
			err := UpdateStatefulSetRequest_FieldsValidationError{
				field:  fmt.Sprintf("Annotations[%v]", key),
				reason: "value length must be at least 1 bytes",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		// no validation rules for Annotations[key]
	}

	if len(errors) > 0 {
		return UpdateStatefulSetRequest_FieldsMultiError(errors)
	}
	return nil
}

// UpdateStatefulSetRequest_FieldsMultiError is an error wrapping multiple
// validation errors returned by
// UpdateStatefulSetRequest_Fields.Validate(true) if the designated
// constraints aren't met.
type UpdateStatefulSetRequest_FieldsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateStatefulSetRequest_FieldsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateStatefulSetRequest_FieldsMultiError) AllErrors() []error { return m }

// UpdateStatefulSetRequest_FieldsValidationError is the validation error
// returned by UpdateStatefulSetRequest_Fields.Validate if the designated
// constraints aren't met.
type UpdateStatefulSetRequest_FieldsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateStatefulSetRequest_FieldsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateStatefulSetRequest_FieldsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateStatefulSetRequest_FieldsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateStatefulSetRequest_FieldsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateStatefulSetRequest_FieldsValidationError) ErrorName() string {
	return "UpdateStatefulSetRequest_FieldsValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateStatefulSetRequest_FieldsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateStatefulSetRequest_Fields.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateStatefulSetRequest_FieldsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateStatefulSetRequest_FieldsValidationError{}
